<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>作品集-天氣：威特App</title>
    <url>/2024/02/16/%E4%BD%9C%E5%93%81%E9%9B%86-%E5%A4%A9%E6%B0%A3%EF%BC%9A%E5%A8%81%E7%89%B9App/</url>
    <content><![CDATA[<blockquote>
<p><strong>天氣：威特 App</strong> 使用氣象局 API 即時更新天氣資訊，並透過 GPS 定位您的所在位置，顯示使用者所在區域之天氣狀況。</p>
</blockquote>
<div style="display: flex;justify-content: center;">
    <div style="width:20%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/QMH3e52.png">
    </div>
    <div style="width:20%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/fVaRh2J.png">
    </div>
    <div style="width:20%;float:left;margin-right:10px">
        <img src="https://i.imgur.com/4KYdGOs.png">
    </div>
    <div style="width:20%;float:left;">
        <img src="https://i.imgur.com/5ZyOnRw.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<span id="more"></span>

<hr>
<h4 id="App-簡介"><a href="#App-簡介" class="headerlink" title="App 簡介"></a>App 簡介</h4><ul>
<li><strong>起始畫面</strong><br>開啟「天氣：威特 App」時會先出現如下圖的起始畫面。</li>
</ul>
<img src="https://i.imgur.com/QMH3e52.png" width="40%">

<ul>
<li><strong>目前位置</strong></li>
</ul>
<ol>
<li>出現起始畫面後，會進入到目前位置頁面。</li>
<li>首次開啟時，會向使用者要求位置權限，當權限通過後，即開始嘗試定位使用者的所在位置。</li>
<li>當取得使用者的所在位置，且確認使用者的所在國家為台灣時，便會抓取該地區的天氣資料，並呈現在畫面中。</li>
</ol>
<img src="https://i.imgur.com/fVaRh2J.png" width="40%">

<ul>
<li><strong>現在天氣</strong><br>進入現在天氣頁面後，使用者可點選右上角的下拉選單，選取欲查詢的地區及縣市，畫面中便會呈現該縣市即時的天氣狀況。</li>
</ul>
<img src="https://i.imgur.com/4KYdGOs.png" width="40%">

<ul>
<li><strong>天氣預報</strong><br>進入天氣預報頁面後，使用者可點選右上角的下拉選單，選取欲查詢的地區，畫面中便會呈現該地區今明 36 小時的天氣預報。</li>
</ul>
<img src="https://i.imgur.com/5ZyOnRw.png" width="40%">

<hr>
<h4 id="天氣資料簡介"><a href="#天氣資料簡介" class="headerlink" title="天氣資料簡介"></a>天氣資料簡介</h4><p>「天氣：威特 App」中使用的天氣資料皆為<u>中央氣象署&#x2F;中央氣象局</u>提供的 <a href="https://opendata.cwa.gov.tw/dist/opendata-swagger.html#/">API 資料</a>。</p>
<ul>
<li>現在天氣：使用「預報」的「現在天氣觀測報告」(O-A0003-001)</li>
<li>天氣預報：使用「觀測」的「臺灣各縣市天氣預報資料」(F-C0032-001)</li>
</ul>
<hr>
<h4 id="使用的方法"><a href="#使用的方法" class="headerlink" title="使用的方法"></a>使用的方法</h4><p>以下將「天氣：威特 App」中使用到的一些重要方法&#x2F;架構&#x2F;工具等整理成表格來呈現。</p>
<table>
<thead>
<tr>
<th align="center"><div style="width:100px">架構&#x2F;功能</div></th>
<th align="center">工具&#x2F;套件</th>
<th align="center">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">App 架構</td>
<td align="center">MVVM</td>
<td align="center">使用 LiveData+ViewModel 實現 MVVM 架構</td>
</tr>
<tr>
<td align="center">抓取資料</td>
<td align="center">Retrofit、Moshi</td>
<td align="center">使用 Retrofit 抓取氣象局 API 資料，並使用 Moshi 將 JSON 資料解析成 data object</td>
</tr>
<tr>
<td align="center">App 畫面</td>
<td align="center">RyclcerView、Data Binding</td>
<td align="center">使用 RyclcerView 呈現天氣資料，並透過 Data Binding 更新 UI</td>
</tr>
<tr>
<td align="center">切換畫面</td>
<td align="center">Fragment、Bottom Navigation</td>
<td align="center">使用 Fragment 搭配 Bottom Navigation 切換 App 畫面</td>
</tr>
<tr>
<td align="center">GPS 定位</td>
<td align="center">LocationManager、Fused Location Provider</td>
<td align="center">使用 LocationManager API 和 Fused Location Provider API 實現定位功能</td>
</tr>
</tbody></table>
<hr>
<h4 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h4><p>以下為「天氣：威特 App」的 Demo 影片：</p>
<div class="video-container"><iframe src="https://player.vimeo.com/video/914676522" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<h4 id="下載-App"><a href="#下載-App" class="headerlink" title="下載 App"></a>下載 App</h4><ul>
<li><p>由於此 App 處於封閉測試階段，如欲安裝「天氣：威特 App」可寄信至 <a href="mailto:linglingdr00@gmail.com">linglingdr00@gmail.com</a>，這邊會邀請您加入封閉測試。</p>
</li>
<li><p>如欲查看專案 <strong>source code</strong>，可點選以下連結查看。<br>Github: <a href="https://github.com/linglingdr00/Weather_App">https://github.com/linglingdr00/Weather_App</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Portfolio</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Fragment</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Retrofit</tag>
        <tag>Moshi</tag>
        <tag>ListAdapter</tag>
        <tag>MVVM</tag>
        <tag>RyclcerView</tag>
        <tag>RecyclerView.Adapter</tag>
        <tag>DataBinding</tag>
        <tag>BottomNavigation</tag>
        <tag>LocationManager</tag>
        <tag>FusedLocationProvider</tag>
      </tags>
  </entry>
  <entry>
    <title>計算機結構筆記(1)-電腦基礎概念</title>
    <url>/2024/03/10/%E8%A8%88%E7%AE%97%E6%A9%9F%E7%B5%90%E6%A7%8B%E7%AD%86%E8%A8%98-1-%E9%9B%BB%E8%85%A6%E5%9F%BA%E7%A4%8E%E6%A6%82%E5%BF%B5/</url>
    <content><![CDATA[<blockquote>
<p>為什麼<u>數字比對</u>比<u>字串比對</u>還要快？因為<b>暫存器</b>只能存放數字，所以做字串比對的話，必須先轉換成數字，再放到暫存器，接著才能比對。相較於將數字直接放進暫存器來說，速度會比較慢。<b>循環展開(loop unrolling)</b>為什麼能加速迴圈執行的速度？為什麼深度學習要交給 GPU 來算？這些其實都跟計算機架構息息相關，而對軟體工程師來說，了解程式如何寫可以跑得更快就是最關鍵的議題。</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="硬體元件"><a href="#硬體元件" class="headerlink" title="硬體元件"></a>硬體元件</h3><img src="https://imgur.com/MBvTeJe.png" width="50%">

<p>一個簡化的典型的電腦系統架構可由上圖來表示。電腦的運算是由<b>中央處理單元(Central Processing Unit, CPU)</b>來執行。它包含了<b>控制單元(Control Unit, CU)</b>和<b>算術邏輯單元(Arithmetic and Logic Unit, ALU)</b>兩大部份。</p>
<table>
<thead>
<tr>
<th align="left"><div style="width:150px"></th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">控制單元(CU)</td>
<td align="left">用來解釋電腦指令，搬移CPU內部資料，以指揮協調CPU各部份的運作。</td>
</tr>
<tr>
<td align="left">算術邏輯單元(ALU)</td>
<td align="left">是電腦指令主要的執行部份，它又可細分成加法器、乘法器、及多個<b>暫存器(Register)</b>等部份。</td>
</tr>
<tr>
<td align="left">暫存器(Register)</td>
<td align="left"><b>CPU內部</b>用來<u>儲存資料</u>的地方。</td>
</tr>
</tbody></table>
<p><b>記憶體</b>是用來<u>儲存程式和資料</u>的地方。一般又稱為<b>RAM(Random Access Memory)</b>或<b>Main Memory(主記憶體)</b>。我們可將記憶體視為由一個個小格子所組成的<b>陣列</b>，每個格子內都儲存著一個二進位數字以代表程式指令或資料。我們給每一個格子一個特有的編號，稱為<b>地址(Address)</b>，就像我們的門牌號碼一樣，可供CPU定址某一塊記憶體。</p>
<p><b>輸入輸出(Input &#x2F; Output, I&#x2F;O)</b>裝置是我們最常見的硬體元件。常見的輸入元件有鍵盤、滑鼠、搖桿、DVD光碟機(或燒錄機)等。常見的輸出元件有螢幕、印表機、喇叭等。可同時做輸入輸出的元件有磁碟機、磁帶機等儲存媒介及網路卡等。CPU、RAM和之間是由<b>匯流排(Bus)</b>連接起來。Bus係作為連接其上各硬體元件交換電子資料的路徑。</p>
<hr>
<h3 id="軟體元件"><a href="#軟體元件" class="headerlink" title="軟體元件"></a>軟體元件</h3><p>軟體元件是由許多的<b>程式(Program)</b>所組成。這些程式是用來指揮電腦硬體的運作，以達我們的工作。我們一般將軟體分為<b>系統軟體</b>和<b>應用軟體</b>兩大類。</p>
<p><b>系統軟體</b>幫我們<u>管理檔案</u>、<u>分配電腦的各種資源</u>、<u>執行程式</u>以及<u>從鍵盤接收我們的命令</u>。其中和<u>管理電腦相關的一些程式</u>我們稱為<b>作業系統(Operating System)</b>，如Window NT和UNIX都是一種作業系統。而應用軟體則幫助我們完成特定的工作，如Word可用來編輯文書，Excel可用來作分析計算等。</p>
<p>作業系統是電腦系統不可或缺的一部份，當電腦啟動時，首先會執行儲存在<b>唯讀記憶體(Read Only Memory, ROM)</b>內的程式，此程式會從<u>本地磁碟機</u>或透過網路從<u>伺服器的磁碟機</u>上將作業系統載入<b>記憶體(Random Access Memory, RAM)</b>內執行，然後我們就可以透過輸入裝置下達命令，以執行應用程式來處理我們的資料。</p>
<hr>
<h3 id="數字系統"><a href="#數字系統" class="headerlink" title="數字系統"></a>數字系統</h3><h4 id="數字表示法"><a href="#數字表示法" class="headerlink" title="數字表示法"></a>數字表示法</h4><p>在<b>十進位系統</b>中, <code>43 = 4*10 + 3</code>, 而 <code>527 = 5*102 + 2*10 + 7</code>。目前的電腦大多使用<b>二進位系統</b>，我們稱<span class="label primary">一個<b>二進位數字</b>(0 or 1)為一個<b>位元(Bit, Binary Digit)</b></span>。由於 bit 實在太小了,現在<u>記憶體的最小儲存單位</u>通常為 <strong>8 bits</strong>,又稱為 <strong>byte</strong>。下圖是二進位系統的計數方式：</p>
<table>
<thead>
<tr>
<th align="left">二進位</th>
<th align="left">等於</th>
<th align="left">十進位</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td align="left">$0*2^0$</td>
<td align="left">0</td>
</tr>
<tr>
<td align="left">1</td>
<td align="left">$1*2^0$</td>
<td align="left">1</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">$1<em>2^1 + 0</em>2^0$</td>
<td align="left">2</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">$1<em>2^1 + 1</em>2^0$</td>
<td align="left">3</td>
</tr>
<tr>
<td align="left">100</td>
<td align="left">$1<em>2^2 + 0</em>2^1 + 0*2^0$</td>
<td align="left">4</td>
</tr>
<tr>
<td align="left">101</td>
<td align="left">$1<em>2^2 + 0</em>2^1 + 1*2^0$</td>
<td align="left">5</td>
</tr>
<tr>
<td align="left">110</td>
<td align="left">$1<em>2^2 + 1</em>2^1 + 0*2^0$</td>
<td align="left">6</td>
</tr>
<tr>
<td align="left">111</td>
<td align="left">$1<em>2^2 + 1</em>2^1 + 1*2^0$</td>
<td align="left">7</td>
</tr>
<tr>
<td align="left">1000</td>
<td align="left">$1<em>2^3 + 0</em>2^2 + 0<em>2^1 + 0</em>2^0$</td>
<td align="left">8</td>
</tr>
<tr>
<td align="left">1001</td>
<td align="left">$1<em>2^3 + 0</em>2^2 + 0<em>2^1 + 1</em>2^0$</td>
<td align="left">9</td>
</tr>
<tr>
<td align="left">1010</td>
<td align="left">$1<em>2^3 + 0</em>2^2 + 1<em>2^1 + 0</em>2^0$</td>
<td align="left">10</td>
</tr>
</tbody></table>
<p>一般而言，以 $B$ 為底的 $K$ 個數字所能表達的範圍為 $R &#x3D; B^K$。以二進位為例，不同的位元數所能表達的數字如下表：</p>
<table>
<thead>
<tr>
<th align="left">位元數</th>
<th align="left">表達範圍</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">2 ($2^1$)</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">16 ($2^4$)</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">256 ($2^8$)</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">1024 ($2^{10}$)</td>
</tr>
<tr>
<td align="left">16</td>
<td align="left">65536 ($2^{16}$)</td>
</tr>
<tr>
<td align="left">20</td>
<td align="left">1048576 ($2^{20}$)</td>
</tr>
<tr>
<td align="left">32</td>
<td align="left">4294967296 ($2^{32}$)</td>
</tr>
<tr>
<td align="left">64</td>
<td align="left">約等於 $1.6*10^{19}$</td>
</tr>
<tr>
<td align="left">128</td>
<td align="left">約等於 $2.6*10^{38}$</td>
</tr>
</tbody></table>
<hr>
<p>待更新…</p>
]]></content>
      <categories>
        <category>計算機結構</category>
      </categories>
      <tags>
        <tag>Computer Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Java筆記(3)-內聚和耦合</title>
    <url>/2024/03/06/Java%E7%AD%86%E8%A8%98-3-%E5%85%A7%E8%81%9A%E5%92%8C%E8%80%A6%E5%90%88/</url>
    <content><![CDATA[<blockquote>
<p>好的程式往往追求「高內聚、低耦合」，「內聚」指的是和其它程式碼「無」相關；「耦合」指的是和其它程式碼「有」相關。</p>
</blockquote>
<span id="more"></span>

<h3 id="內聚"><a href="#內聚" class="headerlink" title="內聚"></a>內聚</h3><p>內聚(Cohesion)是指模組的獨立性，當這個模組可以獨力完成工作，就代表我們能夠重複使用它，且不需要擔心影響到其他模組，<u>越不需要依賴其他模組，內聚力就越高</u>。</p>
<p>白話一點的解釋：就算自己修改了也不影響其它人(模組)。</p>
<h3 id="耦合"><a href="#耦合" class="headerlink" title="耦合"></a>耦合</h3><p>耦合(Coupling)是指模組的關聯性，如果模組和另一個模組有關聯，那這兩者之間就耦合。例如：一個模組中的 function 使用<u>全域變數</u>或是<u>接受其他模組傳入的參數</u>，那麼這兩個模組就彼此耦合。</p>
<p>白話一點的解釋：牽一髮而動全身。</p>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p>高內聚：分類分得越精準越好。<br>低耦合：建立的關係越少越好。</p>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://ithelp.ithome.com.tw/articles/10203659">實務上的高內聚與低耦合</a><br><a href="https://igouist.github.io/post/2020/09/oo-8-cohesion-and-coupling/">菜雞與物件導向 (8): 內聚、耦合</a><br><a href="https://devs.tw/post/385">元件如何正確使用 ? | 元件耦合性三大原則 : ADP、SDP、SAP</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
        <tag>Cohesion</tag>
        <tag>Coupling</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(46)-Android架構</title>
    <url>/2024/03/06/Android%E7%AD%86%E8%A8%98-46-Android%E6%9E%B6%E6%A7%8B/</url>
    <content><![CDATA[<blockquote>
<p>比較 Android 架構(MVC、MVP、MVVM、Clean Architecture、MVI)</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="MVC-Model-View-Controller"><a href="#MVC-Model-View-Controller" class="headerlink" title="MVC(Model-View-Controller)"></a>MVC(Model-View-Controller)</h3><p>MVC 是最古老和最廣為人知的架構模式之一。 </p>
<ul>
<li>在啟動小型專案或快速原型設計時使用 MVC。 </li>
<li>它在 <b>data(Model)</b>、<b>UI(View)</b>和<b>邏輯(Controller)</b>之間提供了明確的分離。 </li>
<li>但是 MVC 會導致元件之間的<u>高耦合</u>和<u>單元測試</u>的困難。</li>
</ul>
<p>MVC 將程式碼劃分為三個部分：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>View</strong></td>
<td align="left">Layout XML 文件。</td>
</tr>
<tr>
<td align="left"><strong>Model</strong></td>
<td align="left">負責管理商業資料邏輯，如網絡請求、資料庫處理。</td>
</tr>
<tr>
<td align="left"><strong>Controller</strong></td>
<td align="left">Activity 負責處理表現邏輯。</td>
</tr>
</tbody></table>
<img src="https://imgur.com/UZjDO3d.png" width="80%">

<p>MVC 希望 Activity &#x2F; Fragment 是只處理表現邏輯的部分 ，但現實是 Activity 不可避免要處理 UI，也要處理和使用者的互動，說明 Activity 也承擔了 View 的角色。那麼這個架構就會造成 Activity 中融合了 view 和 logic 的代碼，分離程度不夠。</p>
<hr>
<h3 id="MVP-Model-View-Presenter"><a href="#MVP-Model-View-Presenter" class="headerlink" title="MVP(Model-View-Presenter)"></a>MVP(Model-View-Presenter)</h3><p>MVP 是 MVC 的演變，它進一步分離了 UI 和商業邏輯(business logic)的關注點。 </p>
<ul>
<li>將 MVP 用於要求更複雜的中型專案。 </li>
<li>它強制將 <b>Model</b>、<b>View</b> 和 <b>Presenter</b> 明確分開，使程式碼更易於理解和測試。 </li>
<li>MVP 允許更好的可測試性，並促進<a href="https://igouist.github.io/post/2020/10/oo-10-single-responsibility-principle/">單一責任原則(Single Responsibility Principle)</a>。 </li>
<li>但是，它仍然可能受到過多的樣板程式碼的影響，並且隨著專案的擴展而變得複雜。</li>
</ul>
<p>為了將 Activity 中的表現邏輯徹底分離出來，業界提出了 MVP 的設計。</p>
<p>MVP 將程式碼劃分為三個部分：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>View</strong></td>
<td align="left">Activity 和 Layout XML 文件。</td>
</tr>
<tr>
<td align="left"><strong>Model</strong></td>
<td align="left">負責管理商業資料邏輯，如網絡請求、資料庫處理。</td>
</tr>
<tr>
<td align="left"><strong>Presenter</strong></td>
<td align="left">負責處理表現邏輯。</td>
</tr>
</tbody></table>
<img src="https://imgur.com/CdbisGM.png">

<p>在實現細節上，View 和 Presenter 中間會定義一個協議介面 Contract，這個介面會約定 View 如何向 Presenter 發指令和 Presenter 如何 Callback 給 View。這樣的架構里 Activity 不再有表現邏輯的部分，Activity 作為 View 的角色只處理和 UI 有關的事情。但還是存在一些缺點：</p>
<ul>
<li>雙向依賴： View 和 Presenter 是雙向依賴的，一旦 View 層做出改變，相應地 Presenter 也需要做出調整。在業務語境下，View 層變化是大概率事件；</li>
<li>內存泄漏風險： Presenter 持有 View 層的引用，當用戶關閉了 View 層，但 Model 層仍然在進行耗時操作，就會有內存泄漏風險。雖然有解決辦法，但還是存在風險點和複雜度（弱引用 &#x2F; onDestroy() 回收 Presenter）。</li>
<li>協議介面類膨脹： View 層和 Presenter 層的交互需要定義介面方法，當交互非常複雜時，需要定義很多介面方法和 callback 方法，也不好維護。</li>
</ul>
<hr>
<h3 id="MVVM-Model-View-ViewModel"><a href="#MVVM-Model-View-ViewModel" class="headerlink" title="MVVM(Model-View-ViewModel)"></a>MVVM(Model-View-ViewModel)</h3><p>MVVM 是一種利用數據綁定(data binding)和響應式(reactive)程式設計的現代體系結構模式。 </p>
<ul>
<li>將 MVVM 用於大型專案，重點關注數據驅動的 UI 和複雜的數據流。 </li>
<li>它在 <b>View</b>、<b>ViewModel</b> 和 <b>Model</b> 之間提供了明確的分離。 </li>
<li>MVVM 利用雙向數據綁定(data binding)，使 UI 更新自動並減少樣板程式碼。 </li>
<li>這種架構允許更好的解耦、可測試性和可維護性。 </li>
<li>但是，採用 MVVM 需要對響應式程式設計和 data binding 概念有很好的理解。</li>
</ul>
<p>MVVM 將程式碼劃分為三個部分：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>View</strong></td>
<td align="left">Activity 和 Layout XML 文件，與 MVP 中 View 的概念相同。</td>
</tr>
<tr>
<td align="left"><strong>Model</strong></td>
<td align="left">負責管理業務數據邏輯，如網絡請求、資料庫處理，與 MVP 中 Model 的概念相同。</td>
</tr>
<tr>
<td align="left"><strong>ViewModel</strong></td>
<td align="left">存儲視圖狀態，負責處理表現邏輯，並將數據設置給可觀察數據容器。</td>
</tr>
</tbody></table>
<img src="https://imgur.com/za9JdgN.png">

<p>在實現細節上，View 和 Presenter 從雙向依賴變成 View 可以向 ViewModel 發指令，但 ViewModel 不會直接向 View 回調，而是讓 View 通過觀察者的模式去監聽數據的變化，有效規避了 MVP 雙向依賴的缺點。但 MVVM 本身也存在一些缺點：</p>
<ul>
<li>多數據流： View 與 ViewModel 的交互分散，缺少唯一修改源，不易於追蹤。</li>
<li>LiveData 膨脹： 複雜的頁面需要定義多個 MutableLiveData，並且都需要暴露為不可變的 LiveData。</li>
</ul>
<div class="note primary">
            <p>DataBinding、ViewModel 和 LiveData 等組件是 Google 為了幫助我們實現 MVVM 模式提供的架構組件，它們並不是 MVVM 的本質，只是實現上的工具。</p><ul><li>Lifecycle： 生命周期狀態回調。</li><li>LiveData： 可觀察的數據存儲類。</li><li>DataBinding： 可以自動同步 UI 和 data。</li><li>ViewModel： 存儲界面相關的數據，這些數據不會在手機旋轉等配置改變時丟失。</li></ul>
          </div>

<hr>
<h3 id="Clean-Architecture"><a href="#Clean-Architecture" class="headerlink" title="Clean Architecture"></a>Clean Architecture</h3><p>Clean Architecture 強調關注點和依賴關係規則的分離。</p>
<ul>
<li>將 Clean 架構用於大型複雜專案，重點關注可維護性和可測試性。 </li>
<li>它將代碼庫(codebase)劃分為多個層：<b>Presentation</b>、<b>Domain</b> 和 <b>Data</b>，每個層都有自己的職責和依賴關係。 </li>
<li>簡潔的架構允許輕鬆更換元件並促進單元測試。 </li>
<li>但是，它引入了額外的複雜性，並且可能會針對較小的專案進行過度設計。</li>
</ul>
<hr>
<h3 id="MVI-Model-View-Intent"><a href="#MVI-Model-View-Intent" class="headerlink" title="MVI(Model-View-Intent)"></a>MVI(Model-View-Intent)</h3><p> MVI 是一種新興的架構模式，旨在提供<u>可預測(predictable)</u>且<u>響應式(reactive)</u> UI。 </p>
<ul>
<li>將 MVI 用於需要嚴格的單向數據流(data flow)和高度互動式 UI 的專案。 </li>
<li>它將 <b>Model</b>、<b>View</b> 和 <b>Intent</b> 的關注點分開，提供清晰的數據流(data flow)方向。 </li>
<li>MVI 促進了不變性(immutability)和回應式(reactive)程式設計，使得對狀態變化的推理變得更加容易。 </li>
<li>但是，MVI 可能會帶來額外的複雜性，尤其是對於簡單的專案。</li>
</ul>
<p>MVI 模式的改動在於將 View 和 ViewModel 之間的多數據流改為基於 ViewState 的單數據流。</p>
<p>MVI 將程式碼劃分為四個部分：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">說明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>View</strong></td>
<td align="left">Activity 和 Layout XML 文件，與 MVVM 中 View 的概念相同。</td>
</tr>
<tr>
<td align="left"><strong>Intent</strong></td>
<td align="left">定義數據操作，是將數據傳到 Model 的唯一來源，相比 MVVM 是新的概念。</td>
</tr>
<tr>
<td align="left"><strong>ViewModel</strong></td>
<td align="left">存儲視圖狀態，負責處理表現邏輯，並將 ViewState 設置給可觀察數據容器。</td>
</tr>
<tr>
<td align="left"><strong>ViewState</strong></td>
<td align="left">一個數據類，包含頁面狀態和對應的數據。</td>
</tr>
</tbody></table>
<img src="https://imgur.com/RkvcUAT.png">

<p>在實現細節上，View 和 ViewModel 之間的多個交互（多 LiveData 數據流）變成了單數據流。無論 View 有多少個視圖狀態，只需要訂閱一個 ViewState 便可以獲取所有狀態，再根據 ViewState 去響應。當然，實踐中應該根據狀態之間的關聯程度來決定數據流的個數，不應該為了使用 MVI 模式而強行將多個無關的狀態壓縮在同一個數據流中。</p>
<ul>
<li>唯一可信源： 數據只有一個來源（ViewModel），與 MVVM 的思想相同；</li>
<li>單數據流： View 和 ViewModel 之間只有一個數據流，只有一個地方可以修改數據，確保數據是安全穩定的。並且 View 只需要訂閱一個 ViewState 就可以獲取所有狀態和數據，相比 MVVM 是新的特性；</li>
<li>響應式： ViewState 包含頁面當前的狀態和數據，View 通過訂閱 ViewState 就可以完成頁面刷新，相比於 MVVM 是新的特性。</li>
</ul>
<p>但 MVI 本身也存在一些缺點：</p>
<ul>
<li>State 膨脹： 所有視圖變化都轉換為 ViewState，還需要管理不同狀態下對應的數據。實踐中應該根據狀態之間的關聯程度來決定使用單流還是多流；</li>
<li>內存開銷： ViewState 是不可變類，狀態變更時需要創建新的對象，存在一定內存開銷；</li>
<li>局部刷新： View 根據 ViewState 響應，不易實現局部 Diff 刷新，可以使用 Flow#distinctUntilChanged() 來刷新來減少不必要的刷新。</li>
</ul>
<hr>
<h3 id="Android-架構的比較"><a href="#Android-架構的比較" class="headerlink" title="Android 架構的比較"></a>Android 架構的比較</h3><p>MVVM 和 MVP 的思想是相同的，最本質的概念就是 Activity 里做的事情太多了，所以要把 Activity 中與 UI 無關的部分抽離出來，交給別人做。這個 「別人」 在 MVP 里叫作 Presenter，在 MVVM 里叫作 ViewModel。而不論是 MVP 中的約定接口，還是 ViewModel 里的觀察者模式，這些都是實現上的細節而已。</p>
<p>MVI 與前者的主要區別不在於強調嚴格的單向數據流，而在於從命令式的開發模式，轉變為響應式的開發模式。</p>
<ul>
<li>MVC 和 MVP 適用於較小的專案。</li>
<li>MVVM、Clean Architecture 和 MVI 為更大和更複雜的專案提供了更好的可伸縮性、可測試性和可維護性。</li>
</ul>
<hr>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://medium.com/@KodeFlap/choosing-android-architectures-mvc-mvp-mvvm-clean-architecture-and-mvi-8ad2a43f7f9b">Choosing Android Architectures: MVC, MVP, MVVM, Clean Architecture, and MVI</a><br><a href="https://kknews.cc/zh-tw/n/pjb52mj.html">Android 架構演進：從 MVC 到 MVP、MVVM、MVI，Android開發如何選？</a></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>MVC</tag>
        <tag>MVP</tag>
        <tag>MVVM</tag>
        <tag>Clean Architecture</tag>
        <tag>MVI</tag>
      </tags>
  </entry>
  <entry>
    <title>Java筆記(2)-介面和抽象</title>
    <url>/2024/03/06/Java%E7%AD%86%E8%A8%98-2-%E4%BB%8B%E9%9D%A2%E5%92%8C%E6%8A%BD%E8%B1%A1/</url>
    <content><![CDATA[<blockquote>
<p>了解 Java 中的<b>介面(interface)</b>和<b>抽象(abstract)</b>。</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="介面"><a href="#介面" class="headerlink" title="介面"></a>介面</h3><p>介面可以被理解為「接口」，讓外部可以透過這個接口與內部作溝通。而「接口」通常都是有著某些特定形態的，只有收發雙方都有一樣的「接口」，接口才能被有效使用。介面作為接口，規範了方法能被外部使用的規則。</p>
<p>在程式設計中，我們可以透過介面來設定我們想被外部使用的規則，一是可以為每個需要的類別設定一樣的規則，二是避免把不應公開的內部程式碼對外公開。</p>
<p><b>介面(interface)</b>的方法都是<b>抽象(abstract)</b>且<b>公開(public)</b>的，以及其屬性全部都為<b>常數(const)</b>，介面本身<u>不實作方法</u>，而是為了<u>被外部使用</u>，因此方法都必定是公開的。</p>
<p>範例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不過這邊有個小技巧，由於介面裡面的屬性和方法一定「全部」都是「常數」和「抽象方法」，也一定要是 public 的，因此所有的修飾子都可以省略不寫：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是一個類別<b>實作(implements)</b> USB 介面的方式，<b><span class="label primary">介面中的所有方法都必需被實作</span></b>。亦即表示，介面變成了類別的規範。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Class Mouse <span class="keyword">implements</span> <span class="title class_">USB</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> countClick;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.state = <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">countClicking</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.countClick += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只要我們的類別需要用到 USB，我們就可以把 USB 介面實作到類別中。當介面作出改動時，所有實作該介面的類別都會收到訊息，以保實所有實作介面的類別都合符介面提出的規範。</p>
<p>但我們要注意的是，介面不一定是要能被重複使用的。換句話說，不是必需要可以被用在多個類別上時我們才使用介面，即使每個類別都有屬於自已的介面也是可以的，重點在於不要過度設計。</p>
<hr>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><h4 id="抽象類別"><a href="#抽象類別" class="headerlink" title="抽象類別"></a>抽象類別</h4><p>抽象類別不能建立實體，專門用來<span class="label primary">被繼承</span>。<br>抽象類別(Abstract Class)是很容易與介面搞混的概念，但他們其實是有很大的不同。<b><span class="label primary">抽象類別是不能直接實例化的類別</span></b>，<b><span class="label primary">抽象類別是用來被繼承的</span></b>。</p>
<p>擁有這個概念的類別，繼承抽象類別，在程式撰寫上就可以利用<b>多型</b>的概念上程式更有邏輯性。舉例來說，Animal 這個抽象的概念不應該被實體化，因為現實中不存在一種東西叫作「動物」，而狗、鳥、魚都是實際存在的東西，都擁有「動物」這個概念的特性。</p>
<p>抽象類別範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 成員定義</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 成員定義</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 成員定義</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Fish</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// 成員定義</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h4><p>抽象方法只能定義原型，專門用來<span class="label primary">被覆寫</span>。<br>抽象方法只能寫<u>方法的原型</u>，無法定義<u>方法的本體</u>，抽象方法只能定義在抽象類別中。</p>
<div class="note primary">
            <ul><li>方法的原型：只定義修飾子、回傳值型態、方法名稱、參數型態，而沒有大括號 <code>{}</code> 的部分就是方法原型。</li><li>方法的本體：就是用大括號 <code>{}</code> 定義的東西，有寫 <code>{}</code> 就算有定義，不管裡面有沒有程式敘述。</li></ul>
          </div>

<p>抽象方法(方法的原型)範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> &lt;修飾子&gt; 回傳型態 方法名稱(&lt;參數...&gt;);</span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure>

<p>因為抽象方法只能定義方法的原型，所以必須要有子類別「<b>覆寫</b>」這個抽象方法。</p>
<p>範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="type">int</span> weight,heigh;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(<span class="type">int</span> w,<span class="type">int</span> h)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.weight = w;</span><br><span class="line">        <span class="built_in">this</span>.height = h;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;啃骨頭...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;早起吃蟲...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="介面-vs-抽象類別"><a href="#介面-vs-抽象類別" class="headerlink" title="介面 vs 抽象類別"></a>介面 vs 抽象類別</h3><ul>
<li>相同：</li>
</ul>
<ol>
<li>介面和抽象類別都<u>無法直接被<b>實例化(實體化)</b></u>。</li>
<li>介面和抽象類別中的<b>抽象方法</b>都必須<b>被實作(被覆寫)</b>。</li>
</ol>
<ul>
<li>相異：</li>
</ul>
<ol>
<li>介面是用來被類別<b>實作(extends)</b>的，抽象類別是用來被類別<b>繼承(extends)</b>的。</li>
<li>抽象類別中可以定義<u>抽象方法</u>和<u>非抽象方法</u>，而介面中只能定義<u>抽象方法</u>。</li>
</ol>
<hr>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E4%B8%AD%E7%9A%84%E4%BB%8B%E9%9D%A2%E8%88%87%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5%E6%98%AF%E4%BB%80%E9%BA%BC-1199804ccc5f">Java備忘筆記</a><br><a href="https://medium.com/%E7%A8%8B%E5%BC%8F%E6%84%9B%E5%A5%BD%E8%80%85/%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91%E4%B8%AD%E7%9A%84%E4%BB%8B%E9%9D%A2%E8%88%87%E6%8A%BD%E8%B1%A1%E9%A1%9E%E5%88%A5%E6%98%AF%E4%BB%80%E9%BA%BC-1199804ccc5f">物件導向中的介面與抽象類別是什麼？</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
        <tag>Interface</tag>
        <tag>Abstract</tag>
      </tags>
  </entry>
  <entry>
    <title>Java筆記(1)-物件導向(OOP)</title>
    <url>/2024/02/29/Java%E7%AD%86%E8%A8%98-1-%E7%89%A9%E4%BB%B6%E5%B0%8E%E5%90%91-OOP/</url>
    <content><![CDATA[<blockquote>
<p>物件導向(Object-oriented programming)是程式開發的抽象方針，將物件作為程式的基本單元，將程式和資料封裝其中，以提高軟體的重用性、靈活性和擴充性。</p>
</blockquote>
<span id="more"></span>

<h3 id="類別-class"><a href="#類別-class" class="headerlink" title="類別(class)"></a>類別(class)</h3><p><b>類別(class)</b>是建立<b>物件(object)</b>的藍圖，內部定義了具體的<u><b>屬性(attribute)</b></u>和<u><b>方法(method)</b></u>，一旦類別做了<b>實體化(new)</b>的動作之後，就可以產生<b>物件(object)</b>，這個具體的物件就會擁有該類別所定義的屬性，並且可以執行該類別所定義的方法。</p>
<p>類別可能包括：</p>
<ul>
<li>屬性(attribute)：<b>變數(variable)</b>，需要記憶的資訊。</li>
<li>方法(method)：<b>函式(function)</b>，能夠提供的服務。</li>
<li>建構子&#x2F;建構函式(constructor)：設定<u>初始化</u>的<b>函式(function)</b>。<ul>
<li>建構子是「不可以」宣告回傳值型態，即使寫 void 也不行。</li>
<li><u>建構子名稱</u>需和該<u>類別(class)</u>同名。</li>
</ul>
</li>
</ul>
<div class="note primary">
            <h4 id="建構子的多載-overload"><a href="#建構子的多載-overload" class="headerlink" title="建構子的多載(overload)"></a>建構子的多載(overload)</h4><p>多載(overloading)：</p><ul><li>函數名稱相同，引數個數不同</li><li>引數個數相同，引數型態(type)不同</li></ul><p>相似功能的函數，以相同的名稱來命名之；透過不同的引數個數，或是不同的型態，來執行相對應的功能。</p><p>範例程式碼如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="comment">/* 屬性 */</span></span><br><span class="line">    String type;</span><br><span class="line">    String color; </span><br><span class="line">    Integer age; </span><br><span class="line">    Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 建構子 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123; <span class="comment">// 定義無引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&quot;米格魯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, String color, Integer age)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, Integer age, Integer weight)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;黃金獵犬&quot;</span>, <span class="string">&quot;金毛&quot;</span>, <span class="number">7</span>); <span class="comment">// 建構子的多載</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;薩摩耶&quot;</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;type:&quot;</span> + dog1.type + <span class="string">&quot; color:&quot;</span> + dog1.color + <span class="string">&quot; age:&quot;</span> + dog1.age + <span class="string">&quot; weight:&quot;</span> + dog1.weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;type:&quot;</span> + dog2.type + <span class="string">&quot; color:&quot;</span> + dog2.color + <span class="string">&quot; age:&quot;</span> + dog2.age + <span class="string">&quot; weight:&quot;</span> + dog2.weight);</span><br><span class="line">        System.out.println(<span class="string">&quot;type:&quot;</span> + dog3.type + <span class="string">&quot; color:&quot;</span> + dog3.color + <span class="string">&quot; age:&quot;</span> + dog3.age + <span class="string">&quot; weight:&quot;</span> + dog3.weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>執行結果：</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type:黃金獵犬 color:金毛 age:7 weight:null</span><br><span class="line">type:米格魯 color:null age:null weight:null</span><br><span class="line">type:薩摩耶 color:null age:5 weight:20</span><br></pre></td></tr></table></figure>
          </div>

<hr>
<h3 id="物件-object"><a href="#物件-object" class="headerlink" title="物件(object)"></a>物件(object)</h3><p>物件是實體的，由定義好的類別去建立一個物件，並將它實例化，可以是一個變數或是一個函式。</p>
<p>物件可能包括：</p>
<ul>
<li>屬性(attribute)：<b>變數(variable)</b>，需要記憶的資訊。</li>
<li>方法(method)：<b>函式(function)</b>，能夠提供的服務。</li>
</ul>
<p>延續上面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="comment">/* 屬性 */</span></span><br><span class="line">    String type;</span><br><span class="line">    String color; </span><br><span class="line">    Integer age; </span><br><span class="line">    Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 建構子 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123; <span class="comment">// 定義無引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&quot;米格魯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, String color, Integer age)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, Integer age, Integer weight)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDogInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span> + type + <span class="string">&quot; color:&quot;</span> + color + <span class="string">&quot; age:&quot;</span> + age + <span class="string">&quot; weight:&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;黃金獵犬&quot;</span>, <span class="string">&quot;金毛&quot;</span>, <span class="number">7</span>); <span class="comment">// 建構子的多載</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>(<span class="string">&quot;薩摩耶&quot;</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(dog1.getDogInfo());</span><br><span class="line">        System.out.println(dog2.getDogInfo());</span><br><span class="line">        System.out.println(dog3.getDogInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type:黃金獵犬 color:金毛 age:7 weight:null</span><br><span class="line">type:米格魯 color:null age:null weight:null</span><br><span class="line">type:薩摩耶 color:null age:5 weight:20</span><br></pre></td></tr></table></figure>

<p>有了 Dog 這個類別之後，可以產出很多 Dog 資料(dog1, dog2, dog3…)，每個 Dog 都是物件，每一個物件是獨立的個體，彼此互不影響。</p>
<hr>
<h3 id="物件導向的三大特性"><a href="#物件導向的三大特性" class="headerlink" title="物件導向的三大特性"></a>物件導向的三大特性</h3><p>物件導向的三大特性包括：<b>封裝(Encapsulation)</b>、<b>繼承(Inheritance)</b>、<b>多型(Polymorphism)</b>。</p>
<h4 id="封裝-Encapsulation"><a href="#封裝-Encapsulation" class="headerlink" title="封裝(Encapsulation)"></a>封裝(Encapsulation)</h4><p>所謂<b>封裝(Encapsulation)</b>，是指<u>類別</u>的設計者可以指定<u>其他的類別</u>能否存取自己的某個 <b>member</b>，也就是<b>存取範圍的控制(對外的開放程度)</b>。</p>
<div class="note primary">
            <p>封裝包含了兩個重要的觀念：</p><ul><li>控制<b>物件</b>和<b>外部</b>進行互動的<b>出入口</b></li><li>隱藏<b>物件內部</b>的細節資訊</li></ul>
          </div>

<p>Java 定義了四種存取範圍：</p>
<ul>
<li><b>private</b>：只有 <u>自己</u>才可以存取，使用關鍵字 <code>private</code>。</li>
<li><b>package</b>：只有<u>和自己同一個 package 的 class</u> 才可以存取，沒有相對應的關鍵字。</li>
<li><b>protected</b>：只有<u>同一個 package</u> 或是 <u>自己的子類別</u>才可以存取，使用關鍵字   <code>protected</code>。</li>
<li><b>public</b>：所有的 class 都可以存取，使用關鍵字 <code>public</code>。</li>
</ul>
<p>如果 member 的前面沒有 <code>private / protected / public</code> 其中一個修飾字，則該 member 的存取範圍就是 <b>package</b>。從以上的敘述，讀者可以推知這四種存取範圍的大小是：<br><code>public &gt; protected &gt; package &gt; private</code></p>
<h4 id="繼承-Inheritance"><a href="#繼承-Inheritance" class="headerlink" title="繼承(Inheritance)"></a>繼承(Inheritance)</h4><p><u>子類別(sub class)</u>可以繼承<u>父類別(super class)</u>的屬性和方法，而不需重新定義，有程式碼再利用的概念。</p>
<ul>
<li>每個子類別只能有一個父類別，而父類別可擁有一個以上的子類別。</li>
<li>兩者之間的關係可以用「is a」表示：<u>SmartPhone(子類別)</u> <strong>is a</strong> <u>Product(父類別)</u>。</li>
<li>透過關鍵字 <code>extends</code> 繼承來自父類別的 member。</li>
</ul>
<img src="https://i.imgur.com/GeSlqpx.png" width="70%">

<h4 id="多型-Polymorphism"><a href="#多型-Polymorphism" class="headerlink" title="多型(Polymorphism)"></a>多型(Polymorphism)</h4><p>多型(Polymorphism)可以分為兩種類型：</p>
<ul>
<li>編譯時多型 - 多載(Overloading)。</li>
<li>執行時多型 - 覆寫(Overriding)。</li>
</ul>
<h5 id="多載-Overloading"><a href="#多載-Overloading" class="headerlink" title="多載(Overloading)"></a>多載(Overloading)</h5><p>有多個<u>相同名稱的方法</u>，但是<u>傳入不同的參數</u>就會執行不同的敘述。</p>
<p>範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, String color, Integer age, Integer weight)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, String color, Integer age)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, Integer age, Integer weight)</span></span><br></pre></td></tr></table></figure>

<p>再使用前面的 Dog class 舉例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> &#123;</span><br><span class="line">    <span class="comment">/* 屬性 */</span></span><br><span class="line">    String type;</span><br><span class="line">    String color;</span><br><span class="line">    Integer age;</span><br><span class="line">    Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 建構子 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">()</span> &#123; <span class="comment">//定義無引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&quot;米格魯&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, String color, Integer age)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dog</span><span class="params">(String type, Integer age, Integer weight)</span> &#123; <span class="comment">// 定義有引數的建構子</span></span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getDogInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;type:&quot;</span> + type + <span class="string">&quot; color:&quot;</span> + color + <span class="string">&quot; age:&quot;</span> + age + <span class="string">&quot; weight:&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, String color, Integer age, Integer weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, String color, Integer age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDogInfo</span><span class="params">(String type, Integer age, Integer weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 將物件實例化</span></span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設定 Dog 資料</span></span><br><span class="line">        dog1.setDogInfo(<span class="string">&quot;黃金獵犬&quot;</span>, <span class="string">&quot;金毛&quot;</span>, <span class="number">7</span>);</span><br><span class="line">        dog2.setDogInfo(<span class="string">&quot;薩摩耶&quot;</span>, <span class="number">5</span>, <span class="number">20</span>);</span><br><span class="line">        dog3.setDogInfo(<span class="string">&quot;米格魯&quot;</span>, <span class="string">&quot;金毛&quot;</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 印出 Dog 資料</span></span><br><span class="line">        System.out.println(dog1.getDogInfo());</span><br><span class="line">        System.out.println(dog2.getDogInfo());</span><br><span class="line">        System.out.println(dog3.getDogInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">type:黃金獵犬 color:金毛 age:7 weight:null</span><br><span class="line">type:薩摩耶 color:null age:5 weight:20</span><br><span class="line">type:米格魯 color:金毛 age:3 weight:15</span><br></pre></td></tr></table></figure>

<h5 id="覆寫-Overriding"><a href="#覆寫-Overriding" class="headerlink" title="覆寫(Overriding)"></a>覆寫(Overriding)</h5><p><u>子類別</u>可以<b>覆寫</b><u>父類別</u>的<b>方法</b>，使其擁有不同於父類別的行為。</p>
<p>父類別範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">/* 屬性 */</span></span><br><span class="line">    String type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 建構子 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = <span class="string">&quot;貓&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;動物資料: type:&quot;</span> + type;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setType</span><span class="params">(String type)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = type;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>子類別範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dog</span> <span class="keyword">extends</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">/* 屬性 */</span></span><br><span class="line">    String species;</span><br><span class="line">    String color;</span><br><span class="line">    Integer age;</span><br><span class="line">    Integer weight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 方法 */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getInfo</span><span class="params">()</span> &#123; <span class="comment">// 覆寫父類別方法</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;小狗資料: type:&quot;</span> + type + <span class="string">&quot; species:&quot;</span> + species + <span class="string">&quot; color:&quot;</span> + color + <span class="string">&quot; age:&quot;</span> + age + <span class="string">&quot; weight:&quot;</span> + weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setInfo</span><span class="params">(String species, String color, Integer age, Integer weight)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.species = species;</span><br><span class="line">        <span class="built_in">this</span>.color = color;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Main 函式範例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 將物件實例化</span></span><br><span class="line">        <span class="type">Animal</span> <span class="variable">animal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Animal</span>();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 設定資料</span></span><br><span class="line">        dog.setType(<span class="string">&quot;狗&quot;</span>); <span class="comment">// 使用父類別的方法</span></span><br><span class="line">        dog.setInfo(<span class="string">&quot;米格魯&quot;</span>, <span class="string">&quot;金毛&quot;</span>, <span class="number">3</span>, <span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 印出資料</span></span><br><span class="line">        System.out.println(animal.getInfo());</span><br><span class="line">        System.out.println(dog.getInfo());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">動物資料: type:貓</span><br><span class="line">小狗資料: type:狗 species:米格魯 color:金毛 age:3 weight:15</span><br></pre></td></tr></table></figure>

<p>原本父類別的 getInfo() 方法只能取得 type。<br>因子類別覆寫了父類別的 getInfo() 方法，可取得 type、species、color、age 和 weight。</p>
<h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="https://hackmd.io/@Aquamay/H1nxBOLcO/https%3A%2F%2Fhackmd.io%2F%40Aquamay%2FrkAMTLIjd">物件導向(Object-oriented programming)</a><br><a href="https://java.4-x.tw/">Java 學習系列</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>OOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Privacy Policy(隱私權政策)-天氣：威特 App</title>
    <url>/2024/02/09/%E9%9A%B1%E7%A7%81%E6%AC%8A%E6%94%BF%E7%AD%96-%E5%A4%A9%E6%B0%A3%EF%BC%9A%E5%A8%81%E7%89%B9-App/</url>
    <content><![CDATA[<h1 id="Privacy-Policy"><a href="#Privacy-Policy" class="headerlink" title="Privacy Policy"></a>Privacy Policy</h1><p>Last updated: February 09, 2024</p>
<p>This Privacy Policy describes Our policies and procedures on the collection, use and disclosure of Your information when You use the Service and tells You about Your privacy rights and how the law protects You.</p>
<p>We use Your Personal data to provide and improve the Service. By using the Service, You agree to the collection and use of information in accordance with this Privacy Policy. This Privacy Policy has been created with the help of the <a href="https://www.privacypolicies.com/privacy-policy-generator/">Privacy Policy Generator</a>.</p>
<span id="more"></span>

<h2 id="Interpretation-and-Definitions"><a href="#Interpretation-and-Definitions" class="headerlink" title="Interpretation and Definitions"></a>Interpretation and Definitions</h2><h3 id="Interpretation"><a href="#Interpretation" class="headerlink" title="Interpretation"></a>Interpretation</h3><p>The words of which the initial letter is capitalized have meanings defined under the following conditions. The following definitions shall have the same meaning regardless of whether they appear in singular or in plural.</p>
<h3 id="Definitions"><a href="#Definitions" class="headerlink" title="Definitions"></a>Definitions</h3><p>For the purposes of this Privacy Policy:</p>
<ul>
<li><p><strong>Account</strong> means a unique account created for You to access our Service or parts of our Service.</p>
</li>
<li><p><strong>Affiliate</strong> means an entity that controls, is controlled by or is under common control with a party, where “control” means ownership of 50% or more of the shares, equity interest or other securities entitled to vote for election of directors or other managing authority.</p>
</li>
<li><p><strong>Application</strong> refers to 天氣：威特, the software program provided by the Company.</p>
</li>
<li><p><strong>Company</strong> (referred to as either “the Company”, “We”, “Us” or “Our” in this Agreement) refers to 天氣：威特.</p>
</li>
<li><p><strong>Country</strong> refers to:  Taiwan</p>
</li>
<li><p><strong>Device</strong> means any device that can access the Service such as a computer, a cellphone or a digital tablet.</p>
</li>
<li><p><strong>Personal Data</strong> is any information that relates to an identified or identifiable individual.</p>
</li>
<li><p><strong>Service</strong> refers to the Application.</p>
</li>
<li><p><strong>Service Provider</strong> means any natural or legal person who processes the data on behalf of the Company. It refers to third-party companies or individuals employed by the Company to facilitate the Service, to provide the Service on behalf of the Company, to perform services related to the Service or to assist the Company in analyzing how the Service is used.</p>
</li>
<li><p><strong>Usage Data</strong> refers to data collected automatically, either generated by the use of the Service or from the Service infrastructure itself (for example, the duration of a page visit).</p>
</li>
<li><p><strong>You</strong> means the individual accessing or using the Service, or the company, or other legal entity on behalf of which such individual is accessing or using the Service, as applicable.</p>
</li>
</ul>
<h2 id="Collecting-and-Using-Your-Personal-Data"><a href="#Collecting-and-Using-Your-Personal-Data" class="headerlink" title="Collecting and Using Your Personal Data"></a>Collecting and Using Your Personal Data</h2><h3 id="Types-of-Data-Collected"><a href="#Types-of-Data-Collected" class="headerlink" title="Types of Data Collected"></a>Types of Data Collected</h3><h4 id="Personal-Data"><a href="#Personal-Data" class="headerlink" title="Personal Data"></a>Personal Data</h4><p>While using Our Service, We may ask You to provide Us with certain personally identifiable information that can be used to contact or identify You. Personally identifiable information may include, but is not limited to:</p>
<ul>
<li><p>Address, State, Province, ZIP&#x2F;Postal code, City</p>
</li>
<li><p>Usage Data</p>
</li>
</ul>
<h4 id="Usage-Data"><a href="#Usage-Data" class="headerlink" title="Usage Data"></a>Usage Data</h4><p>Usage Data is collected automatically when using the Service.</p>
<p>Usage Data may include information such as Your Device’s Internet Protocol address (e.g. IP address), browser type, browser version, the pages of our Service that You visit, the time and date of Your visit, the time spent on those pages, unique device identifiers and other diagnostic data.</p>
<p>When You access the Service by or through a mobile device, We may collect certain information automatically, including, but not limited to, the type of mobile device You use, Your mobile device unique ID, the IP address of Your mobile device, Your mobile operating system, the type of mobile Internet browser You use, unique device identifiers and other diagnostic data.</p>
<p>We may also collect information that Your browser sends whenever You visit our Service or when You access the Service by or through a mobile device.</p>
<h4 id="Information-Collected-while-Using-the-Application"><a href="#Information-Collected-while-Using-the-Application" class="headerlink" title="Information Collected while Using the Application"></a>Information Collected while Using the Application</h4><p>While using Our Application, in order to provide features of Our Application, We may collect, with Your prior permission:</p>
<ul>
<li>Information regarding your location</li>
</ul>
<p>We use this information to provide features of Our Service, to improve and customize Our Service. The information may be uploaded to the Company’s servers and&#x2F;or a Service Provider’s server or it may be simply stored on Your device.</p>
<p>You can enable or disable access to this information at any time, through Your Device settings.</p>
<h3 id="Use-of-Your-Personal-Data"><a href="#Use-of-Your-Personal-Data" class="headerlink" title="Use of Your Personal Data"></a>Use of Your Personal Data</h3><p>The Company may use Personal Data for the following purposes:</p>
<ul>
<li><p><strong>To provide and maintain our Service</strong>, including to monitor the usage of our Service.</p>
</li>
<li><p><strong>To manage Your Account:</strong> to manage Your registration as a user of the Service. The Personal Data You provide can give You access to different functionalities of the Service that are available to You as a registered user.</p>
</li>
<li><p><strong>For the performance of a contract:</strong> the development, compliance and undertaking of the purchase contract for the products, items or services You have purchased or of any other contract with Us through the Service.</p>
</li>
<li><p><strong>To contact You:</strong> To contact You by email, telephone calls, SMS, or other equivalent forms of electronic communication, such as a mobile application’s push notifications regarding updates or informative communications related to the functionalities, products or contracted services, including the security updates, when necessary or reasonable for their implementation.</p>
</li>
<li><p><strong>To provide You</strong> with news, special offers and general information about other goods, services and events which we offer that are similar to those that you have already purchased or enquired about unless You have opted not to receive such information.</p>
</li>
<li><p><strong>To manage Your requests:</strong> To attend and manage Your requests to Us.</p>
</li>
<li><p><strong>For business transfers:</strong> We may use Your information to evaluate or conduct a merger, divestiture, restructuring, reorganization, dissolution, or other sale or transfer of some or all of Our assets, whether as a going concern or as part of bankruptcy, liquidation, or similar proceeding, in which Personal Data held by Us about our Service users is among the assets transferred.</p>
</li>
<li><p><strong>For other purposes</strong>: We may use Your information for other purposes, such as data analysis, identifying usage trends, determining the effectiveness of our promotional campaigns and to evaluate and improve our Service, products, services, marketing and your experience.</p>
</li>
</ul>
<p>We may share Your personal information in the following situations:</p>
<ul>
<li><strong>With Service Providers:</strong> We may share Your personal information with Service Providers to monitor and analyze the use of our Service,  to contact You.</li>
<li><strong>For business transfers:</strong> We may share or transfer Your personal information in connection with, or during negotiations of, any merger, sale of Company assets, financing, or acquisition of all or a portion of Our business to another company.</li>
<li><strong>With Affiliates:</strong> We may share Your information with Our affiliates, in which case we will require those affiliates to honor this Privacy Policy. Affiliates include Our parent company and any other subsidiaries, joint venture partners or other companies that We control or that are under common control with Us.</li>
<li><strong>With business partners:</strong> We may share Your information with Our business partners to offer You certain products, services or promotions.</li>
<li><strong>With other users:</strong> when You share personal information or otherwise interact in the public areas with other users, such information may be viewed by all users and may be publicly distributed outside. </li>
<li><strong>With Your consent</strong>: We may disclose Your personal information for any other purpose with Your consent.</li>
</ul>
<h3 id="Retention-of-Your-Personal-Data"><a href="#Retention-of-Your-Personal-Data" class="headerlink" title="Retention of Your Personal Data"></a>Retention of Your Personal Data</h3><p>The Company will retain Your Personal Data only for as long as is necessary for the purposes set out in this Privacy Policy. We will retain and use Your Personal Data to the extent necessary to comply with our legal obligations (for example, if we are required to retain your data to comply with applicable laws), resolve disputes, and enforce our legal agreements and policies.</p>
<p>The Company will also retain Usage Data for internal analysis purposes. Usage Data is generally retained for a shorter period of time, except when this data is used to strengthen the security or to improve the functionality of Our Service, or We are legally obligated to retain this data for longer time periods.</p>
<h3 id="Transfer-of-Your-Personal-Data"><a href="#Transfer-of-Your-Personal-Data" class="headerlink" title="Transfer of Your Personal Data"></a>Transfer of Your Personal Data</h3><p>Your information, including Personal Data, is processed at the Company’s operating offices and in any other places where the parties involved in the processing are located. It means that this information may be transferred to — and maintained on — computers located outside of Your state, province, country or other governmental jurisdiction where the data protection laws may differ than those from Your jurisdiction.</p>
<p>Your consent to this Privacy Policy followed by Your submission of such information represents Your agreement to that transfer.</p>
<p>The Company will take all steps reasonably necessary to ensure that Your data is treated securely and in accordance with this Privacy Policy and no transfer of Your Personal Data will take place to an organization or a country unless there are adequate controls in place including the security of Your data and other personal information.</p>
<h3 id="Delete-Your-Personal-Data"><a href="#Delete-Your-Personal-Data" class="headerlink" title="Delete Your Personal Data"></a>Delete Your Personal Data</h3><p>You have the right to delete or request that We assist in deleting the Personal Data that We have collected about You.</p>
<p>Our Service may give You the ability to delete certain information about You from within the Service.</p>
<p>You may update, amend, or delete Your information at any time by signing in to Your Account, if you have one, and visiting the account settings section that allows you to manage Your personal information. You may also contact Us to request access to, correct, or delete any personal information that You have provided to Us.</p>
<p>Please note, however, that We may need to retain certain information when we have a legal obligation or lawful basis to do so.</p>
<h3 id="Disclosure-of-Your-Personal-Data"><a href="#Disclosure-of-Your-Personal-Data" class="headerlink" title="Disclosure of Your Personal Data"></a>Disclosure of Your Personal Data</h3><h4 id="Business-Transactions"><a href="#Business-Transactions" class="headerlink" title="Business Transactions"></a>Business Transactions</h4><p>If the Company is involved in a merger, acquisition or asset sale, Your Personal Data may be transferred. We will provide notice before Your Personal Data is transferred and becomes subject to a different Privacy Policy.</p>
<h4 id="Law-enforcement"><a href="#Law-enforcement" class="headerlink" title="Law enforcement"></a>Law enforcement</h4><p>Under certain circumstances, the Company may be required to disclose Your Personal Data if required to do so by law or in response to valid requests by public authorities (e.g. a court or a government agency).</p>
<h4 id="Other-legal-requirements"><a href="#Other-legal-requirements" class="headerlink" title="Other legal requirements"></a>Other legal requirements</h4><p>The Company may disclose Your Personal Data in the good faith belief that such action is necessary to:</p>
<ul>
<li>Comply with a legal obligation</li>
<li>Protect and defend the rights or property of the Company</li>
<li>Prevent or investigate possible wrongdoing in connection with the Service</li>
<li>Protect the personal safety of Users of the Service or the public</li>
<li>Protect against legal liability</li>
</ul>
<h3 id="Security-of-Your-Personal-Data"><a href="#Security-of-Your-Personal-Data" class="headerlink" title="Security of Your Personal Data"></a>Security of Your Personal Data</h3><p>The security of Your Personal Data is important to Us, but remember that no method of transmission over the Internet, or method of electronic storage is 100% secure. While We strive to use commercially acceptable means to protect Your Personal Data, We cannot guarantee its absolute security.</p>
<h2 id="Children’s-Privacy"><a href="#Children’s-Privacy" class="headerlink" title="Children’s Privacy"></a>Children’s Privacy</h2><p>Our Service does not address anyone under the age of 13. We do not knowingly collect personally identifiable information from anyone under the age of 13. If You are a parent or guardian and You are aware that Your child has provided Us with Personal Data, please contact Us. If We become aware that We have collected Personal Data from anyone under the age of 13 without verification of parental consent, We take steps to remove that information from Our servers.</p>
<p>If We need to rely on consent as a legal basis for processing Your information and Your country requires consent from a parent, We may require Your parent’s consent before We collect and use that information.</p>
<h2 id="Links-to-Other-Websites"><a href="#Links-to-Other-Websites" class="headerlink" title="Links to Other Websites"></a>Links to Other Websites</h2><p>Our Service may contain links to other websites that are not operated by Us. If You click on a third party link, You will be directed to that third party’s site. We strongly advise You to review the Privacy Policy of every site You visit.</p>
<p>We have no control over and assume no responsibility for the content, privacy policies or practices of any third party sites or services.</p>
<h2 id="Changes-to-this-Privacy-Policy"><a href="#Changes-to-this-Privacy-Policy" class="headerlink" title="Changes to this Privacy Policy"></a>Changes to this Privacy Policy</h2><p>We may update Our Privacy Policy from time to time. We will notify You of any changes by posting the new Privacy Policy on this page.</p>
<p>We will let You know via email and&#x2F;or a prominent notice on Our Service, prior to the change becoming effective and update the “Last updated” date at the top of this Privacy Policy.</p>
<p>You are advised to review this Privacy Policy periodically for any changes. Changes to this Privacy Policy are effective when they are posted on this page.</p>
<h2 id="Contact-Us"><a href="#Contact-Us" class="headerlink" title="Contact Us"></a>Contact Us</h2><p>If you have any questions about this Privacy Policy, You can contact us:</p>
<ul>
<li>By email: <a href="mailto:&#x6c;&#105;&#x6e;&#x67;&#108;&#x69;&#x6e;&#103;&#x64;&#114;&#48;&#48;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;">&#x6c;&#105;&#x6e;&#x67;&#108;&#x69;&#x6e;&#103;&#x64;&#114;&#48;&#48;&#64;&#x67;&#x6d;&#97;&#x69;&#108;&#x2e;&#99;&#x6f;&#109;</a></li>
</ul>
]]></content>
      <categories>
        <category>Privacy Policy</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(45)-使用WorkManager處理background work</title>
    <url>/2023/12/29/Android%E7%AD%86%E8%A8%98-45-%E4%BD%BF%E7%94%A8WorkManager%E8%99%95%E7%90%86background-work/</url>
    <content><![CDATA[<blockquote>
<p>瞭解如何使用 <code>WorkManager</code> 編寫 simple work，然後執行設有<b>限制條件(constraints)</b>的複雜<b>鏈結(chaining)</b> work。</p>
</blockquote>
<p><strong>建構項目</strong><br>使用 Blur-O-Matic，該 app 可對照片進行模糊處理，並將處理後的照片保存在檔案中。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:40%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/android-workmanager/img/9e4707e0fbdd93c7_1920.png">
    </div>
    <div style="width:40%;float:left;">
        <img src="https://developer.android.com/static/codelabs/android-workmanager/img/f290bdf51724bfd7_1920.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p><strong>學習目標</strong></p>
<ul>
<li>將 <code>WorkManager</code> 添加到您的 project 中</li>
<li>安排(scheduling) 一個 simple task</li>
<li>Input 和 output 參數</li>
<li>鏈結(chaining) work</li>
<li>唯一(unique) work</li>
<li>在 UI 中顯示 work status </li>
<li>取消(cancel) work</li>
<li>work 限制條件(constraints)</li>
</ul>
<span id="more"></span>

<h3 id="WorkManager-簡介"><a href="#WorkManager-簡介" class="headerlink" title="WorkManager 簡介"></a>WorkManager 簡介</h3><p>Android 有多個選項用於處理可延遲的後台工作。此 Codelab 中介紹的 <a href="https://developer.android.com/develop/background-work/background-tasks/persistent?hl=zh-tw">WorkManager</a> 是一種具有<u>向後兼容性(backwards compatible)</u>且簡單靈活的 <strong>library</strong>，用於處理<u>可延遲的<b>後台工作(background work)</b></u>。<strong>WorkManager</strong> 是 Android 平台上推薦用於處理<u>可延遲工作(deferrable work)</u>的 <strong>task scheduler</strong>，能夠保證工作得到執行。</p>
<h4 id="什麽是-WorkManager"><a href="#什麽是-WorkManager" class="headerlink" title="什麽是 WorkManager"></a>什麽是 WorkManager</h4><p>WorkManager 屬於 <a href="https://developer.android.com/jetpack?hl=zh-tw">Android Jetpack</a> 的一部分，是一種<a href="https://developer.android.com/topic/architecture?hl=zh-tw">Architecture Component</a>，用於處理既需要機會性執行，又需要有保證的執行的後台工作。<b>機會性執行(Opportunistic execution)</b>意味著 WorkManager 會<u>盡快執行您的後台工作</u>。<b>有保證的執行(Guaranteed execution)</b>意味著 WorkManager 會<u>負責通過邏輯保障在各種情況下啟動您的工作</u>，即使使用者離開您的 app 也無妨。</p>
<p>WorkManager 是一個極其靈活的 library，具有許多其他優勢。這其中包括：</p>
<ul>
<li>支援<b>非同步(asynchronous)</b><u>一次性(one-off)任務</u>和<u>週期性(periodic)任務</u></li>
<li>支持 <u>network conditions</u>、<u>儲存空間</u>和<u>充電狀態</u>等<b>限制(constraints)條件</b></li>
<li>鏈接複雜的 <strong>work requests</strong>，包括<u>並行(parallel)</u> 運行 work</li>
<li>將來自一個 work requests 的 <strong>output</strong> 用作下一個 work requests 的 <strong>input</strong></li>
<li>處理到 API 等級的兼容性，可向後兼容至 API 等級 14</li>
<li>無論是否使用 <strong>Google Play services</strong> 都可以運行</li>
<li>遵循系統健康最佳做法</li>
<li>提供 <code>LiveData</code> 支持，可在 UI 中輕鬆顯示 <strong>work request state</strong></li>
</ul>
<div class="note success">
            <p><strong>注意：</strong>WorkManager 依賴於幾個 API，例如 <a href="https://developer.android.com/reference/android/app/job/JobScheduler">JobScheduler</a> 和 <a href="https://developer.android.com/reference/android/app/AlarmManager">AlarmManager</a>。WorkManager 會根據使用者裝置 API 級別等條件選擇使用適合的 API。如需了解詳情，請查看 <a href="https://developer.android.com/topic/libraries/architecture/workmanager?hl=zh-tw">WorkManager 文件</a>。</p>
          </div>

<h4 id="何時使用-WorkManager"><a href="#何時使用-WorkManager" class="headerlink" title="何時使用 WorkManager"></a>何時使用 WorkManager</h4><p>有些任務，即便使用者離開特定螢幕或您的 app，也需要完成。對於這些任務(tasks)，<strong>WorkManager library</strong> 是不錯的選擇。</p>
<p>以下是一些適合使用 WorkManager 的任務(tasks)的典型範例：</p>
<ul>
<li>上傳(Uploading) logs</li>
<li>對 image 套用濾鏡(filters)並儲存 image</li>
<li>定期將 local data 與 network 同步</li>
</ul>
<p>WorkManager 提供有保證的執行，然而並非所有任務都需要這種保證。因此，它並非運行所有非 main thread 任務(task)的萬全之選。如需詳細了解何時使用 WorkManager，請參閱<a href="https://developer.android.com/guide/background/?hl=zh-cn">Background 處理指南</a>。</p>
<hr>
<h3 id="準備工作"><a href="#準備工作" class="headerlink" title="準備工作"></a>準備工作</h3><h4 id="第-1-步-下載程式碼"><a href="#第-1-步-下載程式碼" class="headerlink" title="第 1 步 - 下載程式碼"></a>第 1 步 - 下載程式碼</h4><p>從 GitHub clone WorkManager Codelab：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone -b start_kotlin https://github.com/googlecodelabs/android-workmanager</span><br></pre></td></tr></table></figure>

<h4 id="第-2-步-執行-app"><a href="#第-2-步-執行-app" class="headerlink" title="第 2 步 - 執行 app"></a>第 2 步 - 執行 app</h4><p>執行 app，您應該會看到下方的畫面。</p>
<img src="https://i.imgur.com/M5wSsva.png" width="40%">

<p>螢幕上應該會顯示一些 radio buttons，您可以通過這些 button 選擇要對圖片進行什麽程度的模糊處理。按 Go button 即可對圖片進行模糊處理並保存。</p>
<p>截至目前，此 app 不會應用任何模糊處理。</p>
<p>起始程式碼包含以下內容：</p>
<ul>
<li><code>WorkerUtils</code>：這個 class 包含<u>對圖片實際進行模糊處理</u>所需的程式碼，並包含之後您會用於顯示<code>Notifications</code>、<u>將 bitmap 保存到檔案</u>以及<u>減慢 app 運行速度</u>的一些便捷方法。</li>
<li><code>BlurActivity</code>：* 此 <code>activity</code> 用於<u>顯示圖片</u>以及添加用於<u>選擇模糊程度的 radio buttons</u>。</li>
<li><code>BlurViewModel</code>：*此 view model 用於<u>儲存顯示 <code>BlurActivity</code> 所需的所有資料</u>，也將是您<u>使用 <code>WorkManager</code> 啟動後台工作(background work)</u>的 class。</li>
<li><code>Constants</code>：一個靜態(static) class，其中包含您在學習此 Codelab 期間會用到的一些常數(constants)。</li>
<li><code>res/activity_blur.xml</code>：<code>BlurActivity</code> 的 layout 檔案。</li>
</ul>
<p>您將僅在這些檔案中編寫程式碼。</p>
<hr>
<h3 id="將-WorkManager-添加到-app"><a href="#將-WorkManager-添加到-app" class="headerlink" title="將 WorkManager 添加到 app"></a>將 WorkManager 添加到 app</h3><p><code>WorkManager</code> 需要使用以下 Gradle dependency，這些 dependency 已包含在 build 檔案中：</p>
<p><code>app/build.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="comment">// WorkManager dependency</span></span><br><span class="line">    implementation <span class="string">&quot;androidx.work:work-runtime-ktx:$versions.work&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>您應該在<a href="https://developer.android.com/jetpack/androidx/releases/work?hl=zh-cn">此處</a>獲取最新穩定版 <code>work-runtime-ktx</code>，並部署正確的版本。</li>
</ul>
<p>目前，最新版本為：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">versions.work = <span class="string">&quot;2.7.1&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="創建-WorkRequest"><a href="#創建-WorkRequest" class="headerlink" title="創建 WorkRequest"></a>創建 WorkRequest</h3><p>在此步驟中，您將接受 <code>res/drawable</code> 資料夾中一張名為 <code>android_cupcake.png</code> 的圖片，並在<u>後台(background)</u>對這張圖片運行一些函數。這些函數會對圖片進行<u>模糊處理</u>，然後將圖片保存到暫存檔案中。</p>
<h4 id="WorkManager-基礎知識"><a href="#WorkManager-基礎知識" class="headerlink" title="WorkManager 基礎知識"></a>WorkManager 基礎知識</h4><p>您需要了解以下幾個 WorkManager class：</p>
<ul>
<li><a href="https://developer.android.com/reference/androidx/work/Worker"><code>Worker</code></a>：此位置用於放置您希望在<b>後台(background)</b>執行的實際工作的程式碼。您需要<u>繼承</u>此 class 並替換 <a href="https://developer.android.com/reference/androidx/work/Worker#doWork()"><code>doWork()</code></a> 方法。</li>
<li><a href="https://developer.android.com/reference/androidx/work/WorkRequest"><code>WorkRequest</code></a>：此 class 表示<u>請求(request)執行某些工作</u>。您將在創建 <code>WorkRequest</code> 的過程中傳入 <code>Worker</code>。在創建 <code>WorkRequest</code> 時，您還可以指定 <a href="https://developer.android.com/reference/androidx/work/Constraints"><code>Constraints</code></a> 等內容，例如運行 <code>Worker</code> 的時間。</li>
<li><a href="https://developer.android.com/reference/androidx/work/WorkManager"><code>WorkManager</code></a>：這個 class 實質上可以安排(schedules)您的 <code>WorkRequest</code> 並使其運行。它以<u>分散<b>系統資源(system resources)</b>負載(load)</u>的方式安排(schedules) <code>WorkRequest</code>，同時遵守您指定的<u>限制條件(constraints)</u>。</li>
</ul>
<p>在這種情況下，您將定義新的 <code>BlurWorker</code>，其中包含用於對圖片進行模糊處理的程式碼。點擊 Go button 時，系統會創建一個 <code>WorkRequest</code>，然後通過 <code>WorkManager</code> 將其加入<b>隊列(enqueued)</b>。</p>
<h4 id="第-1-步-創建-BlurWorker"><a href="#第-1-步-創建-BlurWorker" class="headerlink" title="第 1 步 - 創建 BlurWorker"></a>第 1 步 - 創建 BlurWorker</h4><p>在 <code>workers</code> package 中，新建一個名為 <code>BlurWorker</code> 的 Kotlin class。</p>
<h4 id="第-2-步-新增-constructor"><a href="#第-2-步-新增-constructor" class="headerlink" title="第 2 步 - 新增 constructor"></a>第 2 步 - 新增 constructor</h4><p>向 <code>BlurWorker</code> class 新增對 <code>Worker</code> 的 dependency：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlurWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-覆寫並實作-doWork"><a href="#第-3-步-覆寫並實作-doWork" class="headerlink" title="第 3 步 - 覆寫並實作 doWork()"></a>第 3 步 - 覆寫並實作 doWork()</h4><p><code>Worker</code> 會對所顯示的 cupcake image 進行模糊處理。</p>
<p>為了更好地了解何時執行工作，您將使用 <code>WorkerUtil</code> 的 <code>makeStatusNotification()</code>。使用此方法，您可以輕松地在螢幕頂部顯示 <strong>notification banner</strong>。</p>
<p>替換 <code>doWork()</code> 方法，然後執行以下操作。您可以參考本部分末尾完成後的程式碼：</p>
<ol>
<li>通過呼叫 <code>applicationContext</code> 屬性獲取 <code>Context</code>。將其分配給名為 <code>appContext</code> 的新 <code>val</code>。您接下來要執行的各種 bitmap 處理需要用到此參數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> appContext = applicationContext</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用函數 <code>makeStatusNotification</code> 顯示<b>狀態通知(status notification)</b>，以向使用者發送有關對圖片進行模糊處理的<u>通知(notify)</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">makeStatusNotification(<span class="string">&quot;Blurring image&quot;</span>, appContext)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>利用 cupcake image 創建一個 <code>Bitmap</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> picture = BitmapFactory.decodeResource(</span><br><span class="line">        appContext.resources,</span><br><span class="line">        R.drawable.android_cupcake)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>通過從 <code>WorkerUtils</code> 呼叫 <code>blurBitmap</code> 方法，獲取此 bitmap 模糊處理後的版本。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> output = blurBitmap(picture, appContext)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>從 <code>WorkerUtils</code> 呼叫 <code>writeBitmapToFile</code> 方法，將該 bitmap 寫入暫存檔案。請務必將 return 的 <strong>URI</strong> 保存到 <strong>local variable</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> outputUri = writeBitmapToFile(appContext, output)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>從 <code>WorkerUtils</code> 呼叫 <code>makeStatusNotification</code> 方法，以創建顯示 URI 的通知(notification)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">makeStatusNotification(<span class="string">&quot;Output is <span class="variable">$outputUri</span>&quot;</span>, appContext)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Return <code>Result.success()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Result.success()</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>將步驟 3-6 中的程式碼包裝在 <code>try/catch</code> statement 中。Catch 一個通用的(generic) <code>Throwable</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> picture = BitmapFactory.decodeResource(</span><br><span class="line">            appContext.resources,</span><br><span class="line">            R.drawable.android_cupcake)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> output = blurBitmap(picture, appContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Write bitmap to a temp file</span></span><br><span class="line">    <span class="keyword">val</span> outputUri = writeBitmapToFile(appContext, output)</span><br><span class="line"></span><br><span class="line">    makeStatusNotification(<span class="string">&quot;Output is <span class="variable">$outputUri</span>&quot;</span>, appContext)</span><br><span class="line"></span><br><span class="line">    Result.success()</span><br><span class="line">&#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在 <code>catch</code> statement 中，使用 Log statement <code>Log.e(TAG, &quot;Error applying blur&quot;)</code> 輸出error message 。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Log.e(TAG, <span class="string">&quot;Error applying blur&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>然後在 <code>catch</code> statement 中 return <code>Result.failure()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Result.failure()</span><br></pre></td></tr></table></figure>

<p>此步驟的完整程式碼如下所示。</p>
<p><code>BlurWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.background.workers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.work.Worker</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkerParameters</span><br><span class="line"><span class="keyword">import</span> com.example.background.R</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;BlurWorker&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlurWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="keyword">val</span> appContext = applicationContext</span><br><span class="line"></span><br><span class="line">        makeStatusNotification(<span class="string">&quot;Blurring image&quot;</span>, appContext)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> picture = BitmapFactory.decodeResource(</span><br><span class="line">                    appContext.resources,</span><br><span class="line">                    R.drawable.android_cupcake)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">val</span> output = blurBitmap(picture, appContext)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Write bitmap to a temp file</span></span><br><span class="line">            <span class="keyword">val</span> outputUri = writeBitmapToFile(appContext, output)</span><br><span class="line"></span><br><span class="line">            makeStatusNotification(<span class="string">&quot;Output is <span class="variable">$outputUri</span>&quot;</span>, appContext)</span><br><span class="line"></span><br><span class="line">            Result.success()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Error applying blur&quot;</span>)</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-4-步-在-ViewModel-中獲取-WorkManager"><a href="#第-4-步-在-ViewModel-中獲取-WorkManager" class="headerlink" title="第 4 步 - 在 ViewModel 中獲取 WorkManager"></a>第 4 步 - 在 ViewModel 中獲取 WorkManager</h4><p>在 <code>ViewModel</code> 中為 <code>WorkManager</code> instance 創建 class variable：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> workManager = WorkManager.getInstance(application)</span><br></pre></td></tr></table></figure>

<h4 id="第-5-步-在-WorkManager-中將-WorkRequest-加入-enqueue"><a href="#第-5-步-在-WorkManager-中將-WorkRequest-加入-enqueue" class="headerlink" title="第 5 步 - 在 WorkManager 中將 WorkRequest 加入 enqueue"></a>第 5 步 - 在 WorkManager 中將 WorkRequest 加入 enqueue</h4><p>好吧，是時候發出 <code>WorkRequest</code> 並告訴 <code>WorkManager</code> 要運行它了。</p>
<p><code>WorkRequest</code> 有兩種類型(types)：</p>
<ul>
<li><code>OneTimeWorkRequest</code>：只會執行一次的 <code>WorkRequest</code>。</li>
<li><code>PeriodicWorkRequest</code>：按周期(循環)重覆執行的 <code>WorkRequest</code>。</li>
</ul>
<p>我們只希望在點擊 <strong>Go button</strong> 後對圖片進行<u>模糊處理(blurred)</u>。當使使用者點擊 Go button 時，系統會呼叫 <code>applyBlur</code> 方法，因此請通過 <code>BlurWorker</code> 創建 <code>OneTimeWorkRequest</code>。然後，使用 <code>WorkManager</code> instance 將您的 <code>WorkRequest</code> 加入<b>隊列(enqueue)</b>。</p>
<p>將以下程式碼行添加到 <code>BlurViewModel</code> 的 <code>applyBlur()</code> 方法中：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyBlur</span><span class="params">(blurLevel: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   workManager.enqueue(OneTimeWorkRequest.from(BlurWorker::<span class="keyword">class</span>.java))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-6-步-運行您的程式碼！"><a href="#第-6-步-運行您的程式碼！" class="headerlink" title="第 6 步 - 運行您的程式碼！"></a>第 6 步 - 運行您的程式碼！</h4><p>運行您的程式碼。此程式碼應進行編譯，並且在按下 Go button 時，您應該會看到<b>通知(Notification)</b>。請注意，如需查看更模糊的照片，您應該選擇 “More blurred”（更模糊）或 “The most blurred”（最模糊）選項。</p>
<img src="https://i.imgur.com/o2Yp0Ua.png" width="70%">

<p>如需確認圖片是否已成功模糊，您可以在 Android Studio 中打開 <a href="https://developer.android.com/studio/debug/device-file-explorer?hl=zh-tw">Device File Explorer</a>：</p>
<img src="https://i.imgur.com/JA71kOE.png" width="80%">

<p>然後依次轉到 data &gt; data &gt; <code>com.example.background</code> &gt; files &gt; <code>Blathfilterfilter_outputs</code> &gt; <code>&lt;URI&gt;</code>，並確認 cupcake 確實已經模糊：</p>
<img src="https://i.imgur.com/v5lxFff.png">

<hr>
<h3 id="新增-input-和-output"><a href="#新增-input-和-output" class="headerlink" title="新增 input 和 output"></a>新增 input 和 output</h3><p>對資源目錄中的圖片資源進行模糊處理固然不錯，但如果想讓 O-M-Matic 真正成為一款革命性的圖片編輯應用，您應該讓使用者模糊處理他們在螢幕上看到的圖片，然後向他們展示經過模糊處理的照片。</p>
<p>為實現此目標，我們將提供作為 input 顯示在 <code>WorkRequest</code> 中的紙杯蛋糕圖片的 <strong>URI</strong>，然後使用 <code>WorkRequest</code> 的 output 顯示最終的經過模糊處理的圖片。</p>
<h4 id="第-1-步-創建資料-input-object"><a href="#第-1-步-創建資料-input-object" class="headerlink" title="第 1 步 - 創建資料 input object"></a>第 1 步 - 創建資料 input object</h4><p>Input 和 output 通過 <a href="https://developer.android.com/reference/androidx/work/Data">Data</a> object 傳入和傳出。<code>Data</code> object 是輕量化的 key-value 組合 containers。它們用於儲存少量可從 <code>WorkRequest</code> 傳入和傳出的資料。</p>
<p>您需要將使用者圖片的 URI 傳入捆綁包中。該 URI 儲存在名為 <code>imageUri</code> 的 variable 中。</p>
<p>在 <code>BlurViewModel</code> 中，創建一個名為 <code>createInputDataForUri</code> 的 private 方法。該方法應執行以下操作：</p>
<ol>
<li>創建一個 <code>Data.Builder</code> object。在收到 <strong>request</strong> 時，import <code>androidx.work.Data</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> builder = Data.Builder()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如果 <code>imageUri</code> 是非 null <code>URI</code>，則使用 <code>putString</code> 方法將其添加到 <code>Data</code> object。該方法可獲取一個 <strong>key</strong> 和一個 <strong>value</strong>。您可以使用 <code>Constants</code> class 中的 <code>String</code> constant <code>KEY_IMAGE_URI</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">imageUri?.let &#123;</span><br><span class="line">        builder.putString(KEY_IMAGE_URI, imageUri.toString())</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>對 <code>Data.Builder</code> object 呼叫 <code>build()</code> 以創建 <code>Data</code> object 並 return。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> builder.build()</span><br></pre></td></tr></table></figure>

<p>下面是完整的 <code>createInputDataForUri</code> 方法：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Creates the input data bundle which includes the Uri to operate on</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Data which contains the Image Uri as a String</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">createInputDataForUri</span><span class="params">()</span></span>: Data &#123;</span><br><span class="line">    <span class="keyword">val</span> builder = Data.Builder()</span><br><span class="line">    imageUri?.let &#123;</span><br><span class="line">        builder.putString(KEY_IMAGE_URI, imageUri.toString())</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.build()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-2-步-將-Data-object-傳遞到-WorkRequest"><a href="#第-2-步-將-Data-object-傳遞到-WorkRequest" class="headerlink" title="第 2 步 - 將 Data object 傳遞到 WorkRequest"></a>第 2 步 - 將 Data object 傳遞到 WorkRequest</h4><p>您將更改 <code>BlurViewModel</code> 中的 <code>applyBlur</code> 方法，以便：</p>
<ol>
<li>創建新的 <code>OneTimeWorkRequestBuilder</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> blurRequest = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>呼叫 <code>setInputData</code>，傳入 <code>createInputDataForUri</code> 的結果。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.setInputData(createInputDataForUri())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>build <code>OneTimeWorkRequest</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.build() </span><br></pre></td></tr></table></figure>
<ol start="4">
<li>使用 <code>WorkManager</code> 將 <strong>work request</strong> 加入<b>隊列(enqueues)</b>，以便系統將可以按照預期運行工作(scheduled to run)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">workManager.enqueue(blurRequest)</span><br></pre></td></tr></table></figure>

<p>下面是完整的 <code>applyBlur</code> 方法：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyBlur</span><span class="params">(blurLevel: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> blurRequest = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;()</span><br><span class="line">            .setInputData(createInputDataForUri())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    workManager.enqueue(blurRequest)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-更新-BlurWorker-的-doWork-以獲取-input"><a href="#第-3-步-更新-BlurWorker-的-doWork-以獲取-input" class="headerlink" title="第 3 步 - 更新 BlurWorker 的 doWork() 以獲取 input"></a>第 3 步 - 更新 BlurWorker 的 doWork() 以獲取 input</h4><p>現在，請更新 <code>BlurWorker</code> 的 <code>doWork()</code> 方法，以獲取從 <code>Data</code> object 傳入的 <strong>URI</strong>：</p>
<p><code>BlurWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">    <span class="keyword">val</span> appContext = applicationContext</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ADD THIS LINE</span></span><br><span class="line">    <span class="keyword">val</span> resourceUri = inputData.getString(KEY_IMAGE_URI)</span><br><span class="line">    <span class="comment">// ... rest of doWork()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-4-步-對給定的-URI-進行模糊處理"><a href="#第-4-步-對給定的-URI-進行模糊處理" class="headerlink" title="第 4 步 - 對給定的 URI 進行模糊處理"></a>第 4 步 - 對給定的 URI 進行模糊處理</h4><p>有了此 <strong>URI</strong>，我們現在對螢幕上的 cupcake image 進行模糊處理(blur)。</p>
<ol>
<li>移除之前用於獲取圖片資源的程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> picture = BitmapFactory.decodeResource(appContext.resources, R.drawable.android_cupcake)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>檢查從傳入的 <code>Data</code> 中獲取的 <code>resourceUri</code> 不為空(empty)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (TextUtils.isEmpty(resourceUri)) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">    <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將 <code>picture</code> variable 指派(assign)給傳入的圖片，如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> resolver = appContext.contentResolver</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> picture = BitmapFactory.decodeStream(</span><br><span class="line">        resolver.openInputStream(Uri.parse(resourceUri)))</span><br></pre></td></tr></table></figure>

<p><code>BlurWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">    <span class="keyword">val</span> appContext = applicationContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resourceUri = inputData.getString(KEY_IMAGE_URI)</span><br><span class="line"></span><br><span class="line">    makeStatusNotification(<span class="string">&quot;Blurring image&quot;</span>, appContext)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// REMOVE THIS</span></span><br><span class="line">        <span class="comment">//    val picture = BitmapFactory.decodeResource(</span></span><br><span class="line">        <span class="comment">//            appContext.resources,</span></span><br><span class="line">        <span class="comment">//            R.drawable.android_cupcake)</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(resourceUri)) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resolver = appContext.contentResolver</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> picture = BitmapFactory.decodeStream(</span><br><span class="line">                resolver.openInputStream(Uri.parse(resourceUri)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> output = blurBitmap(picture, appContext)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write bitmap to a temp file</span></span><br><span class="line">        <span class="keyword">val</span> outputUri = writeBitmapToFile(appContext, output)</span><br><span class="line"></span><br><span class="line">        Result.success()</span><br><span class="line">    &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">&quot;Error applying blur&quot;</span>)</span><br><span class="line">        throwable.printStackTrace()</span><br><span class="line">        Result.failure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-5-步-Output-temporary-URI"><a href="#第-5-步-Output-temporary-URI" class="headerlink" title="第 5 步 - Output temporary URI"></a>第 5 步 - Output temporary URI</h4><p>此 Worker 的工作已完成，您可以在 <code>Result.success()</code> 中 return <strong>output URI</strong>。提供 <strong>Output URI</strong> 作為 output Data，使其他 Worker 可以輕鬆存取這張臨時圖片，以執行進一步操作。<br>在下一章中，您將創建<b>工作鏈(Chain of workers)</b>，屆時此操作將非常有幫助。具體操作步驟如下：</p>
<ol>
<li>像對 input 進行的操作一樣，創建新的 <code>Data</code>，並將 <code>outputUri</code> 儲存為 <code>String</code>。使用相同的 <strong>key</strong>，即 <code>KEY_IMAGE_URI</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>Result.success(Data outputData)</code> 方法將它 return 給 <code>WorkManager</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Result.success(outputData)</span><br></pre></td></tr></table></figure>

<p><code>BlurWorker.kt</code><br>將 <code>doWork()</code> 中的 <code>Result.success()</code> 行修改為：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())</span><br><span class="line"></span><br><span class="line">Result.success(outputData)</span><br></pre></td></tr></table></figure>

<h4 id="第-6-步-執行您的-app"><a href="#第-6-步-執行您的-app" class="headerlink" title="第 6 步 - 執行您的 app"></a>第 6 步 - 執行您的 app</h4><p>此時，您應該執行 app。它應會編譯並具有相同的行為，您可以透過 <strong>Device File Explorer</strong> 看到模糊的圖片，但尚未在螢幕上看到。</p>
<p>如需檢查是否存在其他經過模糊處理的圖片，您可以在 Android Studio 中打開 <strong>Device File Explorer</strong>，然後轉到 <code>data/data/com.example.background/files/blur_filter_outputs/&lt;URI&gt;</code>，就像上一步的操作一樣。</p>
<p>請注意，您可能需要點擊 <strong>Synchronize</strong>（同步）才能查看圖片：</p>
<img src="https://i.imgur.com/PUEDtds.png" width="50%">

<p>太棒了！您已使用 <code>WorkManager</code> 對 input image 進行模糊處理！</p>
<hr>
<h3 id="鏈結您的工作-Chain-your-work"><a href="#鏈結您的工作-Chain-your-work" class="headerlink" title="鏈結您的工作(Chain your work)"></a>鏈結您的工作(Chain your work)</h3><p>現在，您將執行一項 work task：對圖片進行模糊處理。這是非常不錯的第一步，但缺少一些核心功能：</p>
<ul>
<li>此操作不會清理<u>暫存檔案(temporary files)</u>。</li>
<li>實際上，它不會將圖片保存到<u>永久性檔案(permanent file)</u>中。</li>
<li>始終對圖片做相同程度的<u>模糊處理(blurs)</u>。<br>我們將使用 <code>WorkManager</code> 工作鏈添加此功能。</li>
</ul>
<p><code>WorkManager</code> 允許您創建<u>按順序(in order)</u>執行或<u>並行(parallel)</u>執行的單獨(separate) <code>WorkerRequest</code>。在此步驟中，您將創建一個如下所示的<b>工作鏈(chain of work)</b>：</p>
<img src="https://i.imgur.com/MQ8a6su.png">

<p><code>WorkRequest</code> 表示為方框。</p>
<p>鏈接(chaining)的另一個簡潔功能是，一個 <code>WorkRequest</code> 的 output 會成為鏈(chain)中下一個 <code>WorkRequest</code> 的 input。在每個 <code>WorkRequest</code> 之間傳遞的 input 和 output 均顯示為 blue text。</p>
<h4 id="第-1-步-創建-Cleanup-和-Save-Workers"><a href="#第-1-步-創建-Cleanup-和-Save-Workers" class="headerlink" title="第 1 步 - 創建 Cleanup 和 Save Workers"></a>第 1 步 - 創建 Cleanup 和 Save Workers</h4><p>首先，您需要定義所需的所有 <code>Worker</code> class。您已經有了用於對圖片進行模糊處理的 <code>Worker</code>，但還需要用於清理<u>暫存檔案(temp files)</u>的 <code>Worker</code> 以及用於永久保存圖片的 <code>Worker</code>。</p>
<p>請在 <code>workers</code> package 中創建兩個繼承 <code>Worker</code> 的新 class。<br>第一個 class 的名稱應為 <code>CleanupWorker</code>，第二個 class 的名稱應為 <code>SaveImageToFileWorker</code>。</p>
<h4 id="第-2-步-繼承-Worker"><a href="#第-2-步-繼承-Worker" class="headerlink" title="第 2 步 - 繼承 Worker"></a>第 2 步 - 繼承 Worker</h4><p>從 <code>Worker</code> class 繼承 <code>CleanupWorker</code> class。添加所需的 constructor 參數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CleanupWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-覆寫和實作-doWork-以用於-CleanupWorker"><a href="#第-3-步-覆寫和實作-doWork-以用於-CleanupWorker" class="headerlink" title="第 3 步 - 覆寫和實作 doWork() 以用於 CleanupWorker"></a>第 3 步 - 覆寫和實作 doWork() 以用於 CleanupWorker</h4><p><code>CleanupWorker</code> 不需要獲取任何 input 或傳遞任何 ouput。它只是刪除暫存檔案(temporary files)（如果存在）。由於檔案操作不在本 Codelab 的範圍之內，因此您可以複製 <code>CleanupWorker</code> 的程式碼，如下所示：</p>
<p><code>CleanupWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.background.workers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.work.Worker</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkerParameters</span><br><span class="line"><span class="keyword">import</span> com.example.background.OUTPUT_PATH</span><br><span class="line"><span class="keyword">import</span> java.io.File</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cleans up temporary files generated during blurring process</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;CleanupWorker&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CleanupWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Makes a notification when the work starts and slows down the work so that</span></span><br><span class="line">        <span class="comment">// it&#x27;s easier to see each WorkRequest start, even on emulated devices</span></span><br><span class="line">        makeStatusNotification(<span class="string">&quot;Cleaning up old temporary files&quot;</span>, applicationContext)</span><br><span class="line">        sleep()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> outputDirectory = File(applicationContext.filesDir, OUTPUT_PATH)</span><br><span class="line">            <span class="keyword">if</span> (outputDirectory.exists()) &#123;</span><br><span class="line">                <span class="keyword">val</span> entries = outputDirectory.listFiles()</span><br><span class="line">                <span class="keyword">if</span> (entries != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (entry <span class="keyword">in</span> entries) &#123;</span><br><span class="line">                        <span class="keyword">val</span> name = entry.name</span><br><span class="line">                        <span class="keyword">if</span> (name.isNotEmpty() &amp;&amp; name.endsWith(<span class="string">&quot;.png&quot;</span>)) &#123;</span><br><span class="line">                            <span class="keyword">val</span> deleted = entry.delete()</span><br><span class="line">                            Log.i(TAG, <span class="string">&quot;Deleted <span class="variable">$name</span> - <span class="variable">$deleted</span>&quot;</span>)</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            Result.success()</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            exception.printStackTrace()</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-4-步-覆寫和實作-doWork-以用於-SaveImageToFileWorker"><a href="#第-4-步-覆寫和實作-doWork-以用於-SaveImageToFileWorker" class="headerlink" title="第 4 步 - 覆寫和實作 doWork() 以用於 SaveImageToFileWorker"></a>第 4 步 - 覆寫和實作 doWork() 以用於 SaveImageToFileWorker</h4><p><code>SaveImageToFileWorker</code> 將獲取 input 和 output。Input 是使用 key <code>KEY_IMAGE_URI</code> 儲存的 <code>String</code>，即暫時模糊處理的圖片 URI(<b>temporarily blurred image URI</b>)，而 output 也將是使用 key <code>KEY_IMAGE_URI</code> 儲存的 <code>String</code>，即保存的模糊處理圖片的 URI(<b>saved blurred image stored URI</b>)。</p>
<img src="https://i.imgur.com/gYfCyRY.png" width="50%">

<p>此 Codelab 不涉及檔案處理，因此我們在下面提供了程式碼。請注意，系統會使用 key <code>KEY_IMAGE_URI</code> 檢索 <code>resourceUri</code> 和 <code>output</code> 值。該程式碼與您在最後一步中為 input 和 output 編寫的程式碼非常相似（它使用了全部相同的 key）。</p>
<p><code>SaveImageToFileWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.background.workers</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.graphics.BitmapFactory</span><br><span class="line"><span class="keyword">import</span> android.net.Uri</span><br><span class="line"><span class="keyword">import</span> android.provider.MediaStore</span><br><span class="line"><span class="keyword">import</span> android.util.Log</span><br><span class="line"><span class="keyword">import</span> androidx.work.workDataOf</span><br><span class="line"><span class="keyword">import</span> androidx.work.Worker</span><br><span class="line"><span class="keyword">import</span> androidx.work.WorkerParameters</span><br><span class="line"><span class="keyword">import</span> com.example.background.KEY_IMAGE_URI</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat</span><br><span class="line"><span class="keyword">import</span> java.util.Date</span><br><span class="line"><span class="keyword">import</span> java.util.Locale</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Saves the image to a permanent file</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;SaveImageToFileWorker&quot;</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SaveImageToFileWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> title = <span class="string">&quot;Blurred Image&quot;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dateFormatter = SimpleDateFormat(</span><br><span class="line">            <span class="string">&quot;yyyy.MM.dd &#x27;at&#x27; HH:mm:ss z&quot;</span>,</span><br><span class="line">            Locale.getDefault()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">        <span class="comment">// Makes a notification when the work starts and slows down the work so that</span></span><br><span class="line">        <span class="comment">// it&#x27;s easier to see each WorkRequest start, even on emulated devices</span></span><br><span class="line">        makeStatusNotification(<span class="string">&quot;Saving image&quot;</span>, applicationContext)</span><br><span class="line">        sleep()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resolver = applicationContext.contentResolver</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">val</span> resourceUri = inputData.getString(KEY_IMAGE_URI)</span><br><span class="line">            <span class="keyword">val</span> bitmap = BitmapFactory.decodeStream(</span><br><span class="line">                    resolver.openInputStream(Uri.parse(resourceUri)))</span><br><span class="line">            <span class="keyword">val</span> imageUrl = MediaStore.Images.Media.insertImage(</span><br><span class="line">                    resolver, bitmap, title, dateFormatter.format(Date()))</span><br><span class="line">            <span class="keyword">if</span> (!imageUrl.isNullOrEmpty()) &#123;</span><br><span class="line">                <span class="keyword">val</span> output = workDataOf(KEY_IMAGE_URI to imageUrl)</span><br><span class="line"></span><br><span class="line">                Result.success(output)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">&quot;Writing to MediaStore failed&quot;</span>)</span><br><span class="line">                Result.failure()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (exception: Exception) &#123;</span><br><span class="line">            exception.printStackTrace()</span><br><span class="line">            Result.failure()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-5-步-修改-BlurWorker-Notification"><a href="#第-5-步-修改-BlurWorker-Notification" class="headerlink" title="第 5 步 - 修改 BlurWorker Notification"></a>第 5 步 - 修改 BlurWorker Notification</h4><p>現在，我們有了用於將圖片保存到正確資料夾的 <code>Worker</code> 鏈(chain)，我們可以使用 <code>WorkerUtils</code> class 中定義的 <code>sleep()</code> 方法減慢工作(work)速度，以便更輕松地做到查看每個 <code>WorkRequest</code> 的啟動情況，即使在模擬器上也不例外。<code>BlurWorker</code> 的最終版本如下所示：</p>
<p><code>BlurWorker.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BlurWorker</span>(ctx: Context, params: WorkerParameters) : Worker(ctx, params) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">doWork</span><span class="params">()</span></span>: Result &#123;</span><br><span class="line">    <span class="keyword">val</span> appContext = applicationContext</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resourceUri = inputData.getString(KEY_IMAGE_URI)</span><br><span class="line"></span><br><span class="line">    makeStatusNotification(<span class="string">&quot;Blurring image&quot;</span>, appContext)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ADD THIS TO SLOW DOWN THE WORKER</span></span><br><span class="line">    sleep()</span><br><span class="line">    <span class="comment">// ^^^^</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(resourceUri)) &#123;</span><br><span class="line">            Timber.e(<span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">            <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Invalid input uri&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> resolver = appContext.contentResolver</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> picture = BitmapFactory.decodeStream(</span><br><span class="line">                resolver.openInputStream(Uri.parse(resourceUri)))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> output = blurBitmap(picture, appContext)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Write bitmap to a temp file</span></span><br><span class="line">        <span class="keyword">val</span> outputUri = writeBitmapToFile(appContext, output)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> outputData = workDataOf(KEY_IMAGE_URI to outputUri.toString())</span><br><span class="line"></span><br><span class="line">        Result.success(outputData)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (throwable: Throwable) &#123;</span><br><span class="line">        throwable.printStackTrace()</span><br><span class="line">        Result.failure()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-6-步-創建-WorkRequest-鏈-chain"><a href="#第-6-步-創建-WorkRequest-鏈-chain" class="headerlink" title="第 6 步 - 創建 WorkRequest 鏈(chain)"></a>第 6 步 - 創建 WorkRequest 鏈(chain)</h4><p>您需要修改 <code>BlurViewModel</code> 的 <code>applyBlur</code> 方法以執行 <code>WorkRequest</code> 鏈，而不是僅執行一個請求。目前，程式碼如下所示：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> blurRequest = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;()</span><br><span class="line">        .setInputData(createInputDataForUri())</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line">workManager.enqueue(blurRequest)</span><br></pre></td></tr></table></figure>

<p>呼叫 <code>workManager.beginWith()</code>，而不是呼叫 <code>workManager.enqueue()</code>。此呼叫會 return  <code>WorkContinuation</code>，其定義了 <code>WorkRequest</code> 鏈(chain)。您可以通過呼叫 <code>then()</code> 方法向此<u>工作請求鏈(chain of work requests)</u>中添加 <strong>request object</strong>。例如，如果您擁有三個 <code>WorkRequest</code> objects，即 <code>workA</code>、<code>workB</code> 和 <code>workC</code>，則可以編寫以下程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example code, don&#x27;t copy to the project</span></span><br><span class="line"><span class="keyword">val</span> continuation = workManager.beginWith(workA)</span><br><span class="line"></span><br><span class="line">continuation.then(workB) <span class="comment">// FYI, then() returns a new WorkContinuation instance</span></span><br><span class="line">        .then(workC)</span><br><span class="line">        .enqueue() <span class="comment">// Enqueues the WorkContinuation which is a chain of work</span></span><br></pre></td></tr></table></figure>

<p>此程式碼將生成並運行以下 <code>WorkRequest</code> 鏈(chain)：</p>
<img src="https://i.imgur.com/iyBRecI.png" width="50%">

<p>在 <code>applyBlur</code> 中創建一個 <code>CleanupWorker</code> <code>WorkRequest</code>、<code>BlurImage</code> <code>WorkRequest</code> 和 <code>SaveImageToFile</code> <code>WorkRequest</code> 鏈(chain)。將 input 傳遞到 <code>BlurImage</code> <code>WorkRequest</code> 中。</p>
<p>此操作的程式碼如下：<br><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyBlur</span><span class="params">(blurLevel: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add WorkRequest to Cleanup temporary images</span></span><br><span class="line">    <span class="keyword">var</span> continuation = workManager</span><br><span class="line">            .beginWith(OneTimeWorkRequest</span><br><span class="line">            .from(CleanupWorker::<span class="keyword">class</span>.java))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add WorkRequest to blur the image</span></span><br><span class="line">    <span class="keyword">val</span> blurRequest = OneTimeWorkRequest.Builder(BlurWorker::<span class="keyword">class</span>.java)</span><br><span class="line">            .setInputData(createInputDataForUri())</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    continuation = continuation.then(blurRequest)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add WorkRequest to save the image to the filesystem</span></span><br><span class="line">    <span class="keyword">val</span> save = OneTimeWorkRequest.Builder(SaveImageToFileWorker::<span class="keyword">class</span>.java).build()</span><br><span class="line"></span><br><span class="line">    continuation = continuation.then(save)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually start the work</span></span><br><span class="line">    continuation.enqueue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此程式碼應該編譯和執行。現在，您應該可以點擊 Go button，並可以在不同 <strong>workers</strong> 執行時看到<u>通知(notifications)</u>。您仍然可以在 Device File Explorer 中查看經過模糊處理的圖片，在下一步中，您將再添加一個 button，以便使用者可以在裝置上查看經過模糊處理的圖片。</p>
<p>在下面的屏幕截圖中，您會發現 <strong>notification messages</strong> 中顯示當前正在執行的 <strong>workers</strong>。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:40%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/Rfxj1l7.png">
    </div>
    <div style="width:40%;float:left;">
        <img src="https://i.imgur.com/X3SouxX.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<img src="https://i.imgur.com/B1Gguul.png" width="40%">

<h4 id="第-7-步-重覆使用-BlurWorker"><a href="#第-7-步-重覆使用-BlurWorker" class="headerlink" title="第 7 步 - 重覆使用 BlurWorker"></a>第 7 步 - 重覆使用 BlurWorker</h4><p>現在，我們需要添加對圖片進行不同程度的模糊處理的功能。請獲取傳遞到 <code>applyBlur</code> 中的 <code>blurLevel</code> 參數，並向鏈(chain)中添加多個模糊處理 <code>WorkRequest</code> 操作。只有第一個 <code>WorkRequest</code> 需要且應該獲取 <strong>URI input</strong>。</p>
<div class="note success">
            <p>請注意，這是為了學習目的而在一定程度上刻意進行的設置。相比之下，呼叫模糊處理程式碼三次效率不如通過 <b>BlurWorker</b> 來獲取控制模糊處理 <strong>level</strong> 的 input。不過使用該方法時，我們可以展示 <b>WorkManager 鏈接(chaining)</b>的靈活性。</p>
          </div>

<p>您可以親自嘗試，然後與以下程式碼進行比較：<br><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">applyBlur</span><span class="params">(blurLevel: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="comment">// Add WorkRequest to Cleanup temporary images</span></span><br><span class="line">    <span class="keyword">var</span> continuation = workManager</span><br><span class="line">            .beginWith(OneTimeWorkRequest</span><br><span class="line">            .from(CleanupWorker::<span class="keyword">class</span>.java))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add WorkRequests to blur the image the number of times requested</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until blurLevel) &#123;</span><br><span class="line">        <span class="keyword">val</span> blurBuilder = OneTimeWorkRequestBuilder&lt;BlurWorker&gt;()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Input the Uri if this is the first blur operation</span></span><br><span class="line">        <span class="comment">// After the first blur operation the input will be the output of previous</span></span><br><span class="line">        <span class="comment">// blur operations.</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            blurBuilder.setInputData(createInputDataForUri())</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        continuation = continuation.then(blurBuilder.build())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add WorkRequest to save the image to the filesystem</span></span><br><span class="line">    <span class="keyword">val</span> save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;()</span><br><span class="line">            .build()</span><br><span class="line"></span><br><span class="line">    continuation = continuation.then(save)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually start the work</span></span><br><span class="line">    continuation.enqueue()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>打開裝置 Device File Explorer，查看經過模糊處理的圖片。請注意，output 資料夾中包含多張<u>模糊處理過的圖片(blurred images)</u>、<u>處於模糊處理中間階段的圖片</u>，以及<u>根據您選擇的模糊處理程度顯示經過模糊處理的最終圖片</u>。</p>
<p>您的 <strong>“Work”</strong> 非常不錯！現在，您可以對圖片進行模糊處理，模糊程度多少完全由您掌控。處理後的圖片非常有神秘感。</p>
<hr>
<h3 id="確保-Work-不重複"><a href="#確保-Work-不重複" class="headerlink" title="確保 Work 不重複"></a>確保 Work 不重複</h3><p>現在，您已學會使用鏈(chains)，接下來應該掌握的是 <code>WorkManager</code> 的另一項強大功能 - <b>唯一工作鏈( unique work chains)</b>。</p>
<p>有時，您一次只希望運行一個<b>工作鏈(chain of work)</b>。例如，您可能有一個可將 local data 與 server 同步(syncs)的工作鏈 - 您可能希望先讓第一批 data 結束同步，然後再開始新的同步。為此，請使用 <code>beginUniqueWork</code> 而非 <code>beginWith</code>；並且要提供唯一的 <code>String</code> 名稱。這會命名<u><b>整個(entire)</b>工作請求鏈(chain of work requests)</u>，以便您一起引用(refer)和查詢(query)這些請求。</p>
<p>請使用 <code>beginUniqueWork</code> 確保對檔案(file)進行模糊處理的工作鏈是唯一的。傳入 <code>IMAGE_MANIPULATION_WORK_NAME</code> 作為 key。您還需要傳入 <code>ExistingWorkPolicy</code>。選項包括 <code>REPLACE</code>、<code>KEEP</code> 或 <code>APPEND</code>。</p>
<p>您將使用 <code>REPLACE</code>，因為如果使用者在當前圖片完成之前決定對另一張圖片進行模糊處理，我們需要停止當前圖片並開始對新圖片進行模糊處理。</p>
<p>用於啟動<b>唯一工作(unique work)</b>延續的程式碼如下：<br><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// REPLACE THIS CODE:</span></span><br><span class="line"><span class="comment">// var continuation = workManager</span></span><br><span class="line"><span class="comment">//            .beginWith(OneTimeWorkRequest</span></span><br><span class="line"><span class="comment">//            .from(CleanupWorker::class.java))</span></span><br><span class="line"><span class="comment">// WITH</span></span><br><span class="line"><span class="keyword">var</span> continuation = workManager</span><br><span class="line">        .beginUniqueWork(</span><br><span class="line">                IMAGE_MANIPULATION_WORK_NAME,</span><br><span class="line">                ExistingWorkPolicy.REPLACE,</span><br><span class="line">                OneTimeWorkRequest.from(CleanupWorker::<span class="keyword">class</span>.java)</span><br><span class="line">        )</span><br></pre></td></tr></table></figure>

<p>現在，Blur-O-Matic 一次只會對一張圖片進行模糊處理。</p>
<hr>
<h3 id="Tag-和顯示-Work-status"><a href="#Tag-和顯示-Work-status" class="headerlink" title="Tag 和顯示 Work status"></a>Tag 和顯示 Work status</h3><p>本部分大量使用了 <code>LiveData</code>，因此，如果要充分了解您自己的情況，您應該熟悉如何使用 <code>LiveData</code>。<code>LiveData</code> 是一種具有<u>生命周期感知(lifecycle-aware)</u>能力的 <strong>data holder</strong>。</p>
<p>如果這是您首次使用 <code>LiveData</code> 或 <code>Observable</code>，您可以查看 <a href="https://developer.android.com/codelabs/android-lifecycles#0">Android Lifecycle-aware components Codelab </a>。</p>
<p>您要做的下一項重大更改是在執行 Work 時實際更改 app 中顯示的內容。</p>
<p>您可以通過獲取保留 <code>WorkInfo</code> object 的 <code>LiveData</code> 來獲取任何 <code>WorkRequest</code> 的狀態(status)。<code>WorkInfo</code> 是一個包含 <code>WorkRequest</code> <u>當前狀態(current state)詳細資料(details)</u>的 object，其中包括：</p>
<ul>
<li>Work 是否為 <code>BLOCKED</code>、<code>CANCELLED</code>、<code>ENQUEUED</code>、<code>FAILED</code>、<code>RUNNING</code> 或 <code>SUCCEEDED</code>。</li>
<li>如果 <code>WorkRequest</code> 完成，則為 Work 的任何 output data。</li>
</ul>
<p>下表顯示了獲取 <code>LiveData&lt;WorkInfo&gt;</code> 或 <code>LiveData&lt;List&lt;WorkInfo&gt;&gt;</code> object 的三種不同方法，以及每種方法相應的用途。</p>
<table>
<thead>
<tr>
<th align="left">Type</th>
<th align="left">WorkManager Method</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">使用 <strong>id</strong> get work</td>
<td align="left">getWorkInfoByIdLiveData</td>
<td align="left">每個 <strong>WorkRequest</strong> 都有一個由 <strong>WorkManager</strong> 生成的 unique ID；您可以用此 ID 獲取適用於該實際 <strong>WorkRequest</strong> 的單個(single) <strong>LiveData</strong>。</td>
</tr>
<tr>
<td align="left">使用 <strong>unique chain name</strong> get work</td>
<td align="left">getWorkInfosForUniqueWorkLiveData</td>
<td align="left">如您所見，<strong>WorkRequest</strong> 可能是<u>唯一鏈(unique chain)</u>的一部分。這會在 <strong>WorkRequests</strong> 的 s<strong>ingle, unique chain</strong> 中為所有 work return <strong>LiveData</strong>。</td>
</tr>
<tr>
<td align="left">使用 <strong>tag</strong> get work</td>
<td align="left">getWorkInfosByTagLiveData</td>
<td align="left">最後，您可以選擇使用 String tag 任何 <strong>WorkRequest</strong>。您可以使用同一 tag 標記多個 <strong>WorkRequest</strong>，並將它們關聯起來。這樣會 return 用於任何 single tag 的 <strong>LiveData</strong>。</td>
</tr>
</tbody></table>
<p>您將 tagging <code>SaveImageToFileWorker</code> <code>WorkRequest</code>，以便您可以使用 <code>getWorkInfosByTag</code> 獲取該 tag。您將使用一個 <strong>tag</strong> 為您的 work 加上 <strong>label</strong>，而不是使用 WorkManager ID。因為如果您的使用者對多張圖片進行模糊處理，則所有保存的圖片 <code>WorkRequest</code> 將具有相同的 tag，而不是相同的 ID。此外，您也可以挑選 tag。</p>
<p>請不要使用 <code>getWorkInfosForUniqueWork</code>，因為它將為所有模糊處理 <code>WorkRequest</code> 和清理(cleanup) <code>WorkRequest</code> return <code>WorkInfo</code>，還需要額外的邏輯來查找保存的圖片 <code>WorkRequest</code>。</p>
<h4 id="第-1-步-Tag-your-work"><a href="#第-1-步-Tag-your-work" class="headerlink" title="第 1 步 - Tag your work"></a>第 1 步 - Tag your work</h4><p>在 <code>applyBlur</code> 中，在創建 <code>SaveImageToFileWorker</code> 時，請使用 <code>String</code> 常量 <code>TAG_OUTPUT</code> tag 您的 work：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;()</span><br><span class="line">        .addTag(TAG_OUTPUT) <span class="comment">// &lt;-- ADD THIS</span></span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<h4 id="第-2-步-Get-the-WorkInfo"><a href="#第-2-步-Get-the-WorkInfo" class="headerlink" title="第 2 步 - Get the WorkInfo"></a>第 2 步 - Get the WorkInfo</h4><p>現在您已經 tag 了 work，可以獲取(get) <code>WorkInfo</code>：</p>
<ol>
<li>在 <code>BlurViewModel</code> 中，宣告一個名為 <code>outputWorkInfos</code> 的新 class variable，該 variable 是 <code>LiveData&lt;List&lt;WorkInfo&gt;&gt;</code></li>
<li>在 <code>BlurViewModel</code> 中添加 <code>init</code> block 以使用 <code>WorkManager.getWorkInfosByTagLiveData</code> 獲取(get) <code>WorkInfo</code></li>
</ol>
<p>您需要的程式碼如下：<br><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// New instance variable for the WorkInfo</span></span><br><span class="line"><span class="keyword">internal</span> <span class="keyword">val</span> outputWorkInfos: LiveData&lt;List&lt;WorkInfo&gt;&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modify the existing init block in the BlurViewModel class to this:</span></span><br><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    imageUri = getImageUri(application.applicationContext)</span><br><span class="line">    <span class="comment">// This transformation makes sure that whenever the current work Id changes the WorkInfo</span></span><br><span class="line">    <span class="comment">// the UI is listening to changes</span></span><br><span class="line">    outputWorkInfos = workManager.getWorkInfosByTagLiveData(TAG_OUTPUT)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-顯示-WorkInfo"><a href="#第-3-步-顯示-WorkInfo" class="headerlink" title="第 3 步 - 顯示 WorkInfo"></a>第 3 步 - 顯示 WorkInfo</h4><p>現在您已擁有適用於 <code>WorkInfo</code> 的 <code>LiveData</code>，可以在 <code>BlurActivity</code> 中進行<b>觀察(observe)</b>。在 <strong>observer</strong> 中：</p>
<ol>
<li>檢查 <code>WorkInfo</code> list 是否不為 <code>null</code> 並且其中是否包含任何 <code>WorkInfo</code> object。如果尚未點擊 Go button，則 return。</li>
<li>獲取(get) list 中的第一個 <code>WorkInfo</code>；只有一個 tag 為 <code>TAG_OUTPUT</code> 的 <code>WorkInfo</code>，因為我們的<b>工作鏈(chain of work)</b>是<b>唯一的(unique)</b>。</li>
<li>使用 <code>workInfo.state.isFinished</code> 檢查 <strong>work status</strong> 是否為<u>已完成(finished)</u>。</li>
<li>如果未完成，請呼叫 <code>showWorkInProgress()</code> 以隱藏 Go button 並顯示 Cancel Work button 和進度條(progress bar)。</li>
<li>如果已完成，請調用 <code>showWorkFinished()</code> 以隱藏 Cancel Work button 和進度條(progress bar)，並顯示 Go button。</li>
</ol>
<p>程式碼如下：<br><code>BlurActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Observe work status, added in onCreate()</span></span><br><span class="line">    viewModel.outputWorkInfos.observe(<span class="keyword">this</span>, workInfosObserver())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the observer function</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">workInfosObserver</span><span class="params">()</span></span>: Observer&lt;List&lt;WorkInfo&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observer &#123; listOfWorkInfo -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that these next few lines grab a single WorkInfo if it exists</span></span><br><span class="line">        <span class="comment">// This code could be in a Transformation in the ViewModel; they are included here</span></span><br><span class="line">        <span class="comment">// so that the entire process of displaying a WorkInfo is in one location.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no matching work info, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (listOfWorkInfo.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Observer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We only care about the one output status.</span></span><br><span class="line">        <span class="comment">// Every continuation has only one worker tagged TAG_OUTPUT</span></span><br><span class="line">        <span class="keyword">val</span> workInfo = listOfWorkInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInfo.state.isFinished) &#123;</span><br><span class="line">            showWorkFinished()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showWorkInProgress()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// Observe work status, added in onCreate()</span></span><br><span class="line">    viewModel.outputWorkInfos.observe(<span class="keyword">this</span>, workInfosObserver())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Define the observer function</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">workInfosObserver</span><span class="params">()</span></span>: Observer&lt;List&lt;WorkInfo&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observer &#123; listOfWorkInfo -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that these next few lines grab a single WorkInfo if it exists</span></span><br><span class="line">        <span class="comment">// This code could be in a Transformation in the ViewModel; they are included here</span></span><br><span class="line">        <span class="comment">// so that the entire process of displaying a WorkInfo is in one location.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no matching work info, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (listOfWorkInfo.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Observer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We only care about the one output status.</span></span><br><span class="line">        <span class="comment">// Every continuation has only one worker tagged TAG_OUTPUT</span></span><br><span class="line">        <span class="keyword">val</span> workInfo = listOfWorkInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInfo.state.isFinished) &#123;</span><br><span class="line">            showWorkFinished()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showWorkInProgress()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.lifecycle.Observer</code>。</li>
</ul>
<h4 id="第-4-步-執行您的-app"><a href="#第-4-步-執行您的-app" class="headerlink" title="第 4 步 - 執行您的 app"></a>第 4 步 - 執行您的 app</h4><p>執行您的 app - 它應該編譯並運行，且現在可以在工作時顯示<b>進度條(progress bar)</b>以及 <b>cancel button</b>：</p>
<img src="https://i.imgur.com/a59SNFe.png" width="40%">

<hr>
<h3 id="顯示-final-output"><a href="#顯示-final-output" class="headerlink" title="顯示 final output"></a>顯示 final output</h3><p>每個 <code>WorkInfo</code> 還有一個 <code>getOutputData</code> 方法，該方法可讓您獲取(get)包含<u>最終保存的圖片(final saved image)</u>的 <strong>output</strong> <code>Data</code> object。在 Kotlin 中，您可以使用該語言為您生成的 variable <code>outputData</code> 存取此方法。每當有經過模糊處理的圖片準備就緒可供顯示時，便在螢幕上顯示 <strong>See File button</strong>。</p>
<h4 id="第-1-步-創建-See-File-button"><a href="#第-1-步-創建-See-File-button" class="headerlink" title="第 1 步 - 創建 See File button"></a>第 1 步 - 創建 See File button</h4><p><code>activity_blur.xml</code> layout 中有一個隱藏的 button。它位於 <code>BlurActivity</code> 中，名為 <code>outputButton</code>。</p>
<p>在 <code>BlurActivity</code> 的 <code>onCreate()</code> 中，為該 button 設置 <strong>click listener</strong>。此操作應獲取(get) <strong>URI</strong>，然後打開一個 activity 以查看該 URI。您可以使用以下程式碼：</p>
<p><code>BlurActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="comment">// Setup view output image file button</span></span><br><span class="line">   binding.seeFileButton.setOnClickListener &#123;</span><br><span class="line">       viewModel.outputUri?.let &#123; currentUri -&gt;</span><br><span class="line">           <span class="keyword">val</span> actionView = Intent(Intent.ACTION_VIEW, currentUri)</span><br><span class="line">           actionView.resolveActivity(packageManager)?.run &#123;</span><br><span class="line">               startActivity(actionView)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-2-步-設置-URI-並顯示-button"><a href="#第-2-步-設置-URI-並顯示-button" class="headerlink" title="第 2 步 - 設置 URI 並顯示 button"></a>第 2 步 - 設置 URI 並顯示 button</h4><p>您需要對 <code>WorkInfo</code> observer 應用一些最後的調整，才能達到預期效果：</p>
<ol>
<li>如果 <code>WorkInfo</code> 完成，請使用 <code>workInfo.outputData</code> 獲取(get) <strong>output data</strong>。</li>
<li>然後獲取(get) <strong>output URI</strong>，請記住，它是使用 <code>Constants.KEY_IMAGE_URI</code> key 儲存的。</li>
<li>如果 URI 不為空(empty)，則會正確儲存(saved)；系統會顯示 <code>outputButton</code> 並使用該 URI 對 view model 呼叫 <code>setOutputUri</code>。</li>
</ol>
<p><code>BlurActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">workInfosObserver</span><span class="params">()</span></span>: Observer&lt;List&lt;WorkInfo&gt;&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Observer &#123; listOfWorkInfo -&gt;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Note that these next few lines grab a single WorkInfo if it exists</span></span><br><span class="line">        <span class="comment">// This code could be in a Transformation in the ViewModel; they are included here</span></span><br><span class="line">        <span class="comment">// so that the entire process of displaying a WorkInfo is in one location.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If there are no matching work info, do nothing</span></span><br><span class="line">        <span class="keyword">if</span> (listOfWorkInfo.isNullOrEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span><span class="symbol">@Observer</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We only care about the one output status.</span></span><br><span class="line">        <span class="comment">// Every continuation has only one worker tagged TAG_OUTPUT</span></span><br><span class="line">        <span class="keyword">val</span> workInfo = listOfWorkInfo[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInfo.state.isFinished) &#123;</span><br><span class="line">            showWorkFinished()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Normally this processing, which is not directly related to drawing views on</span></span><br><span class="line">            <span class="comment">// screen would be in the ViewModel. For simplicity we are keeping it here.</span></span><br><span class="line">            <span class="keyword">val</span> outputImageUri = workInfo.outputData.getString(KEY_IMAGE_URI)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If there is an output file show &quot;See File&quot; button</span></span><br><span class="line">            <span class="keyword">if</span> (!outputImageUri.isNullOrEmpty()) &#123;</span><br><span class="line">                viewModel.setOutputUri(outputImageUri)</span><br><span class="line">                binding.seeFileButton.visibility = View.VISIBLE</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showWorkInProgress()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-執行您的程式碼"><a href="#第-3-步-執行您的程式碼" class="headerlink" title="第 3 步 - 執行您的程式碼"></a>第 3 步 - 執行您的程式碼</h4><p>執行您的程式碼。您應該會看到新的可點擊(clickable)的 <strong>See File button</strong>，該 button 會將您轉到 <strong>outputted file</strong>：</p>
<img src="https://i.imgur.com/RbMQGSF.png" width="40%">

<img src="https://i.imgur.com/9kb3CK0.png" width="40%">

<hr>
<h3 id="取消-work"><a href="#取消-work" class="headerlink" title="取消 work"></a>取消 work</h3><img src="https://developer.android.com/static/codelabs/android-workmanager/img/632d75e145022d14_1920.png" width="30%">

<p>您已新增此 <strong>cancel work button</strong>，所以我們要新增一些程式碼來執行操作。借助 <code>WorkManager</code>，您可以<u>使用 <b>ID</b>、依照 <b>tag</b> 和 <b>unique chain name</b> 取消 work</u>。</p>
<p>在這種情況下，您需要依照 <strong>unique chain name</strong> 取消 work，因為您想要取消 <b>chain</b> 中的所有 work，而不僅僅是某個特定步驟。</p>
<h4 id="第-1-步-依照-name-取消-work"><a href="#第-1-步-依照-name-取消-work" class="headerlink" title="第 1 步 - 依照 name 取消 work"></a>第 1 步 - 依照 name 取消 work</h4><p>在 <code>BlurViewModel</code> 中，新增一個名為 <code>cancelWork()</code> 的新方法以取消<b>唯一工作(unique work)</b>。在函數內，對 <code>workManager</code> 呼叫 <code>cancelUniqueWork</code>，並傳入 <code>IMAGE_MANIPULATION_WORK_NAME</code> tag。</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">internal</span> <span class="function"><span class="keyword">fun</span> <span class="title">cancelWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">    workManager.cancelUniqueWork(IMAGE_MANIPULATION_WORK_NAME)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-2-步-呼叫-cancel-方法"><a href="#第-2-步-呼叫-cancel-方法" class="headerlink" title="第 2 步 - 呼叫 cancel 方法"></a>第 2 步 - 呼叫 cancel 方法</h4><p>然後，使用 <code>cancelButton</code> button 呼叫 <code>cancelWork</code>：</p>
<p><code>BlurActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// In onCreate()</span></span><br><span class="line"><span class="comment">// Hookup the Cancel button</span></span><br><span class="line">binding.cancelButton.setOnClickListener &#123; viewModel.cancelWork() &#125;</span><br></pre></td></tr></table></figure>

<h4 id="第-3-步-執行和取消-work"><a href="#第-3-步-執行和取消-work" class="headerlink" title="第 3 步 - 執行和取消 work"></a>第 3 步 - 執行和取消 work</h4><p>運行您的 app。它應該可以正常編譯。先對圖片進行模糊處理，然後點擊 <strong>cancel button</strong>。整個<b>鏈(chain)</b>都會被取消！</p>
<img src="https://i.imgur.com/OJe7YmQ.png" width="40%">

<p>請注意，由於 <code>WorkState</code> 不再處於 <code>FINISHED</code>(已完成) 狀態，因此 <strong>work</strong> 取消後，只有 <strong>GO button</strong>。</p>
<hr>
<h3 id="Work-constraints"><a href="#Work-constraints" class="headerlink" title="Work constraints"></a>Work constraints</h3><p>最後，很重要的一點是，<code>WorkManager</code> 支持 <a href="https://developer.android.com/reference/androidx/work/Constraints"><code>Constraints</code></a>。對於 Blur-O-Matic，您將使用<u>裝置必須充電(charging)</u>的<b>限制條件(constraints)</b>。也就是說，您的 <strong>work request</strong> 只會在裝置充電(charging)的情況下運行。</p>
<h4 id="第-1-步-創建並添加充電限制條件"><a href="#第-1-步-創建並添加充電限制條件" class="headerlink" title="第 1 步 - 創建並添加充電限制條件"></a>第 1 步 - 創建並添加充電限制條件</h4><p>如需創建 <code>Constraints</code> object，請使用 <code>Constraints.Builder</code>。然後，您可以設置所需的，<u>限制條件(constraints)</u>，並使用方法 <code>setRequiresCharging()</code> 將其添加到 <code>WorkRequest</code>：</p>
<p><code>BlurViewModel.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Put this inside the applyBlur() function, above the save work request.</span></span><br><span class="line"><span class="comment">// Create charging constraint</span></span><br><span class="line"><span class="keyword">val</span> constraints = Constraints.Builder()</span><br><span class="line">        .setRequiresCharging(<span class="literal">true</span>)</span><br><span class="line">        .build()</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add WorkRequest to save the image to the filesystem</span></span><br><span class="line"><span class="keyword">val</span> save = OneTimeWorkRequestBuilder&lt;SaveImageToFileWorker&gt;()</span><br><span class="line">        .setConstraints(constraints)</span><br><span class="line">        .addTag(TAG_OUTPUT)</span><br><span class="line">        .build()</span><br><span class="line">continuation = continuation.then(save)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Actually start the work</span></span><br><span class="line">continuation.enqueue()</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.work.Constraints</code></li>
</ul>
<h4 id="第-2-步-使用模擬器或裝置進行測試"><a href="#第-2-步-使用模擬器或裝置進行測試" class="headerlink" title="第 2 步 - 使用模擬器或裝置進行測試"></a>第 2 步 - 使用模擬器或裝置進行測試</h4><p>現在您就可以執行 Blur-O-Matic 了。如果您使用的是一台裝置，則可以移除或插入您的裝置。在模擬器上，您可以在 <b>Extended controls window</b> 中更改充電狀態：</p>
<img src="https://i.imgur.com/QM7oKH1.png">

<p>當裝置不充電時，應會暫停執行 <code>SaveImageToFileWorker</code>，直到您將裝置插入充電。</p>
<img src="https://i.imgur.com/7qq8doF.png" width="40%">

<div class="note success">
            <p><strong>重要：</strong>添加到 Blur-O-Matic 的另一個良好<b>限制條件(constraint)</b>是保存時的(saving) <b><a href="https://developer.android.com/reference/androidx/work/Constraints.html#setRequiresStorageNotLow(boolean)">setRequiresStorageNotLow</a></b> constraint。如需查看 <strong>constraint options</strong> 的完整列表，請參閱 <b><a href="https://developer.android.com/reference/androidx/work/Constraints.Builder.html">Constraints.Builder</a></b> reference。</p>
          </div>

<hr>
<h3 id="最終程式碼"><a href="#最終程式碼" class="headerlink" title="最終程式碼"></a>最終程式碼</h3><p>可以從 GitHub clone 已完成的 WorkManager 的 Codelab：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/googlecodelabs/android-workmanager</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>WorkManager</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(44)-專案：Forage應用程式</title>
    <url>/2023/12/28/Android%E7%AD%86%E8%A8%98-44-%E5%B0%88%E6%A1%88%EF%BC%9AForage%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>建構一款名為「Forage」的 app。本程式碼研究室將引導您逐步完成 Forage app project，包括在 Android Studio 中設定和測試 project。</p>
</blockquote>
<p>完成後的 Forage app 可讓使用者追蹤他們在自然界中搜尋到的物品，例如食物。通過使用 Room，可使這些資料在會話間<u>持久保存(persisted)</u>下來。運用您掌握的 Room 知識以及對 database 進行讀取、寫入、更新和刪除，以在 Forage app 中實現資料的<u>持久保留(persisted)</u>。</p>
<p><strong>建構項目</strong><br>實作 <strong>entity</strong>、<strong>DAO</strong>、<strong>ViewModel</strong> 和 <strong>database class</strong>，以便透過 Room 在 app 中加入<u>持續性機制(persistence)</u>。</p>
<span id="more"></span>

<hr>
<h3 id="完成的應用程式總覽"><a href="#完成的應用程式總覽" class="headerlink" title="完成的應用程式總覽"></a>完成的應用程式總覽</h3><p>完成後的 Forage app 可讓使用者<u>追蹤他們在自然界中覓得的 items</u>，例如食物(food)。在使用 Room 的工作階段之間會<u>保留(persisted)</u>此資料。您將運用所掌握的 Room 知識，以及對在 database 執行讀取、寫入、更新及刪除作業的瞭解，在 Forage app 中實現<u>持續性(persistence)</u>。下文說明完成後的 app 及其功能。</p>
<p>App 初次啟動時，使用者會看到空白畫面，其中包含顯示 foraged items 的 recycler view，還有右下角可用來新增 items 的 floating button。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-forage/img/3edd87e63c387d88_1920.png?hl=zh-tw" width="40%">

<p>新增 item 時，使用者可以指定<u>名稱(name)</u>、<u>找到項目的地點(location)</u>，並加上<u>其他附註(notes)</u>。你也可以有 <strong>checkbox</strong>，以指定 <strong>food item</strong> 是否屬於當季。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-forage/img/6c0c739569bb3b4f_1920.png?hl=zh-tw" width="40%">

<p>新增的 item 將顯示在第一個畫面的 recycler view 中。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-forage/img/bcc75e60b70320e8_1920.png?hl=zh-tw" width="40%">

<p>輕觸某個 item 就會開啟詳細資料(detail)畫面，並顯示名稱(name)、地點(location)和附註(notes)。</p>
<imf src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-forage/img/5096995a4921dcac_1920.png?hl=zh-tw" width="40%">

<p><u>浮動式按鈕(floating button)</u>也會從<u>加號</u>變更為<u>編輯</u> icon。輕觸此按鈕即可開啟畫面，以便編輯<u>名稱(name)</u>、<u>地點(location)</u>、<u>附註(notes)</u>和<u>當季(in season) checkbox</u>。輕觸 delete button 則可從 database 中移除 item。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-forage/img/f8c708fed3dede1a_1920.png?hl=zh-tw" width="40%">

<p>雖然系統已導入此 app 的 UI 部分，但您的任務是運用對 Room 的瞭解來<u>實現持續性(persistence)</u>，讓 app 能夠讀取、寫入、更新及刪除 database 中的 items。</p>
<hr>
<h3 id="開始操作"><a href="#開始操作" class="headerlink" title="開始操作"></a>開始操作</h3><h4 id="下載專案程式碼"><a href="#下載專案程式碼" class="headerlink" title="下載專案程式碼"></a>下載專案程式碼</h4><p>請注意，資料夾名稱是 <code>android-basics-kotlin-forage-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-forage-app/tree/main">https://github.com/google-developer-training/android-basics-kotlin-forage-app/tree/main</a><br><strong>分支名稱：</strong><b>main</b></p>
          </div>

<hr>
<h3 id="設定專案以使用-Room"><a href="#設定專案以使用-Room" class="headerlink" title="設定專案以使用 Room"></a>設定專案以使用 Room</h3><h4 id="定義-Forageable-entity"><a href="#定義-Forageable-entity" class="headerlink" title="定義 Forageable entity"></a>定義 Forageable entity</h4><p>專案已有 <code>Forageable</code> class，可定義 app 的資料 (<code>model.Forageable.kt</code>)。此 class 有多個屬性：<code>id</code>、<code>name</code>、<code>address</code>、<code>inSeason</code> 和 <code>notes</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Forageable</span>(</span><br><span class="line">   <span class="keyword">val</span> id: <span class="built_in">Long</span> = <span class="number">0</span>,</span><br><span class="line">   <span class="keyword">val</span> name: String,</span><br><span class="line">   <span class="keyword">val</span> address: String,</span><br><span class="line">   <span class="keyword">val</span> inSeason: <span class="built_in">Boolean</span>,</span><br><span class="line">   <span class="keyword">val</span> notes: String?</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>不過，若要使用此 class 儲存持續性資料，就需要將 class 轉換為 <code>Room</code> entity。</p>
<ol>
<li>使用這個 table 名稱為 <code>&quot;forageable_database&quot;</code> 的 <code>@Entity</code> 為 class 加上註解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;forageable_database&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Forageable</span>(</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>id</code> 屬性設定為主鍵(primary key)。主鍵應由系統自動產生。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line"><span class="keyword">val</span> id: <span class="built_in">Long</span> = <span class="number">0</span>,</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將 <code>inSeason</code> 屬性的 column name 設定為 <code>&quot;in_season&quot;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ColumnInfo(name = <span class="string">&quot;in_season&quot;</span>)</span></span><br><span class="line"><span class="keyword">val</span> inSeason: <span class="built_in">Boolean</span>,</span><br></pre></td></tr></table></figure>

<h4 id="實作-DAO"><a href="#實作-DAO" class="headerlink" title="實作 DAO"></a>實作 DAO</h4><p>您將透過 view model 存取 database，而 <code>ForageableDao</code> (<code>data.ForageableDao.kt</code>) 可用來定義從 database 讀取及寫入 database 的方法，就如同您的猜像。由於 DAO 只是您定義的 interface，因此無需撰寫任何程式碼即可導入這些方法。您應該改用 Room 註解，視需要指定 SQL 查詢。</p>
<p>在 <code>ForageableDao</code> interface 中，您必須新增五個方法。</p>
<ol>
<li><code>getForageables()</code> 方法會對 database 中的所有 row 傳回 <code>Flow&lt;List&lt;Forageable&gt;&gt;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * FROM forageable_database&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getForageables</span><span class="params">()</span></span>: Flow&lt;List&lt;Forageable&gt;&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>getForageable(id: Long)</code> 方法會傳回符合指定 <code>id</code> 的 <code>Flow&lt;Forageable&gt;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * FROM forageable_database WHERE id = :id&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getForageable</span><span class="params">(id: <span class="type">Long</span>)</span></span>: Flow&lt;Forageable&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>insert(forageable: Forageable)</code> 方法會將新的 <code>Forageable</code> 插入至 database 中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(onConflict = OnConflictStrategy.REPLACE)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(forageable: <span class="type">Forageable</span>)</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>update(forageable: Forageable)</code> 方法會採用現有 <code>Forageable</code> 作為參數，並據此更新 row。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(forageable: <span class="type">Forageable</span>)</span></span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li><code>delete(forageable: Forageable)</code> 方法會採用 <code>Forageable</code> 作為參數，然後從 database 中將其刪除。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Delete</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(forageable: <span class="type">Forageable</span>)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="實作-view-model"><a href="#實作-view-model" class="headerlink" title="實作 view model"></a>實作 view model</h4><p><code>ForageableViewModel</code> (<code>ui.viewmodel.ForageableViewModel.kt</code>) 已部分導入，但您必須新增可存取 DAO 方法的功能，才能實際讀取及寫入資料。請按照下列步驟導入 <code>ForageableViewModel</code>。</p>
<ol>
<li>傳遞 <code>ForageableDao</code> instance 時，應以 class constructor 中參數的形式傳遞。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 將 ForageableDao object 做為參數傳遞至預設 constructor</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ForageableViewModel</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> forageableDao: ForageableDao</span><br><span class="line">): ViewModel() &#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立 <code>LiveData&lt;List&lt;Forageable&gt;&gt;</code> class 的變數，此變數會使用 DAO 取得完整的 <code>Forageable</code> entity list，並將結果轉換為 <code>LiveData</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> forageables: LiveData&lt;List&lt;Forageable&gt;&gt; = forageableDao.getForageables().asLiveData()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立採用 id (<code>Long</code> type) 做為參數的方法，此方法會在 DAO 上呼叫 <code>getForageable()</code> 方法，並將結果轉換為 <code>LiveData</code>，藉此傳回 <code>LiveData&lt;Forageable&gt;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">retrieveForageable</span><span class="params">(id: <span class="type">Long</span>)</span></span>: LiveData&lt;Forageable&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> forageableDao.getForageable(id).asLiveData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>addForageable()</code> 方法中，使用 <code>viewModelScope</code> 啟動 coroutine，並使用 DAO 將 <code>Forageable</code> instance 插入至 database 中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">    forageableDao.insert(forageable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>updateForageable()</code> 方法中，使用 DAO 更新 <code>Forageable</code> entity。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    forageableDao.update(forageable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>deleteForageable()</code> 方法中，使用 DAO 更新 <code>Forageable</code> entity。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">    forageableDao.delete(forageable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>建立可透過 <code>ForageableDao</code> constructor 參數建立 <code>ForageableViewModel</code> instance 的 <code>ViewModelFactory</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ForageableViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> forageableDao: ForageableDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="comment">// 檢查 modelClass 是否和 ForageableViewModel class 相同</span></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isAssignableFrom(ForageableViewModel::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//  return 一個 instance</span></span><br><span class="line">            <span class="keyword">return</span> ForageableViewModel(forageableDao) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// throw exception</span></span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="實作-Database-class"><a href="#實作-Database-class" class="headerlink" title="實作 Database class"></a>實作 Database class</h4><p><code>ForageDatabase</code> (<code>data.ForageDatabase.kt</code>) class 實際上是將 <strong>entities</strong> 和 <strong>DAO</strong> 公開給 Room。按照說明導入 <code>ForageDatabase</code> class。</p>
<ol>
<li>Entities：<code>Forageable</code></li>
<li>Version：<code>1</code></li>
<li>exportSchema：<code>false</code></li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = [Forageable::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ForageDatabase</span> : <span class="type">RoomDatabase</span>()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>ForageDatabase</code> class 中，加入能夠傳回 <code>ForageableDao</code> 的抽象函式(abstract function)</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">forageableDao</span><span class="params">()</span></span>: ForageableDao</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>ForageDatabase</code> class 中，用名為 <code>INSTANCE</code> 的 private 變數和傳回 <code>ForageDatabase</code> <b>單例模式(singleton)</b>的 <code>getDatabase()</code> 函式定義 <strong>companion object</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定義 companion object (可使用 class name 做為限定詞，建立或取得 database)</span></span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: ForageDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 使用 database builder 所需的 Context 參數定義 getDatabase() method</span></span><br><span class="line">       <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ForageDatabase &#123;</span><br><span class="line">           <span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123; <span class="comment">// synchronized區塊中，一次只能執行一個 thread</span></span><br><span class="line">               <span class="comment">// 使用 database builder 取得 database instance</span></span><br><span class="line">               <span class="comment">// 將 application context、database class 以及 database name item_database 傳遞給 database builder</span></span><br><span class="line">               <span class="keyword">val</span> instance = Room.databaseBuilder(</span><br><span class="line">                   context.applicationContext,</span><br><span class="line">                   ForageDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">                   <span class="string">&quot;forageable_database&quot;</span>)</span><br><span class="line">                   .fallbackToDestructiveMigration() <span class="comment">// 將遷移策略新增至 builder</span></span><br><span class="line">                   .build()</span><br><span class="line">               INSTANCE = instance <span class="comment">// 將 INSTANCE 設為剛才建立好的 instance</span></span><br><span class="line">               <span class="keyword">return</span> instance</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>BaseApplication</code> class 中，建立使用<b>延遲(lazy)初始化</b>功能傳回 <code>ForageDatabase</code> instance 的 <code>database</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> provide a ForageDatabase value by lazy here</span></span><br><span class="line">    <span class="keyword">val</span> database: ForageDatabase <span class="keyword">by</span> lazy &#123; ForageDatabase.getDatabase(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="保留及讀取-fragment-中的資料"><a href="#保留及讀取-fragment-中的資料" class="headerlink" title="保留及讀取 fragment 中的資料"></a>保留及讀取 fragment 中的資料</h3><p>設定 <b>entity</b>、<b>DAO</b>、<b>view model</b>，以及定義要在 Room 公開的 <strong>database class</strong> 後，您只需要修改 <code>Fragments</code>，即可存取 <strong>view model</strong>。您必須在三個檔案中進行變更，各檔案用於 app 中的各畫面。</p>
<h4 id="Forageable-list"><a href="#Forageable-list" class="headerlink" title="Forageable list"></a>Forageable list</h4><p>Forageable list 畫面只需要兩個 item：</p>
<ul>
<li>view model 的 reference。</li>
<li>對完整 Forageable list 的存取權限。<br>在 <code>ui.ForageableListFragment.kt</code> 中執行以下工作。</li>
</ul>
<ol>
<li>class 中已有 <code>viewModel</code> 屬性。但不使用您在上一個步驟中定義的 Factory function。您必須先重構此宣告，才能使用 <code>ForageableViewModelFactory</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: ForageableViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   ForageableViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> BaseApplication).database.foragableDao()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然後在 <code>onViewCreated()</code> 中，從 <code>viewModel</code> 觀察(observe) <code>allForageables</code> 屬性，並視需要在 adapter 上呼叫 <code>submitList()</code> 來填入 list。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.forageables.observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; forageables -&gt;</span><br><span class="line">    forageables.let &#123;</span><br><span class="line">        adapter.submitList(it)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Forageable-detail-畫面"><a href="#Forageable-detail-畫面" class="headerlink" title="Forageable detail 畫面"></a>Forageable detail 畫面</h4><p>對於 <code>ui/ForageableDetailFragment.kt</code> 中的 detail list，您需要執行的動作幾乎完全相同。</p>
<ol>
<li>轉換 <code>viewModel</code> 屬性以正確初始化 <code>ForageableViewModelFactory</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: ForageableViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">    ForageableViewModelFactory(</span><br><span class="line">        (activity?.application <span class="keyword">as</span> BaseApplication).database.forageableDao()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>onViewCreated()</code> 中，呼叫 view model 上的 <code>getForageable()</code>，並傳入 <code>id</code> 以取得 <code>Forageable</code> entity。觀察(observe) <code>LiveData</code> 並將結果設定為 <code>forageable</code> 屬性，然後呼叫 <code>bindForageable()</code> 來更新 UI。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.getForageable(id).observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; selectedForageable -&gt;</span><br><span class="line">    forageable = selectedForageable</span><br><span class="line">    bindForageable()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增及編輯-Forageable-畫面"><a href="#新增及編輯-Forageable-畫面" class="headerlink" title="新增及編輯 Forageable 畫面"></a>新增及編輯 Forageable 畫面</h4><p>最後，您需要在 <code>ui.AddForageableFragment.kt</code> 中執行類似操作。請注意，此畫面也會負責更新及刪除 entity。不過，系統已從 view model 的正確位置呼叫這些方法。您只需在此檔案中進行兩項變更即可。</p>
<ol>
<li>再次重構 <code>viewModel</code> 屬性以使用 <code>ForageableViewModelFactory</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: ForageableViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">    ForageableViewModelFactory(</span><br><span class="line">        (activity?.application <span class="keyword">as</span> BaseApplication).database.forageableDao()</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在您調整 delete button 的顯示設定之前，請在 <code>onViewCreated()</code> 的 <code>if</code> statement 區塊中，呼叫 view model 上的 <code>getForageable()</code>，並傳入 <code>id</code>，然後將結果設定為 <code>forageable</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.getForageable(id).observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; selectedForageable -&gt;</span><br><span class="line">    forageable = selectedForageable</span><br><span class="line">    bindForageable(forageable)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這就是您需要在 fragment 中執行的所有動作。您現在可以執行 app，藉此查看動作中的所有持續性(persistence)功能。</p>
<hr>
<h3 id="執行-App"><a href="#執行-App" class="headerlink" title="執行 App"></a>執行 App</h3><div class="video-container"><iframe src="https://player.vimeo.com/video/900157947" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<hr>
<h3 id="執行自動化測試"><a href="#執行自動化測試" class="headerlink" title="執行自動化測試"></a>執行自動化測試</h3><p>執行結果：<br><img src="https://i.imgur.com/NTv4kMn.png"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
        <tag>companion object</tag>
        <tag>singleton</tag>
        <tag>Fragment</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Coroutine</tag>
        <tag>suspend function</tag>
        <tag>SQL</tag>
        <tag>Room</tag>
        <tag>DAO</tag>
        <tag>Entity</tag>
        <tag>Factory</tag>
        <tag>Flow</tag>
        <tag>Database Class</tag>
        <tag>Concurrency</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(43)-Preferences DataStore</title>
    <url>/2023/12/27/Android%E7%AD%86%E8%A8%98-43-Preferences-DataStore/</url>
    <content><![CDATA[<blockquote>
<p>學習如何使用 <strong>Jetpack DataStore</strong> 在 app 中儲存 <strong>key-value</strong> 組合。</p>
</blockquote>
<p>在先前的程式碼研究室中，我們已說明如何使用 Room (database 抽象層) 將資料儲存在 SQLite database 中。本程式碼研究室會介紹 <strong>Jetpack DataStore</strong>。<strong>DataStore</strong> 以 Kotlin <strong>coroutine</strong> 和 <strong>Flow</strong> 為基礎而設計，共提供兩種不同的<u>實作方式</u>，一種是<u>專門儲存 typed objects 的 <b>Proto DataStore</b></u>，另一種則是<u>專門儲存 key-value 組合的 <b>Preferences DataStore</b></u>。</p>
<p>本程式碼研究室會說明如何使用 <strong>Preferences DataStore</strong>，Proto DataStore 則不在本程式碼研究室的說明範圍內。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>DataStore 是什麼？您應使用 DataStore 的原因及時機為何？</li>
<li>如何將 <strong>Preference DataStore</strong> 新增至 app。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>在本程式碼研究室中，您將會從先前的解決方案程式碼擴充 Word app 的功能。範例程式碼可能包含您在先前程式碼研究室中也熟悉的程式碼。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-words-app/tree/main">https://github.com/google-developer-training/android-basics-kotlin-words-app/tree/main</a><br><strong>分支版本：</strong><b>main</b></p>
          </div>

<h4 id="範例-app-總覽"><a href="#範例-app-總覽" class="headerlink" title="範例 app 總覽"></a>範例 app 總覽</h4><p>Words app 包含兩個畫面：第一個畫面會顯示<u>使用者可選取的字母</u>，第二個畫面則會顯示<u>開頭為所選字母的字詞 list</u>。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:40%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/9a0edc77939b7ece_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/2149e95ae2f3a0a0_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>這個 app 可讓使用者透過 menu option，切換為以 list 或 grid layout 來顯示字母。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:40%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/9a0edc77939b7ece_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/1c8cf63c8d175aad_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<ol>
<li>下載範例程式碼，然後在 Android Studio 中開啟並執行 app。系統會以 <strong>liner layout</strong> 顯示字母。</li>
<li>輕觸右上角的 menu option。layout 會切換為 <strong>grid layout</strong>。</li>
<li>結束 app 並重新啟動。您可以在 Android Studio 中使用「Stop ‘app’」和「Run ‘app’」選項。請注意，重新啟動 app 後，字母會以 <strong>liner layout</strong> 顯示，而不是 <strong>grid layout</strong>。</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/9a0edc77939b7ece_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/1c8cf63c8d175aad_1920.png?hl=zh-tw">
    </div>
        <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/9a0edc77939b7ece_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>請注意，系統<u>不會保留使用者的選擇</u>。本程式碼研究室會說明如何修正此問題。<br>在本程式碼研究室中，您會瞭解如何使用 <strong>Preferences DataStore</strong>，<u>保留 <strong>DataStore</strong> 中的 layout 設定</u>。</p>
<hr>
<h3 id="Preferences-DataStore-簡介"><a href="#Preferences-DataStore-簡介" class="headerlink" title="Preferences DataStore 簡介"></a>Preferences DataStore 簡介</h3><p><strong>Preferences DataStore</strong> 適合用於<b>簡單的小型 dataset</b>，例如<u>儲存登入詳細資料</u>、<u>深色模式設定</u>、<u>字型大小</u>等等。<strong>DataStore</strong> <b>不適用於複雜的 dataset</b>，例如<u>線上雜貨店的商品目錄清單</u>或<u>學生資料庫</u>。如果需要儲存大型或複雜的 dataset，建議您使用 <strong>Room</strong> 而非 DataStore。</p>
<ul>
<li>儲存簡單的小型 dataset：<strong>DataStore</strong></li>
<li>儲存大型或複雜的 dataset：<strong>Room</strong></li>
</ul>
<p>使用 <strong>Jetpack DataStore 程式庫</strong>就能建立<u>簡單、安全且非同步的 API</u>，可用來<u>儲存資料</u>。其提供兩種不同的導入方式：<strong>Preferences DataStore</strong> 和 <strong>Proto DataStore</strong>。雖然 Preferences DataStore 和 Proto DataStore 都能儲存資料，但卻使用不同的做法：</p>
<ul>
<li><strong>Preferences DataStore</strong> 可依據 <strong>keys</strong> 來存取和儲存資料，而不必事先界定<u>結構定義(schema)</u> (database model)。</li>
<li><strong>Proto DataStore</strong> 使用<a href="https://protobuf.dev/">通訊協定緩衝區(Protocol buffers)</a>來界定<u>結構定義(schema)</u>。使用<u>通訊協定緩衝區(Protocol buffers)</u> (或 <u>Protobufs</u>) 可讓您<b>保留強類型資料(persist strongly typed data)</b>。與 XML 和其他類似的資料格式相比，Protobufs 更快更簡單，而且更清晰明確。</li>
</ul>
<p><strong>Room 與 Datastore 的比較：適用時機</strong><br>如果您的 app 需要以 SQL 等結構化格式儲存大型&#x2F;複雜的資料，建議您使用 Room。不過，如果您只想<u>儲存簡單或少許資料</u>，且這些資料可以儲存在 <b>key&#x2F;value</b> 組合中，建議您使用 <strong>DataStore</strong>。</p>
<p><strong>Proto DataStore 與 Preferences DataStore 的比較：使用時機</strong><br><strong>Proto DataStore</strong> <u>type safe</u> 和 <u>efficient</u>，但需要 <u>configuration</u> 和 <u>setup</u>。如果您的 app 資料夠簡單，可以儲存在 key&#x2F;value 組合中，那麼易於設定的 <strong>Preferences DataStore</strong> 則較為適合。</p>
<h4 id="將-Preferences-DataStore-新增為-dependency"><a href="#將-Preferences-DataStore-新增為-dependency" class="headerlink" title="將 Preferences DataStore 新增為 dependency"></a>將 Preferences DataStore 新增為 dependency</h4><p>要將 DataStore 整合至 app，第一步是將其新增為 dependency。</p>
<ol>
<li>在 <code>build.gradle(Module: Words.app)</code> 中新增下列 dependency：</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.datastore:datastore-preferences:1.0.0&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.lifecycle:lifecycle-livedata-ktx:2.3.1&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="建立-Preferences-DataStore"><a href="#建立-Preferences-DataStore" class="headerlink" title="建立 Preferences DataStore"></a>建立 Preferences DataStore</h3><ol>
<li><p>新增名為 <code>data</code> 的 package，並在其中建立名為 <code>SettingsDataStore</code> 的 Kotlin class。</p>
</li>
<li><p>在 <code>SettingsDataStore</code> class 中加入 type 為 <code>Context</code> 的 constructor 參數。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SettingsDataStore</span>(context: Context) &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>SettingsDataStore</code> class 之外，宣告名為 <code>LAYOUT_PREFERENCES_NAME</code> 的 <code>private</code> <code>const</code> <code>val</code>，並為其指派 string 值 <code>layout_preferences</code>。這是你在下一步要執行<u>實例化(instantiate)</u>的 <strong>Preferences Datastore</strong> name。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> LAYOUT_PREFERENCES_NAME = <span class="string">&quot;layout_preferences&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>請在 class 外<u>使用 <code>preferencesDataStore</code> 委托(delegate)來建立 <code>DataStore</code> instance</u>。由於您使用 <strong>Preferences Datastore</strong>，因此需要<u>將 <code>Preferences</code> 傳遞做為 <strong>datastore type</strong></u>。此外，請<u>將 <code>LAYOUT_PREFERENCES_NAME</code> 設為 datastore <code>name</code></u>。</li>
</ol>
<p>完成的程式碼如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> LAYOUT_PREFERENCES_NAME = <span class="string">&quot;layout_preferences&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a DataStore instance using the preferencesDataStore delegate, with the Context as</span></span><br><span class="line"><span class="comment">// receiver.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> Context.dataStore : DataStore&lt;Preferences&gt; <span class="keyword">by</span> preferencesDataStore(</span><br><span class="line">   name = LAYOUT_PREFERENCES_NAME</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>提示：</strong>只要在 Kotlin 檔案的頂層建立 <b>DataStore instance</b>，便可在 app 的其他部分透過此屬性存取 instance。這樣就能更輕鬆地將 DataStore 保持為<b>單例模式(singleton)</b>。</p>
          </div>

<hr>
<h3 id="實作-SettingsDataStore-class"><a href="#實作-SettingsDataStore-class" class="headerlink" title="實作 SettingsDataStore class"></a>實作 SettingsDataStore class</h3><p>如前所述，<strong>Preferences DataStore</strong> 會以 <strong>key&#x2F;value</strong> 組合的形式儲存資料。在這個步驟中，您會<u>定義儲存 layout 設定所需的 <strong>key</strong></u>，也會<u>定義要寫入和讀取 <strong>Preferences DataStore</strong> 的函式</u>。</p>
<h4 id="Key-type-functions"><a href="#Key-type-functions" class="headerlink" title="Key type functions"></a>Key type functions</h4><p>有別於 Room，Preferences DataStore 並<u>不會使用預先定義的<b>結構定義(schema)</b></u>，而是使用<u>對應的 key type functions</u>，來定義您儲存在 <code>DataStore&lt;Preferences&gt;</code> instance 中每個 value 的 key。舉例來說，如要定義 int 值的 key，請使用 <code>intPreferencesKey()</code>；要定義 <code>string</code> 值的鍵，則使用 <code>stringPreferencesKey()</code>。整體來說，這些 function names 的<u>前置 string</u>會與所儲存 <u>key 的 data type</u> 相同。</p>
<p>在 <code>data\SettingsDataStore</code> class 中實作以下內容：</p>
<ol>
<li>如要導入 <code>SettingsDataStore</code> class，首先請建立用於儲存 <code>Boolean</code> 值的 key，該 <code>Boolean</code> 值會指定<u>使用者設定是否屬於 liner layout</u>。建立名為 <code>IS_LINEAR_LAYOUT_MANAGER</code> 的 <code>private</code> class type，並使用 <code>booleanPreferencesKey()</code> (傳入 <code>is_linear_layout_manager</code> key name 做為函式參數) 來初始化。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> IS_LINEAR_LAYOUT_MANAGER = booleanPreferencesKey(<span class="string">&quot;is_linear_layout_manager&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="寫入-Preferences-DataStore"><a href="#寫入-Preferences-DataStore" class="headerlink" title="寫入 Preferences DataStore"></a>寫入 Preferences DataStore</h4><p>現在，請開始使用 key，並將 <code>Boolean</code> 值 layout 設定儲存在 <code>DataStore</code> 中。Preferences DataStore 提供 <code>edit()</code> suspend function，可以<u>交易形式(transactionally)</u>更新 <code>DataStore</code> 中的資料。函式的<u>轉換(transform)參數</u>接受程式碼區塊，您可以視需要更新 value。<u>轉換區塊(transform block)</u>的所有程式碼皆視為<u>單一交易(single transaction)</u>。原理上，交易作業會移至 <code>Dispacter.IO</code> 底下，因此在呼叫 <code>edit()</code> 函式時，別忘了將函式設為 <code>suspend</code>。</p>
<ol>
<li>建立一個名為 <code>saveLayoutToPreferencesStore()</code> 的 <code>suspend</code> 函式，該函式採用以下兩個參數：layout 設定 Boolean 值和 <code>Context</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveLayoutToPreferencesStore</span><span class="params">(isLinearLayoutManager: <span class="type">Boolean</span>, context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>實作上述函式，呼叫 <code>dataStore.edit()</code>，並傳遞程式碼區塊以儲存新的 value。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">saveLayoutToPreferencesStore</span><span class="params">(isLinearLayoutManager: <span class="type">Boolean</span>, context: <span class="type">Context</span>)</span></span> &#123;</span><br><span class="line">   context.dataStore.edit &#123; preferences -&gt;</span><br><span class="line">       preferences[IS_LINEAR_LAYOUT_MANAGER] = isLinearLayoutManager</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="從-Preferences-DataStore-讀取"><a href="#從-Preferences-DataStore-讀取" class="headerlink" title="從 Preferences DataStore 讀取"></a>從 Preferences DataStore 讀取</h4><p>Preferences DataStore 會公開儲存在 <code>Flow&lt;Preferences&gt;</code> 的資料，只要偏好設定有所變更，該程式碼就會發出資料。您不想公開整個 <code>Preferences</code> object，只需公開 <code>Boolean</code> 值即可。因此，我們會對應 <code>Flow&lt;Preferences&gt;</code>，並取得您所需的 <code>Boolean</code> 值。</p>
<ol start="3">
<li>公開根據 <code>dataStore.data: Flow&lt;Preferences&gt;</code> 建構的 <code>preferenceFlow: Flow&lt;UserPreferences&gt;</code>，進行對應以擷取 <code>Boolean</code> 偏好設定。由於 <code>Datastore</code> 在首次執行時沒有任何內容，因此系統會預設傳回 <code>true</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> preferenceFlow: Flow&lt;<span class="built_in">Boolean</span>&gt; = context.dataStore.<span class="keyword">data</span></span><br><span class="line">   .map &#123; preferences -&gt;</span><br><span class="line">       <span class="comment">// On the first run of the app, we will use LinearLayoutManager by default</span></span><br><span class="line">       preferences[IS_LINEAR_LAYOUT_MANAGER] ?: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果下列項目未自動 import，請新增以下資訊：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.Flow</span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.<span class="keyword">catch</span></span><br><span class="line"><span class="keyword">import</span> kotlinx.coroutines.flow.map</span><br></pre></td></tr></table></figure>

<h4 id="例外狀況處理"><a href="#例外狀況處理" class="headerlink" title="例外狀況處理"></a>例外狀況處理</h4><p>DataStore 從<u>檔案讀取(reads)</u>及<u>寫入(writes)資料</u>，系統可能會在存取資料時出現 <code>IOExceptions</code>。您可以使用 <code>catch()</code> 運算子來擷取例外狀況(exceptions)，以處理這些問題。</p>
<ol>
<li>若在讀取資料時發生錯誤，<strong>SharedPreference DataStore</strong> 會 throws <code>IOException</code>。在 <code>preferenceFlow</code> 宣告中，請在 <code>map()</code> 之前使用 <code>catch()</code> 運算子擷取 <code>IOException</code>，並發出 <code>emptyPreferences()</code>。為求簡單，我們預計此處不會出現其他類型的 exceptions；如果出現其他類型的 exception，請重新 thrown 該 exception。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> preferenceFlow: Flow&lt;<span class="built_in">Boolean</span>&gt; = context.dataStore.<span class="keyword">data</span></span><br><span class="line">   .<span class="keyword">catch</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (it <span class="keyword">is</span> IOException) &#123;</span><br><span class="line">           it.printStackTrace()</span><br><span class="line">           emit(emptyPreferences())</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">throw</span> it</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   .map &#123; preferences -&gt;</span><br><span class="line">       <span class="comment">// On the first run of the app, we will use LinearLayoutManager by default</span></span><br><span class="line">       preferences[IS_LINEAR_LAYOUT_MANAGER] ?: <span class="literal">true</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>


<hr>
<h3 id="使用-SettingsDataStore-class"><a href="#使用-SettingsDataStore-class" class="headerlink" title="使用 SettingsDataStore class"></a>使用 SettingsDataStore class</h3><p>在下一個工作中，您將會在 <code>LetterListFragment</code> class 中使用 <code>SettingsDataStore</code>。您要將 <strong>observer</strong> 附加到 <u>layout 設定</u>，並據此更新 <strong>UI</strong>。</p>
<p>請在 <code>LetterListFragment</code> 中採取下列步驟：</p>
<ol>
<li>宣告稱為 <code>SettingsDataStore</code> 且 type 為 <code>SettingsDataStore</code> 的 <code>private</code> class 變數。由於您後將會初始化這個變數，因此請將其設為 <code>lateinit</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> SettingsDataStore: SettingsDataStore</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>onViewCreated()</code> 函式的末尾，請初始化新變數，然後將 <code>requireContext()</code> 傳遞至 <code>SettingsDataStore</code> constructor。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Initialize SettingsDataStore</span></span><br><span class="line">   SettingsDataStore = SettingsDataStore(requireContext())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Read-和-observe-資料"><a href="#Read-和-observe-資料" class="headerlink" title="Read 和 observe 資料"></a>Read 和 observe 資料</h4><ol start="3">
<li>在 <code>LetterListFragment</code> 的 <code>onViewCreated()</code> 方法中，於 <code>SettingsDataStore</code> 初始化底下，使用 <code>asLiveData()</code> 將 <code>preferenceFlow</code> 轉換為 <code>Livedata</code>。請附加一個 <strong>observer</strong>，並傳遞到 <code>viewLifecycleOwner</code> 做為 <strong>owner</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SettingsDataStore.preferenceFlow.asLiveData().observe(viewLifecycleOwner, &#123; &#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <strong>observer</strong> 內，<u>將新的 layout 設定指派給 <code>isLinearLayoutManager</code> 變數</u>。呼叫 <code>chooseLayout()</code> 函式以<u>更新 <code>RecyclerView</code> layout</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SettingsDataStore.preferenceFlow.asLiveData().observe(viewLifecycleOwner, &#123; value -&gt;</span><br><span class="line">           isLinearLayoutManager = value</span><br><span class="line">           chooseLayout()</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>完成的 <code>onViewCreated()</code> 函式應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   recyclerView = binding.recyclerView</span><br><span class="line">   <span class="comment">// Initialize SettingsDataStore</span></span><br><span class="line">   SettingsDataStore = SettingsDataStore(requireContext())</span><br><span class="line">   SettingsDataStore.preferenceFlow.asLiveData().observe(viewLifecycleOwner, &#123; value -&gt;</span><br><span class="line">           isLinearLayoutManager = value</span><br><span class="line">           chooseLayout()</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="將-layout-設定寫入-DataStore"><a href="#將-layout-設定寫入-DataStore" class="headerlink" title="將 layout 設定寫入 DataStore"></a>將 layout 設定寫入 DataStore</h4><p>最後一個步驟則是在使用者輕觸 <strong>menu option</strong> 時，，<u>將 layout 設定寫入 <strong>Preferences DataStore</strong></u>。您應以<u>同步(asynchronously)</u>方式在 <strong>coroutine</strong> 中將資料寫入 Preferences DataStore。如要在 fragment 中執行此操作，請使用名為 <a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-tw#lifecyclescope"><code>LifecycleScope</code></a> 的 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/"><code>CoroutineScope</code></a>。</p>
<h4 id="LifecycleScope"><a href="#LifecycleScope" class="headerlink" title="LifecycleScope"></a>LifecycleScope</h4><p><a href="https://developer.android.com/topic/libraries/architecture/lifecycle?hl=zh-tw">Lifecycle-aware components</a> (如 fragment) 為 app 中的<u>邏輯範圍(logical scopes)</u>以及<u>與 <code>LiveData</code> 的互通層</u>提供一流支援。系統會為每個 <code>Lifecycle</code> object 定義 <code>LifecycleScope</code>。<u><code>Lifecycle</code> owner 遭到<b>刪除(destroyed)</b>時</u>，系統就會<u>取消此<b>範圍(scope)</b>內啟動的所有 <strong>coroutine</strong></u>。</p>
<ol>
<li>在 <code>LetterListFragment</code> 的 <code>onOptionsItemSelected()</code> 函式內，於 <code>R.id.action_switch_layout</code> case 的結尾，使用 <code>lifecycleScope</code> 來啟動 <strong>coroutine</strong>。在 <code>launch</code> 區塊內，呼叫 <code>saveLayoutToPreferencesStore()</code> 以傳遞 <code>isLinearLayoutManager</code> 和 <code>context</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">       R.id.action_switch_layout -&gt; &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// Launch a coroutine and write the layout setting in the preference Datastore</span></span><br><span class="line">           lifecycleScope.launch &#123;</span><br><span class="line">       SettingsDataStore.saveLayoutToPreferencesStore(isLinearLayoutManager, requireContext())</span><br><span class="line">           &#125;</span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>現在，請測試 Preferences DataStore 的<b>持續性(persistence)</b>。將 app layout 變更為 grid layout。結束 app 並重新啟動。</li>
</ol>
<p>重新啟動 app 後，字母現在會以 <strong>grid layout</strong> 顯示，而不是 <strong>liner layout</strong>。您的 app 已成功儲存使用者選取的 layout！</p>
<p>請注意，雖然字母現在會以 grid layout 顯示，但 <strong>menu icon</strong> 未正確更新。我們接下來會說明如何解決這個問題。</p>
<hr>
<h3 id="修正-menu-icon-bug"><a href="#修正-menu-icon-bug" class="headerlink" title="修正 menu icon bug"></a>修正 menu icon bug</h3><p>Menu icon bug，原因在於在 <code>onViewCreated()</code> 中，<code>RecyclerView</code> layout 的更新依據是 layout 設定而而不是 menu icon。只要在<u>更新 <code>RecyclerView</code> layout 時同時<b>重畫(redrawing) menu</b></u>，即可解決這個問題。</p>
<h4 id="重畫-options-menu"><a href="#重畫-options-menu" class="headerlink" title="重畫 options menu"></a>重畫 options menu</h4><p>建立 menu 後，系統就不會多此一舉地為每個 frame 重畫(redrawn)相同的 menu。<a href="https://developer.android.com/reference/android/app/Activity#invalidateOptionsMenu()"><code>invalidateOptionsMenu()</code></a> 函式會<u>指示 Android 重畫(redraw) <strong>options menu</strong></u>。</p>
<p>變更 option menu 的內容 (例如<u>新增 menu item</u>、<u>刪除 item</u> 或是<u>變更 menu text 或 icon</u>) 時，您可以呼叫這個函式。在本例中，<u>menu icon 已變更。呼叫此方法就會宣告 <b>option menu 已變更</b>，並應<b>重新建立 menu</b></u>。下次需要顯示時 option menu 時，就會呼叫 <a href="https://developer.android.com/reference/android/app/Activity#onCreateOptionsMenu(android.view.Menu)"><code>onCreateOptionsMenu(android.view.Menu)</code></a> 方法。</p>
<ol>
<li>在 <code>LetterListFragment</code> 中的 <code>onViewCreated()</code> 內，於 <code>preferenceFlow</code> observer 結尾，呼叫 <code>chooseLayout()</code> 的底下，透過對 <code>activity</code> 呼叫 <code>invalidateOptionsMenu()</code> 來重畫(redraw) menu。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   SettingsDataStore.preferenceFlow.asLiveData().observe(viewLifecycleOwner, &#123; value -&gt;</span><br><span class="line">           ...</span><br><span class="line">           <span class="comment">// Redraw the menu</span></span><br><span class="line">           activity?.invalidateOptionsMenu()</span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>再次執行 app，並變更 layout。</p>
</li>
<li><p>結束 app 並重新啟動。請注意，menu icon 現在已正確更新。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-preferences-datastore/img/1c8cf63c8d175aad_1920.png?hl=zh-tw" width="40%">

<p>恭喜！您已成功將 <strong>Preferences DataStore</strong> 新增至 app，以便儲存使用者的選擇。</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>DataStore 提供採用 Kotlin coroutines 和 Flow 的完全非同步(asynchronous) API，可確保<u>資料的一致性(consistency)</u>。</li>
<li>Jetpack DataStore 是一項<u>資料儲存(data storage) solution</u>，可讓您使用<a href="https://protobuf.dev/">protocol buffers</a>來儲存 <strong>key-value</strong> 組合或 <strong>typed objects</strong>。</li>
<li>DataStore 提供兩種實作方式：<strong>Preferences DataStore</strong> 和 <strong>Proto DataStore</strong>。</li>
<li>Preferences DataStore 不會使用<u>預先定義(predefined)</u>的<u>結構定義(schema)</u>。</li>
<li>Preferences DataStore 使用對應的 <strong>key type function</strong>，定義每個需要儲存在 <code>DataStore&lt;Preferences&gt;</code> instance 中的 value。舉例來說，想定義 <code>int</code> value 的 key，請使用 <a href="https://developer.android.com/reference/kotlin/androidx/datastore/preferences/core/package-summary#intPreferencesKey(kotlin.String)"><code>intPreferencesKey()</code></a>。</li>
<li>Preferences DataStore 提供 <code>edit()</code> 函式，可以<u>交易形式(transactionally)</u>更新 <code>DataStore</code> 中的資料。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Lifecycle</tag>
        <tag>LiveData</tag>
        <tag>Observer</tag>
        <tag>LifecycleOwner</tag>
        <tag>Coroutine</tag>
        <tag>suspend function</tag>
        <tag>CoroutineScope</tag>
        <tag>Flow</tag>
        <tag>DataStore</tag>
        <tag>Preferences DataStore</tag>
        <tag>Proto DataStore</tag>
        <tag>LifecycleScope</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(42)-Repository Pattern</title>
    <url>/2023/12/24/Android%E7%AD%86%E8%A8%98-42-Repository-Pattern/</url>
    <content><![CDATA[<blockquote>
<p>在本程式碼研究室中，您將使用<u>離線快取(offline caching)</u>功能來改善 app 的使用者體驗。許多 app 都依賴來自網路的 data。如果 app 在每次啟動時都從 server 擷取 data，並顯示 loading 畫面，可能會造成使用者體驗不佳，導致使用者解除安裝 app。</p>
</blockquote>
<p>使用者啟動 app 時，會希望 app 能快速顯示 data。實作<u>離線快取(offline caching)</u>功能就能實現這個目標。<b>離線快取(offline caching)</b>是指 app <u>將從網路擷取的 data 儲存到裝置的本機<b>儲存空間(local storage)</b></u>，進而<u>加快存取速度</u>。</p>
<p>由於 app 將可從網路取得 data，並且保留先前下載結果的離線快取(offline cache)，因此您需要讓 app 透過某種方式<u>彙整來自多個來源的 data</u>。做法是實作<b>repository class</b>，做為 app data 的單一可靠資料來源，並從 view model 中提取資料來源 (例如<u>網路(network)、快取(cache)</u>等)。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>如何<u>實作 repository</u>，以便從 app 的其他部分提取 data layer。</li>
<li>如何<u>使用 repository</u> 載入<b>快取資料(cached data)</b>。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><p><strong>下載專案程式碼</strong><br>請注意，資料夾名稱是 <code>RepositoryPattern-Starter</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-kotlin-fundamentals-starter-apps/tree/master/RepositoryPattern-Starter">https://github.com/google-developer-training/android-kotlin-fundamentals-starter-apps/tree/master/RepositoryPattern-Starter</a><br><strong>分支版本名稱：</strong><b>master</b></p>
          </div>

<hr>
<h3 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h3><p>DevBytes app 會在 <code>RecyclerView</code> 中顯示 <a href="https://www.youtube.com/user/androiddevelopers">Android 開發人員 YouTube 頻道</a>的 DevBytes 影片清單(list)，使用者可以從中點選以開啟影片的<a href="https://www.youtube.com/watch?v=sYGKUtM2ga8">連結</a>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/9757e53b89d2de7c_1920.png?hl=zh-tw" width="40%">

<p>雖然範例程式碼可以完全正常運作，但有重大瑕疵，可能會對使用者體驗造成負面影響。如果使用者的網路連線不穩，或根本沒有網路連線，系統將無法顯示任何一部影片。即使先前已開啟 app 也是如此。假如使用者退出 app 並重新啟動，這次不使用網際網路，app 會嘗試重新下載影片清單(list)，但沒有成功。</p>
<p>您可以在模擬器中查看實際運作情形。</p>
<ol>
<li>在 Android Emulator 中暫時開啟飛航模式 (依序點選「Settings App」&gt;「Network &amp; Internet」&gt;「Airplane mode」)。</li>
<li>執行 DevBytes app，可觀察到畫面呈現空白。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/f0365b27d0dd8f78_1920.png?hl=zh-tw" width="40%">

<ol start="3">
<li>務必先關閉飛航模式，再繼續完成程式碼研究室的其餘部分。</li>
</ol>
<p>這是因為 DevBytes app 首次下載資料後，就不會快取任何資料以供日後使用。這個 app 目前包含 <code>Room</code> database。您必須使用這個 database 來實作快取功能，並更新 view model 以使用「repository」，這樣一來，就能下載新資料或從 <code>Room</code> database 中擷取資料。Repository class 會將這個邏輯從 view model 中提取出來，讓程式碼保持井然有序且已分離。</p>
<p>範例專案分為數個 packages。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/25b5f8d0997df54c_1920.png?hl=zh-tw" width="70%">

<p>除了歡迎您並鼓勵您熟悉程式碼以外，您只會接觸以下兩個檔案：<code>repository/VideosRepository.kt</code> 和 <code>viewmodels/DevByteViewModel</code>。首先，您將建立 <code>VideosRepository</code> class 來實作用於快取的 repository pattern (在接下來幾頁中會有更進一步的說明)，接著更新 <code>DevByteViewModel</code> 以使用新的 <code>VideosRepository</code> class。</p>
<p>不過在開始使用程式碼之前，請花點時間進一步瞭解快取(caching)和存放區模式(repository pattern)。</p>
<hr>
<h3 id="Caching-和-repository-pattern"><a href="#Caching-和-repository-pattern" class="headerlink" title="Caching 和 repository pattern"></a>Caching 和 repository pattern</h3><h4 id="Repositories"><a href="#Repositories" class="headerlink" title="Repositories"></a>Repositories</h4><p><b>存放區模式(repository pattern)</b>是一種設計模式，可將資料層( data layer)與 app 的其他部分分開。資料層是指<u>獨立於 UI 的 app 部分</u>，用於<u>處理 app 的資料和商業邏輯</u>，讓 app 的其餘部分都能使用一致的 API 存取這類資料。儘管 UI 會向使用者顯示資訊，但<b>資料層(data layer)</b>會包括<u>網路程式碼(networking code)</u>、<u><code>Room</code> database</u>、<u>錯誤處理(error handling)</u>，以及<u>任何讀取或操控資料的程式碼</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/9e528301efd49aea_1920.png?hl=zh-tw" width="60%">

<p>Repository 可以解決資料來源(data sources) (例如 persistent models、web services 和 caches) 之間的衝突，並集中管理這項資料的變更。下圖顯示 app components (例如 activity) 如何透過 repository 與資料來源(data sources)互動。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/69021c8142d29198_1920.png?hl=zh-tw">

<p>如要實作 repository，請使用其他 class，例如您在下一個工作中建立的 <code>VideosRepository</code> class。<strong>Repository class</strong> 可將<u>資料來源(data sources)</u>與 app 的其他部分分開，並提供<u>簡潔的 API</u>，方便存取 app 其餘部分的資料。使用 repository class 可確保這個程式碼與 <code>ViewModel</code> class 分開，而且是適合用於程式碼分隔和架構的建議最佳做法。</p>
<h4 id="使用-repository-的優點"><a href="#使用-repository-的優點" class="headerlink" title="使用 repository 的優點"></a>使用 repository 的優點</h4><p>repository module 會處理資料作業，並且讓您可以使用多個後端。在一般的實際 app 中，repository 會實作邏輯，以<u>判斷是否要從網路擷取資料</u>，或使用<b>本機資料庫(local database)</b>中的快取結果。透過 repository，您可以替換實作的詳細資料(details)，例如遷移至不同的 persistence library，而不會影響到呼叫的程式碼 (例如 view model)。這也有助於讓程式碼<u>模組化(modular)</u>且<u>可用於測試(testable)</u>。您可以輕鬆模擬 repository，並測試程式碼的其他部分。</p>
<p>Repository 應做為 app 特定資料的單一可靠資料來源。使用<u>網路資源(networked resource)</u>和<u>離線快取(offline cache)</u>等多個資料來源時，repository 能夠盡可能地確保 app 資料正確無誤且為最新狀態，即使 app 處於離線狀態，也能提供最佳體驗。</p>
<h4 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h4><p><a href="https://www.techtarget.com/searchstorage/definition/cache">快取(cache)</a>是指 <u>app 所使用的資料儲存空間</u>。舉例來說，使用者網路連線中斷時，您可能會想要暫時儲存網路的資料。即使已無法使用網路，app 仍可借助快取資料。快取也可以為不再顯示於畫面上的 activity 儲存暫存資料，甚至儲存 app 啟動期間的持續性資料(persisting data)。</p>
<p>快取(cache)可以採用多種形式，有些較為簡單、有些較為複雜，視特定工作而定。以下表格說明在 Android 中實作<u>網路快取(network caching)</u>的方法。</p>
<table>
<thead>
<tr>
<th align="left">快取技術</th>
<th align="left">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://square.github.io/retrofit/">Retrofit</a> 是一個 networking library，用於實作 Android 適用的 type-safe REST client。您可以設定 Retrofit 在本機儲存所有網路結果的副本。</td>
<td align="left">對於簡單的 <u>requests 和 responses</u>、<u>網路呼叫(network calls)頻率不高</u>或<u>小型資料集(small datasets)</u>來說，這是不錯的解決方式。</td>
</tr>
<tr>
<td align="left">您可以使用 <a href="https://developer.android.com/topic/libraries/architecture/datastore?gclid=CjwKCAiAo4OQBhBBEiwA5KWu_ycTffFKG5WREVR823MtLnXULsZ7GMJJ-mlFljeziSYPCx2jQdmIIBoCd5AQAvD_BwE&gclsrc=aw.ds">DataStore</a> 儲存 key-value 組合。</td>
<td align="left">如果 key 很少且 value 較為簡單 (例如 app 設定)，這是不錯的解決方式。您<u>無法使用這項技術儲存大量結構化資料(structured data)</u>。</td>
</tr>
<tr>
<td align="left">您可以<a href="https://developer.android.com/training/data-storage/app-specific">存取 app 的內部儲存空間目錄</a>，並將資料檔案儲存在其中。app 的 package name 會指定 app 的<u>內部儲存空間目錄(internal storage directory)</u>，這個目錄位於 Android 檔案系統中的特殊位置。目錄僅供您的 app 使用，而且會在 app 解除安裝後清除。</td>
<td align="left">如果有檔案系統可以解決的特定需求 (例如您需要儲存媒體檔案或資料檔案，且必須自行管理檔案時)，這是不錯的解決方案。您<u>無法使用這項技術儲存 app 所需查詢的複雜結構化資料(structured data)</u>。</td>
</tr>
<tr>
<td align="left">您可以使用 <a href="https://developer.android.com/training/data-storage/room">Room</a> 快取資料(cache data)。Room 是一個 SQLite object-mapping library，可提供以 SQLite 為基礎的抽象層(abstraction layer)。</td>
<td align="left"><u>對於複雜的結構化可查詢資料，這是建議的解決方式</u>，因為在裝置的檔案系統中<u>儲存<b>結構化資料(structured data)</b>的最佳方式就是儲存在 <b>local SQLite database</b></u>。</td>
</tr>
</tbody></table>
<p>在這個程式碼研究室中，您將使用 <code>Room</code>，因為這是在裝置的檔案系統中<u>儲存<b>結構化資料(structured data)</b>的建議方式</u>。DevBytes app 已設定為使用 <code>Room</code>。您的工作是<u>使用 <strong>repository pattern</strong> 實作<b>離線快取(offline caching)</b></u>，<u>將<b>資料層(data layer)</b>與 <b>UI code</b> 分開</u>。</p>
<hr>
<h3 id="實作-VideoRepository"><a href="#實作-VideoRepository" class="headerlink" title="實作 VideoRepository"></a>實作 VideoRepository</h3><h4 id="工作：建立-repository"><a href="#工作：建立-repository" class="headerlink" title="工作：建立 repository"></a>工作：建立 repository</h4><p>在這項工作中，您會建立 <strong>repository</strong> 來<u>管理在上一個工作中已實作的<b>離線快取(offline caching)</b></u>。<strong>Room database</strong> <u>沒有管理<b>離線快取(offline caching)</b>的邏輯</u>，其中只有 insert、update、delete 及 retrieve 資料的方法。<strong>Repository</strong> 將<u>使用邏輯擷取<b>網路結果(network results)</b></u>，並<u>讓 database 保持在最新狀態</u>。</p>
<h5 id="步驟-1：新增-repository"><a href="#步驟-1：新增-repository" class="headerlink" title="步驟 1：新增 repository"></a>步驟 1：新增 repository</h5><p>在 <code>repository/VideosRepository.kt</code> 建立 <code>VideosRepository</code> class。傳入 <code>VideosDatabase</code> object 做為 class 的 constructor，以<u>存取 DAO 方法</u>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VideosRepository</span>(<span class="keyword">private</span> <span class="keyword">val</span> database: VideosDatabase) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>VideosRepository</code> class 中，新增名為 <code>refreshVideos()</code> 的 <code>suspend</code> 方法，這個方法沒有引數，且不會 return 任何內容。這個方法是用於<u>重新整理離線快取的 API</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshVideos</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>注意：</strong>Android 中的 database 會儲存在檔案系統或磁碟中。如要儲存，這類 database 必須執行<u>磁碟(disk) I&#x2F;O 作業</u>。<b>Disk I&#x2F;O</b> 或讀取和寫入磁碟(disk)的速度緩慢，而且在操作完成之前會一律封鎖目前的 thread。因此，您必須在 <a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html">I&#x2F;O dispatcher</a>中執行 <b>disk I&#x2F;O</b>。這個 dispatcher 可用於<u>使用 <b><a href="https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html">withContext</a>(Dispatchers.IO) { … }</b>，將封鎖的 I&#x2F;O 工作卸載至<b>共用執行緒集區(shared pool of threads)</b></u>。</p>
          </div>

<ol start="3">
<li>在 <code>refreshVideos()</code> 方法中，將 coroutine context 切換為 <code>Dispatchers.IO</code>，以執行<u>網路(network)和 database 作業</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshVideos</span><span class="params">()</span></span> &#123;</span><br><span class="line">   withContext(Dispatchers.IO) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>withContext</code> 區塊內，使用 <code>Retrofit</code> service instance <code>DevByteNetwork</code> 從網路擷取 <code>DevByte</code> video playlist。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> playlist = DevByteNetwork.devbytes.getPlaylist()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>refreshVideos()</code> 方法中，從網路擷取 playlist 後，將 <u>playlist</u> 儲存在 <u>Room database</u> 中。如要儲存 playlist，請使用 <code>VideosDatabase</code> class。呼叫 <code>insertAll()</code> DAO 方法，傳入從網路擷取的 playlist。使用 <code>asDatabaseModel()</code> extension function，將 playlist 對應到 database object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">database.videoDao.insertAll(playlist.asDatabaseModel())</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>以下是完整的 <code>refreshVideos()</code> 方法，其中包含追蹤何時該方法會被呼叫的 <strong>log statement</strong>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshVideos</span><span class="params">()</span></span> &#123;</span><br><span class="line">   withContext(Dispatchers.IO) &#123;</span><br><span class="line">       <span class="keyword">val</span> playlist = DevByteNetwork.devbytes.getPlaylist()</span><br><span class="line">       database.videoDao.insertAll(playlist.asDatabaseModel())</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="步驟-2：從-database-擷取資料"><a href="#步驟-2：從-database-擷取資料" class="headerlink" title="步驟 2：從 database 擷取資料"></a>步驟 2：從 database 擷取資料</h5><p>在這個步驟中，您會<u>建立 <b><code>LiveData</code> object</b></u>，以<u>從 <strong>database</strong> 中讀取 <strong>video playlist</strong></u>。在 database 更新時，這個 <code>LiveData</code> object 會自動更新。附加的 fragment 或 activity 會使用新的 value 重新整理。</p>
<div class="note success">
            <p><strong>注意：</strong>為求簡單，<b>LiveData</b> 會保留在這個範例中。一般來說，建議將 <a href="https://kotlinlang.org/docs/flow.html">Flow</a> 與 repositories 搭配使用，因為這種函式與生命週期無關。</p>
          </div>

<ol>
<li>在 <code>VideosRepository</code> class 中，宣告名為 <code>videos</code> 的 <code>LiveData</code> object 以存放 <code>DevByteVideo</code> object list。使用 <code>database.videoDao</code> 初始化 <code>videos</code> object。呼叫 <code>getVideos()</code> DAO 方法。由於 <code>getVideos()</code> 方法會 return <strong>database object list</strong>，而不是 <code>DevByteVideo</code> object list，因此 Android Studio 會 throw「類型不符(type mismatch)」的錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> videos: LiveData&lt;List&lt;DevByteVideo&gt;&gt; = database.videoDao.getVideos()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如要修正錯誤，請使用 <code>Transformations.map</code> 將 database object list 轉換成使用 <code>asDomainModel()</code> conversion function 的 domain object list。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> videos: LiveData&lt;List&lt;DevByteVideo&gt;&gt; = Transformations.map(database.videoDao.getVideos()) &#123;</span><br><span class="line">   it.asDomainModel()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在您已為 app 實作 repository。在下一個工作中，您將使用簡單的重新整理策略，以確保 local database 保持在最新狀態。</p>
<div class="note success">
            <p><strong>溫故知新：</strong><b>Transformations.map()</b> 方法會使用 conversion function，將一個 <b>LiveData</b> object 轉換成另一個 <b>LiveData</b> object。只有在 active activity 和 fragment 觀察(observing)到 return 的 <b>LiveData</b> 屬性時，系統才會計算轉換(transformations)。</p>
          </div>

<hr>
<h3 id="在-DevByteViewModel-中使用-VideoRepository"><a href="#在-DevByteViewModel-中使用-VideoRepository" class="headerlink" title="在 DevByteViewModel 中使用 VideoRepository"></a>在 DevByteViewModel 中使用 VideoRepository</h3><h4 id="工作：使用-refresh-策略整合-repository"><a href="#工作：使用-refresh-策略整合-repository" class="headerlink" title="工作：使用 refresh 策略整合 repository"></a>工作：使用 refresh 策略整合 repository</h4><p>在這項工作中，您會使用簡單的<b>重新整理(refresh)策略</b><u>將 repository 與 <code>ViewModel</code> 整合</u>。還會顯示 Room database 的 video playlist，而不是直接從網路擷取。</p>
<p>Database 重新整理是更新或重新整理 local database 的過程，讓 database 與網路中的資料保持同步。在這個範例 app 中，您將使用簡單的重新整理策略，其中<u>向 <strong>repository</strong> 要求資料(requests data)的模組(module)會負責重新整理(refresh)<b>本機資料(local data)</b></u>。</p>
<p>在實際 app 中，這類策略可能會更複雜。例如，程式碼可能會自動在背景重新整理資料 (將頻寬納入考量)，或快取使用者接下來最有可能使用的資料。</p>
<ol>
<li>在 <code>viewmodels/DevByteViewModel.kt</code> 的 <code>DevByteViewModel</code> class 內，建立名為 <code>videosRepository</code> 且 type 為 <code>VideosRepository</code> 的 private member 變數。透過傳遞<b>單例模式(singleton)</b> <code>VideosDatabase</code> object 將變數執行<u>實例化(instantiate)</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> videosRepository = VideosRepository(getDatabase(application))</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>DevByteViewModel</code> class 中，將 <code>refreshDataFromNetwork()</code> 方法替換為 <code>refreshDataFromRepository()</code> 方法。舊方法 <code>refreshDataFromNetwork()</code> 使用 Retrofit library 從網路擷取 <u>video playlist</u>。新方法則會從 <strong>repository</strong> 載入 <u>video playlist</u>。Repository 會決定要從哪個來源 (例如 network、database 等) 擷取 playlist，而不需在 view model 中包含實作的詳細資料(details)。Repository 也可以使程式碼更容易維護；即使日後要變更取得資料的實作方式，也不需要修改 view model。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">refreshDataFromRepository</span><span class="params">()</span></span> &#123;</span><br><span class="line">   viewModelScope.launch &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           videosRepository.refreshVideos()</span><br><span class="line">           _eventNetworkError.value = <span class="literal">false</span></span><br><span class="line">           _isNetworkErrorShown.value = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">       &#125; <span class="keyword">catch</span> (networkError: IOException) &#123;</span><br><span class="line">           <span class="comment">// Show a Toast error message and hide the progress bar.</span></span><br><span class="line">           <span class="keyword">if</span>(playlist.value.isNullOrEmpty())</span><br><span class="line">               _eventNetworkError.value = <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>DevByteViewModel</code> class 的 <code>init</code> 區塊中，將函式呼叫從 <code>refreshDataFromNetwork()</code> 變更為 <code>refreshDataFromRepository()</code>。這個程式碼可從 repository 擷取 video playlist，而不是直接從網路擷取。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">   refreshDataFromRepository()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>DevByteViewModel</code> class 中，刪除 <code>_playlist</code> 屬性及其幕後(backing)屬性 <code>playlist</code>。</li>
</ol>
<p>要刪除的程式碼</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _playlist = MutableLiveData&lt;List&lt;Video&gt;&gt;()</span><br><span class="line">...</span><br><span class="line"><span class="keyword">val</span> playlist: LiveData&lt;List&lt;Video&gt;&gt;</span><br><span class="line">   <span class="keyword">get</span>() = _playlist</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>DevByteViewModel</code> class 中，將 <code>videosRepository</code> object 執行實例化(instantiating)之後，新增一個名為 <code>playlist</code> 的新 <code>val</code>，來保存 repository 中的 <code>LiveData</code> video list。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> playlist = videosRepository.videos</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行 app。 App 會照常運作，但系統現在會從網路擷取 DevBytes playlist，並儲存至 Room database。螢幕上顯示的 playlist 是取自 Room database，而非直接取自網路。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-repository-pattern/img/30ee74d946a2f6ca_1920.png?hl=zh-tw">

<ol start="7">
<li><p>只要在模擬器或裝置上啟用飛航模式，就可以看出這項差異。</p>
</li>
<li><p>再次執行 app。請注意，app 不會顯示「Network Error」的 toast 訊息，而會顯示從<u>離線快取(offline cache)</u>中擷取的 playlist。</p>
</li>
<li><p>在模擬器或裝置上關閉飛航模式。</p>
</li>
<li><p>關閉再重新開啟 app。<u><b>網路要求(network request)</b>在<b>背景(background)</b>執行時</u>，<u>app 會從<b>離線快取(offline cache)</b>載入 <strong>playlist</strong></u>。</p>
</li>
</ol>
<p>如果有來自網路的新資料，螢幕會自動更新以顯示新資料。不過，DevBytes server 不會重新整理其內容，因此您不會看到資料正在更新。</p>
<div class="note success">
            <p><strong>提示：</strong>如要移除測試用的快取(cache)，最簡單的方法是解除安裝 app。</p>
          </div>

<p>真厲害！在這個程式碼研究室中，您<u>將 offline cache 與 <code>ViewModel</code> 整合，以顯示來自 repository 的 playlist</u>，而不是從網路(network)擷取的 playlist。</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><a href="https://www.techtarget.com/searchstorage/definition/cache">快取(Caching)</a>是將從<b>網路(network)</b>擷取的資料儲存到<b>裝置儲存空間(storage)</b>的過程。快取(Caching)可讓 app 在裝置離線，或 app 必須重新存取相同資料時，得以存取資料。</li>
<li>如要讓 app 在裝置的檔案系統中儲存<u>結構化資料(structured data)</u>，最好的做法是使用 <b>local SQLite database</b>。<strong>Room</strong> 是 <strong>SQLite object-mapping library</strong>，意味著其提供了以 SQLite 為基礎的抽象層(abstraction layer)。<u>使用 Room 是實作離線快取(offline caching)的建議最佳做法</u>。</li>
<li><strong>Repository class</strong> 可以將<b>資料來源(data sources)</b>，例如 <u>Room database</u> 和 <u>web service</u>s，與 app 的其他部分隔離。<strong>Repository class</strong> 提供<u>簡潔的 API</u>，方便存取 app 其餘部分的資料。</li>
<li>對於程式碼分隔(separation)和架構(architecture)，使用 <strong>repositories</strong> 是建議的最佳做法。</li>
<li>設計離線快取(offline cache)時，最佳做法是將 app 的網路(network)、網域(domain)和 database objects 做出區隔。這項策略是<a href="https://en.wikipedia.org/wiki/Separation_of_concerns">區隔疑慮(separation of concerns)</a>的例子之一。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>RecyclerView</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Room</tag>
        <tag>DAO</tag>
        <tag>Flow</tag>
        <tag>Cache</tag>
        <tag>Repository</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(41)-使用Room讀取和更新data</title>
    <url>/2023/12/22/Android%E7%AD%86%E8%A8%98-41-%E4%BD%BF%E7%94%A8Room%E8%AE%80%E5%8F%96%E5%92%8C%E6%9B%B4%E6%96%B0data/</url>
    <content><![CDATA[<blockquote>
<p>在本程式碼研究室中，您要為 Inventory app 新增更多功能，並學習如何使用 <code>Room</code> <u>讀取、顯示、更新及刪除</u> <strong>SQLite database</strong> 中的 data。使用 <code>RecyclerView</code> 顯示 database 中的 data，並在 database 中的<b>基礎資料(underlying data)</b>發生變更時<u>自動更新 data</u>。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何<u>讀取及顯示</u> SQLite database 中的 <strong>entities</strong>。</li>
<li>如何使用 <code>Room</code> library <u>更新和刪除</u> SQLite database 中的 <strong>entities</strong>。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="Starter-app-overview"><a href="#Starter-app-overview" class="headerlink" title="Starter app overview"></a>Starter app overview</h3><p>本程式碼研究室會使用先前程式碼研究室的 Inventory app solution code，做為範例程式碼。範例 app 已使用 <code>Room</code> persistence library 儲存 data。使用者可以透過「Add Item」畫面，將 data 新增至 app database。</p>
<p>注意：目前版本的範例 app 不會顯示 database 中儲存的日期(date)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/771c6a677ecd96c7_1920.png?hl=zh-tw">

<p>在本程式碼研究室中，您將擴充 app，使其<u>使用 <code>Room</code> library 讀取及顯示 database 中的 data</u>，以及<u>更新及刪除 database 中的 <strong>entities</strong></u>。</p>
<h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>這個範例程式碼與先前程式碼研究室的 solution code 相同。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-inventory-app/tree/room">https://github.com/google-developer-training/android-basics-kotlin-inventory-app/tree/room</a><br><strong>分支名稱：</strong><b>room</b></p>
          </div>

<hr>
<h3 id="新增-RecyclerView"><a href="#新增-RecyclerView" class="headerlink" title="新增 RecyclerView"></a>新增 RecyclerView</h3><p>在這項工作中，您要在 app 中新增 <code>RecyclerView</code>，以顯示 database 中儲存的 data。</p>
<h4 id="新增-helper-function-以-format-price"><a href="#新增-helper-function-以-format-price" class="headerlink" title="新增 helper function 以 format price"></a>新增 helper function 以 format price</h4><p>以下是最終 app 的螢幕截圖。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/d6e7b7b9f12e7a16_1920.png?hl=zh-tw" width="40%">

<p>請注意，price 會以<u>貨幣格式(currency format)</u>顯示。如要將 <u>double value</u>轉換成所需的<u>貨幣格式(currency format)</u>，請在 <code>Item</code> class 中加入 <strong>extension function</strong>。</p>
<h5 id="Extension-Functions"><a href="#Extension-Functions" class="headerlink" title="Extension Functions"></a>Extension Functions</h5><p>Kotlin 能夠<u>使用新功能<b>擴充(extend)</b> class</u>，無需沿用 class 或修改 class 的現有定義。這表示您可以將 functions 加入現有 class，而無需存取其原始碼。方法是透過名為<a href="https://kotlinlang.org/docs/extensions.html">擴充功能</a>的特殊宣告來執行。</p>
<p>舉例來說，您可以<u>在無法修改的<b>第三方 library</b> 中，為某個 <strong>class</strong> 編寫新的 <strong>functions</strong></u>。這類 functions 可以照常呼叫，就像是原始 class 的方法一樣。這些 functions 稱為 <strong>extension function</strong>。(您也可以使用 <b>extension properties(擴充屬性)</b>為現有 class 定義新屬性)。</p>
<p><strong>Extension function</strong> 實際上<u>不會修改 class</u>，但可以讓您<u>在呼叫該 <strong>class objects</strong> 的 <strong>function</strong> 時</u>使用<b>點號標記法( <code>.</code> )</b>。</p>
<p>例如，在下列程式碼中，有一個名為 <code>Square</code> 的 class。此 class 內會有<u>正方形四邊的屬性 <code>side</code></u>，以及<u>計算正方形面積的 function <code>area()</code></u>。請注意，<u><code>Square.perimeter()</code> <strong>extension function</strong> 的 <b>function name 開頭</b>是其使用的 <strong>class</strong></u>。在 function 中，您<u>可以引用 <code>Square</code> class 的 public 屬性( <code>side</code> )</u>。</p>
<p>查看 <code>main()</code> function 中的 extension function 使用方式。建立的 extension function <code>perimeter()</code> 會在該 <code>Square</code> class 中做為一般 function 呼叫。</p>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Square</span>(<span class="keyword">val</span> side: <span class="built_in">Double</span>)&#123;</span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">area</span><span class="params">()</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> side * side;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Extension function to calculate the perimeter of the square</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Square.<span class="title">perimeter</span><span class="params">()</span></span>: <span class="built_in">Double</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span> * side;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Usage</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span>&#123;</span><br><span class="line">      <span class="keyword">val</span> square = Square(<span class="number">5.5</span>);</span><br><span class="line">      <span class="keyword">val</span> perimeterValue = square.perimeter()</span><br><span class="line">      println(<span class="string">&quot;Perimeter: <span class="variable">$perimeterValue</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">val</span> areaValue = square.area()</span><br><span class="line">      println(<span class="string">&quot;Area: <span class="variable">$areaValue</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個步驟中，您要將 <strong>item price</strong> 轉換為<u>貨幣格式(currency format) string</u>。一般而言，建議您<u>不要只是為了設定 data 格式而去變更代表 data 的 <strong>entity class</strong></u> (請參見<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">單一責任原則</a>)，您可改為新增 <strong>extension function</strong>。</p>
<ol>
<li>在 <code>Item.kt</code> 的 class 定義下方，新增名為 <code>Item.getFormattedPrice()</code> 的 extension function，該 function 不使用參數並且會 return <code>String</code>。請注意 function 名稱中的 <strong>class name</strong> 和<b>點號( <code>.</code> )標記</b>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> Item.<span class="title">getFormattedPrice</span><span class="params">()</span></span>: String =</span><br><span class="line">   NumberFormat.getCurrencyInstance().format(itemPrice)</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>java.text.NumberFormat</code>。</li>
</ul>
<p>或者：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 新增 Item 的 extension function</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> Item.<span class="title">getFormatPrice</span><span class="params">()</span></span>:String &#123;</span><br><span class="line">    <span class="comment">// 將 item price 轉換為貨幣格式(currency format) string</span></span><br><span class="line">    <span class="keyword">return</span> NumberFormat.getCurrencyInstance().format(itemPrice)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增-ListAdapter"><a href="#新增-ListAdapter" class="headerlink" title="新增 ListAdapter"></a>新增 ListAdapter</h4><p>在這個步驟中，您要在 <code>RecyclerView</code> 中新增 <strong>list adapter</strong>。鑒於您熟悉了之前程式碼研究室中有關實作 adapter 的內容，操作說明匯總如下。為了方便起見，這個步驟最後提供了完整的 <code>ItemListAdapter</code> 檔案，可協助您瞭解程式碼研究室中的 <code>Room</code> 概念。</p>
<ol>
<li>在 <code>com.example.inventory</code> package 中，新增名為 <code>ItemListAdapter</code> 的 Kotlin class。傳入名為 <code>onItemClicked()</code> 的 function 做為 constructor 參數，並將 <code>Item</code> object 做為參數使用。</li>
<li>變更 <code>ItemListAdapter</code> class signature 來繼承(extend) <code>ListAdapter</code>。傳入 <code>Item</code> 和 <code>ItemListAdapter.ItemViewHolder</code> 做為參數。</li>
<li>新增 constructor 參數 <code>DiffCallback</code>；<code>ListAdapter</code> 會使用這項參數來<u>偵測 list 中的變更內容</u>。</li>
<li>覆寫必要的方法 <code>onCreateViewHolder()</code> 和 <code>onBindViewHolder()</code>。</li>
<li><code>onCreateViewHolder()</code> 方法會在 <code>RecyclerView</code> 需要時 return 新的 <code>ViewHolder</code>。</li>
<li>在 <code>onCreateViewHolder()</code> 方法中，建立一個新的 <code>View</code>，並&gt;使用自動產生的 binding class <code>ItemListItemBinding</code> 從 <code>item_list_item.xml</code> layout 檔案加載它。</li>
<li>實作 <code>onBindViewHolder()</code> 方法。使用 <code>getItem()</code> 方法取得 <strong>current item</strong>，並傳遞 <strong>position</strong>。</li>
<li>在 <code>itemView</code> 上設定 <strong>click listener</strong>，在 listener 中呼叫 function <code>onItemClicked()</code>。</li>
<li>定義 <code>ItemViewHolder</code> class，並從 <code>RecyclerView.ViewHolder</code> 繼承該 class。覆寫 <code>bind()</code> function，並傳入 <code>Item</code> object。</li>
<li>定義 <strong>companion object</strong>。在 companion object 中，定義 type 為 <code>DiffUtil.ItemCallback&lt;Item&gt;()</code> 且名稱為 <code>DiffCallback</code> 的 <code>val</code>。覆寫必要的方法 <code>areItemsTheSame()</code> 和 <code>areContentsTheSame()</code>，然後加以定義。</li>
</ol>
<p>完成的 class 應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.inventory</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.DiffUtil</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.ListAdapter</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.example.inventory.<span class="keyword">data</span>.Item</span><br><span class="line"><span class="keyword">import</span> com.example.inventory.<span class="keyword">data</span>.getFormattedPrice</span><br><span class="line"><span class="keyword">import</span> com.example.inventory.databinding.ItemListItemBinding</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* [ListAdapter] implementation for the recyclerview.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItemListAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> onItemClicked: (Item) -&gt; <span class="built_in">Unit</span>) :</span><br><span class="line">   ListAdapter&lt;Item, ItemListAdapter.ItemViewHolder&gt;(DiffCallback) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ItemViewHolder &#123;</span><br><span class="line">       <span class="keyword">return</span> ItemViewHolder(</span><br><span class="line">           ItemListItemBinding.inflate(</span><br><span class="line">               LayoutInflater.from(</span><br><span class="line">                   parent.context</span><br><span class="line">               )</span><br><span class="line">           )</span><br><span class="line">       )</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ItemViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">       <span class="keyword">val</span> current = getItem(position)</span><br><span class="line">       holder.itemView.setOnClickListener &#123;</span><br><span class="line">           onItemClicked(current)</span><br><span class="line">       &#125;</span><br><span class="line">       holder.bind(current)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(<span class="keyword">private</span> <span class="keyword">var</span> binding: ItemListItemBinding) :</span><br><span class="line">       RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">val</span> DiffCallback = <span class="keyword">object</span> : DiffUtil.ItemCallback&lt;Item&gt;() &#123;</span><br><span class="line">           <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Item</span>, newItem: <span class="type">Item</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> oldItem === newItem</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">Item</span>, newItem: <span class="type">Item</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">               <span class="keyword">return</span> oldItem.itemName == newItem.itemName</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>在 <code>ItemViewHolder</code> class 中實作 <code>bind()</code>  function。將 <code>itemName</code> TextView bind 至 <code>item.itemName</code>。使用 <code>getFormattedPrice()</code> extension function 以貨幣格式(currency format)取得 price，並將其 bind 至 <code>itemPrice</code> TextView。將 <code>quantityInStock</code> 值轉換為 <code>String</code>，並將其 bind 至 <code>itemQuantity</code> TextView。已完成的方法應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       itemName.text = item.itemName</span><br><span class="line">       itemPrice.text = item.getFormattedPrice()</span><br><span class="line">       itemQuantity.text = item.quantityInStock.toString()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>com.example.inventory.data.getFormattedPrice</code>。</li>
</ul>
<p>從完成的 app 查看 inventory list 畫面。請注意，每個 list element 都會顯示 inventory item 的 <u>name</u>、<u>以貨幣格式(currency format)顯示的 price</u>，以及 <u>current stock</u>。在先前的步驟中，您使用了 <code>item_list_item.xml</code> layout 檔案和三個 <code>TextView</code> 來建立 rows。在下一個步驟中，您要將 entity 的詳細資料(details) bind 至這些 <code>TextView</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/9c416f2fbf1e5ae2_1920.png?hl=zh-tw" width="40%">

<h4 id="使用-ListAdapter"><a href="#使用-ListAdapter" class="headerlink" title="使用 ListAdapter"></a>使用 ListAdapter</h4><p>在這項工作中，您要更新 <code>InventoryViewModel</code> 和 <code>ItemListFragment</code>，以便使用您在上一個步驟中建立的 <strong>list adapter</strong>，在畫面中顯示 item 詳細資料(details)。</p>
<ol>
<li>在 <code>InventoryViewModel</code> class 的開頭，針對 <u>database 中的 item</u>，建立一個名為 <code>allItems</code> 且 type 為 <code>LiveData&lt;List&lt;Item&gt;&gt;</code> 的 <code>val</code>。如果出現錯誤，別擔心，您將很快進行修正。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> allItems: LiveData&lt;List&lt;Item&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.lifecycle.LiveData</code>。</li>
</ul>
<ol start="2">
<li>在 <code>itemDao</code> 上呼叫 <code>getItems()</code>，並指派給 <code>allItems</code>。<code>getItems()</code> function 會 return <code>Flow</code>。如要以 <code>LiveData</code> 值的形式使用 data，請使用 <code>asLiveData()</code> function。已完成的定義應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> allItems: LiveData&lt;List&lt;Item&gt;&gt; = itemDao.getItems().asLiveData()</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.lifecycle.asLiveData</code>。</li>
</ul>
<ol start="3">
<li>在 <code>ItemListFragment</code> 中，請於 class 開頭宣告一個 type 為 <code>InventoryViewModel</code> 的 <code>private</code> 不可變屬性 <code>viewModel</code>。使用 <code>by</code> 委派，將屬性初始化作業傳送至 <code>activityViewModels</code> class。傳入 <code>InventoryViewModelFactory</code> constructor。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: InventoryViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   InventoryViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> InventoryApplication).database.itemDao()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.fragment.app.activityViewModels</code>。</li>
</ul>
<ol start="4">
<li><p>同樣在 <code>ItemListFragment</code> 中，捲動至 function <code>onViewCreated()</code>。在 <code>super.onViewCreated()</code> 呼叫下方，宣告名為 <code>adapter</code> 的 <code>val</code>。使用預設 constructor 初始化新的 <code>adapter</code> 屬性，<code>ItemListAdapter&#123;&#125;</code> 不會傳入任何內容。</p>
</li>
<li><p>將新建立的 <code>adapter</code>  bind 至 <code>recyclerView</code>，如下所示：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">&#125;</span><br><span class="line">binding.recyclerView.adapter = adapter</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>設定 adapter 後，仍位於 <code>onViewCreated()</code> 內。在 <code>allItems</code> 上附加 <strong>observer</strong>，<u>監聽 data 變更</u>。</p>
</li>
<li><p>在 observer 內，對 <code>adapter</code> 呼叫 <code>submitList()</code>，並傳遞新的 list。此操作會使用 list 中的新 item 更新 <code>RecyclerView</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.allItems.observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; items -&gt;</span><br><span class="line">   items.let &#123;</span><br><span class="line">       adapter.submitList(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>確認已完成的 <code>onViewCreated()</code> 方法如下所示。執行 app。請注意，如果您將 item 儲存在 app database 中，則系統會顯示 inventory list。如果 list 為 empty，請新增部分 inventory items 至 app database。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">      &#125;</span><br><span class="line">   binding.recyclerView.adapter = adapter</span><br><span class="line">   viewModel.allItems.observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; items -&gt;</span><br><span class="line">       items.let &#123;</span><br><span class="line">           adapter.submitList(it)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   binding.recyclerView.layoutManager = LinearLayoutManager(<span class="keyword">this</span>.context)</span><br><span class="line">   binding.floatingActionButton.setOnClickListener &#123;</span><br><span class="line">       <span class="keyword">val</span> action = ItemListFragmentDirections.actionItemListFragmentToAddItemFragment(</span><br><span class="line">           getString(R.string.add_fragment_title)</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">this</span>.findNavController().navigate(action)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/9c416f2fbf1e5ae2_1920.png?hl=zh-tw" width="40%">

<hr>
<h3 id="顯示-item-details"><a href="#顯示-item-details" class="headerlink" title="顯示 item details"></a>顯示 item details</h3><p>在這項工作中，您將在「Item Details」畫面中讀取並顯示 <strong>entity details</strong>。您要使用 <strong>primary key</strong> (也就是 <u>item <code>id</code></u>) 來從 inventory app <strong>database</strong> 中讀取 <strong>details</strong> (例如 <u>name、price 和 quantity</u>)，並使用 <code>fragment_item_detail.xml</code> layout 檔案將這些 details 顯示在「Item Details」畫面上。我們已預先為您設計好 layout 檔案 (<code>fragment_item_detail.xml</code>)，當中包含三個用來顯示 item details 的 <code>TextView</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/d699618f5d9437df_1920.png?hl=zh-tw" width="80%">

<p>在這項工作中，您將執行下列步驟：</p>
<ul>
<li>在 <code>RecyclerView</code> 中新增 <strong>click handler</strong>，將 app 移至「Item Details」畫面。</li>
<li>在 <code>ItemListFragment</code> fragment 中，從 <strong>database</strong> 擷取並顯示 data。</li>
<li>將 <code>TextView</code> bind 至 <code>ViewModel</code> data。</li>
</ul>
<h4 id="新增-click-handler"><a href="#新增-click-handler" class="headerlink" title="新增 click handler"></a>新增 click handler</h4><ol>
<li>在 <code>ItemListFragment</code> 中，捲動至 <code>onViewCreated()</code> function，即可更新 adapter 定義。</li>
<li>將 <code>lambda</code> 新增為 <code>ItemListAdapter&#123;&#125;</code> 的 constructor 參數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>lambda</code> 中，建立名為 <code>action</code> 的 <code>val</code>。您很快便要修正初始化錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">    <span class="keyword">val</span> action</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>對 <code>ItemListFragmentDirections</code> 呼叫 <code>actionItemListFragmentToItemDetailFragment()</code> 方法，傳入 item <code>id</code>。將 return 的 <code>NavDirections</code> object 指派給 <code>action</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">   <span class="keyword">val</span> action =  ItemListFragmentDirections.actionItemListFragmentToItemDetailFragment(it.id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>action</code> 定義下方，使用 <code>this.findNavController()</code> 擷取 <code>NavController</code> instance，然後對其呼叫 <code>navigate()</code>，傳入 <code>action</code>。Adapter 的定義如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemListAdapter &#123;</span><br><span class="line">   <span class="keyword">val</span> action =   ItemListFragmentDirections.actionItemListFragmentToItemDetailFragment(it.id)</span><br><span class="line">   <span class="keyword">this</span>.findNavController().navigate(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行 app。在 <code>RecyclerView</code> 中按一下某個 item。App 將轉至「Item Details」畫面。請注意，details 為空白(blank)。輕觸 buttons，系統沒有回應。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/196553111ee69beb_1920.png?hl=zh-tw" width="40%">

<p>在接下來的步驟中，您要在「Item Details」畫面中顯示 entity details，並為「Sell」和「Delete」button 新增功能。</p>
<h4 id="擷取-item-details"><a href="#擷取-item-details" class="headerlink" title="擷取 item details"></a>擷取 item details</h4><p>在這個步驟中，您將在 <code>InventoryViewModel</code> 中新增 function，以根據 <u>item <code>id</code></u> 從 <strong>database</strong> 中擷取 <u><strong>item details</strong></u>。在下一個步驟中，您將使用此 function 在「Item Details」畫面中顯示 <strong>entity details</strong>。</p>
<ol>
<li>在 <code>InventoryViewModel</code> 中，新增名為 <code>retrieveItem()</code> 的 function，該 function 會以 <code>Int</code> 做為 item <code>id</code>，並 return <code>LiveData&lt;Item&gt;</code>。您很快便要修正 return 運算式錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">retrieveItem</span><span class="params">(id: <span class="type">Int</span>)</span></span>: LiveData&lt;Item&gt; &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在新 function 中，對 <code>itemDao</code> 呼叫 <code>getItem()</code>，並傳入參數 <code>id</code>。<code>getItem()</code> function 會 return <code>Flow</code>。如要將 <code>Flow</code> value 做為 <code>LiveData</code> 使用，請呼叫 <code>asLiveData()</code> function，並將此 function 做為 <code>retrieveItem()</code> function 的 return。已完成的 function 應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">retrieveItem</span><span class="params">(id: <span class="type">Int</span>)</span></span>: LiveData&lt;Item&gt; &#123;</span><br><span class="line">   <span class="keyword">return</span> itemDao.getItem(id).asLiveData()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="將-data-bind-至-TextView"><a href="#將-data-bind-至-TextView" class="headerlink" title="將 data bind 至 TextView"></a>將 data bind 至 TextView</h4><p>在這個步驟中，您將在 <code>ItemDetailFragment</code> 中<u>建立 <code>ViewModel</code> instance</u>，並將 <u><code>ViewModel</code> data</u> bind 至「Item Details」畫面中的 <u><code>TextView</code></u>。您還要將 <strong>observer</strong> 附加至 <u><code>ViewModel</code> 中的 data</u>，以便在 database 中的基礎 data 有所變更時，隨時<u>更新畫面上的 <strong>inventory list</strong></u>。</p>
<ol>
<li>在 <code>ItemDetailFragment</code> 中，新增 type <code>Item</code> entity 的 <code>item</code> 可變動屬性( <code>var</code> )。這個屬性可用來<u>儲存單一 entity 的相關資訊</u>。這個屬性稍後會初始化，請在前面加上 <code>lateinit</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> item: Item</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>com.example.inventory.data.Item</code></li>
</ul>
<ol start="2">
<li>請於 class <code>ItemDetailFragment</code> 開頭宣告一個 type 為 <code>InventoryViewModel</code> 的 <code>private</code> 不可變屬性 <code>viewModel</code>。使用 <code>by</code> 委派，將屬性初始化作業傳送至 <code>activityViewModels</code> class。傳入 <code>InventoryViewModelFactory</code> constructor。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: InventoryViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   InventoryViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> InventoryApplication).database.itemDao()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.fragment.app.activityViewModels</code>。</li>
</ul>
<ol start="3">
<li>同樣在 <code>ItemDetailFragment</code> 中，建立名為 <code>bind()</code> 的 <code>private</code> function，該 function 會採用 <code>Item</code> entity 的 instance 做為參數，並且不會 return 任何內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>實作 <code>bind()</code> function，這與您在 <code>ItemListAdapter</code> 中所進行的操作類似。將 <code>itemName</code> TextView 的 <code>text</code> 屬性設為 <code>item.itemName</code>。對 <code>item</code> 屬性呼叫 <code>getFormattedPrice()</code>，以設定 price value 的格式(format)，然後將其設為 <code>itemPrice</code> TextView 的 <code>text</code> 屬性。將 <code>quantityInStock</code> 轉換為 <code>String</code>，並將其設為 <code>itemQuantity</code> TextView 的 <code>text</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.itemName.text = item.itemName</span><br><span class="line">   binding.itemPrice.text = item.getFormattedPrice()</span><br><span class="line">   binding.itemCount.text = item.quantityInStock.toString()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>更新 <code>bind()</code> function，以對程式碼區塊使用 <code>apply&#123;&#125;</code> scope function，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       itemName.text = item.itemName</span><br><span class="line">       itemPrice.text = item.getFormattedPrice()</span><br><span class="line">       itemCount.text = item.quantityInStock.toString()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>還是在 <code>ItemDetailFragment</code> 中，覆寫 <code>onViewCreated()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在之前某個步驟中，您已從 <code>ItemListFragment</code> 將 item <code>id</code> 做為 navigation 引數傳遞至 <code>ItemDetailFragment</code> 在 <code>onViewCreated()</code> 中的 <b>super</b> function 呼叫下方，建立名為 <code>id</code> 的不可變變數( <code>val</code> )。擷取 navigation 引數並將其指派給這個新的變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> id = navigationArgs.itemId</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>接著，請使用這個 <code>id</code> 變數來擷取 <strong>item details</strong>。同樣在 <code>onViewCreated()</code> 中，對傳入 <code>id</code> 的 <code>viewModel</code> 呼叫 <code>retrieveItem()</code> function。將 observer 附加至傳入 <code>viewLifecycleOwner</code> 和 <code>lambda</code> 的 return value。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.retrieveItem(id).observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在 <code>lambda</code> 中，傳入 <code>selectedItem</code> 做為參數，其中包含擷取自 database 的 <code>Item</code> entity。在 <code>lambda</code> function 內文中，將 <code>selectedItem</code> value 指派給 <code>item</code>。呼叫傳入 <code>item</code> 的 <code>bind()</code> function。已完成的 function 應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">   <span class="keyword">val</span> id = navigationArgs.itemId</span><br><span class="line">   viewModel.retrieveItem(id).observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; selectedItem -&gt;</span><br><span class="line">       item = selectedItem</span><br><span class="line">       bind(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>執行 app。按一下「Inventory」畫面上的任何 list 元素，系統會隨即顯示「Item Details」畫面。請注意，現在畫面不再為空白(blank)，而是顯示擷取自 inventory database 的 entity details。</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:40%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/9c416f2fbf1e5ae2_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/ac6529b8cc0801ac_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div>
</div>

<ol start="11">
<li>依序輕觸「Sell」button、「Delete」button 和 FAB button。沒有回應！接下來的工作中，您將實作這些 button 的功能。</li>
</ol>
<hr>
<h3 id="實作-sell-item"><a href="#實作-sell-item" class="headerlink" title="實作 sell item"></a>實作 sell item</h3><p>在這項工作中，您要擴充 app 功能，並<u>實作 <strong>sell</strong> 功能</u>。</p>
<p>以下是這個步驟的詳細操作說明：</p>
<ul>
<li>在 <code>ViewModel</code> 中新增函式以<u>更新 entity</u>。</li>
<li>建立一個新方法，用於<u>減少數量</u>，同時<u>更新 app database 中的 entity</u>。</li>
<li>將 <strong>click listener</strong> 附加到 Sell button。</li>
<li>如果數量為 <code>0</code>，請停用 Sell button。</li>
</ul>
<ol>
<li>在 <code>InventoryViewModel</code> 中，新增名為 <code>updateItem()</code> 的 private 函式，該函式會使用 entity class <code>Item</code> 的 instance 且不會 return 任何內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>實作新方法：<code>updateItem()</code>。如要從 <code>ItemDao</code> class 呼叫 <code>update()</code> <strong>suspend</strong> 方法，請使用 <code>viewModelScope</code> 啟動 <strong>coroutine</strong>。在 launch 區塊中，對傳入 <code>item</code> 的 <code>itemDao</code> 呼叫 <code>update()</code> 函式。已完成的方法應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   viewModelScope.launch &#123;</span><br><span class="line">       itemDao.update(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>InventoryViewModel</code> 中，新增其他名為 <code>sellItem()</code> 的方法，該方法會使用 <code>Item</code> entity class 的 instance，且不會 return 任何內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sellItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>sellItem()</code> 函式中，新增 <code>if</code> 條件來檢查 <code>item.quantityInStock</code> 是否大於 <code>0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sellItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (item.quantityInStock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>if</code> 區塊內，您需要使用 <strong>data class</strong> 的 <a href="https://kotlinlang.org/docs/data-classes.html#copying"><code>copy()</code></a> 函式來<u>更新 entity</u>。</p>
<h5 id="Data-class：copy"><a href="#Data-class：copy" class="headerlink" title="Data class：copy()"></a>Data class：copy()</h5><p>根據預設，系統會向 data class 的所有 <strong>instance</strong> 提供 <a href="https://kotlinlang.org/docs/data-classes.html#copying"><code>copy()</code></a> 函式。此函式可用於<u>複製物件來變更其部分屬性</u>，但保留其餘屬性。</p>
<p>舉例來說，考慮如下所示的 <code>User</code> class 及其 instance <code>jack</code>。如要建立新的 instance 且僅更新 <code>age</code> 屬性，則實作方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Data class</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> name: String = <span class="string">&quot;&quot;</span>, <span class="keyword">val</span> age: <span class="built_in">Int</span> = <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Data class instance</span></span><br><span class="line"><span class="keyword">val</span> jack = User(name = <span class="string">&quot;Jack&quot;</span>, age = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// A new instance is created with its age property changed, rest of the properties unchanged.</span></span><br><span class="line"><span class="keyword">val</span> olderJack = jack.copy(age = <span class="number">2</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>返回 <code>InventoryViewModel</code> 中的 <code>sellItem()</code> 函式。在 <code>if</code> 區塊中，建立名為 <code>newItem</code> 的新不可變屬性( <code>val</code> )。在傳入更新的 <code>quantityInStock</code> 的 <code>item</code> instance 上呼叫 <code>copy()</code> 函式，藉此減少 <code>1</code> 庫存。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> newItem = item.copy(quantityInStock = item.quantityInStock - <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>newItem</code> 定義下方，呼叫傳入新的更新 entity (即 <code>newItem</code>) 的 <code>updateItem()</code> 函式。已完成的方法應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sellItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (item.quantityInStock &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       <span class="comment">// Decrease the quantity by 1</span></span><br><span class="line">       <span class="keyword">val</span> newItem = item.copy(quantityInStock = item.quantityInStock - <span class="number">1</span>)</span><br><span class="line">       updateItem(newItem)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>如要新增<u>銷售庫存(selling stock)</u>功能，請前往 <code>ItemDetailFragment</code>。捲動至 <code>bind()</code> 函式的結尾。在 <code>apply</code> 區塊內，為 Sell button 設定 <strong>click listener</strong>，並在 <code>viewModel</code> 上呼叫 <code>sellItem()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">binding.apply &#123;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">    sellItem.setOnClickListener &#123; viewModel.sellItem(item) &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>執行 app。在「Inventory」畫面中，按一下數量大於 <code>0</code> 的 list 元素。系統隨即顯示「Item Details」畫面。輕觸 Sell button。請注意數量值會減少一個單位。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/aa63ca761dc8f009_1920.png?hl=zh-tw" width="80%">

<ol start="9">
<li>在「Item Details」畫面上，連續輕觸 Sell button 即可將數量設為 <code>0</code>。數量設為 <code>0</code> 後，輕觸 Sell button。不會出現明顯的變更。這是因為函式 <code>sellItem()</code> 會先檢查數量是否大於 <code>0</code>，然後再更新數量。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/3e099d3c55596938_1920.png?hl=zh-tw" width="40%">

<ol start="10">
<li>如要為使用者提供更符合需求的意見回饋，建議您在沒有 item 可銷售時停用 Sell button。在 <code>InventoryViewModel</code> 中，新增函式，檢查數量是否大於 <code>0</code>。將函式命名為 <code>isStockAvailable()</code>，該函式使用 <code>Item</code> instance 並傳回 <code>Boolean</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isStockAvailable</span><span class="params">(item: <span class="type">Item</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> (item.quantityInStock &gt; <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>前往 <code>ItemDetailFragment</code>，捲動至 <code>bind()</code> 函式。在 apply 區塊中，在傳入 <code>item</code> 的 <code>viewModel</code> 上呼叫 <code>isStockAvailable()</code> 函式。請將 return 的 value 設為 Sell button 的 <code>isEnabled</code> 屬性。程式碼應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       ...</span><br><span class="line">       sellItem.isEnabled = viewModel.isStockAvailable(item)</span><br><span class="line">       sellItem.setOnClickListener &#123; viewModel.sellItem(item) &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>執行 app，請注意，當庫存數量為 <code>0</code> 時，系統將停用 Sell button。恭喜您在 app 中實作了 sell item 功能。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/5e49db8451e77c2b_1920.png?hl=zh-tw" width="40%">

<h4 id="Delete-item-entity"><a href="#Delete-item-entity" class="headerlink" title="Delete item entity"></a>Delete item entity</h4><p>與上一項工作一樣，您將實作刪除(delete)功能，進一步擴充 app 的功能。</p>
<p>以下是這個步驟的詳細操作說明：</p>
<ul>
<li>在 <code>ViewModel</code> 中新增函式，以<u>從 database 中刪除 entity</u>。</li>
<li>在 <code>ItemDetailFragment</code> 中新增方法，以呼叫新的 delete 函式並處理 navigation。</li>
<li>將 <strong>click listener</strong> 附加到 Delete button。</li>
</ul>
<ol>
<li>在 <code>InventoryViewModel</code> 中，新增名為 <code>deleteItem()</code> 的函式，該函式會使用名為 <code>item</code> 的 <code>Item</code> entity class 的 instance，但不會 return 任何內容。在 <code>deleteItem()</code> 函式中，使用 <code>viewModelScope</code> 啟動 coroutine。在 <code>launch</code> 區塊內，對傳入 <code>item</code> 的 <code>itemDao</code> 呼叫 <code>delete()</code> 方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">deleteItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   viewModelScope.launch &#123;</span><br><span class="line">       itemDao.delete(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>ItemDetailFragment</code> 中，捲動至 <code>deleteItem()</code> 函式的開頭。對 <code>viewModel</code> 呼叫 <code>deleteItem()</code>，並傳入 <code>item</code>。<code>item</code> instance 會包含目前顯示在「Item Details」畫面上的 entity。已完成的方法應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">deleteItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">   viewModel.deleteItem(item)</span><br><span class="line">   findNavController().navigateUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>ItemDetailFragment</code> 中，捲動至 <code>showConfirmationDialog()</code> 函式。這個函式會在範例程式碼中提供給您。這個方法會顯示 alert dialog，以便在刪除 item 前取得使用者的確認，並在使用者輕觸 <b>positive button</b> 時呼叫 <code>deleteItem()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showConfirmationDialog</span><span class="params">()</span></span> &#123;</span><br><span class="line">        MaterialAlertDialogBuilder(requireContext())</span><br><span class="line">            ...</span><br><span class="line">            .setPositiveButton(getString(R.string.yes)) &#123; _, _ -&gt;</span><br><span class="line">                deleteItem()</span><br><span class="line">            &#125;</span><br><span class="line">            .show()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p><code>showConfirmationDialog()</code> 函式會顯示 alert dialog，如下所示：<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/728bfcbb997c8017_1920.png?hl=zh-tw" width="50%"></p>
<ol start="4">
<li>在 <code>ItemDetailFragment</code> 中，請在 <code>bind()</code> 函式結尾的 <code>apply</code> 區塊內，將設定 Delete button 的 click listener。呼叫 click listener <code>lambda</code> 中的 <code>showConfirmationDialog()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       ...</span><br><span class="line">       deleteItem.setOnClickListener &#123; showConfirmationDialog() &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行 app！在「Inventory」list 畫面中選取 list 元素，然後在「Item Details」畫面中輕觸「Delete」button。輕觸「Yes」，app 將返回「Inventory」畫面。請注意，已刪除的 entity 已不在 app database 中。恭喜您實作了 delete 功能。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/c05318ab8c216fa1_1920.png?hl=zh-tw">

<h4 id="Edit-item-entity"><a href="#Edit-item-entity" class="headerlink" title="Edit item entity"></a>Edit item entity</h4><p>與先前的工作類似，在這項工作中，您要在 app 中新增另一項功能，實作 <u>edit item entity</u>。</p>
<p>以下為編輯 app database 中 entity 的步驟：</p>
<ul>
<li>將 <strong>fragment title</strong> 更新為「Edit Item」，藉此重複使用「Add Item」畫面。</li>
<li>將 <strong>click listener</strong> 新增至 FAB button，前往「Edit Item」畫面。</li>
<li>為 <code>TextView</code> 填入 <u>entity details</u>。</li>
<li>使用 <code>Room</code> 更新 database 中的 entity。</li>
</ul>
<h5 id="將-click-listener-新增至-FAB-button"><a href="#將-click-listener-新增至-FAB-button" class="headerlink" title="將 click listener 新增至 FAB button"></a>將 click listener 新增至 FAB button</h5><p>在 <code>ItemDetailFragment</code> 中，新增名為 <code>editItem()</code> 的 <code>private</code> 函式，該函式不採用任何參數，且不會 return 任何內容。在下一個步驟中，請將畫面標題更新為「Edit Item」，這樣就能重複使用 <code>fragment_add_item.xml</code>。為實作此操作，您需要傳送 <u>fragment title string</u> 以及 <u>item id</u>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">editItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>更新 fragment title 後，「Edit Item」畫面應顯示如下。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/bcd407af7c515a21_1920.png?hl=zh-tw" width="40%"></p>
<ol start="2">
<li>在 <code>editItem()</code> 函式中，建立名為 <code>action</code> 的不可變變數( <code>val</code> )。對傳入 title string  <code>edit_fragment_title</code> 和 item <code>id</code> 的 <code>ItemDetailFragmentDirections</code> 呼叫 <code>actionItemDetailFragmentToAddItemFragment()</code>。將 return 的 value 指派給 <code>action</code>。在 <code>action</code> 定義下方，呼叫 <code>this.findNavController().navigate()</code> 並傳入 <code>action</code>，前往「Edit Item」畫面。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">editItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> action = ItemDetailFragmentDirections.actionItemDetailFragmentToAddItemFragment(</span><br><span class="line">       getString(R.string.edit_fragment_title),</span><br><span class="line">       item.id</span><br><span class="line">   )</span><br><span class="line">   <span class="keyword">this</span>.findNavController().navigate(action)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>還是在 <code>ItemDetailFragment</code> 中，捲動至 <code>bind()</code> 函式。在 <code>apply</code> 區塊內，為 FAB button 設定 <strong>click listener</strong>，以及從 <code>lambda</code> 呼叫 <code>editItem()</code> 函式，以便前往「Edit Item」畫面。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       ...</span><br><span class="line">       editItem.setOnClickListener &#123; editItem() &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行 app。前往「Item Details」畫面。按一下 FAB button。請注意，螢幕 title 已更新為「Edit Item」，但所有 <strong>text fields</strong> 均為<u>空白(empty)</u>。在下一個步驟中，您將修正這個問題。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/a6a6583171b68230_1920.png?hl=zh-tw" width="80%">

<h5 id="填入-TextView"><a href="#填入-TextView" class="headerlink" title="填入 TextView"></a>填入 TextView</h5><p>在這個步驟中，您要在「Edit Item」螢幕的 <strong>text fields</strong> 中填入 <strong>entity details</strong>。由於我們使用的是 <code>Add Item</code> 螢幕，因此您要在 Kotlin 檔案 <code>AddItemFragment.kt</code> 中新增函式。</p>
<ol>
<li>在 <code>AddItemFragment</code> 中，新增 <code>private</code> 函式，<u>將 <strong>text fields</strong> 與 <strong>entity details</strong> bind 在一起</u>。為函式 <code>bind()</code> 命名，該函式會使用商品 entity class 的 instance，且不會 return 任何內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>bind()</code> 函式的實作方式與先前在 <code>ItemDetailFragment</code> 中的實作類似。在 <code>bind()</code> 函式中，使用 <code>format()</code> 函式將 price 四捨五入至小數點後兩位，並指派給名為 <code>price</code> 的 <code>val</code>，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> price = <span class="string">&quot;%.2f&quot;</span>.format(item.itemPrice)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>price</code> 定義下方，針對 <code>binding</code> 屬性使用 <code>apply</code> scope function，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.apply &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>apply</code> scope function 程式碼區塊內，將 <code>item.itemName</code> 設為 <code>itemName</code> 的 <code>text</code> 屬性。使用 <code>setText()</code> 函式，並傳入 <code>item.itemName</code> string 和 <code>TextView.BufferType.SPANNABLE</code> 做為 <code>BufferType</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.apply &#123;</span><br><span class="line">   itemName.setText(item.itemName, TextView.BufferType.SPANNABLE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>類似於上述步驟，設定 price <code>EditText</code> 的 <code>text</code> 屬性，如下所示。如要設定 <code>EditEdit</code> 數量的 <code>text</code> 屬性，請記得將 <code>item.quantityInStock</code> 轉換為 <code>String</code>。您完成的函式應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> price = <span class="string">&quot;%.2f&quot;</span>.format(item.itemPrice)</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       itemName.setText(item.itemName, TextView.BufferType.SPANNABLE)</span><br><span class="line">       itemPrice.setText(price, TextView.BufferType.SPANNABLE)</span><br><span class="line">       itemCount.setText(item.quantityInStock.toString(), TextView.BufferType.SPANNABLE)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>AddItemFragment</code> 中，捲動至 <code>onViewCreated()</code> 函式。在呼叫 super class 函式之後。建立名為 <code>id</code> 的 <code>val</code>，並從 navigation 引數擷取 <code>itemId</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> id = navigationArgs.itemId</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>新增帶有條件的 <code>if-else</code> 區塊，以檢查 <code>id</code> 是否大於零，並將 Save button 的 <strong>click listener</strong> 移至 <code>else</code> 區塊。在 <code>if</code> 區塊內，使用 <code>id</code> 擷取 entity，然後在其中新增 observer。在 observer 內部，更新 <code>item</code> 屬性並呼叫傳入 <code>item</code> 的 <code>bind()</code>。系統會提供完整函式供您複製貼上。這個函式簡單易懂，您可以自行研究。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">   <span class="keyword">val</span> id = navigationArgs.itemId</span><br><span class="line">   <span class="keyword">if</span> (id &gt; <span class="number">0</span>) &#123;</span><br><span class="line">       viewModel.retrieveItem(id).observe(<span class="keyword">this</span>.viewLifecycleOwner) &#123; selectedItem -&gt;</span><br><span class="line">           item = selectedItem</span><br><span class="line">           bind(item)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       binding.saveAction.setOnClickListener &#123;</span><br><span class="line">           addNewItem()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>執行 app，前往「Item Details」，然後輕觸「+」這個 FAB button。請注意，這些欄位會填入 item details。編輯 stock quantity 或任何其他欄位，然後輕觸 Save button。沒有回應！這是因為您<u>並未更新 app database 中的 entity</u>。您很快就會解決這個問題。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/829ceb9dd7993215_1920.png?hl=zh-tw" width="80%">

<h5 id="使用-Room-更新-entity"><a href="#使用-Room-更新-entity" class="headerlink" title="使用 Room 更新 entity"></a>使用 Room 更新 entity</h5><p>在最後一項工作中，新增最後一段程式碼來實作更新功能。您要在 <code>ViewModel</code> 中定義必要的函式，並在 <code>AddItemFragment</code> 中使用它們。</p>
<ol>
<li>在 <code>InventoryViewModel</code> 中，新增名為 <code>getUpdatedItemEntry()</code> 的 <code>private</code> 函式，該函式使用 <code>Int</code>，以及 entity details 三個名為 <code>itemName</code>、<code>itemPrice</code> 和 <code>itemCount</code> 的 string。Return 函式的 <code>Item</code> instance。程式碼僅供參考。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUpdatedItemEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   itemId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemPrice: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemCount: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Item &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>getUpdatedItemEntry()</code> 函式中，使用函式參數建立 item instance，如下所示。Return 函式的 <code>Item</code> instance。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getUpdatedItemEntry</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   itemId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemPrice: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemCount: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: Item &#123;</span><br><span class="line">   <span class="keyword">return</span> Item(</span><br><span class="line">       id = itemId,</span><br><span class="line">       itemName = itemName,</span><br><span class="line">       itemPrice = itemPrice.toDouble(),</span><br><span class="line">       quantityInStock = itemCount.toInt()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同樣在 <code>InventoryViewModel</code> 中，新增其他名為 <code>updateItem()</code> 的函式。此函式也會使用 <code>Int</code> 和 entity details 的三個 strung，且不會 return 任何內容。使用以下程式碼片段中的變數名稱。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   itemId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemPrice: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemCount: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>updateItem()</code> 函式中，呼叫傳入 entity 資訊的 <code>getUpdatedItemEntry()</code> 函式，該函式會以函式參數的形式傳遞，如下所示。將 return 的 value 指派給名為 <code>updatedItem</code> 的不可變變數( <code>val</code> )。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> updatedItem = getUpdatedItemEntry(itemId, itemName, itemPrice, itemCount)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>getUpdatedItemEntry()</code> 函式呼叫的正下方，呼叫傳入 <code>val</code> <code>updatedItem</code> 的 <code>updateItem(item: Item)</code> 函式。已完成的函式如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   itemId: <span class="type">Int</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemName: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemPrice: <span class="type">String</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   itemCount: <span class="type">String</span></span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span> &#123;</span><br><span class="line">   <span class="comment">// 呼叫 getUpdatedItemEntry()，取得 Item object</span></span><br><span class="line">   <span class="keyword">val</span> updatedItem = getUpdatedItemEntry(itemId, itemName, itemPrice, itemCount)</span><br><span class="line">   <span class="comment">// 將 Item object 傳入 updateItem(item: Item) 以更新 database</span></span><br><span class="line">   updateItem(updatedItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>返回 <code>AddItemFragment</code>，新增名為 <code>updateItem()</code> 的 private 函式，該函式不含任何參數，且不會 return 任何內容。在函式中，新增 <code>if</code> 條件，以透過呼叫函式 <code>isEntryValid()</code> 來驗證使用者輸入內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (isEntryValid()) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 <code>if</code> 區塊中，呼叫傳遞 entity details 的 <code>viewModel.updateItem()</code>。請使用 navigation 引數中的 <code>itemId</code>，以及 <code>EditText</code> 中的其他 entity details，例如 name、price 和 quantity，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.updateItem(</span><br><span class="line">    <span class="keyword">this</span>.navigationArgs.itemId,</span><br><span class="line">    <span class="keyword">this</span>.binding.itemName.text.toString(),</span><br><span class="line">    <span class="keyword">this</span>.binding.itemPrice.text.toString(),</span><br><span class="line">    <span class="keyword">this</span>.binding.itemCount.text.toString()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>updateItem()</code> 函式呼叫下方，定義名為 <code>action</code> 的 <code>val</code>。對 <code>AddItemFragmentDirections</code> 呼叫 <code>actionAddItemFragmentToItemListFragment()</code>，並將 return 的 value 指派給 <code>action</code>。請瀏覽(navigate)至 <code>ItemListFragment</code>，並呼叫傳入 <code>action</code> 的 <code>findNavController().navigate()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (isEntryValid()) &#123;</span><br><span class="line">       viewModel.updateItem(</span><br><span class="line">           <span class="keyword">this</span>.navigationArgs.itemId,</span><br><span class="line">           <span class="keyword">this</span>.binding.itemName.text.toString(),</span><br><span class="line">           <span class="keyword">this</span>.binding.itemPrice.text.toString(),</span><br><span class="line">           <span class="keyword">this</span>.binding.itemCount.text.toString()</span><br><span class="line">       )</span><br><span class="line">       <span class="keyword">val</span> action = AddItemFragmentDirections.actionAddItemFragmentToItemListFragment()</span><br><span class="line">       findNavController().navigate(action)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>還是在 <code>AddItemFragment</code> 中，捲動至 <code>bind()</code> 函式。在 <code>binding.apply</code> scope functino 區塊中，為 Save button 設定 <strong>click listener</strong>。呼叫 <code>lambda</code> 中的 <code>updateItem()</code> 函式，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   binding.apply &#123;</span><br><span class="line">       ...</span><br><span class="line">       saveAction.setOnClickListener &#123; updateItem() &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;   </span><br></pre></td></tr></table></figure>

<ol start="10">
<li>執行 app！嘗試編輯 inventory items；您應該可以編輯 inventory app database 中的任何 item。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-update-data-room/img/1bbd094a77c25fc4_1920.png?hl=zh-tw">

<h4 id="App-執行結果"><a href="#App-執行結果" class="headerlink" title="App 執行結果"></a>App 執行結果</h4><p>完成的 app 如下：</p>
<div style="position:relative; overflow:hidden; width:100%; padding-top:75%;">
    <iframe src="https://streamable.com/e/40ijw0" frameborder="0" width="100%" height="100%" allowfullscreen style="position:absolute; top:0; left:0; bottom:0; right:0; width:100%; height:100%;">
    </iframe>
</div>
<div style="clear:static;"></div>]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
        <tag>Navigation</tag>
        <tag>Fragment</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Coroutine</tag>
        <tag>suspend function</tag>
        <tag>ListAdapter</tag>
        <tag>SQL</tag>
        <tag>Room</tag>
        <tag>DAO</tag>
        <tag>Entity</tag>
        <tag>Flow</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(40)-使用Room儲存persist data</title>
    <url>/2023/12/20/Android%E7%AD%86%E8%A8%98-40-%E4%BD%BF%E7%94%A8Room%E5%84%B2%E5%AD%98persist-data/</url>
    <content><![CDATA[<blockquote>
<p>建構一個 inventory app，使用 <strong>Room</strong> 將庫存商品儲存至 <strong>SQLite database</strong>。</p>
</blockquote>
<ul>
<li>如何使用 <strong>Room library</strong> 建立 <strong>SQLite database</strong> 並與之互動。</li>
<li>如何建立 <u>entity</u>、<u>DAO</u> 和 <u>database classes</u>。</li>
<li>如何使用 <strong>data access object (DAO)</strong> 將 <u>Kotlin function</u> 對應至 <u>SQL 查詢(queries)</u>。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="Persist-data"><a href="#Persist-data" class="headerlink" title="Persist data"></a>Persist data</h3><p><u>大多數的 production quality apps 都有<b>需要儲存的 data</b>，即便使用者關閉 app 也不例外</u>。舉例來說，app 可能會儲存歌曲播放清單、待辦事項清單、支出和收入記錄、星座目錄或個人資料記錄。在大部分情況下，您可以使用 database 來儲存這些<u><b>持續性資料(persistent data)</b></u>。</p>
<p><a href="https://developer.android.com/training/data-storage/room?hl=zh-tw">Room</a> 是 <a href="https://developer.android.com/jetpack/?hl=zh-tw">Android Jetpack</a> 中的 persistence library。Room 是 <a href="https://developer.android.com/training/data-storage/sqlite?hl=zh-tw">SQLite</a>  database 頂端的<u>抽象層(abstraction layer)</u>。<strong>SQLite</strong> 使用 <u>specialized language (SQL)</u> 執行 database 作業。<strong>Room</strong> <u>不直接使用 <strong>SQLite</strong></u>，因此<u>簡化了設定 <strong>database</strong> 並與之互動的過程</u>。<strong>Room</strong> 也提供 <strong>SQLite statements</strong> 的<u>編譯時間(compile-time)檢查</u>。</p>
<p>下圖說明了 Room 如何配合本課程推薦的整體架構。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/7521165e051cc0d4_1920.png?hl=zh-tw" width="50%">

<hr>
<h3 id="App-overview"><a href="#App-overview" class="headerlink" title="App overview"></a>App overview</h3><p>在本程式碼研究室中，您將使用名為 <strong>Inventory app</strong> 的 starter app，並透過 <strong>Room</strong> library 將 <strong>database layer</strong> 加入其中。最終版本的 app 會使用 <code>RecyclerView</code> 顯示 <u>inventory database</u> 的<u>items list</u>。使用者可以選擇在 inventory database 中<u>新增(new) item</u>、<u>更新(update)其中的現有 item</u>，以及<u>刪除(delete)其中的 item</u> (您將於下一個程式碼研究室完成 app 功能)。</p>
<p>以下是最終版本 app 的螢幕截圖。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/439ad9a8183278c5_1920.png?hl=zh-tw">

<div class="note success">
            <p><strong>注意：</strong>以上螢幕截圖均來自課程最後的最終版本 app，而非本程式碼研究室最後的 app。此處提供這些螢幕截圖，以便您大概瞭解最終版本的 app。</p>
          </div>

<h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>如果您使用 GitHub 中的範例程式碼，請注意資料夾名稱是 <code>android-basics-kotlin-inventory-app-starter</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-inventory-app/tree/starter">https://github.com/google-developer-training/android-basics-kotlin-inventory-app/tree/starter</a><br><strong>分支名稱：</strong><b>starter</b></p>
          </div>

<h4 id="範例程式碼相關問題"><a href="#範例程式碼相關問題" class="headerlink" title="範例程式碼相關問題"></a>範例程式碼相關問題</h4><ol>
<li>在「Add Item」畫面中，<u>輸入 item 的詳細資料(details)</u>。輕觸「Save」(儲存)。目前，此 <u>add item fragment</u> 未關閉。使用系統 back 鍵返回。系統<u>不會儲存 new item，也不會將其列在 inventory 畫面中</u>。請注意，此 app 並不完整，且<u>未實作「Save」button 功能</u>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/f0931dab5089a14f_1920.png?hl=zh-tw" width="70%">

<p>在本程式碼研究室中，您將新增 app 的 <strong>database</strong> 部分，該部分會將 <b>inventory 詳細資料(details)</b>儲存至 <strong>SQLite database</strong>。您將使用 Room persistence library 與 SQLite database 互動。</p>
<h4 id="程式碼逐步操作說明"><a href="#程式碼逐步操作說明" class="headerlink" title="程式碼逐步操作說明"></a>程式碼逐步操作說明</h4><p>您下載的範例程式碼包含已為您預先設計的螢幕版面配置。在本課程中，您將重點瞭解<u>實作 database 邏輯</u>。以下是一些檔案的簡要逐步操作說明，協助您快速上手。</p>
<ol>
<li><p><code>main_activity.xml</code><br>App 中代管(hosts)所有其他 fragment 的 main activity。<code>onCreate()</code> method 會從 <code>NavHostFragment</code> 擷取 <code>NavController</code>，並設定與 <code>NavController</code> 搭配使用的 action bar。</p>
</li>
<li><p><code>item_list_fragment.xml</code><br>App 中顯示的第一個畫面。主要包含 <u><code>RecyclerView</code></u> 和<u>懸浮動作按鈕 (FAB)</u>。您會在稍後的課程中實作 <code>RecyclerView</code>。</p>
</li>
<li><p><code>fragment_add_item.xml</code><br>這個 layout 包含 <strong>text fields</strong>，用於<u>輸入要被 added 的 new inventory item 的詳細資料(details)</u>。</p>
</li>
<li><p><code>ItemListFragment.kt</code><br>這個 fragment 主要包含樣板程式碼。在 <code>onViewCreated()</code> method 中，<u>在 <strong>FAB</strong> 上設定 <strong>click listener</strong> 以導覽(navigate)至 <code>AddItemFragment</code></u></p>
</li>
<li><p><code>AddItemFragment.kt</code><br>這個 fragment 用於<u>向 database 加入 new items</u>。<code>onCreateView()</code> function 會<u>初始化<strong>binding variable</strong></u>，<code>onDestroyView()</code> function 則會<u>在 destroying fragment 前隱藏鍵盤(keyboard)</u>。</p>
</li>
</ol>
<hr>
<h3 id="★Room-的主要-components"><a href="#★Room-的主要-components" class="headerlink" title="★Room 的主要 components"></a>★Room 的主要 components</h3><p>Kotlin 可透過引入 <strong>data classes</strong>，輕鬆處理 data。<u>這些 data 可存取，並可透過 function 呼叫加以修改</u>。但在 database 中，您需要使用 <strong>tables</strong> 和 <strong>queries</strong> 來<u>存取及修改 data</u>。以下 Room components 能讓這些工作流程順暢運作。</p>
<p>Room 有三個主要 components：</p>
<ul>
<li><a href="https://developer.android.com/training/data-storage/room/defining-data?hl=zh-tw">Data entities</a>，代表 app database 中的 <strong>tables</strong>。它們可用於<u>更新 tables 中以 <strong>rows</strong> 形式儲存的 data</u>，也可用於<u>建立要插入(insertion)的 <strong>new rows</strong></u>。</li>
<li><a href="https://developer.android.com/training/data-storage/room/accessing-data?hl=zh-tw">Data access object (DAO)</a> 為 app 提供了各種 <strong>methods</strong>，用來<u>擷取(retrieve)、更新(update)、插入(insert)及刪除(delete) database 中的 data</u>。</li>
<li><a href="https://developer.android.com/reference/kotlin/androidx/room/Database">Database class</a><u>可存放 database</u>，是 app database 連線的<u>主要存取點(main access point)</u>。Database class 為您的 app <u>提供了與該 database 關聯的 <strong>DAO instances</strong></u>。</li>
</ul>
<p>您將在稍後的程式碼研究室中實作這些 components，並進一步瞭解它們。下圖演示了 Room 的各 components 如何一起工作以與 database 互動。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/33a193a68c9a8e0e_1920.png?hl=zh-tw" width="70%">

<h4 id="新增-Room-libraries"><a href="#新增-Room-libraries" class="headerlink" title="新增 Room libraries"></a>新增 Room libraries</h4><p>在這項工作中，您要將必要的 Room component libraries 加入 Gradle 檔案。</p>
<p>開啟 module level 的 Gradle 檔案 <code>build.gradle (Module: InventoryApp.app)</code>。在 <code>dependencies</code> 區塊中，為 Room library 新增下列 dependencies。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Room</span></span><br><span class="line">implementation <span class="string">&quot;androidx.room:room-runtime:$room_version&quot;</span></span><br><span class="line">kapt <span class="string">&quot;androidx.room:room-compiler:$room_version&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.room:room-ktx:$room_version&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>room_version</code> 可至 <a href="https://developer.android.com/jetpack/androidx/versions">AndroidX</a> 查詢最新版本。</li>
</ul>
<div class="note primary">
            <p><strong>重要：</strong>因使用了 kapt，需在 app-level <code>build.gradle</code> 檔案的 plugins 中新增 <code>id &#39;kotlin-kapt&#39;</code>。</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>

<hr>
<h3 id="建立-item-Entity"><a href="#建立-item-Entity" class="headerlink" title="建立 item Entity"></a>建立 item Entity</h3><p><strong>Entity class</strong> 定義了 <strong>table</strong>，<u>這個 class 的所有 <strong>instance</strong> 都代表了 database table 中的一個 <strong>row</strong></u>。Entity class 擁有<b>對應項目(mappings)</b>，可用來<u>向 Room 顯示它打算如何呈現 database 中的資訊並與之互動</u>。在 app 中，這個 entity 會<u>存放有關 <strong>inventory items</strong> 的資訊</u>，例如 <u>item name</u>、<u>item price</u> 和 <u>stock</u> 狀況。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/8c9f1659ee82ca43_1920.png?hl=zh-tw">

<p><code>@Entity</code> 註解會<u>將 class 標示為 <strong>database Entity class</strong></u>。系統會為每個 <strong>entity class</strong> 建立 <strong>database table</strong>，用於<u>存放 items</u>。在 entity 中，每個<u>欄位(field)</u>都會表示為 <u>database 中的一列 column</u>，除非另有說明。儲存在 database 中的所有 <strong>entity instance</strong> 都必須有<u>主鍵(primary key)</u>。<a href="https://developer.android.com/reference/androidx/room/PrimaryKey">Primary key</a> 用於唯一識別 database table 中的每個 record&#x2F;entry。Primary key 一經指派即無法修改，只要存在於 database 中，指的就是 <strong>entity object</strong>。</p>
<p>在這項工作中，您將建立 entity class。定義 field 以儲存每個 item 的下列 <u>inventory information</u>。</p>
<ul>
<li>用於儲存 primary key 的 <code>Int</code>。</li>
<li>用於儲存 item name 的 <code>String</code>。</li>
<li>用於儲存 item price 的 <code>Double</code>。</li>
<li>用於儲存 stock 數量的 <code>Int</code>。</li>
</ul>
<ol>
<li><p>在 Android Studio 中開啟範例程式碼。</p>
</li>
<li><p>在 <code>com.example.inventory</code> 基本 package 下方建立名為 <code>data</code> 的 package。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/be39b42484ba2664_1920.png" width="50%">
</li>
<li><p>在 <code>data</code> package 中，建立名為 <code>Item</code> 的 Kotlin class。這個 class 將代表 app 中的 <strong>database entity</strong>。在下一個步驟中，您將新增<b>對應欄位(fields)</b>來<u>儲存 inventory information</u>。</p>
</li>
<li><p>使用下列程式碼更新 <code>Item</code> class 定義。宣告 <code>Int</code> type 的 <code>id</code>、<code>String</code> type 的 <code>itemName</code>、<code>Double</code> type 的 <code>itemPrice</code>，以及 <code>Int</code> type 的 <code>quantityInStock</code> <u>做為 <strong>primary constructor</strong> 的參數</u>。將 <code>id</code> 的預設值設為 <code>0</code>。<code>id</code> 將成為 <strong>primary key</strong>，用來辨識 <code>Item</code> table 中每個 record&#x2F;entry 的 <strong>uniquely ID</strong>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">   <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">   <span class="keyword">val</span> itemName: String,</span><br><span class="line">   <span class="keyword">val</span> itemPrice: <span class="built_in">Double</span>,</span><br><span class="line">   <span class="keyword">val</span> quantityInStock: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>Refresher on primary constructor：</strong><b>Primary constructor</b> 是 Kotlin class 的 <u>class header</u> 的一部分；<u>出現在 <b>class name</b> (和 <u>optional type 參數</u>) 之後</u>。</p>
          </div>

<h4 id="Data-classes"><a href="#Data-classes" class="headerlink" title="Data classes"></a>Data classes</h4><p><strong>Data classes</strong> 主要用於<u>保存 Kotlin 中的 data</u>。這些 class 有標示 <code>data</code> keyword。Kotlin data class objects 有許多其他優勢，compiler 會自動產生<u>公用程式(utilities)</u>，用於comparing、printing 及 copying： <code>toString()</code>、<code>copy()</code>、<code>equals()</code> 等。</p>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Example data class with 2 properties.</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">User</span>(<span class="keyword">val</span> first_name: String, <span class="keyword">val</span> last_name: String)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>為了讓產生的程式碼保持一致且行為有意義，data classes 必須符合下列規定：</p>
<ul>
<li><strong>Primary constructor</strong> 必須有<u>至少一個參數</u>。</li>
<li>所有 <strong>primary constructor</strong> 參數都必須標示為 <code>val</code> 或 <code>var</code>。</li>
<li><strong>Data classes</strong> 不得為 <code>abstract</code>、<code>open</code>、<code>sealed</code> 或 <code>inner</code>。</li>
</ul>
<div class="note danger">
            <p><strong>警告：</strong><u><strong>Compiler</strong> 只會使用 <b>primary constructor</b> 內部定義的屬性，來自動產生 <b>functions</b></u>。產生的實作會排除在 class body 中宣告的屬性。</p>
          </div>
<ul>
<li>如要進一步瞭解 data classes，請參閱<a href="https://kotlinlang.org/docs/data-classes.html">說明文件</a>。</li>
</ul>
<ol start="5">
<li>在 <code>Item</code> class 的 class 定義前加上 <code>data</code> keyword，將其轉換為 data class。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">   <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">   <span class="keyword">val</span> itemName: String,</span><br><span class="line">   <span class="keyword">val</span> itemPrice: <span class="built_in">Double</span>,</span><br><span class="line">   <span class="keyword">val</span> quantityInStock: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>Item</code> class 宣告上方，為 data class 加上註解 <code>@Entity</code>。使用 <code>tableName</code> 引數提供 <code>item</code> 做為 <strong>SQLite table name</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;item&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">   ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>重要：</strong>當 Android Studio 顯示<u>提示(prompted)</u>時，請從 <strong>androidx library</strong> import <b>Entity</b> 和所有其他 <b>Room</b> 註解。例如，<b>androidx.room.Entity</b>。</p>
          </div>

<div class="note success">
            <p><strong>注意：</strong><b>@Entity</b> 註解有幾個可能的引數。<u>根據預設 (<b>@Entity</b> 沒有引數)，table name 將與 class 相同</u>。<b>tableName</b> 引數可讓您提供其他更為實用的 table name。雖然 <b>tableName</b> 引數是可選的(optional)，但我們強烈建議使用。為求簡單，請<u>提供與 <strong>class name</strong> 相同的名稱，也就是 <b>item</b></u>。您還可以在<a href="https://developer.android.com/reference/androidx/room/Entity">說明文件</a>中調查 <b>@Entity</b> 的其他幾個引數。</p>
          </div>

<ol start="7">
<li>要將 <code>id</code> 作為 primary key，請為 <code>id</code> 屬性加上註解 <code>@PrimaryKey</code>。<u>將 <code>autoGenerate</code> 參數設為 <code>true</code>，以便 <strong>Room</strong> 為每個 <strong>entity</strong> 產生 <strong>ID</strong></u>。這能保證<u>每個 item 的 ID 都不重複</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;item&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">   <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">   <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">   ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>為其餘屬性加上註解 <code>@ColumnInfo</code>。<code>ColumnInfo</code> 註解可用來<u>自訂與特定欄位(field)相關的 column</u>。舉例來說，使用 <code>name</code> 引數時，您可以<u>為欄位(field)指定不同的 <strong>column name</strong></u>。</li>
</ol>
<p><code>Item.kt</code> 完整程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data class entity</span></span><br><span class="line"><span class="comment">// 建立 item Entity</span></span><br><span class="line"><span class="meta">@Entity(tableName = <span class="string">&quot;item&quot;</span>)</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">    <span class="meta">@PrimaryKey(autoGenerate = true)</span> <span class="comment">// 將 id 設為 primary key</span></span><br><span class="line">    <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>, <span class="comment">// 將 id 的預設值設為 0</span></span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="string">&quot;name&quot;</span>)</span> <span class="comment">// 將 itemName 設為 column，name 設為 column name</span></span><br><span class="line">    <span class="keyword">val</span> itemName: String,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="string">&quot;price&quot;</span>)</span> <span class="comment">// 將 itemPrice 設為 column，price 設為 column name</span></span><br><span class="line">    <span class="keyword">val</span> itemPrice: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="meta">@ColumnInfo(name = <span class="string">&quot;quantity&quot;</span>)</span> <span class="comment">// 將 quantityInStock 設為 column，quantity 設為 column name</span></span><br><span class="line">    <span class="keyword">val</span> quantityInStock: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="建立-item-DAO"><a href="#建立-item-DAO" class="headerlink" title="建立 item DAO"></a>建立 item DAO</h3><h4 id="Data-Access-Object-DAO"><a href="#Data-Access-Object-DAO" class="headerlink" title="Data Access Object (DAO)"></a>Data Access Object (DAO)</h4><p>Data Access Object (DAO) 是一種<u>模式(pattern)</u>，可透過提供 <strong>abstract interface</strong>，從 app 的其餘部分中區隔出 <strong>persistence layer</strong>。這種隔離機制符合<a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">單一責任原則(single responsibility principle)</a>。</p>
<p>DAO 的功能是向 app 的其餘部分<u>隱藏在基礎 <strong>persistence layer</strong> 中執行 <strong>database</strong> 作業所涉及的所有復雜性</u>。這樣一來，就可以<u>變更 <strong>data access layer</strong>，而不受使用該 data 的程式碼影響</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/7a8480711f04b3ef_1920.png?hl=zh-tw">

<p>在這項工作中，您要為 Room 定義 <a href="https://developer.android.com/reference/androidx/room/Dao">Data Access Object (DAO)</a>。<strong>Data Access Object</strong> 是 Room 的<u>主要 components</u>，負責<u>定義存取 <strong>database</strong> 的 <strong>interface</strong></u>。</p>
<p><strong>DAO</strong> 是<u>自訂 interface</u>，該 interface 可提供便利的 <strong>methods</strong>，用於 <u><b>querying&#x2F;retrieving</b>、<b>inserting</b>、<b>deleting</b> 及 <b>updating</b> database</u>。Room 會在 compile time 產生這個 class 的實作。</p>
<p>針對常見的 database 作業，<strong>Room library</strong> 可提供便利的<b>註解</b>，例如 <code>@Insert</code>、<code>@Delete</code> 和 <code>@Update</code>。除此之外，您還可以使用 <code>@Query</code> 註解。您可以編寫受 <strong>SQLite</strong> 支援的任何查詢(query)。</p>
<p>另一個好處是，當您在 Android Studio 中編寫<u>查詢(queries)</u>時，<strong>Compiler</strong> 會<u>檢查 SQL 查詢是否有語法錯誤</u>。</p>
<p>對於 inventory app，您需要能夠執行以下操作：</p>
<ul>
<li><b>插入(Insert)</b>或新增(add) ，<u>new item</u>。</li>
<li><b>更新(Update)</b> 現有 item 的 <u>name</u>、<u>price</u> 和 <u>quantity</u>。</li>
<li>根據 <u>primary key</u> <code>id</code>，<b>取得(Get)</b><u>特定 item</u>。</li>
<li><b>取得(Get)</b><u>所有 items</u>，以便顯示它們。</li>
<li><b>刪除(Delete)</b> database 中的 <u>entry</u>。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/bb381857d5fba511_1920.png?hl=zh-tw" width="50%">

<p>接著在 app 中實作 item DAO：</p>
<ol>
<li>在 <code>data</code> package 中建立 Kotlin class <code>ItemDao.kt</code>。</li>
<li>將 class 定義變更為 <strong>interface</strong>，並加上註解 <code>@Dao</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ItemDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 interface body 中，新增 <code>@Insert</code> 註解。在 <code>@Insert</code> 下方，新增 <code>insert()</code> function，以<u>將 <code>Entity</code> class <code>item</code> 的 instance 做為引數</u>。<u>Database 作業執行時間可能較長，因此應該會在另一個 <strong>thread</strong> 中執行</u>。請<u>將 function 設為 <strong>suspend function</strong></u>，以便<u>從 <strong>coroutine</strong> 中呼叫</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增引數 <code>OnConflict</code>，並為其指派 <code>OnConflictStrategy.IGNORE</code> 的值。<code>OnConflict</code> 引數會<u>指示 <strong>Room</strong> 在發生衝突時應如何處理</u>。如果 new item 的 <strong>primary key</strong> 已存在於 database 中，則 <code>OnConflictStrategy.IGNORE</code> 策略<u>會忽略 <strong>new item</strong></u>。如要進一步瞭解可用的衝突策略，請參閱<a href="https://developer.android.com/reference/androidx/room/OnConflictStrategy">說明文件</a>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span> <span class="comment">// 發生衝突時會忽略 new item</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>Room</strong> 會<u>產生將 <code>item</code> insert database 所需的所有程式碼</u>。當從 Kotlin 程式碼呼叫 <code>insert()</code> 時，Room 會<u>執行 SQL 查詢(query)，將 <strong>entity</strong> insert 到 database 中</u>。</li>
</ul>
<ol start="5">
<li>為一個 <code>item</code> 新增帶有 <code>update()</code> function 的 <code>@Update</code> 註解。<u>更新的 entity 與傳入的 <strong>entity key</strong> 相同</u>。您可以更新 entity 的部分或全部其他屬性。類似於 <code>insert()</code> method，使以下 <code>update()</code> method <code>suspend</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Update</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>新增具有 <code>delete()</code> function 的 <code>@Delete</code> 註解以刪除 item。使其成為 <strong>suspend method</strong>。<code>@Delete</code> 註解會<u>刪除一個 item 或一個 item list</u>。(您需要傳遞要刪除的 <b>entity(s)</b>；若沒有 <strong>entity</strong>，則要在呼叫 <code>delete()</code> function 之前擷取 <strong>entity</strong>。)</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Delete</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br></pre></td></tr></table></figure>

<p>剩餘的 function 沒有方便的註解，因此您必須<u>使用 <code>@Query</code> 註解並提供 <strong>SQLite 查詢(queries)</strong></u>。</p>
<ul>
<li>編寫 <u>SQLite 查詢(query)</u>，根據指定的 <code>id</code> 從 <strong>item table</strong> 中<u>擷取特定 item</u>。接著，您要新增 <u>Room 註解</u>，並在後續步驟中使用修改後的下列 query。在後續步驟中，您還要透過 Room 將這項內容變更為 <strong>DAO method</strong>。</li>
<li>從 <code>item</code> 中選取所有 columns。</li>
<li><code>WHERE</code> <code>id</code> 符合特定值。</li>
</ul>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SELECT * from item WHERE id = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>變更上述 <u>SQL 查詢(query)</u>，使其與 <u>Room 註解</u>和<u>引數</u>搭配使用。新增 <code>@Query</code> 註解，將 query 以 string 參數的形式提供給 <code>@Query</code> 註解。將 <code>String</code> 參數新增至 <code>@Query</code>，這是一個 SQLite 查詢(query)，用於<u>從 <strong>item table</strong> 中擷取 item</u>。</li>
<li>從 <code>item</code> 中選取所有 columns。</li>
<li><code>WHERE</code> <code>id</code> &#x3D; <code>:id</code> 引數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * from item WHERE id = :id&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>筆記：</strong>請留意 <code>:id</code>。您可以<span class="label primary">在 <b>Query</b> 中使用<b>冒號</b>( <b>:</b> )來引用 <b>function</b> 中的<b>引數(argument)</b></span>。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * from item WHERE id = :引數&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(引數: <span class="type">Int</span>)</span></span>: Flow&lt;Item&gt;</span><br></pre></td></tr></table></figure>
          </div>

<ol start="10">
<li>在 <code>@Query</code> 註解下方，新增 <code>getItem()</code> function，這個 function 會採用 <code>Int</code> 引數並 return <code>Flow&lt;Item&gt;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * from item WHERE id = :id&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(id: <span class="type">Int</span>)</span></span>: Flow&lt;Item&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>kotlinx.coroutines.flow.Flow</code>。</li>
</ul>
<p>使用 <code>Flow</code> 或 <code>LiveData</code> 做為 return type，可確保當 database 中的 data 有變更時，您會收到通知。建議您在 persistence layer 中使用 <code>Flow</code>。<strong>Room</strong> 將隨時為您更新這個 <code>Flow</code>，因此您<u>只需要明確取得一次 data 即可</u>。這有助於<u>更新 <strong>inventory list</strong></u>，您將於下一個程式碼研究室中實作這部分內容。根據 <code>Flow</code> return type，<strong>Room</strong> 也會在 <strong>background thread</strong> 上執行查詢(query)。您<u>不需要將它明確設為 <code>suspend</code> function，並在 <strong>coroutine scope</strong> 內呼叫</u>。</p>
<ol start="11">
<li>新增具有 <code>getItems()</code> function 的 <code>@Query</code>：</li>
<li>讓 <strong>SQLite query</strong> return <u><code>item</code> table 中的所有 columns</u>，以 <strong>name</strong> <u>遞增順序</u>排序。</li>
<li>使 <code>getItems()</code> return <u><code>Item</code> entities list</u> (做為 <code>Flow</code>)。<strong>Room</strong> 將隨時為您更新這個 <code>Flow</code>，因此您只需要明確取得一次 data 即可。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * from item ORDER BY name ASC&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getItems</span><span class="params">()</span></span>: Flow&lt;List&lt;Item&gt;&gt;</span><br></pre></td></tr></table></figure>

<p><code>ItemDao.kt</code> 完整程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// data access object (DAO)</span></span><br><span class="line"><span class="comment">// 建立 item DAO</span></span><br><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ItemDao</span> &#123;</span><br><span class="line">    <span class="comment">// insert suspend function</span></span><br><span class="line">    <span class="meta">@Insert(onConflict = OnConflictStrategy.IGNORE)</span> <span class="comment">// 發生衝突時會忽略 new item</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">insert</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// update suspend function</span></span><br><span class="line">    <span class="meta">@Update</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">update</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete suspend function</span></span><br><span class="line">    <span class="meta">@Delete</span></span><br><span class="line">    <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">delete</span><span class="params">(item: <span class="type">Item</span>)</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 選取特定 item 的 所有 column</span></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * from item WHERE id = :id&quot;</span>)</span> <span class="comment">// :id 為 getItem 中的引數(id)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getItem</span><span class="params">(id: <span class="type">Int</span>)</span></span>: Flow&lt;Item&gt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 選取 item table 中的所有 columns，以 name 遞增順序排序</span></span><br><span class="line">    <span class="meta">@Query(<span class="string">&quot;SELECT * from item ORDER BY name ASC&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getItems</span><span class="params">()</span></span>: Flow&lt;List&lt;Item&gt;&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>雖然您看不到任何明顯的變更，但請執行 app，確定沒有任何錯誤。</li>
</ol>
<hr>
<h3 id="建立-database-class"><a href="#建立-database-class" class="headerlink" title="建立 database class"></a>建立 database class</h3><p>在這項工作中，您要建立 <a href="https://developer.android.com/reference/androidx/room/RoomDatabase">RoomDatabase</a>，並使用您在先前工作中建立的 <u><code>Entity</code></u> 和 <u><strong>DAO</strong></u>。<strong>Database class</strong> 定義了 <u>entities list</u> 和 <u>data access objects(DAO) list</u>。同時也是基礎連線(connection)的<u>主要存取點(main access point)</u>。</p>
<p><code>Database</code> class 為您的 app 提供了定義的 <strong>DAO instance</strong>。反過來，app 可以<u>使用 <strong>DAO</strong> 來擷取 database 中的 data</u>，做為<b>關聯(associated) data entity objects</b> 的 <strong>instance</strong>。App 也可以使用定義的 <strong>data entity</strong>，<u>更新對應 table 中的 rows</u>，或是<u>建立 new rows 來插入 data</u>。</p>
<p>您需要建立 <u>abstract <code>RoomDatabase</code> class</u>，並加上 <code>@Database</code> 註解。此 class 包含一個 <strong>method</strong>，可在 <code>RoomDatabase</code> 的 <u><strong>instance</strong> 不存在時建立該 <strong>instance</strong></u>，或者 return <code>RoomDatabase</code> 的<u>現有 <strong>instance</strong></u>。</p>
<p>取得 <code>RoomDatabase</code> instance 的一般程序如下：</p>
<ul>
<li>建立繼承 <code>RoomDatabase</code> 的 <code>public abstract</code> class。您定義的新 abstract class 會成為 <u>database holder</u>。您定義的 class 為 abstract，因為 <code>Room</code> 會為您建立實作。</li>
<li>使用 <code>@Database</code> 為 class 加上註解。在<u>引數</u>中，列出 <u>database 的 entity</u> 並設定 <u>version number</u>。</li>
<li>定義 return <code>ItemDao</code> instance 的 <u>abstract method</u> 或<u>屬性(property)</u>，<code>Room</code> 會為您產生實作。</li>
<li>整個 app <u>只需要一個 <code>RoomDatabase</code> instance</u>，因此請將 <code>RoomDatabase</code> 設為<b>單例模式(singleton)</b>。</li>
<li>僅在您的 (<code>item_database</code>) <u>database 不存在</u>的情況下，使用 Room 的 <code>Room.databaseBuilder</code> <u>建立 database</u>。否則，請 return <u>現有 database</u>。</li>
</ul>
<div class="note primary">
            <p><strong>筆記：</strong><b>單例模式(singleton)</b>可確保<u>只建立一個 instance</u>。<b>Companion object</b> 只會存在<u>一個 instance</u>，所以也屬於<b>單例模式(singleton)</b>。</p>
          </div>

<h4 id="建立-Database"><a href="#建立-Database" class="headerlink" title="建立 Database"></a>建立 Database</h4><ol>
<li>在 <code>data</code> package 中，建立 Kotlin class <code>ItemRoomDatabase.kt</code>。</li>
<li>在 <code>ItemRoomDatabase.kt</code> 檔案中，將 <code>ItemRoomDatabase</code> class 設為繼承 <code>RoomDatabase</code> 的 <code>abstract</code> class。使用 <code>@Database</code> 為 class 加上註解。您將在下一步中修正缺少參數的錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ItemRoomDatabase</span>: <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><code>@Database</code> 註解需要多個<u>引數</u>，以便 <code>Room</code> 能夠 build database。</li>
</ol>
<ul>
<li>將 <code>Item</code> 指定為<u>包含 <code>entities</code> list 的唯一 class</u>。</li>
<li>將 <code>version</code> 設為 <code>1</code>。每次變更 database table 的<u>結構定義(schema)</u>時，都必須增加 <strong>version number</strong>。</li>
<li>只要將 <code>exportSchema</code> 設為 <code>false</code>，即可<u>不保留結構定義(schema) version 紀錄的備份</u>。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities= [Item::class], version = 1, exportSchema = false)</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Database 需要知道該 <strong>DAO</strong>。在 class body 中，宣告一個 return <code>ItemDao</code> 的 <strong>abstract function</strong>。您可以擁有多個 DAO。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">itemDao</span><span class="params">()</span></span>: ItemDao</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 abstract function 下方，定義 <code>companion object</code>。Companion object 可讓您<u>使用 <strong>class name</strong> 做為限定詞(qualifier)，建立或取得 database</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>companion object</code> 中，宣告 database 的 private nullable 變數 <code>INSTANCE</code>，並將其初始化為 <code>null</code>。<code>INSTANCE</code> 變數會<u>在建立 database 時保留對該 database 的引用</u>。這有助於<u>維護在指定時間開啟的 database <b>單一 instance</b></u>，該 instance 是建立及維護成本很高的資源。</li>
</ol>
<p>使用 <code>@Volatile</code> 為 <code>INSTANCE</code> 加上註解。系統一律<u>不會快取易失變數的值</u>，所有<u>讀取與寫入作業</u>都會在<b>主記憶體(main memory)</b>中完成。這有助於<u>確保所有執行 thread 的 <code>INSTANCE</code> 值保持在最新狀態且相同</u>。這表示一個 thread 對 <code>INSTANCE</code> 所做的變更將立即對所有其他 thread 可見。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: ItemRoomDatabase? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 <code>INSTANCE</code> 下方的 <code>companion object</code> 內，使用 database builder 所需的 <code>Context</code> 參數定義 <code>getDatabase()</code> method。Return type <code>ItemRoomDatabase</code>。由於 <code>getDatabase()</code> 尚未 return 任何內容，因此系統會顯示錯誤訊息。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ItemRoomDatabase &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li><u>多個 thread</u> 可能會產生<b>競爭狀況(race condition)</b>，並<u>同時要求一個 <strong>database instance</strong></u>，如此一來就會<u>產生兩個 database</u>。納入程式碼以將 database 納入 <code>synchronized</code> 區塊中，這表示<u>一次只能執行一個 thread</u>，只有這個 thread 可以進入此<b>程式碼區塊</b>，從而確保系統<u>只會將 database 初始化一次</u>。</li>
</ol>
<p>在 <code>getDatabase()</code> 中，return <code>INSTANCE</code> 變數；如果 <code>INSTANCE</code> 為 null，則在 <code>synchronized&#123;&#125;</code> 區塊內對其進行初始化。使用 <code>elvis</code> 運算子 (<code>?:</code>) 執行此作業。傳入 companion object <code>this</code>，也就是要在 function 區塊中鎖定的 companion object。您將在後續步驟中修正此錯誤。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123; &#125;</span><br></pre></td></tr></table></figure>
<div class="note primary">
            <p><strong>筆記：</strong> <b>A ?: B</b> 意思是「當 <b>A</b> 不為 <b>null</b> 時就返回 <b>A</b>，當 <b>A</b> 為 <b>null</b> 時就返回 <b>B</b>」。</p>
          </div>

<ol start="9">
<li>在 <code>synchronized</code> 區塊中，<u>建立 <code>val</code> instance 變數</u>，並<u>使用 <strong>database builder</strong> 取得 database</u>。您還有錯誤有待在後續步驟中修正。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = Room.databaseBuilder()</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>在 <code>synchronized</code> 區塊的結尾，return <code>instance</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> instance</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>在 <code>synchronized</code> 區塊中，<u>初始化 <code>instance</code> 變數</u>，並<u>使用 <strong>database builder</strong> 取得 database</u>。將 <strong>application context</strong>、<strong>database class</strong> 以及 <strong>database name</strong> <code>item_database</code> 傳遞給 <code>Room.databaseBuilder()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> instance = Room.databaseBuilder(</span><br><span class="line">   context.applicationContext,</span><br><span class="line">   ItemRoomDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">   <span class="string">&quot;item_database&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>Android Studio 會產生「 type mismatch」錯誤。如要移除這項錯誤，請按照下列步驟新增遷移策略和 <code>build()</code>。</li>
</ul>
<ol start="12">
<li>將必要的<u>遷移策略(migration strategy)</u>新增至 <strong>builder</strong>。使用 <code>.fallbackToDestructiveMigration()</code>。</li>
</ol>
<p>一般來說，您必須為<b>遷移物件(migration object)</b>提供有關<u>何時變更結構定義(schema)</u>的遷移策略(migration strategy)。遷移物件(migration object)是一種 object，可定義<u>如何擷取舊結構定義(schema)中的所有 rows</u>，並將其<u>轉換為新結構定義(schema)中的 rows</u>，以免 data 遺失。<a href="https://medium.com/androiddevelopers/understanding-migrations-with-room-f01e04b07929">遷移(migration)</a>不在本程式碼研究室的範圍內。其中一個簡單的解決方法是刪除並重新 build database，但代表 data 會遺失。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.fallbackToDestructiveMigration()</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>如要建立 <strong>database instance</strong>，請呼叫 <code>.build()</code>。這應該會移除 Android Studio 錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.build()</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>在 <code>synchronized</code> 區塊內，指派 <code>INSTANCE = instance</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">INSTANCE = instance</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>在 <code>synchronized</code> 區塊的結尾，return <code>instance</code>。</li>
</ol>
<p><code>ItemRoomDatabase.kt</code> 完整程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// database class</span></span><br><span class="line"><span class="comment">// 建立 item database class</span></span><br><span class="line"><span class="meta">@Database(entities = [Item::class], version = 1, exportSchema = false)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">ItemRoomDatabase</span>: <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">    <span class="comment">// return ItemDao 的 abstract function</span></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">itemDao</span><span class="params">()</span></span>: ItemDao</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定義 companion object (可使用 class name 做為限定詞，建立或取得 database)</span></span><br><span class="line">    <span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">        <span class="meta">@Volatile</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: ItemRoomDatabase? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用 database builder 所需的 Context 參數定義 getDatabase() method</span></span><br><span class="line">        <span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: ItemRoomDatabase &#123;</span><br><span class="line">            <span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123; <span class="comment">// synchronized區塊中，一次只能執行一個 thread</span></span><br><span class="line">                <span class="comment">// 使用 database builder 取得 database instance</span></span><br><span class="line">                <span class="comment">// 將 application context、database class 以及 database name item_database 傳遞給 database builder</span></span><br><span class="line">                <span class="keyword">val</span> instance = Room.databaseBuilder(</span><br><span class="line">                    context.applicationContext,</span><br><span class="line">                    ItemRoomDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">                    <span class="string">&quot;item_database&quot;</span>)</span><br><span class="line">                    .fallbackToDestructiveMigration() <span class="comment">// 將遷移策略新增至 builder</span></span><br><span class="line">                    .build()</span><br><span class="line">                INSTANCE = instance <span class="comment">// 將 INSTANCE 設為剛才建立好的 instance</span></span><br><span class="line">                <span class="keyword">return</span> instance</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>建構程式碼，確保沒有錯誤。</li>
</ol>
<h4 id="實作-Application-class"><a href="#實作-Application-class" class="headerlink" title="實作 Application class"></a>實作 Application class</h4><p>在這項工作中，您需要在 <strong>Application class</strong> 中<u>對 <strong>database instance</strong> 執行<b>實例化(instantiate)</b></u>。</p>
<ol>
<li><ul>
<li>開啟 <code>InventoryApplication.kt</code>，建立 type 為 <code>ItemRoomDatabase</code> 且名為 <code>database</code> 的 <code>val</code>。</li>
<li>在傳入 <strong>context</strong> 的 <code>ItemRoomDatabase</code> 中呼叫 <code>getDatabase()</code>，藉此對 <code>database</code> instance 執行實例化(instantiate)。</li>
<li>請使用 <code>lazy</code> 委派(delegate)，讓系統<u>在您首次需要&#x2F;存取 <strong>reference</strong> 時</u> (而非 app starts 時) <u>延遲建立 <code>database</code> instance</u>。這項操作會<u>在首次存取時建立 database</u> (也就是磁碟(disk)上的<b>實體(physical) database</b>)。</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.app.Application</span><br><span class="line"><span class="keyword">import</span> com.example.inventory.<span class="keyword">data</span>.ItemRoomDatabase</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryApplication</span> : <span class="type">Application</span>()&#123;</span><br><span class="line">   <span class="keyword">val</span> database: ItemRoomDatabase <span class="keyword">by</span> lazy &#123; ItemRoomDatabase.getDatabase(<span class="keyword">this</span>) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>稍後在程式碼研究室中建立 <code>ViewModel</code> instance 時，您將用到這個 <code>database</code>。</li>
</ul>
<p>現在您擁有了使用 <code>Room</code> 所需的所有 building 區塊。這個程式碼可以編譯並執行，但無法判斷它是否正常運作。因此，我們建議您在 Inventory database 中新增 new item 來測試 database。如要完成這項工作，您需要使用 <code>ViewModel</code> 與 database 互動。</p>
<hr>
<h3 id="新增-ViewModel"><a href="#新增-ViewModel" class="headerlink" title="新增 ViewModel"></a>新增 ViewModel</h3><p>目前您建立了一個 database，且 UI class 屬於範例程式碼。如要儲存 app 的暫時性 data 並存取 database ，您必須具備 <code>ViewModel</code>。<span class="label primary"> <b>Inventory ViewModel</b> 將透過 <b>DAO</b> 與 <b>database</b> 互動，並將 data 提供給 <b>UI</b></span>。所有 database 作業都必須透過 <strong>main UI thread</strong> 執行，為此，使用 <u>coroutines</u> 和 <a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-tw#viewmodelscope">viewModelScope</a> 即可。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/91298a7c05e4f5e0_1920.png?hl=zh-tw" width="60%">

<h4 id="建立-Inventory-ViewModel"><a href="#建立-Inventory-ViewModel" class="headerlink" title="建立 Inventory ViewModel"></a>建立 Inventory ViewModel</h4><ol>
<li>在 <code>com.example.inventory</code> package 中，建立 Kotlin class 檔案 <code>InventoryViewModel.kt</code>。</li>
<li><code>InventoryViewModel</code> class 繼承 <code>ViewModel</code> class。將 <u><code>ItemDao</code> object</u> 做為參數傳遞至預設 constructor。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> itemDao: ItemDao) : ViewModel() &#123;&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 class 外的 <code>InventoryViewModel.kt</code> 檔案結尾，新增 <code>InventoryViewModelFactory</code> class，對 <code>InventoryViewModel</code> instance 執行<u>實例化(instantiate)</u>。傳入與做為 <code>ItemDao</code> instance 的 <code>InventoryViewModel</code> 相同的 constructor 參數。繼承 <code>ViewModelProvider.Factory</code> class。您將在下一個步驟中修正未實作 method 的錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> itemDao: ItemDao) : ViewModelProvider.Factory &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>按一下紅色燈泡並選取「Implement Members」，或是覆寫 <code>ViewModelProvider.Factory</code> class 中的 <code>create()</code> method，這會將任何 <strong>class type</strong> 當做引數，然後 return <code>ViewModel</code> object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel?&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>實作 <code>create()</code> method。檢查 <code>modelClass</code> 是否和 <code>InventoryViewModel</code> class 相同，如果是，請 return 一個 instance。否則，您可以 throw 例外狀況(exception)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (modelClass.isAssignableFrom(InventoryViewModel::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">   <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">   <span class="keyword">return</span> InventoryViewModel(itemDao) <span class="keyword">as</span> T</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)</span><br></pre></td></tr></table></figure>

<h4 id="填入-ViewModel"><a href="#填入-ViewModel" class="headerlink" title="填入 ViewModel"></a>填入 ViewModel</h4><p>在這項工作中，您要填入 <code>InventoryViewModel</code> class，<u>將 <strong>inventory data</strong> 新增至 <strong>database</strong></u>。請查看 inventory app 中的 <code>Item</code> entity 和「Add Item」畫面。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Item</span>(</span><br><span class="line">   <span class="meta">@PrimaryKey(autoGenerate = true)</span></span><br><span class="line">   <span class="keyword">val</span> id: <span class="built_in">Int</span> = <span class="number">0</span>,</span><br><span class="line">   <span class="meta">@ColumnInfo(name = <span class="string">&quot;name&quot;</span>)</span></span><br><span class="line">   <span class="keyword">val</span> itemName: String,</span><br><span class="line">   <span class="meta">@ColumnInfo(name = <span class="string">&quot;price&quot;</span>)</span></span><br><span class="line">   <span class="keyword">val</span> itemPrice: <span class="built_in">Double</span>,</span><br><span class="line">   <span class="meta">@ColumnInfo(name = <span class="string">&quot;quantity&quot;</span>)</span></span><br><span class="line">   <span class="keyword">val</span> quantityInStock: <span class="built_in">Int</span></span><br><span class="line">)   </span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-persisting-data-room/img/85c644aced4198c5_1920.png?hl=zh-tw" width="40%">

<p>您需要該特定 item 的 <u>name</u>、<u>price</u> 和 <u>stock</u>，以便將 <strong>entity</strong> 新增到 database。在程式碼研究室的後續部分，您將使用「Add Item」畫面取得使用者的詳細資料(details)。在目前的工作中，您要：</p>
<ul>
<li>使用三個 <strong>strings</strong> 做為 <u><code>ViewModel</code> 的 input</u>。</li>
<li>將這些 <strong>strings</strong> 轉換為 <u><code>Item</code> entity instance</u>。</li>
<li>使用 <u><code>ItemDao</code> instance</u> 將其儲存至 <strong>database</strong>。</li>
</ul>
<ol>
<li>在 <code>InventoryViewModel</code> class 中，新增名為 <code>insertItem()</code> 的 <code>private</code> function，該 function 會<u>擷取 <code>Item</code> object</u>，並以<a href="https://linglingdr00.github.io/2023/12/05/Android%E7%AD%86%E8%A8%98-33-Coroutines%E7%B0%A1%E4%BB%8B/#%E9%97%9C%E6%96%BC-runBlocking">非阻塞(non-blocking)</a>的方式<u>將 <strong>data</strong> 加入 <strong>database</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如要透過 main thread 與 database 互動，請啟動 <a href="https://linglingdr00.github.io/2023/12/05/Android%E7%AD%86%E8%A8%98-33-Coroutines%E7%B0%A1%E4%BB%8B/#Kotlin-%E4%B8%AD%E7%9A%84%E5%8D%94%E7%A8%8B-coroutines">coroutine</a>，然後呼叫其中的 <strong>DAO method</strong>。在 <code>insertItem()</code> method 中，使用 <code>viewModelScope.launch</code> 來啟動 <code>ViewModelScope</code> 中的 coroutine。在啟動 function 中，對傳入 <code>item</code> 的 <code>itemDao</code> 呼叫 <strong>suspend function</strong> <code>insert()</code>。<code>ViewModelScope</code> 是 <code>ViewModel</code> class 的 extension 屬性，<u>會在 <code>ViewModel</code> 刪除時自動取消其子項 coroutine</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   viewModelScope.launch &#123;</span><br><span class="line">       itemDao.insert(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>import <code>kotlinx.coroutines.launch</code> 和 <code>androidx.lifecycle.viewModelScope</code>。</p>
<ol start="3">
<li>在 <code>InventoryViewModel</code> class 中，新增另一個 private function，該 function 會<u>擷取三個 strings，並 return <code>Item</code> instance</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNewItemEntry</span><span class="params">(itemName: <span class="type">String</span>, itemPrice: <span class="type">String</span>, itemCount: <span class="type">String</span>)</span></span>: Item &#123;</span><br><span class="line">   <span class="keyword">return</span> Item(</span><br><span class="line">       itemName = itemName,</span><br><span class="line">       itemPrice = itemPrice.toDouble(),</span><br><span class="line">       quantityInStock = itemCount.toInt()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>InventoryViewModel</code> class 中，新增名為 <code>addNewItem()</code> 的 public function，該 function 會<u>採用三個 <strong>strings</strong> 來取得 <strong>item detail strings</strong></u>。將 <strong>item detail strings</strong> 傳遞至 <code>getNewItemEntry()</code> function，並將 return 的值指派給名為 <code>newItem</code> 的值。呼叫傳入 <code>newItem</code> 的 <code>insertItem()</code>，以<u>將 new <strong>entity</strong> 新增至 database</u>。系統會從 <strong>UI fragment</strong> 中呼叫，將 <strong>Item details</strong> 新增至 database。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addNewItem</span><span class="params">(itemName: <span class="type">String</span>, itemPrice: <span class="type">String</span>, itemCount: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> newItem = getNewItemEntry(itemName, itemPrice, itemCount)</span><br><span class="line">   insertItem(newItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>請注意，您並沒有在 <code>addNewItem()</code> 中使用 <code>viewModelScope.launch</code>，但呼叫 <strong>DAO method</strong> 時在上述 <code>insertItem()</code> 中會用到。這是因為<span class="label primary">系統只能從 <b>coroutine</b> 或其他 <b>suspend function</b> 中呼叫 <b>suspend function</b></span>，而 <code>itemDao.insert(item)</code> 是一種 suspend function。</p>
<p><code>InventoryViewModel.kt</code> 完整程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// view model</span></span><br><span class="line"><span class="comment">// ViewModel 將透過 DAO 與 database 互動，並將 data 提供給 UI</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> itemDao: ItemDao): ViewModel() &#123;</span><br><span class="line">    <span class="comment">// 抓取 Item object，將其加入 database</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">insertItem</span><span class="params">(item: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">        viewModelScope.launch &#123; <span class="comment">// 啟動 coroutine</span></span><br><span class="line">            <span class="comment">// 透過 dao 的 insert 方法，新增 item 到 database</span></span><br><span class="line">            itemDao.insert(item)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 抓取三個 strings，並 return Item instance</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNewItemEntry</span><span class="params">(itemName: <span class="type">String</span>, itemPrice: <span class="type">String</span>, itemCount: <span class="type">String</span>)</span></span>: Item &#123;</span><br><span class="line">        <span class="keyword">return</span> Item(</span><br><span class="line">            itemName = itemName,</span><br><span class="line">            itemPrice = itemPrice.toDouble(), <span class="comment">// 轉成 Double</span></span><br><span class="line">            quantityInStock = itemCount.toInt() <span class="comment">// 轉成 Int</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 將 new entity 新增至 database</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addNewItem</span><span class="params">(itemName: <span class="type">String</span>, itemPrice: <span class="type">String</span>, itemCount: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 將 newItem 轉換成 Item object</span></span><br><span class="line">        <span class="keyword">val</span> newItem = getNewItemEntry(itemName, itemPrice, itemCount)</span><br><span class="line">        <span class="comment">// 將 Item object 傳給 insertItem function</span></span><br><span class="line">        insertItem(newItem)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 對 InventoryViewModel instance 執行實例化(instantiate)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryViewModelFactory</span>(<span class="keyword">private</span> <span class="keyword">val</span> itemDao: ItemDao): ViewModelProvider.Factory &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">        <span class="comment">// 檢查 modelClass 是否和 InventoryViewModel class 相同</span></span><br><span class="line">        <span class="keyword">if</span> (modelClass.isAssignableFrom(InventoryViewModel::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">            <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">            <span class="comment">//  return 一個 instance</span></span><br><span class="line">            <span class="keyword">return</span> InventoryViewModel(itemDao) <span class="keyword">as</span> T</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// throw exception</span></span><br><span class="line">        <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您已新增所有必要的 function，<u>可將 entity 新增至 database</u>。在下一項工作中，您需要更新 <strong>Add Item fragment</strong> 以使用上述 function。</p>
<hr>
<h3 id="更新-AddItemFragment"><a href="#更新-AddItemFragment" class="headerlink" title="更新 AddItemFragment"></a>更新 AddItemFragment</h3><ol>
<li>在 <code>AddItemFragment.kt</code> 中 <code>AddItemFragment</code> class 的開頭，建立 type 為 <code>InventoryViewModel</code> 且名為 <code>viewModel</code> 的 <code>private val</code>。<u>使用 <code>by activityViewModels()</code></u> Kotlin 屬性委派(delegate)功能，即可<u>跨 <strong>fragments</strong> 共用(shared) <code>ViewModel</code></u>。您將在下一個步驟中修正錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: InventoryViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>lambda</code> 中，呼叫 <code>InventoryViewModelFactory()</code> constructor 並傳入 <code>ItemDao</code> instance。請使用先前其中一項工作中建立的 <u><code>database</code> instance</u>，<u>呼叫 <code>itemDao</code> constructor</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: InventoryViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   InventoryViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> InventoryApplication).database</span><br><span class="line">           .itemDao()</span><br><span class="line">   )</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>viewModel</code> 定義下方，建立 type 為 <code>Item</code> 且名為 <code>item</code> 的 <code>lateinit var</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> item: Item</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>「Add Item」畫面會顯示三個 <u>text fields</u>，用於取得使用者的 <u>item details</u>。在這個步驟中，您要新增 function，<u>驗證 <code>TextFields</code> 中的 text 並非 empty</u>。在新增或更新 database 中的 <strong>entity</strong> 之前，請使用這個 function 來<u>驗證使用者輸入內容(input)</u>。這項驗證程序必須在 <code>ViewModel</code>、而非 fragments 中進行。在 <code>InventoryViewModel</code> class 中，新增下列名為 <code>isEntryValid()</code> 的 <code>public</code> function。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">isEntryValid</span><span class="params">(itemName: <span class="type">String</span>, itemPrice: <span class="type">String</span>, itemCount: <span class="type">String</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (itemName.isBlank() || itemPrice.isBlank() || itemCount.isBlank()) &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>AddItemFragment.kt</code> 的 <code>onCreateView()</code> function 下方，建立一個名為 <code>isEntryValid()</code> 的 <code>private</code> function，該 function 會 return <code>Boolean</code>。您將在下一步中修正缺少 return 值這一錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEntryValid</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>AddItemFragment</code> class 中，實作 <code>isEntryValid()</code> function。在 <code>viewModel</code> instance 上呼叫 <code>isEntryValid()</code> function，傳入 text views 中的 text。Return <code>viewModel.isEntryValid()</code> function 的值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">isEntryValid</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> viewModel.isEntryValid(</span><br><span class="line">       binding.itemName.text.toString(),</span><br><span class="line">       binding.itemPrice.text.toString(),</span><br><span class="line">       binding.itemCount.text.toString()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 <code>AddItemFragment</code> class 的 <code>isEntryValid()</code> function 下方，請新增另一個名為 <code>addNewItem()</code> 的 <code>private</code> function，<u>該 function 沒有參數且不會 return 任何內容</u>。在 function 中，在 <code>if</code> 條件內呼叫 <code>isEntryValid()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addNewItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (isEntryValid()) &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>if</code> 區塊內，對 <code>viewModel</code> instance 呼叫 <code>addNewItem()</code> 方法。傳入使用者輸入的 <strong>item details</strong>，使用 <code>binding</code> instance 讀取這些 data。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (isEntryValid()) &#123;</span><br><span class="line">   viewModel.addNewItem(</span><br><span class="line">   binding.itemName.text.toString(),</span><br><span class="line">   binding.itemPrice.text.toString(),</span><br><span class="line">   binding.itemCount.text.toString(),</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在 <code>if</code> 區塊下方建立 <code>val action</code>，<b>導覽回(navigate back)</b> <code>ItemListFragment</code>。呼叫 <code>findNavController().navigate()</code>，以傳入 <code>action</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> action = AddItemFragmentDirections.actionAddItemFragmentToItemListFragment()</span><br><span class="line">findNavController().navigate(action)</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>完整方法應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">addNewItem</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (isEntryValid()) &#123;</span><br><span class="line">           viewModel.addNewItem(</span><br><span class="line">               binding.itemName.text.toString(),</span><br><span class="line">               binding.itemPrice.text.toString(),</span><br><span class="line">               binding.itemCount.text.toString(),</span><br><span class="line">           )</span><br><span class="line">           <span class="keyword">val</span> action = AddItemFragmentDirections.actionAddItemFragmentToItemListFragment()</span><br><span class="line">           findNavController().navigate(action)</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li><p>如要連結所有內容，請<u>在 <strong>save button</strong> 中新增 <strong>click handler</strong></u>。在 <code>AddItemFragment</code> class 的 <code>onDestroyView()</code> function 上方，覆寫 <code>onViewCreated()</code> function。</p>
</li>
<li><p>在 <code>onViewCreated()</code> function 中，將 <strong>click handler</strong> 新增至 <strong>save button</strong>，並呼叫 <code>addNewItem()</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">   binding.saveAction.setOnClickListener &#123;</span><br><span class="line">       addNewItem()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>build 並執行 app，然後輕觸「+」(FAB)。在「Add Item」畫面中，新增 item details，然後輕觸「Save」。這項操作會儲存 data，但 app 還不會顯示任何 data。在下一項工作中，您將使用 App Inspector 瀏覽已儲存的 data。</li>
</ol>
<img src="https://i.imgur.com/AyYav11.png" width="40%">

<img src="https://i.imgur.com/QCHoAgW.png">

<p>恭喜！您已經建立了一個 app，可使用 <code>Room</code> 保存 data。在接下來的程式碼研究室中，您將在 app 中<u>新增 <code>RecyclerView</code> 以顯示 <strong>databse</strong> 中的 <strong>items</strong></u>，並在 app 中<u>新增刪除(deleting)及更新(updating) <strong>entities</strong> 等功能</u>。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>companion object</tag>
        <tag>singleton</tag>
        <tag>Fragment</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Coroutine</tag>
        <tag>suspend function</tag>
        <tag>SQL</tag>
        <tag>Room</tag>
        <tag>DAO</tag>
        <tag>Entity</tag>
        <tag>Factory</tag>
        <tag>Flow</tag>
        <tag>Database Class</tag>
        <tag>Concurrency</tag>
        <tag>SQLite</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(39)-Room與Flow簡介</title>
    <url>/2023/12/17/Android%E7%AD%86%E8%A8%98-39-Room%E8%88%87Flow%E7%B0%A1%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>使用 <strong>Room library</strong> 即可輕鬆在 Android app 中使用 database。<strong>Room</strong> 也稱為 <u>ORM (Object Relational Mapping) library</u>，顧名思義，就是<u>將 relational database 中的 table 對應至可在 Kotlin 程式碼中使用的 objects</u>。在本課程中，您只需要關注<u>讀取 data</u>。使用預先填入的 database，您就能載入公車抵達時間 table 中的 data，並在 <code>RecyclerView</code> 中呈現這些 data。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/70c597851eba9518_1920.png?hl=zh-tw" width="40%">

<p>在課程中，您將瞭解使用 Room 的基礎知識，包括 <u>database class</u>、<u>DAO</u>、<u>實體(entities)</u>和 <u>view models</u>。此外，課程中也會介紹 <code>ListAdapter</code> class，讓您透過另一種方式在 <code>RecyclerView</code> 中呈現 data；以及 <strong>Flow</strong>，這是一種<u>類似於 <code>LiveData</code></u> 的 Kotlin 語言功能，<u>可使 UI 針對 database 變更做出 response</u>。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>將 database table 以 <strong>Kotlin  objects</strong> (<u>實體(entities)</u>) 表示。</li>
<li><u>定義</u>要用於在 app 中<u>使用 Room 的 <strong>database class</strong></u>，並從檔案預先填入 database。</li>
<li>定義 <strong>DAO class</strong>，並<u>使用 SQL 查詢</u>從 <u>Kotlin 程式碼</u>存取 database。</li>
<li>定義 <strong>view models</strong>，以允許 <u>UI 與 DAO 互動</u>。</li>
<li>瞭解如何<u>在 recycler view 中使用 <code>ListAdapter</code></u>。</li>
<li>瞭解 Kotlin <strong>Flow</strong> 的基本概念，以及學習如何實際運用，<u>讓 UI 對基礎 data 的變更做出 response</u>。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="開始操作"><a href="#開始操作" class="headerlink" title="開始操作"></a>開始操作</h3><p>在本程式碼研究室中，您要使用的 app 稱為 Bus Schedule。此 app 會顯示<u>公車站(bus stops) list</u>，以及<u>從最早到最晚的抵達時間(arrival times)</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/70c597851eba9518_1920.png?hl=zh-tw" width="40%">

<p>輕觸第一個畫面中的任意一列可開啟新畫面，只顯示所選公車站的公車即將抵達時間。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/f477c0942746e584_1920.png?hl=zh-tw" width="40%">

<p><b>bus stop data</b> 來自 app <u><b>預先封裝(prepackaged)</b>的 database</u>。不過，在目前的狀態下，app 首次執行時不會顯示任何內容。您的工作是<u>整合 <strong>Room</strong></u>，讓 app 顯示<u><b>預先填入(prepopulated)</b>的 <b>arrival times database</b></u>。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-bus-schedule-app/tree/starter">https://github.com/google-developer-training/android-basics-kotlin-bus-schedule-app/tree/starter</a><br><strong>分支版本：</strong><b>starter</b></p>
          </div>

<hr>
<h3 id="新增-Room-dependency"><a href="#新增-Room-dependency" class="headerlink" title="新增 Room dependency"></a>新增 Room dependency</h3><p>和任何其他 library 一樣，您必須先新增必要的 <strong>dependency</strong>，才能在 Bus Schedule app 中使用 Room。這只需要兩個小幅變更，每個 Gradle 檔案中各一個。</p>
<ol>
<li>在 project-level 的 <code>build.gradle</code> 檔案中，請在 <code>ext</code> 區塊中定義 <code>room_version</code>。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line">   kotlin_version = <span class="string">&quot;1.6.20&quot;</span></span><br><span class="line">   nav_version = <span class="string">&quot;2.4.1&quot;</span></span><br><span class="line">   room_version = <span class="string">&#x27;2.4.2&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 app-level 的 <code>build.gradle</code> 檔案中，請於 dependency list 的結尾新增下列 dependency。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.room:room-runtime:$room_version&quot;</span></span><br><span class="line">kapt <span class="string">&quot;androidx.room:room-compiler:$room_version&quot;</span></span><br><span class="line"><span class="comment">// optional - Kotlin Extensions and Coroutines support for Room</span></span><br><span class="line">implementation <span class="string">&quot;androidx.room:room-ktx:$room_version&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>請同步(sync)處理變更並建構 project，確認是否已正確新增 dependency。</li>
</ol>
<p>sync 後會產生以下 error：<br><img src="https://i.imgur.com/5DcJfZr.png"></p>
<div class="note danger">
            <p><strong>重要：</strong>sync 後，會產生 <font color="red">Could not find method kapt() for arguments</font> error。參考 <a href="https://github.com/google-developer-training/android-basics-kotlin-bus-schedule-app/issues/92">issue</a>，需要在 app-level <code>build.gradle</code> 檔案的 plugins 中新增 <code>id &#39;kotlin-kapt&#39;</code>：</p><figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    ...</span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最後重新 sync 即可解決。</p>
          </div>

<p>在接下來的幾個頁面中，我們會介紹將 Room 整合至 app 所需的 <strong>components</strong>：</p>
<ul>
<li>models</li>
<li>DAO</li>
<li>view models</li>
<li>database class</li>
</ul>
<hr>
<h3 id="建立實體-entity"><a href="#建立實體-entity" class="headerlink" title="建立實體(entity)"></a>建立實體(entity)</h3><p>在先前的程式碼研究室中瞭解 <strong>relational databases</strong> 後，您便知道系統如何將 data 整理成含有<u>多欄(columns)</u>的 table 其中<u>每欄(column)都代表特定 data type 的特定屬性</u>。如同 <u>Kotlin 中的 class 為每個 object 都提供一個 template</u>，database 中的 <strong>table</strong> 也會為其中<u>每個項目(item)</u>或<u>每列(row)</u>各提供一個 <strong>template</strong>。因此，<u>Kotlin class 可用於代表 database 中的每個 table</u>，這點並不讓人意外。</p>
<p>使用 Room 時，<span class="label primary">每個 <b>table</b> 都以一個 <b>class</b> 表示</span>。在 Room 等 <u>ORM (Object Relational Mapping) library</u> 中，通常稱為 <span class="label primary"><b>model classes</b> 或<b>實體(entities)</b></span>。</p>
<p>Bus Schedule app 的 database 只包含「schedule」這一個 table，當中包含 bus arrival 的部分基本資訊。</p>
<ul>
<li><code>id</code>：提供 <strong>unique ID</strong> 做為主鍵的 integer</li>
<li><code>stop_name</code>：string</li>
<li><code>arrival_time</code>：integer</li>
</ul>
<p>請注意， database 中使用的 SQL type 實際上對於 <code>Int</code> 是 <code>INTEGER</code>，對於 <code>String</code> 是 <code>TEXT</code>。不過，使用 Room 時，您應該<u>只在定義 <strong>model classes</strong> 時考慮 <strong>Kotlin type</strong></u>。系統會<u>自動將 <b>model class 的 data type</b> 對應至 <b>database 使用的 data type</b></u>。</p>
<p>如果 project 含有多個檔案，建議您將檔案整理成不同的 <strong>packages</strong>，以便為各個 class 提供更好的<u>存取權控管(access control)</u>，並更輕鬆地找出相關 class。</p>
<p>如要為 <code>schedule</code> table 建立<u>實體(entity)</u>，請在 <code>com.example.busschedule</code> package 中加入名為 <code>database</code> 的新 package。在這個 package 中，為<b>實體(entity)</b>新增名為 <code>schedule</code> 的新 package。接著，在 <code>database.schedule</code> package 中建立名為 <code>Schedule.kt</code> 的新檔案，並定義名為 <code>Schedule</code> 的 data class。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Schedule</span>(</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如 SQL 基礎課程所述，table 應有一個<b>主鍵(primary key)</b>，用來<u>識別每個 rows</u>。您要新增至 <code>Schedule</code> class 的第一個屬性是 <strong>integer</strong>，代表<u>專屬 ID(uniquely identify)</u>。新增一個新屬性，並為其<u>標示 <code>@PrimaryKey</code> 註解</u>。此項操作會<u>指示 Room 在插入<b>新 row</b> 時，將這個屬性視為<b>主鍵(primary key)</b></u>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>

<p>為 <u>bus stop 的名稱</u> 新增一欄(column)。該 column 的 type 應為 <code>String</code>。如果是新 column，則需要新增 <code>@ColumnInfo</code> 註解來<u>指定該 column 的 <strong>name</strong></u>。通常，與 Kotlin 屬性使用的 <code>lowerCamelCase</code> 不同，<strong>SQL column name</strong> 的字詞<u>以<b>底線</b>分隔</u>。我們也<u>不允許這個 column 中的 value 為<b>空值(null)</b></u>，請<u>使用 <code>@NonNull</code> 註解</u>加以標示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="string">&quot;stop_name&quot;</span>)</span> <span class="keyword">val</span> stopName: String,</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>注意：</strong>在 <u>SQL 中，根據預設，column 的 value 可以是空值(null)</u>，但您可以視需要另外將 value 標示為非空值(non null)。這不同於 Kotlin 的運作方式，<u>在 Kotlin 中，根據預設，value 不可為<b>空值(null)</b></u>。</p>
          </div>

<p><strong>Arrival times</strong> 會在 database 中以 <strong>integers</strong> 表示。這是 <a href="https://www.unixtimestamp.com/">Unix timestamp</a>，可轉換成可用<b>日期(date)</b>。雖然不同版本的 SQL 都提供了<u>轉換日期(dates)</u>的方式，但您仍可按照自己的需要使用 <strong>Kotlin date formatting functions</strong>。將下列 <code>@NonNull</code> column 新增至 <strong>model class</strong>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="string">&quot;arrival_time&quot;</span>)</span> <span class="keyword">val</span> arrivalTime: <span class="built_in">Int</span></span><br></pre></td></tr></table></figure>

<p>最後，為了讓 <strong>Room</strong> <u>辨識出這個 class 可用於定義 <strong>database table</strong></u>，您需要為 class 本身新增一個<u>註解</u>。在 <u>class name 之前的行</u>中新增 <code>@Entity</code>。</p>
<p>根據預設，Room 會<u>使用 <strong>class name</strong> 做為 <strong>database table name</strong></u>。因此，目前 class 定義的 table name 就是 <code>Schedule</code>。另外，您也可以選擇指定 <code>@Entity(tableName=&quot;schedule&quot;)</code>，但由於 <u>Room 查詢不區分大小寫</u>，因此可以不使用明確定義小寫的 table 名稱。</p>
<p>現在，schedule 實體(entity)的 class 應如下所示。  </p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Schedule</span>(</span><br><span class="line">   <span class="meta">@PrimaryKey</span> <span class="keyword">val</span> id: <span class="built_in">Int</span>,</span><br><span class="line">   <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="string">&quot;stop_name&quot;</span>)</span> <span class="keyword">val</span> stopName: String,</span><br><span class="line">   <span class="meta">@NonNull</span> <span class="meta">@ColumnInfo(name = <span class="string">&quot;arrival_time&quot;</span>)</span> <span class="keyword">val</span> arrivalTime: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定義-DAO"><a href="#定義-DAO" class="headerlink" title="定義 DAO"></a>定義 DAO</h3><p>需要新增以整合 Room 的下一個 <strong>class</strong> 是 <strong>DAO</strong>。DAO 代表 <strong>Data Access Object</strong>，是一種可供存取 data 的 Kotlin class 。具體來說，DAO 包含<u>用來讀取及操控 data 的 function</u>。<u>在 DAO 上呼叫 function</u> 相當於<u>在 database 上執行 SQL 指令</u>。事實上，<strong>DAO function</strong> 就像您在此 app 中定義的 function 一樣，通常會指定 SQL 指令，以便您準確指定希望該 function 執行的操作。定義 DAO 時，在先前程式碼研究室中瞭解的 SQL 知識可派上用場。</p>
<ol>
<li>請為 <strong>Schedule entity</strong> 新增 <strong>DAO class</strong>。在 <code>database.schedule</code> package 中，建立名為 <code>ScheduleDao.kt</code> 的新檔案，並<u>定義名為 <code>ScheduleDao</code> 的 interface</u>。與 <code>Schedule</code> class 相似，您必須加上<u>註解 <code>@Dao</code></u>，才能在 Room 中使用 interface。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ScheduleDao</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p>注意：雖然 DAO 是首字母縮寫，但 Kotlin 程式碼的命名慣例只會將首字母縮寫中的第一個字母大寫，因此請使用 <b>ScheduleDao</b> 名稱，而非 <b>ScheduleDAO</b> 名稱。</p>
          </div>

<ol start="2">
<li><ul>
<li>App 有兩個畫面，每個畫面都需要不同的查詢。第一個畫面會<u>依 <strong>arrival time</strong> 遞增排序所有 <strong>bus stops</strong></u>。在這種情況下，查詢只需要<u>取得所有 columns</u>，並加入適當的 <u><code>ORDER BY</code> 子句</u>。查詢以傳遞至 <code>@Query</code> 註解的 <u>string</u> 形式指定。</li>
<li>定義 function <code>getAll()</code>，該 function 會 return <u><code>Schedule</code> list</u>，其中包括 <code>@Query</code> 註解，如下所示。</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * FROM schedule ORDER BY arrival_time ASC&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><ul>
<li>對於第二個查詢，同樣建議您，<u>從 schedule table 中選取所有 columns</u>。不過請注意，您只需符合<u>所選(selected) stop name</u> 的結果，因此請新增 <code>WHERE</code> 子句。如要<u>引用查詢的 <strong>Kotlin value</strong></u>，請在查詢前加上<b>冒號 <code>:</code></b> (例如來自 function 參數的 <code>:stopName</code>)。和以前一樣，結果會<u>依 <strong>arrival time</strong> 遞增排序</u>。</li>
<li>定義 <code>getByStopName()</code> function ，該 function 採用名為 <code>stopName</code> 的參數 <code>String</code>，並 return <code>Schedule</code> object 的 <code>List</code>，包含 <code>@Query</code> 註解，如下所示。</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Query(<span class="string">&quot;SELECT * FROM schedule WHERE stop_name = :stopName ORDER BY arrival_time ASC&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getByStopName</span><span class="params">(stopName: <span class="type">String</span>)</span></span>: List&lt;Schedule&gt;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="定義-ViewModel"><a href="#定義-ViewModel" class="headerlink" title="定義 ViewModel"></a>定義 ViewModel</h3><p>現在，DAO 已設定完畢，從技術面來說，您已備齊所有必要項目，必須開始<u>透過 fragments 存取 database</u>。然而，雖然這在理論上可行，但通常<u>不被視為最佳做法</u>。這是因為在較複雜的 app 中，可能有多個畫面只會存取 data 的特定部分。雖然 <code>ScheduleDao</code> 相對簡單，但在面對兩個或更多不同的畫面時，很容易會失控。舉例來說，DAO 看起來大致如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Dao</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">ScheduleDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(...)</span></span><br><span class="line">    getForScreenOne() ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(...)</span></span><br><span class="line">    getForScreenTwo() ...</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Query(...)</span></span><br><span class="line">    getForScreenThree()</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>雖然畫面 1 的程式碼可以存取 <code>getForScreenOne()</code>，但該程式碼不適合存取其他 method。最佳做法是<u>將顯示在 view 的 DAO 部分分隔成獨立 class</u> ，稱為「<strong>view model</strong>」。這是行動 app 中常見的架構模式。使用 view model 有助於<u>更清晰地區分 app <strong>UI</strong> 及其 <strong>data model</strong> 的程式碼</u>。也有助於單獨測試程式碼的各個部分，隨著您繼續 Android 開發之旅，之後便會深入探索這個主題。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/ee2524be13171538_1920.png?hl=zh-tw" width="40%">

<p>如果使用 view model，您可以利用 <code>ViewModel</code> class。<code>ViewModel</code> class 用於<u>儲存與 app UI 相關的 <strong>data</strong></u>，並且具有<u>生命週期感知</u>特性，對於 <u>lifecycle events 的 response</u> 與 activity 或 fragments 極為相似。如果畫面旋轉等 lifecycle events 會導致 activity 或 fragments 被刪除並重新建立，則不需要重新建立相關聯的 <code>ViewModel</code>。您無法直接存取 DAO class，因此最好使用 <code>ViewModel</code> 子類別，<u>將 <strong>loading data</strong> 工作與 activity 或 fragments 區分開</u>。</p>
<div class="note success">
            <p><strong>注意：</strong>Bus Schedule 是一個相對簡單的 app ，只包含兩個畫面且內容大致相同。基於教學目的，我們將建立單個 view model class，可供兩個畫面使用，但在大型 app 中，則可以針對各個 fragments 使用單獨的 view model。</p>
          </div>

<ol>
<li>如要建立 view model class，請在名為 <code>viewmodels</code> 的新 package 中建立名為 <code>BusScheduleViewModel.kt</code> 的新檔案。<u>定義 view model 的 class</u>。該 class 應採用 <u><code>ScheduleDao</code> type</u> 的單一參數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusScheduleViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> scheduleDao: ScheduleDao): ViewModel() &#123;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>由於這個 view model 會同時用於兩個畫面，因此您需要新增 <strong>method</strong> 來取得<u>完整 schedule</u> 和<u>依照 <strong>stop name</strong> 進行篩選的 schedule</u>。做法是<u>呼叫 <code>ScheduleDao</code> 的對應 method</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">fullSchedule</span><span class="params">()</span></span>: List&lt;Schedule&gt; = scheduleDao.getAll()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">scheduleForStopName</span><span class="params">(name: <span class="type">String</span>)</span></span>: List&lt;Schedule&gt; = scheduleDao.getByStopName(name)</span><br></pre></td></tr></table></figure>

<p>雖然已經完成 view model 的定義，但您不能直接將 <code>BusScheduleViewModel</code> 實例化(instantiate)，並預期一切運作正常。由於 <code>ViewModel</code> class <code>BusScheduleViewModel</code> 必須有<u>生命週期感知</u>特性，因此應<u>以可回應 <strong>lifecycle events</strong> 的 <strong>object</strong> 進行實例化(instantiate)</u>。</p>
<p>如果直接在其中一個 fragments 中執行實例化(instantiate)，則 fragments object 必須處理一切 (包括所有記憶體管理工作)，而這超出 app 程式碼的工作範圍。您可以改為<u>建立名為 <strong>factory</strong> 的 class</u>，該 class 會替您<u>將 <strong>view model object</strong> 實例化(instantiate)</u>。</p>
<ol>
<li>如要建立 factory，請在 view model class 下方建立繼承自 <code>ViewModelProvider.Factory</code> 的新 class <code>BusScheduleViewModelFactory</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusScheduleViewModelFactory</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> scheduleDao: ScheduleDao</span><br><span class="line">) : ViewModelProvider.Factory &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>您只需要一個樣板程式碼，就能正確<u>對 view model 執行實例化(instantiate)</u>。您不必直接初始化 class，而是可以<u>覆寫名為 <code>create()</code> 的 method</u>，該 method 會 <u>return <code>BusScheduleViewModelFactory</code> 以及一些錯誤檢查(error checking)</u>。在 <code>BusScheduleViewModelFactory</code> class 中實作 <code>create()</code>，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="type">&lt;T : ViewModel&gt;</span> <span class="title">create</span><span class="params">(modelClass: <span class="type">Class</span>&lt;<span class="type">T</span>&gt;)</span></span>: T &#123;</span><br><span class="line">       <span class="keyword">if</span> (modelClass.isAssignableFrom(BusScheduleViewModel::<span class="keyword">class</span>.java)) &#123;</span><br><span class="line">           <span class="meta">@Suppress(<span class="string">&quot;UNCHECKED_CAST&quot;</span>)</span></span><br><span class="line">           <span class="keyword">return</span> BusScheduleViewModel(scheduleDao) <span class="keyword">as</span> T</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">throw</span> IllegalArgumentException(<span class="string">&quot;Unknown ViewModel class&quot;</span>)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 class 上 <code>control + o</code>，即可選擇要覆寫的 method</li>
</ul>
<p>現在您可以<u>使用 <code>BusScheduleViewModelFactory.create()</code> 對 <code>BusScheduleViewModelFactory</code> object 執行實例化(instantiate)</u>，這樣一來，您的 <strong>view model</strong> 便可具有<u>生命週期感知</u>特性，而無需 fragments 直接處理這項工作。</p>
<hr>
<h3 id="建立-database-class-及-pre-populate-database"><a href="#建立-database-class-及-pre-populate-database" class="headerlink" title="建立 database class 及 pre-populate database"></a>建立 database class 及 pre-populate database</h3><p>目前您已定義 models、DAO 及 view model，以供 fragments 存取 DAO，但您還需要指示 Room 如何處理所有這些 classes。此時 <code>AppDatabase</code> class 便可派上用場。一款使用 Room 的 Android app (例如您自己的 app)，可分類 <code>RoomDatabase</code> class ，並具有幾項主要工作。在您的 app 中，<code>AppDatabase</code> 需要：</p>
<ol>
<li>指定 database 中定義的 <strong>entities</strong>。</li>
<li>提供對各個 <strong>DAO class</strong> 的 <strong>single instance</strong> 的存取。</li>
<li>執行任何其他設定，例如<b>預先填入資料庫(pre-populate database)</b>。</li>
</ol>
<p>您可能想知道為什麼 Room 無法找到所有 entities 和 DAO object，很有可能是您的 app 擁有多個 database，或是存在許多<u>場景(scenarios)</u>，在這些場景下，library 無法假設您或開發人員的意圖(intent)。透過 <code>AppDatabase</code> class，您<u>可完全控管 models、DAO class，以及您想執行的任何 database 設定</u>。</p>
<ol>
<li>如要新增 <code>AppDatabase</code> class，請在 <code>database</code> package 中，建立名為 <code>AppDatabase.kt</code> 的新檔案，並定義繼承自 <code>RoomDatabase</code> 的新 abstract class <code>AppDatabase</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span>: <span class="type">RoomDatabase</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>database class 可方便其他 class 存取 <code>DAO</code> class。新增一個 abstract function，該 function 會 return  <code>ScheduleDao</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">scheduleDao</span><span class="params">()</span></span>: ScheduleDao</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>AppDatabase</code> class時，建議您<u>確保畫面上只有一個 database instance</u>，以避免出現競爭狀況或其他潛在問題。instance 儲存在 <strong>companion object</strong> 中，您也必須備妥一個 method，該方法不是 <u>return 現有 instance</u>，就是<u>首次建立 database</u>。必須在 companion object 中定義此項。請在 <code>scheduleDao()</code> function 正下方新增下列 <code>companion object</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>筆記：</strong><u><strong>companion object</strong> 只會存在一個 <strong>instance</strong></u>，也稱為 <a href="https://skyyen999.gitbooks.io/-study-design-pattern-in-java/content/singleton.html">Singleton Pattern</a>，目的為保證<u>一個 <strong>class</strong> 只會產生一個 <strong>object</strong></u>，而且要提供<u>存取該 object 的 <strong>method</strong></u>。</p>
          </div>

<p>在 <code>companion object</code> 中，新增 type 為 <code>AppDatabase</code> 的屬性 <code>INSTANCE</code>。這個 value 最初設為 <code>null</code>，因此 type 標有 <code>?</code> 標記。此外還標有 <code>@Volatile</code> 標記。本課程將詳細說明如何使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-volatile/">volatile</a> 屬性。不過，還是建議您將其用於 <code>AppDatabase</code> instance，以免發生潛在錯誤。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Volatile</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> INSTANCE: AppDatabase? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>在 <code>INSTANCE</code> 屬性下方，定義一個 function 以 return <code>AppDatabase</code> instance：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getDatabase</span><span class="params">(context: <span class="type">Context</span>)</span></span>: AppDatabase &#123;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE ?: synchronized(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">val</span> instance = Room.databaseBuilder(</span><br><span class="line">            context,</span><br><span class="line">            AppDatabase::<span class="keyword">class</span>.java,</span><br><span class="line">            <span class="string">&quot;app_database&quot;</span>)</span><br><span class="line">            .createFromAsset(<span class="string">&quot;database/bus_schedule.db&quot;</span>)</span><br><span class="line">            .build()</span><br><span class="line">        INSTANCE = instance</span><br><span class="line"></span><br><span class="line">        instance</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>getDatabase()</code> 的實作中，<u>如果已有 instance</u>，可以<u>使用 Elvis 運算子 return database 的現有 instance</u>，<u>如果尚未有 instance</u> 則<u>首次建立 database</u>。在這個 app 中，由於系統已預先填入 data，您也可<u>呼叫 <code>createFromAsset()</code> 來載入現有 data</u>。您可以在 project 的 <code>assets.database</code> package 中找到 <code>bus_schedule.db</code> 檔案。</p>
<ol start="4">
<li><strong>database class</strong> 就像 model class 和 <code>DAO</code> 一樣，需要<u>註解</u>來提供特定資訊。所有 <strong>entities type</strong> (<u>使用 <code>ClassName::class</code> 存取 type 本身</u>) 都會列在 <strong>array</strong> 中。database 也會提供 <strong>version number</strong>，請將這個 value 設為 <code>1</code>。請按照下列方式新增 <code>@Database</code> 註解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Database(entities = arrayOf(Schedule::class), version = 1)</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">AppDatabase</span>: <span class="type">RoomDatabase</span>() &#123;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>注意：</strong><u>每次變更 database 結構時，<b>version number</b> 就會遞增</u>。app 會檢查這個版本與 database 中的版本，判斷是否應執行遷移(migration)以及遷移(migration)方式。</p>
          </div>

<p>您已建立 <code>AppDatabase</code> class，只要再完成一個步驟就能開始使用。您需要提供 <u><code>Application</code> class 的自訂子類別</u>，並<u>建立 <code>lazy</code> 屬性來存放 <code>getDatabase()</code> 的結果</u>。</p>
<ol start="5">
<li>在 <code>com.example.busschedule</code> package 中，新增名為 <code>BusScheduleApplication.kt</code> 的 class，並繼承 <code>Application</code> class。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusScheduleApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>新增 <code>database</code> 屬性(type 為 <code>AppDatabase</code>)。這個屬性應<u>延遲處理</u>，並 <u>return 在 <code>AppDatabase</code> class 上呼叫 <code>getDatabase()</code> 的結果</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusScheduleApplication</span> : <span class="type">Application</span>() &#123;</span><br><span class="line">   <span class="keyword">val</span> database: AppDatabase <span class="keyword">by</span> lazy &#123; AppDatabase.getDatabase(<span class="keyword">this</span>) &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>最後，為了<u>確保使用 <code>BusScheduleApplication</code> class</u> (而非預設的 base class <code>Application</code>)，您必須稍微<u>變更 <strong>manifest</strong></u>。在 <code>AndroidMainifest.xml</code> 中，將 <code>android:name</code> 屬性設為 <code>com.example.busschedule.BusScheduleApplication</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:name</span>=<span class="string">&quot;com.example.busschedule.BusScheduleApplication&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>

<p>這時就可以設定 app 的 <strong>model</strong> 了。您可以開始<u>透過 UI 使用 Room 的 data</u>。在接下來幾頁中，您需要<u>為 app 的 <code>RecyclerView</code> 建立 <code>ListAdapter</code></u>，藉此顯示 <strong>bus schedule data</strong>，並以<u>動態(dynamically)</u>方式<u>回應 data 變更</u>。</p>
<hr>
<h3 id="建立-ListAdapter"><a href="#建立-ListAdapter" class="headerlink" title="建立 ListAdapter"></a>建立 ListAdapter</h3><p>現在，我們需要完成一些艱鉅的工作，並<u>將 model 彙整到 view 中</u>。以往使用 <code>RecyclerView</code> 時，您需要使用 <code>RecyclerView</code>。<code>Adapter</code> 可顯示<u>靜態(static) data list</u>。儘管特別適用於 Bus Schedule 等 app，但使用 database 時，往往遇到的都是<u>即時(real time)處理 data 的變更</u>。即使只有<u>一個 item 的內容有變更</u>，系統仍會<u>重新整理整個 recycler view</u>。但對大多數使用持續性的 app 來說，這種做法並不夠。</p>
<p><u>動態變更 list</u> 的替代方案稱為 <code>ListAdapter</code>。<code>ListAdapter</code> 使用 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/AsyncListDiffer">AsyncListDiffer</a> 來<u>判斷<b>舊 data list</b> 和<b>新 data list</b> 之間的差異</u>。之後，系統再<u>根據這兩份 list 之間的差異來更新 recycler view</u>。因此，處理頻繁更新的 data 時，recycler view 的執行效能會較高，就像在 database app 中經常遇到的情況一樣。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/f59cc2fd4d72c551_1920.png?hl=zh-tw" width="80%">

<p>由於這兩個畫面的 UI 都相同，因此您只需要<u>建立可同時用於這兩個畫面的單個 <code>ListAdapter</code></u> 即可。</p>
<ol>
<li><ul>
<li>建立新 class <code>BusStopAdapter.kt</code>。該 class 會繼承一個 generic  <code>ListAdapter</code>，其中會列出 UI 的 <u><code>Schedule</code> object list</u> 和 <u><code>BusStopViewHolder</code> class</u>。</li>
<li>對於 <code>BusStopViewHolder</code>，您也會<u>傳遞即將定義的 <code>DiffCallback</code> type</u>。</li>
<li><code>BusStopAdapter</code> class 本身也會<u>採用參數 <code>onItemClicked()</code></u>。系統會<u>在第一個畫面選取 item 時，使用此功能來處理 <strong>navigation</strong></u>，但在第二個畫面中，您只需<u>傳遞 <strong>empty function</strong></u> 即可。</li>
</ul>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusStopAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> onItemClicked: (Schedule) -&gt; <span class="built_in">Unit</span>) : ListAdapter&lt;Schedule, BusStopAdapter.BusStopViewHolder&gt;(DiffCallback) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>androidx.recyclerview.widget.ListAdapter</code></li>
</ul>
<ol start="2">
<li>與 recycler view adapter 類似，您需要具備 <strong>view holder</strong>，才能在程式碼中<u>存取透過 layout 檔案建立的 view</u>。接著只要建立 <code>BusStopViewHolder</code> class 並實作 <code>bind()</code> function，即可<u>將 <code>stopNameTextView</code> 的 text 設為 <strong>stop name</strong></u>，並<u>將 <code>arrivalTimeTextView</code> 的 text 設為<b>格式化日期(formatted date)</b></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusStopViewHolder</span>(<span class="keyword">private</span> <span class="keyword">var</span> binding: BusStopItemBinding): RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">    <span class="meta">@SuppressLint(<span class="string">&quot;SimpleDateFormat&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(schedule: <span class="type">Schedule</span>)</span></span> &#123;</span><br><span class="line">        binding.stopNameTextView.text = schedule.stopName</span><br><span class="line">        binding.arrivalTimeTextView.text = SimpleDateFormat(</span><br><span class="line">            <span class="string">&quot;h:mm a&quot;</span>).format(Date(schedule.arrivalTime.toLong() * <span class="number">1000</span>)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>覆寫並實作 <code>onCreateViewHolder()</code>，加載 layout，並<u>將 <code>onClickListener()</code> 設定為針對目前位置(position)的 item 呼叫 <code>onItemClicked()</code></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: BusStopViewHolder &#123;</span><br><span class="line">   <span class="keyword">val</span> viewHolder = BusStopViewHolder(</span><br><span class="line">       BusStopItemBinding.inflate(</span><br><span class="line">           LayoutInflater.from( parent.context),</span><br><span class="line">           parent,</span><br><span class="line">           <span class="literal">false</span></span><br><span class="line">       )</span><br><span class="line">   )</span><br><span class="line">   viewHolder.itemView.setOnClickListener &#123;</span><br><span class="line">       <span class="keyword">val</span> position = viewHolder.adapterPosition</span><br><span class="line">       onItemClicked(getItem(position))</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> viewHolder</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>覆寫並實作 <code>onBindViewHolder()</code>，同時<u>在指定位置(position) bind <strong>view</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">BusStopViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   holder.bind(getItem(position))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>記得您為 <code>ListAdapter</code> 指定的 <code>DiffCallback</code> class 嗎？這只是一個 <strong>object</strong>，能夠協助 <code>ListAdapter</code> 在<u>更新 list 時確定新舊 list 中哪些 item 不同</u>。為此，有以下兩種 method：</li>
</ol>
<ul>
<li><code>areItemsTheSame()</code> 透過僅<u>檢查 <strong>ID</strong> 來確認 <strong>object</strong> (database 的 <strong>row</strong>) 是否相同</u>。</li>
<li><code>areContentsTheSame()</code> 會<u>檢查所有屬性 (不只是 ID) 是否相同</u>。這些方法可讓 <code>ListAdapter</code> <u>判斷 <strong>inserted</strong>、<strong>updated</strong> 及 <strong>deleted</strong> 哪些 item</u>，以便更新相應 UI。</li>
</ul>
<p>新增 <strong>companion object</strong>，然後實作 <code>DiffCallback</code>，如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> DiffCallback = <span class="keyword">object</span> : DiffUtil.ItemCallback&lt;Schedule&gt;() &#123;</span><br><span class="line">       <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">Schedule</span>, newItem: <span class="type">Schedule</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> oldItem.id == newItem.id</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">Schedule</span>, newItem: <span class="type">Schedule</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">           <span class="keyword">return</span> oldItem == newItem</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這就是設定 adapter 的全部內容。您將在 app 的兩個畫面中使用。</p>
<ol>
<li>首先，您需要在 <code>FullScheduleFragment.kt</code> 中<u>取得 <strong>view model</strong> 的引用</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: BusScheduleViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   BusScheduleViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> BusScheduleApplication).database.scheduleDao()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著在 <code>onViewCreated()</code> 中，加入以下程式碼，以<u>設定 recycler view，並指派其 <strong>layout manager</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView = binding.recyclerView</span><br><span class="line">recyclerView.layoutManager = LinearLayoutManager(requireContext())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然後<u>指派 adapter 屬性</u>。傳入的<b>動作(action)</b>會使用 <u><code>stopName</code> navigate 所選的下一個畫面</u>，以便篩選 <strong>bus stops list</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> busStopAdapter = BusStopAdapter(&#123;</span><br><span class="line">   <span class="keyword">val</span> action = FullScheduleFragmentDirections.actionFullScheduleFragmentToStopScheduleFragment(</span><br><span class="line">       stopName = it.stopName</span><br><span class="line">   )</span><br><span class="line">   view.findNavController().navigate(action)</span><br><span class="line">&#125;)</span><br><span class="line">recyclerView.adapter = busStopAdapter</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最後，如要<u>更新 <strong>list view</strong></u>，請<u>呼叫 <code>submitList()</code></u>，然後<u>傳入該 <strong>view model</strong> 的 <strong>bus stops list</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// submitList() is a call that accesses the database. To prevent the</span></span><br><span class="line"><span class="comment">// call from potentially locking the UI, you should use a</span></span><br><span class="line"><span class="comment">// coroutine scope to launch the function. Using GlobalScope is not</span></span><br><span class="line"><span class="comment">// best practice, and in the next step we&#x27;ll see how to improve this.</span></span><br><span class="line">GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">   busStopAdapter.submitList(viewModel.fullSchedule())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>StopScheduleFragment</code> 中執行相同動作。首先，<u>取得 <strong>view model</strong> 的引用</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: BusScheduleViewModel <span class="keyword">by</span> activityViewModels &#123;</span><br><span class="line">   BusScheduleViewModelFactory(</span><br><span class="line">       (activity?.application <span class="keyword">as</span> BusScheduleApplication).database.scheduleDao()</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>然後在 <code>onViewCreated()</code> 中<u>設定 recycler view</u>。這次，您只要使用 <code>&#123;&#125;</code> 傳入 <strong>empty block</strong> (function) 即可。輕觸這個畫面中的 row 時，最好不會出現任何動作。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView = binding.recyclerView</span><br><span class="line">recyclerView.layoutManager = LinearLayoutManager(requireContext())</span><br><span class="line"><span class="keyword">val</span> busStopAdapter = BusStopAdapter(&#123;&#125;)</span><br><span class="line">recyclerView.adapter = busStopAdapter</span><br><span class="line"><span class="comment">// submitList() is a call that accesses the database. To prevent the</span></span><br><span class="line"><span class="comment">// call from potentially locking the UI, you should use a</span></span><br><span class="line"><span class="comment">// coroutine scope to launch the function. Using GlobalScope is not</span></span><br><span class="line"><span class="comment">// best practice, and in the next step we&#x27;ll see how to improve this.</span></span><br><span class="line">GlobalScope.launch(Dispatchers.IO) &#123;</span><br><span class="line">   busStopAdapter.submitList(viewModel.scheduleForStopName(stopName))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>Adapter 設定完畢之後，Room 便整合到 Bus Schedule app 中。花點時間執行該 app，畫面中會顯示 <strong>arrival times list</strong>。只要<u>輕觸任一 <strong>row</strong>，即可前往 <strong>detail</strong> 畫面</u>。</li>
</ol>
<div style="display:flex; justify-content:center;">
    <div style="float:left; width:40%; margin-right:10px;"> 
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/835e81ec4c32211_1920.png?hl=zh-tw">
    </div>
    <div style="float:left; width:40%;"> 
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-room-flow/img/67807de86ced0858_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div>
</div>

<hr>
<h3 id="使用-Flow-回應-data-變更"><a href="#使用-Flow-回應-data-變更" class="headerlink" title="使用 Flow 回應 data 變更"></a>使用 Flow 回應 data 變更</h3><p>雖然已設定 list view，如果呼叫了 <code>submitList()</code>，系統就能有效處理 data 變更，但您的 app 目前仍<u>無法處理<b>動態更新(dynamic updates)</b></u>。如果想親眼看一看，您可以嘗試開啟 App Inspector，並執行下列查詢，以便在 <code>schedule</code> table 中插入新 item。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">INSERT INTO schedule</span><br><span class="line">VALUES (<span class="literal">null</span>, <span class="string">&#x27;Winding Way&#x27;</span>, <span class="number">1617202500</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，系統不會在模擬器中執行任何作業。使用者會假設 data 並未變更。您需要<u>重新執行 app ，才能看到這些變更</u>。</li>
</ul>
<p>問題是<u>每個 <strong>DAO function</strong> 只 return <code>List&lt;Schedule&gt;</code> 一次</u>。即使更新基礎 data，系統也<u>不會呼叫 <code>submitList()</code> 來更新 UI</u>，而從使用者的角度來看，就好像什麼也沒發生。</p>
<p>如要修正此問題，您可以利用名為 <strong>asynchronous flow</strong> 的 Kotlin 功能 (通常簡稱為 <strong>Flow</strong>)，此功能可<u>讓 <strong>DAO</strong> 持續從 <strong>database</strong> 發出 <strong>data</strong></u>。如果 <u>inserted、updated 或 deleted item</u>，系統就會<u>將結果傳回 <strong>fragment</strong></u>。</p>
<p>使用名為 <code>collect()</code> 的 function 時，您可以<u>使用 <strong>Flow</strong> 發出的<b>新 value</b> 呼叫 <code>submitList()</code></u>，藉此<u>讓 <code>ListAdapter</code> 根據新 data 更新 UI</u>。</p>
<ol>
<li>如要在 Bus Schedule 中使用 Flow，請開啟 <code>ScheduleDao.kt</code>。如要轉換 <strong>DAO function</strong> 以 return <strong>Flow</strong>，只要<u>將 <code>getAll()</code> function 的 return type 變更為 <code>Flow&lt;List&lt;Schedule&gt;&gt;</code></u> 即可。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Flow&lt;&gt; 包起來，使 DAO 持續從 database 發出 data</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getAll</span><span class="params">()</span></span>: Flow&lt;List&lt;Schedule&gt;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>import <code>kotlinx.coroutines.flow.Flow</code></li>
</ul>
<ol start="2">
<li>同樣地，請更新 <code>getByStopName()</code> function 的 return value。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用 Flow&lt;&gt; 包起來，使 DAO 持續從 database 發出 data</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getByStopName</span><span class="params">(stopName: <span class="type">String</span>)</span></span>: Flow&lt;List&lt;Schedule&gt;&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>此外，也要更新 view model 中存取 <code>DAO</code> 的 function。將 <code>fullSchedule()</code> 和 <code>scheduleForStopName()</code> 的 return value 更新為 <code>Flow&lt;List&lt;Schedule&gt;&gt;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BusScheduleViewModel</span>(<span class="keyword">private</span> <span class="keyword">val</span> scheduleDao: ScheduleDao): ViewModel() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">fullSchedule</span><span class="params">()</span></span>: Flow&lt;List&lt;Schedule&gt;&gt; = scheduleDao.getAll()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">scheduleForStopName</span><span class="params">(name: <span class="type">String</span>)</span></span>: Flow&lt;List&lt;Schedule&gt;&gt; = scheduleDao.getByStopName(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最後，在 <code>FullScheduleFragment.kt</code> 中，當您<u>根據查詢結果呼叫 <code>collect()</code> 時，系統應更新 <code>busStopAdapter</code></u>。<u>由於 <code>fullSchedule()</code> 是 <strong>suspend function</strong>，因此需要從 <strong>coroutine</strong> 中呼叫</u>。取代這一行內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">busStopAdapter.submitList(viewModel.fullSchedule())</span><br></pre></td></tr></table></figure>

<p>這段程式碼會使用 <code>fullSchedule()</code> return 的 Flow。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycle.coroutineScope.launch &#123;</span><br><span class="line">   viewModel.fullSchedule().collect() &#123;</span><br><span class="line">       busStopAdapter.submitList(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>StopScheduleFragment</code> 中執行相同作業，但請將 <code>scheduleForStopName()</code> 呼叫改成以下內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lifecycle.coroutineScope.launch &#123;</span><br><span class="line">   viewModel.scheduleForStopName(stopName).collect() &#123;</span><br><span class="line">       busStopAdapter.submitList(it)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>完成上述變更後，您可以重新執行 app，驗證系統現在是否<u>即時(real time)處理 data 變更</u>。App 執行完畢後，請返回 App Inspector，並傳送下列查詢，<u>在 11:00 PM 前插入新的 arrival time</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">INSERT INTO schedule</span><br><span class="line">VALUES (<span class="literal">null</span>, <span class="string">&#x27;Winding Way&#x27;</span>, <span class="number">1617202500</span>)</span><br></pre></td></tr></table></figure>

<p>新 item 隨即會顯示在 list 頂端。</p>
<img src="https://i.imgur.com/SRXR0FP.png" width="40%">

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>SQL database 中的 tables 會在 <strong>Room</strong> 中<u>以稱為 <strong>entities</strong> 的 Kotlin classes 表示</u>。</li>
<li><strong>DAO(Data Access Object)</strong> 會提供<u>對應於與 database 互動的 SQL 指令的 methods</u>。</li>
<li><code>ViewModel</code> 是一種 <u>lifecycle 感知 component</u>，可<u>將 app <strong>data</strong> 與 <strong>view</strong> 分隔</u>。</li>
<li><code>AppDatabase</code> class 會指示 Room <u>要使用哪些 entities</u>、<u>提供 DAO 的存取權</u>，並<u>在建立 database 時執行任何設定</u>。</li>
<li><code>ListAdapter</code> 是<u>搭配 <code>RecyclerView</code> 使用的 adapter</u>，非常適合處理<u>動態更新的 list</u>。</li>
<li><strong>Flow</strong> 是一種 Kotlin 功能，可用於 <u>return <strong>data stream</strong></u>，可與 Room 搭配使用，<u>確保 UI 和 database 保持同步(sync)</u>。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
        <tag>companion object</tag>
        <tag>Navigation</tag>
        <tag>ViewModel</tag>
        <tag>suspend function</tag>
        <tag>CoroutineScope</tag>
        <tag>ListAdapter</tag>
        <tag>SQL</tag>
        <tag>Database Inspector</tag>
        <tag>App Inspector</tag>
        <tag>Room</tag>
        <tag>ORM</tag>
        <tag>DAO</tag>
        <tag>Entity</tag>
        <tag>Factory</tag>
        <tag>Flow</tag>
        <tag>Database Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(38)-SQL基礎</title>
    <url>/2023/12/16/Android%E7%AD%86%E8%A8%98-38-SQL%E5%9F%BA%E7%A4%8E/</url>
    <content><![CDATA[<blockquote>
<p>瞭解<b>關聯資料庫(relational databases)</b>的基本概念，並練習使用 Android Studio 中的<b>資料庫檢查器(Database Inspector)</b>執行 <u>SQL 查詢(queries)</u>。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>關聯資料庫(relational database)的結構：<b>資料表(tables)</b>、<b>資料欄(columns)</b> 和 <b>資料列(rows)</b></li>
<li>包含 <code>WHERE</code>、<code>ORDER BY</code>、<code>GROUP BY</code> 和 <code>LIMIT</code> 子句的 <code>SELECT</code> 陳述式</li>
<li>如何使用 SQL <u>insert</u>、<u>update</u> 及 <u>delete</u> 資料列(rows)</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="關聯資料庫總覽"><a href="#關聯資料庫總覽" class="headerlink" title="關聯資料庫總覽"></a>關聯資料庫總覽</h3><h4 id="什麼是關聯資料庫-relational-database-？"><a href="#什麼是關聯資料庫-relational-database-？" class="headerlink" title="什麼是關聯資料庫(relational database)？"></a>什麼是關聯資料庫(relational database)？</h4><p>在運算中，資料庫(database)只是可用電子方式存取和寫入的結構化資料集合。資料庫(database)可使用 Kotlin 儲存任何可在 app 中呈現的相同資訊。在行動裝置(mobile devices)上，<b>資料庫(database)</b>通常會用於<u>儲存執行中 app 的資料</u>，如此一來，<u>下次開啟 app 時即可存取該資料，而無須從網際網路等其他來源擷取資料</u>。這就是所謂的<b>資料持續性(data persistence)</b>。</p>
<p>談論<b>資料持續性(data persistence)</b>時，通常會聽到<b>關聯資料庫(relational database)</b>一詞。關聯資料庫(relational database)是一種常見的資料庫，可將資料整理成<u>資料表(tables)</u>、<u>資料欄(columns)</u>和<u>資料列(rows)</u>。編寫 Kotlin 程式碼時，您會<u>建立代表 objects 的 classes</u>。關聯資料庫中的 table 運作方式相同。除了呈現資料之外，table 也可以引用其他 table，以便為 table 建立關聯。常見的範例包括「學生(students)」、「老師(teachers)」和「課程(course)」資料表。課程可能只有一位老師，但學生可能會有許多課程。database 可呈現這些 table 之間的關係，因此您會經常聽到 relational database 一詞。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-sql-basics/img/ef61dd2663e4da82_1920.png">

<p>tables 間的關係可呈現實際關係(real world relationships)。</p>
<h4 id="Tables、columns-和-rows"><a href="#Tables、columns-和-rows" class="headerlink" title="Tables、columns 和 rows"></a>Tables、columns 和 rows</h4><p>建立 relational database 的第一步就是定義 tables，或您要呈現的 data。您也必須思考各 table 中要儲存哪些特定資訊。特定屬性會以 columns 表示。<strong>Columns</strong> 是由 <u>name</u> 和 <u>data type</u> 所組成。您已經熟悉在 Kotlin 中使用 classes 的屬性。您也可以用相同方式看待 SQL tables。<strong>Table</strong> 就如同 class 定義，用於說明您想要呈現的「內容(thing)」type。<strong>Column</strong> 是 table 中每個項目所建立「內容(thing)」的特定屬性。  </p>
<table>
  <thead>
    <tr>
      <th colspan="2">植物(Plant)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>INTEGER</td>
    </tr>
    <tr>
      <td>species</td>
      <td>TEXT (string)</td>
    </tr>
    <tr>
      <td>name</td>
      <td>TEXT (string)</td>
    </tr>
     <tr>
      <td>color</td>
      <td>TEXT (string)</td>
    </tr>
  </tbody>
</table>

<table>
  <thead>
    <tr>
      <th colspan="2">花園(Garden)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>INTEGER</td>
    </tr>
    <tr>
      <td>name</td>
      <td>TEXT (string)</td>
    </tr>
    <tr>
      <td>length</td>
      <td>INTEGER</td>
    </tr>
     <tr>
      <td>width</td>
      <td>INTEGER</td>
    </tr>
  </tbody>
</table>

<p><u>個別 table 項目(entries)稱為 rows</u>。這就如同 Kotlin 中 class 的 instance。<u>每個 row 的資料都會與各個 column 相對應</u>。Table 會提供範本，但這些 <u>rows 會定義 table 中實際儲存的資料</u>。</p>
<table>
<thead>
<tr>
<th align="left">id</th>
<th align="left">species</th>
<th align="left">name</th>
<th align="left">color</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Camellia Sinensis</td>
<td align="left">Tea Plant</td>
<td align="left">green</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Echinacea Purpurea</td>
<td align="left">Purple Coneflower</td>
<td align="left">purple</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Ferula Foetida</td>
<td align="left">Asafoetida</td>
<td align="left">green</td>
</tr>
</tbody></table>
<h4 id="主鍵-Primary-Key"><a href="#主鍵-Primary-Key" class="headerlink" title="主鍵(Primary Key)"></a>主鍵(Primary Key)</h4><p>在上述範例中，請留意 id 屬性的 column 形式。自然界中的植物物種(plant species)或您在 database 中呈現的任何內容，可能沒有方便編號的 id，但 data table 中的 rows 必須具有某種<u>唯一識別碼(unique identifier)</u>。這通常稱為<b>主鍵( primary key)</b>，而且 <u>table 中的每一列(row)皆不得重複</u>。當您需<u>引用其他 tables 內其中一個 data table 的 row </u>時，這項功能就非常實用。</p>
<p>舉例來說，還有另一個名為 garden 的 table，您希望將 <u>garden</u> 與其中所有的<u>植物物種(plant species)</u>建立關聯。您可以使用 plants table 的 <strong>primary key</strong>，<u>從 garden table 中的項目(entry)或 database 中的其他 table 引用 plant</u>。</p>
<p><strong>Primary keys</strong> 可在 relational database 中<u>建立關係(relationships)</u>。在本課程中，雖然您不會使用含有多個 table 的 database，但具有 <b>unique ID</b> 可協助<u>查詢(querying)</u>、<u>更新(updating)</u>及<u>刪除(deleting)</u> table 中的現有項目。</p>
<h4 id="Data-Types"><a href="#Data-Types" class="headerlink" title="Data Types"></a>Data Types</h4><p>如同定義 Kotlin classes 的屬性，<u>database 中的 columns 可為多種  data types 的其中一種</u>。Column 可以呈現 <u>character</u>、<u>string</u>、<u>number(帶或不帶小數)</u>，或 <u>binary data</u>。根據用途，其他 data (例如 <strong>dates</strong> 和 <strong>times</strong>) 可以用 <u>numerically</u> 或 <u>string</u> 表示。使用 <code>Room</code> 時，您主要使用的是 <strong>Kotlin types</strong>，但是其會<u>對應至幕後的 <strong>SQL types</strong></u>。</p>
<div class="note success">
            <p><strong>注意：</strong>如同在 Kotlin 中，database 中的 columns 可能含有不同的 data types。這些 types 與 Kotlin 中的 data types 不太一樣。如需更多資訊，請參閱<a href="https://www.w3schools.com/sql/sql_datatypes.asp">這項資源</a>，以瞭解 SQL 中的 basic data types。不過，在 <b>Room</b> 中使用 database 時，您無法直接使用這些 data types，而是<u>使用同等的 <b>Kotlin data types</b>，在程式碼中定義 data tables</u>。</p>
          </div>

<h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><p>無論是自行或使用 <code>Room</code> 等 library 存取 relational database，您都需要使用 <strong>SQL</strong>。</p>
<p>什麼是 SQL？SQL (有時發音為「sequel」) 代表 <u>Structured Query Language(結構化查詢語言)</u>，可讓您讀取和操控 relational database 中的 data。但別擔心，您不需要為了在 app 中實作持續性(persistence)，而學習全新的程式設計語言。不同於 Kotlin 等程式設計語言，<u>SQL 只包含幾種 statements，用於讀取(reading)及寫入(writing)資料庫</u>。瞭解基本格式後，只需在空格中填入您從 database 讀取(reading)或寫入(writing)的特定資訊即可。</p>
<p>以下為最常見的 SQL statements，以及您要使用的 statements。</p>
<table>
    <tr>
        <td>SELECT</td>
        <td>從 data table 取得特定資訊，並透過多種方式<u>篩選(filtered)</u>及<u>排序(sorted)</u>結果。</td>
    </tr>
    <tr>
        <td>INSERT</td>
        <td>在 table 中新增 row。</td>
    </tr>
    <tr>
        <td>UPDATE</td>
        <td>更新 table 中的現有 row。</td>
    </tr>
    <tr>
        <td>DELETE</td>
        <td>從 table 中移除現有的 row。</td>
    </tr>
</table>

<p>現在，您必須先具備 database，才能在 SQL 中執行任何操作。在下一個畫面中，您將會進行範例專案設定，其包含 database，可供您執行 SQL 查詢(queries)。</p>
<hr>
<h3 id="範例程式碼-Parks-database"><a href="#範例程式碼-Parks-database" class="headerlink" title="範例程式碼 - Parks database"></a>範例程式碼 - Parks database</h3><p>將要下載的範例程式碼與先前程式碼研究室的程式碼略有不同。我們會提供簡易的 Android Studio 專案，其可建立 database 讓您用於執行 <u>SQL 查詢(queries)</u>，而非在現有專案上進行建構。執行 app 一次後，您即可<u>使用名為<b>資料庫檢查器(Database Inspector)</b>的 Android Studio tool 存取 database</u>。</p>
<div class="note success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-sql-basics-app">https://github.com/google-developer-training/android-basics-kotlin-sql-basics-app</a><br><strong>分支版本：</strong>main</p>
          </div>

<p>在前往下一個部分之前，請先完成下列步驟，確保您已透過範例專案完成相關設定。</p>
<ol>
<li>執行 application。app 應會顯示如下所示的單一畫面。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-sql-basics/img/3c62c10fad7c0136_1920.png?hl=zh-tw" width="40%">

<ol start="2">
<li><p>在 Android Studio 中，前往「View」&gt;「Tool Windows」&gt;「Database Inspector」，開啟 Database Inspector。</p>
</li>
<li><p>您應該會在底部看到標示「Database Inspector」的新分頁標籤(tab)。載入可能需要幾秒鐘的時間，但您可在左側看到含有 data tables 的 list，您可選取以執行查詢(queries)。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-sql-basics/img/8c2b12249b4f652a_1920.png?hl=zh-tw">

<div class="note success">
            <p><strong>注意：</strong>如果您使用 <u>Android Studio 2020.3.1 Arctic Fox</u>，可前往「View」&gt;「Tool」&gt;「App Inspection」存取 Database Inspector。</p>
          </div>

<h3 id="基本-SELECT-statements"><a href="#基本-SELECT-statements" class="headerlink" title="基本 SELECT statements"></a>基本 SELECT statements</h3><p>針對下列練習，您必須在<u>資料庫檢查器(Database Inspector)</u>中執行查詢。請務必從左側窗格中選取正確的資料表 (<code>park</code>)，然後按一下「Open New Query Tab」按鈕，接著就會看到可輸入 SQL 指令的文字方塊。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-sql-basics/img/bb06b5ce9ac4ba72_1920.png?hl=zh-tw">

<p>SQL statement 是用於存取(accesses) (讀取(reading)或寫入(writing)) database 的指令，類似程式碼行。在 SQL 中，您可執行的最簡單操作為取得 table 中的所有 data。為此，請先使用 <code>SELECT</code> 字詞，代表您要讀取 data。接著加上星號 (<code>*</code>)。您可以在此處指定要選取的 columns，使用 <code>*</code> 代表選取所有資料欄。然後使用 <code>FROM</code> 關鍵字，後面加上 data table 的名稱 (<code>park</code>)。在 Database Inspector 中執行下列指令，並觀察整個 table 的所有 columns 與 rows。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>如果您只想選取特定 column，而非 table 中的所有 columns，您可以指定 column 名稱。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> city <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>您也可以選取多個特定 columns，並以半形逗號分隔。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, established, city <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>有時候，您不一定要選取 database 中的所有 rows。您可以新增 SQL statement 的子句部分，以進一步縮小結果範圍。</p>
<p>其中一個子句是 <code>LIMIT</code>，可讓您<u>限制傳回的 rows 數量</u>。因此，以下查詢只會傳回前五個，不會傳回全部 23 個結果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> park</span><br><span class="line">LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>最常見且實用的子句之一就是 <code>WHERE</code> 子句。<code>WHERE</code> 子句可讓您根據一或多個 columns 篩選結果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> &quot;national_park&quot;</span><br></pre></td></tr></table></figure>

<div class="note success">
            <p><strong>注意：</strong>有別於 Kotlin，由於 <b>&#x3D;</b> 運算子用於指派，而 <b>&#x3D;&#x3D;</b> 則用於比較，因此在 SQL 中只能使用一個等號來比較兩個值。</p>
          </div>

<p>此外，也有「不等於」(<code>!=</code>) 運算子。以下查詢會列出不屬於 <code>recreation_area</code>，且佔地超過 100,000 英畝的所有公園。使用 <code>WHERE</code> 子句時，您也可以使用 <code>AND</code> 或 <code>OR</code> 等 Boolean 運算子，以新增多個條件。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">!=</span> &quot;recreation_area&quot;</span><br><span class="line"><span class="keyword">AND</span> area_acres <span class="operator">&gt;</span> <span class="number">100000</span></span><br></pre></td></tr></table></figure>

<h4 id="練習"><a href="#練習" class="headerlink" title="練習"></a>練習</h4><p>SQL 查詢相當適合回答各種資料相關問題，而最佳的練習做法就是自行編寫查詢。接下來幾個步驟，您將可編寫查詢，以回答特定問題。請務必先在 Database Inspector 中進行測試，再繼續進行操作。</p>
<div class="note primary">
            <p><strong>問題 1：</strong><br>請編寫 SQL 查詢，取得訪客(visitors)少於 1,000,000 人的所有 parks 的 names。</p>
          </div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">from</span> park <span class="keyword">WHERE</span> park_visitors <span class="operator">&lt;</span> <span class="number">1000000</span></span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/xpL1Jh5.png" width="70%">

<hr>
<h3 id="常見的-SQL-函式"><a href="#常見的-SQL-函式" class="headerlink" title="常見的 SQL 函式"></a>常見的 SQL 函式</h3><p>您編寫的第一個查詢只會傳回 database 中的所有 rows。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>不過，您可能不希望傳回冗長的 results list。SQL 也提供匯總函式，可協助您將 data 縮減為單一個有意義的值。舉例來說，假設您想知道 park table 中的 rows 數量。如果您不使用 <code>SELECT * ...</code>，而是改用 <code>COUNT()</code> 函式並傳遞 <code>*</code> (所有 rows) 或 column 名稱，查詢將會<u>傳回所有 rows 的數量</u>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>另一個實用的匯總函式為 <code>SUM()</code> 函式，可用於<u>加總 columns 中的值</u>。此查詢只會篩選 <code>national parks</code> (由於這是 <code>park_visitors</code>  column 非空值的唯一項目(entries))，並將每個 park 的總訪客(visitors)數加總。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(park_visitors) <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> &quot;national_park&quot;</span><br></pre></td></tr></table></figure>

<p>值得注意的是，您仍然可以在空值中使用 <code>SUM()</code>，但值將會視為零。以下查詢會傳回上述相同結果。但仍建議您盡量具體指定，以避免在應用程式中使用 SQL 時出現錯誤。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(park_visitors) <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>除了匯總值之外，還提供其他實用的函式 (例如 <code>MAX()</code> 和 <code>MIN()</code>)，以分別取得最大或最小值。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">MAX</span>(area_acres) <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> type <span class="operator">=</span> <span class="string">&#x27;national_park&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="取得-DISTINCT-值"><a href="#取得-DISTINCT-值" class="headerlink" title="取得 DISTINCT 值"></a>取得 DISTINCT 值</h4><p>您可能會注意到，在某些 rows 中，此欄與其他 rows 的值相同。舉例來說，type column 值的數量有限。您可以使用 <code>DISTINCT</code> 關鍵字，<u>排除查詢結果中的重複值</u>。例如，如要取得 type column 的所有不重複值，您可以使用以下查詢。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> type <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<p>您也可以在匯總函式中使用 <code>DISTINCT</code>，如此即可直接傳回計數(count)，而不必列出不重複的 <code>type</code> 並自行計算。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> type) <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>

<h4 id="練習-1"><a href="#練習-1" class="headerlink" title="練習"></a>練習</h4><div class="note primary">
            <p><strong>問題 2：</strong><br>請編寫 SQL 查詢，取得 park table 中<u>不同城市(distinct cities)的數量</u></p>
          </div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(<span class="keyword">DISTINCT</span> city) <span class="keyword">FROM</span> park</span><br></pre></td></tr></table></figure>
<img src="https://i.imgur.com/JvDOdoF.png" width="80%">

<div class="note primary">
            <p><strong>問題 3：</strong><br>請編寫 SQL 查詢，取得 <u>San Francisco parks 的遊客(visitors)總數</u>。</p>
          </div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="built_in">SUM</span>(park_visitors) <span class="keyword">FROM</span> park <span class="keyword">WHERE</span> city <span class="operator">=</span> &quot;San Francisco&quot;</span><br></pre></td></tr></table></figure>
<img src="https://i.imgur.com/e8lom9u.png">

<hr>
<h3 id="排序-ordering-及分組-grouping-查詢結果"><a href="#排序-ordering-及分組-grouping-查詢結果" class="headerlink" title="排序(ordering)及分組(grouping)查詢結果"></a>排序(ordering)及分組(grouping)查詢結果</h3><p>在先前的範例中，要找出特定項目(entry)並不容易。所幸，您也可以<u>使用 <code>ORDER BY</code> 子句排序 <code>SELECT</code> statement 的結果</u>。您可<u>在 <code>WHERE</code> 子句後 (如果有) 的查詢結尾新增 <code>ORDER BY</code> 子句</u>，並<u>指定要做為排序依據的 column 名稱</u>。以下範例會取得 database 中每個 park 的名稱，並依字母順序排列結果。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name</span><br></pre></td></tr></table></figure>

<p><u>根據預設，系統會按遞增順序排序結果</u>，但您可以將 <code>ASC</code> 或 <code>DESC</code> keyword 新增至 Order by 子句，以遞增或遞減順序加以排序。您不需要指定 <code>ASC</code>，因為第一個查詢會以遞增順序列出結果，但如要以遞減順序取得結果，請將 <code>DESC</code> keyword 新增至 <code>ORDER BY</code> 子句結尾。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<p>您還可以<u>依 column 將結果分組(group)</u>，以便閱讀。<u>在 <code>ORDER BY</code> 子句 (如果有) 前，您可以視需要指定 <code>GROUP BY</code> 子句和 column</u>。這會將結果分割為 <code>GROUP BY</code> 中 column 特定的子集，每一欄(column)的結果會<u>根據查詢的其餘部分進行篩選(filtered)及排序(ordered)</u>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> type, name <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> type</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> name</span><br></pre></td></tr></table></figure>

<p>這最容易透過範例理解。您不需計算 database 中的所有 parks 數量，即可得知<u>每個 type 的 parks 數量</u>，並取得<u>每種 type 的個別數量(separate count)</u>。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> type, <span class="built_in">COUNT</span>(<span class="operator">*</span>) <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> type</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> type</span><br></pre></td></tr></table></figure>

<h4 id="練習-2"><a href="#練習-2" class="headerlink" title="練習"></a>練習</h4><div class="note primary">
            <p><strong>問題 4：</strong><br>查詢<u>排名前 5 的 park name</u>，和其<u>遊客(visitors)最多的遊客數量(visitor count)</u>(<u>按遞減排序) 編寫一個 SQL 查詢</u>。</p>
          </div>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> name, park_visitors <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> park_visitors <span class="keyword">DESC</span></span><br><span class="line">LIMIT <span class="number">5</span></span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/BxKpBUF.png">

<hr>
<h3 id="插入及刪除-rows"><a href="#插入及刪除-rows" class="headerlink" title="插入及刪除 rows"></a>插入及刪除 rows</h3><p>您必須能夠寫入 data，才能使用 <code>Room</code> 完整發揮 Android 的持續性資料功能。除了查詢 database 之外，您也可以使用 SQL statements <u>插入(inserting)</u>、<u>更新(updating)</u>及<u>刪除(deleting)</u> <strong>rows</strong>。稍後在課程 2 中學習使用 <code>Room</code> 寫入資料時，將會需要具備此基本知識。</p>
<h4 id="INSERT-statement"><a href="#INSERT-statement" class="headerlink" title="INSERT statement"></a>INSERT statement</h4><p>如要新增 row，請使用 <code>INSERT</code> statement。<code>INSERT</code> statement 後方是 <code>INTO</code> keyword，以及您想新增 row 的 table 名稱。<u>在 <code>VALUES</code> keyword 之後，您必須將每個 column 的值加上括號 <code>()</code>，每個值以半形逗號隔開</u>。<code>INSERT</code> statement 的格式如下。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name</span><br><span class="line"><span class="keyword">VALUES</span> (column1, column2, ...)</span><br></pre></td></tr></table></figure>

<p>如要在 <code>park</code> table 中新增 row，<code>INSERT</code> statement 將如下所示。這些值的順序會和為 <code>park</code> table 所定義的 columns 順序相符。請注意，系統不會指定部分 data。這目前沒關係，在您插入(inserted) row 後，可隨時更新(update) row。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> park</span><br><span class="line"><span class="keyword">VALUES</span> (<span class="keyword">null</span>, <span class="string">&#x27;Googleplex&#x27;</span>, <span class="string">&#x27;Mountain View&#x27;</span>, <span class="number">12</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="string">&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>另請注意，您針對 ID 傳入 <code>null</code>。雖然可以提供特定編號，但這實際上並不便利，因為 app 必須追蹤最新的 ID，確保無重複。但是，您可以設定 database，<u>使主鍵(primary key)自動增加</u>，如此處操作。如此一來，當您傳入 <code>null</code> 時，系統就會自動選擇下一個 ID。</p>
<p>確認已使用 <code>WHERE</code> 子句建立項目，以指定名為 “Googleplex” 的 park。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Googleplex&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="UPDATE-statement"><a href="#UPDATE-statement" class="headerlink" title="UPDATE statement"></a>UPDATE statement</h4><p>Row 建立後，您可以隨時變更其中的內容。使用 <code>UPDATE</code> statement 即可進行變更。如同您看過的所有其他 SQL statement，您必須先指定 table 名稱。在 <code>SET</code> 子句中，只需設定您想要變更為新值的 column 即可。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> table_name</span><br><span class="line"><span class="keyword">SET</span> column1 <span class="operator">=</span> ...,</span><br><span class="line">column2 <span class="operator">=</span> ...,</span><br><span class="line">...</span><br><span class="line"><span class="keyword">WHERE</span> column_name <span class="operator">=</span> ...</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果是 Googleplex 項目(entry)，系統會更新現有的屬性，並在其他欄位(fields)填入內容 (這些欄位(fields)先前具有值，但為空白字串(empty string) <code>&quot;&quot;</code>)。您可以使用 <code>UPDATE</code> statement 一次更新多個 (或全部) 欄位(fields)。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> park</span><br><span class="line"><span class="keyword">SET</span> area_acres <span class="operator">=</span> <span class="number">46</span>,</span><br><span class="line">established <span class="operator">=</span> <span class="number">1088640000</span>,</span><br><span class="line">type <span class="operator">=</span> <span class="string">&#x27;office&#x27;</span></span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Googleplex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>查看查詢結果中反映的更新</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Googleplex&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="DELETE-statement"><a href="#DELETE-statement" class="headerlink" title="DELETE statement"></a>DELETE statement</h4><p>最後，您也可以使用 SQL 指令刪除 database 中的 rows。請再次指定 table 名稱，如同使用 <code>SELECT</code> statement，您可以使用 <code>WHERE</code> 子句為要刪除的 rows 提供條件。由於 <code>WHERE</code> 子句可以比對多個 rows，因此只需一個指令就能刪除多個 rows。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> table_name</span><br><span class="line"><span class="keyword">WHERE</span> <span class="operator">&lt;</span>column_name<span class="operator">&gt;</span> <span class="operator">=</span> ...</span><br></pre></td></tr></table></figure>

<p>由於 Googleplex 並非 national park，請嘗試使用 <code>DELETE</code> statement 從 database 中移除此項目。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Googleplex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>進行驗證，確認使用 <code>SELECT</code> statement 刪除 rows。查詢不應傳回任何結果，代表所有名為「Googleplex」的 rows 都已成功刪除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> park</span><br><span class="line"><span class="keyword">WHERE</span> name <span class="operator">=</span> <span class="string">&#x27;Googleplex&#x27;</span></span><br></pre></td></tr></table></figure>

<p>這些就是<u>插入(inserting)、更新(updating)及刪除(deleting) data</u> 的所有步驟。您只需瞭解要執行 SQL 指令的格式，並指定符合 database 中 columns 的值。我們在下一個程式碼研究室中介紹 <code>Room</code> 時，重點在於<u>從 database 進行讀取(reading)</u>。<u>插入(inserting)、更新(updating)及刪除(deleting) data</u> 的步驟將於課程 2 中詳細說明。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Data persistence</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>SQL</tag>
        <tag>Database</tag>
        <tag>Relational Database</tag>
        <tag>Database Inspector</tag>
        <tag>App Inspector</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(37)-專案：Amphibians應用程式</title>
    <url>/2023/12/15/Android%E7%AD%86%E8%A8%98-37-%E5%B0%88%E6%A1%88%EF%BC%9AAmphibians%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>採用會顯示不同兩棲動物物種資訊的 app，再使用網路、JSON 剖析和 view model 的知識，讓該 app 使用來自網路的資料。App 會從這個專案的自訂 API 中取得資料，然後顯示於 list view。</p>
</blockquote>
<p><strong>建構項目</strong><br>使用 <strong>Retrofit</strong> 和 <strong>Moshi</strong> 以及適當的 error 處理方式，在 app 中實作網路。</p>
<span id="more"></span>

<hr>
<h3 id="完成的-app-overview"><a href="#完成的-app-overview" class="headerlink" title="完成的 app overview"></a>完成的 app overview</h3><p>歡迎參與專案：Amphibians！</p>
<p>到目前為止，您建構的所有 app 都依賴儲存在本機的 data。這次，您會採用顯示不同<u>兩棲動物(amphibian)物種(species)資訊</u>的 app，並運用您對<u>網路</u>、<u>JSON 剖析(parsing)</u>及 <u>view models</u> 的知識，讓該 app 能夠<u>使用來自網路的資料</u>。App 會從這個專案的<u>自訂 API 中取得 data</u>，然後顯示於 <strong>list view</strong>。</p>
<p>在最後一個 app 中，使用者看到的第一個畫面，會顯示 <strong>recycler view</strong> 中各個<u>物種(species)的名稱</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-amphibians/img/7697a4e0c9bb5a76_1920.png?hl=zh-tw" width="40%">

<p>輕觸 <strong>list item</strong> 即可前往<u>詳細資料(detail)畫面</u>，當中也會顯示<u>物種名稱(species’ name)</u>和<u>詳細描述(detailed description)</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-amphibians/img/9797605a20dc68d1_1920.png?hl=zh-tw" width="40%">

<p>雖然已為您建立這個 app 的 UI 部分，但執行範例專案並不會顯示任何 data。您必須實作 app 的網路(networking)部分，layout 中才會顯示已下載的 data。</p>
<hr>
<h3 id="開始操作"><a href="#開始操作" class="headerlink" title="開始操作"></a>開始操作</h3><h4 id="下載專案程式碼"><a href="#下載專案程式碼" class="headerlink" title="下載專案程式碼"></a>下載專案程式碼</h4><p>請注意，資料夾名稱是 <code>android-basics-kotlin-amphibians-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-amphibians-app/tree/main">https://github.com/google-developer-training/android-basics-kotlin-amphibians-app/tree/main</a><br><strong>具有範例程式碼的分支版本名稱：</strong><b>main</b></p>
          </div>

<h4 id="實作-API-服務"><a href="#實作-API-服務" class="headerlink" title="實作 API 服務"></a>實作 API 服務</h4><p>App 會列出 network 中的<b>兩棲動物資料(amphibian data)</b>，這些 amphibian data 來自 <u>API 傳回的 JSON object</u>。請看看 <code>network</code> package 中的 <code>Amphibian.kt</code> 檔案。這個 class 會建立單一 amphibian object 的 models，並會由 API 傳回該 object 的 list。每種兩棲動物(amphibian)都有三個屬性：<u>名稱(name)</u>、<u>類型(type)</u>和<u>說明(description)</u>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Amphibian</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String,</span><br><span class="line">    <span class="keyword">val</span> type: String,</span><br><span class="line">    <span class="keyword">val</span> description: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>此 API 的後端相當簡單。您需要取得兩項重要資訊，才能存取 amphibians data，一個是 <u><strong>base URL</strong></u>，另一個則是<u>用於取得 <strong>amphibians list</strong> 的 <strong>endpoint</strong></u>。</p>
<ol>
<li>Base URL：<a href="https://developer.android.com/courses/pathways/android-basics-kotlin-unit-4-pathway-2/">https://developer.android.com/courses/pathways/android-basics-kotlin-unit-4-pathway-2/</a></li>
<li>GET amphibians list：<code>android-basics-kotlin-unit-4-pathway-2-project-api.json</code></li>
</ol>
<div class="note no-icon success">
            <p><strong>提示：</strong>您可以在瀏覽器中檢視<a href="https://developer.android.com/courses/pathways/android-basics-kotlin-unit-4-pathway-2/android-basics-kotlin-unit-4-pathway-2-project-api.json">原始 JSON</a>。</p>
          </div>

<p>Project 已有 <strong>Retrofit</strong> 和 <strong>Moshi</strong> dependencies。您可在 <code>network</code> package 中找到 <code>AmphibianApiService.kt</code> 檔案。檔案含有幾則 <code>TODO</code> 留言。請執行以下五項工作，以實作 amphibians app：</p>
<ol>
<li>建立變數(variable)來儲存 API 的 <strong>base URL</strong>。</li>
<li>使用 <strong>Kotlin Adapter Factory</strong> 建構 <b>Moshi object</b>，此模式會利用 Retrofit 來剖析 JSON。</li>
<li>使用 <strong>Moshi converter</strong> 建構 Retrofit instance。</li>
<li>使用 <code>suspend</code> 函式為每個 API 方法實作 <code>AmphibianApiService</code> interface (這個 app 只有一個方法，即用於取得 amphibians list)。</li>
<li>建立 <code>AmphibianApi</code> object 以顯示採用 <code>AmphibianApiService</code> interface 的延遲初始化(lazy-initialized) Retrofit service。</li>
</ol>
<h4 id="實作-ViewModel"><a href="#實作-ViewModel" class="headerlink" title="實作 ViewModel"></a>實作 ViewModel</h4><p>實作 API 後，您要向 ampimbians API 發出 request，然後儲存所有需要顯示的 values。您需要在 <code>ui</code> package 中的 <code>AmphibianViewModel.kt</code> class 中執行這項操作。</p>
<p>您會發現，class 宣告上方是名為 <code>AmphibianApiStatus</code> 的 enum。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">AmphibianApiStatus</span> &#123;LOADING, ERROR, DONE&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>三個可能的 values 為 <code>LOADING</code>、<code>ERROR</code> 和 <code>DONE</code>，用來向使用者顯示要求的 status。</li>
</ul>
<p>在 <code>AmphibianViewModel.kt</code> class 中，您必須<u>實作部分 <code>LiveData</code> 變數</u>、<u>與 API 互動的函式</u>，以及用於<u>處理 detail 頁面上設定 amphibian 的函式</u>。</p>
<ol>
<li>新增一個 <code>_status</code> private <code>MutableLiveData</code> 變數，可用於保留 <code>AmphibianApiStatus</code> enum 和相關狀態的 backing 屬性 <code>status</code>。</li>
<li>對 type <code>List&lt;Amphibian&gt;</code> 的 amphibians list 新增 <code>amphibians</code> 變數和 private backing 屬性 <code>_amphibians</code>。</li>
<li>為所選的 type <code>LiveData&lt;Amphibian&gt;</code> amphibian object 新增 type <code>MutableLiveData&lt;Amphibian&gt;</code> 的 <code>_amphibian</code> 變數和 backing 屬性 <code>amphibian</code>。此變數會用於儲存 detail 畫面上已選定的 amphibian。</li>
<li>定義名為 <code>getAmphibianList()</code> 的函式。使用 <code>ViewModelScope</code> 啟動 coroutine，在 coroutine 中，透過呼叫 Retrofit service 的 <code>getAmphibians()</code> 方法來執行 GET request 下載 amphibian data。您需要使用 <code>try</code> 和 <code>catch</code> 來妥善處理 errors。在提出 request 之前，請將 <code>_status</code> 的 value 設為 <code>AmphibianApiStatus.LOADING</code>。如果 request 成功，<code>_amphibians</code> 應設為來自 server 的 amphibians list，而 <code>_status</code> 應設為 <code>AmphibianApiStatus.DONE</code>。如果發生 error，<code>_amphibians</code> 應設為 empty list，而 <code>_status</code> 應設為 <code>AmphibianApiStatus.ERROR</code>。</li>
<li>實作 <code>onAmphibianClicked()</code> 方法，將您定義的 <code>_amphibian</code> 屬性設為傳遞到 function 的<u>引數(argument)</u>。在選取 amphibian 時已呼叫此方法，因此 amphibian 的資訊便會顯示在 detail 畫面上。</li>
</ol>
<h3 id="從-ViewModel-更新-UI"><a href="#從-ViewModel-更新-UI" class="headerlink" title="從 ViewModel 更新 UI"></a>從 ViewModel 更新 UI</h3><p>實作 <code>ViewModel</code> 後，您只需要編輯 fragment classes 和 layout 檔案，即可使用 <strong>data bindings</strong>。</p>
<ol>
<li><code>AmphibianListFragment</code> 中已引用 <code>ViewModel</code>。在 <code>onCreateView()</code> 方法中，加載 layout 後，只需從 <code>ViewModel</code> 呼叫 <code>getAmphibianList()</code> 方法即可。</li>
<li>在 <code>fragment_amphibian_list.xml</code> 中，data binding 變數的<code> &lt;data&gt;</code> tags 已新增到 layout 檔案。只需實作 <code>TODO</code>，UI 就會根據 view model 更新。為 <code>listData</code> 和 <code>apiStatus</code> 設定適當的 bindings。</li>
<li>在 <code>fragment_amphibian_detail.xml</code> 中實作 <code>TODO</code>，為 amphibian 的名稱(name)和描述(description) 設定適當的 text 屬性。</li>
</ol>
<hr>
<h3 id="執行-app"><a href="#執行-app" class="headerlink" title="執行 app"></a>執行 app</h3><div class="video-container"><iframe src="https://player.vimeo.com/video/895222504" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<div class="note danger">
            <p><strong>當編譯失敗時：</strong></p><ul><li>更新 <code>compileSdkVersion</code> 和 <code>targetSdkVersion</code></li><li>更新 <code>dependencies</code> 中的 library version</li><li>點開 Project Structure -&gt; 更新 <strong>Gradle Version</strong></li><li>點開 Upgrade Assistant -&gt; 更新 <strong>Android Gradle Plugin(AGP) Version</strong></li></ul>
          </div>

<hr>
<h3 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h3><img src="https://i.imgur.com/KuHSJgw.png">]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Connect to the internet</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Layout</tag>
        <tag>Automated Testing</tag>
        <tag>RecyclerView</tag>
        <tag>Fragment</tag>
        <tag>LiveData</tag>
        <tag>MutableLiveData</tag>
        <tag>Data Binding</tag>
        <tag>suspend function</tag>
        <tag>Internet</tag>
        <tag>RESTful</tag>
        <tag>URI</tag>
        <tag>URL</tag>
        <tag>Retrofit</tag>
        <tag>Moshi</tag>
        <tag>Converter</tag>
        <tag>Enum Classes</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(36)-透過breakpoints來debug</title>
    <url>/2023/12/13/Android%E7%AD%86%E8%A8%98-36-%E9%80%8F%E9%81%8Ebreakpoints%E4%BE%86debug/</url>
    <content><![CDATA[<blockquote>
<p>瞭解如何在 debugging 時使用中斷點(breakpoints)，並留意特定變數。</p>
</blockquote>
<p>到目前為止，大多數的新手 developers 可能已經會使用 Log statements 進行 debugging。完成單元 1 後，您將學到如何解讀 <u>stack traces</u> 和研究 <u>error messages</u>。雖然這兩種工具都是功能強大的 debugging 工具，但現代 IDE 提供更多功能，讓您的 debugging 流程更有效率。</p>
<p>在本課程中，您將瞭解 <u>Android Studio 整合的 debugger</u>、如何<u>暫停執行 app</u>，以及<u>一次執行單行程式碼，找出 bug 的確切來源</u>。此外，您將學會如何使用一項稱為 <strong>Watches</strong> 的功能以及<u>如何追蹤特定變數</u>，而不必新增特定的 log statements。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>如何將 debugger 附加到運作中的 app。</li>
<li>使用<b>中斷點(breakpoints)</b>來暫停執行中的 app，逐行檢查程式碼。</li>
<li>將<u>條件運算式</u>加入<b>中斷點(breakpoints)</b>以節省 debugging 時間。</li>
<li>在 Watches 窗格中新增變數，以輔助 debugging。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="建立新-project"><a href="#建立新-project" class="headerlink" title="建立新 project"></a>建立新 project</h3><p>我們不會一開始就對複雜的大型 app 進行偵錯，而是會從空白專案著手並介紹一些錯誤程式碼，藉此展示 Android Studio 中的偵錯工具。</p>
<p>建立新的 Android Studio 專案，即可開始使用。</p>
<ol>
<li><p>在「Select a Project Template」(選取專案範本) 畫面中選擇「Empty Views Activity」(空白活動)。</p>
</li>
<li><p>將應用程式命名為「Debugging」，接著確認語言已設為 Kotlin，其他項目則保持不變。</p>
</li>
<li><p>系統將開啟一項新的 Android Studio 專案，並顯示一個名為 <code>MainActivity.kt</code> 的檔案。</p>
</li>
</ol>
<h4 id="回報-bug"><a href="#回報-bug" class="headerlink" title="回報 bug"></a>回報 bug</h4><p>還記得單元 1 中 debugging 課程的除以零範例嗎？在迴圈(loop)的最終迭代(iteration)中，app 嘗試執行除以零時，因為不可能除以零，因此 app 當機，並彈出 <code>java.langArithmeticException</code>。藉由檢查 stack trace 找出 bug 並予以解決，並且使用 log statements 驗證該假設。</p>
<p>由於您已經熟悉那個範例，因此將用於示範中斷點(breakpoints)的使用方式。breakpoints 會逐行處理程式碼，不必先新增 log statements 或重新執行 app。</p>
<ol>
<li>開啟 <code>MainActivity.kt</code>，並將程式碼替換為以下程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.myapplication</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       setContentView(R.layout.activity_main)</span><br><span class="line">       division()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">division</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">val</span> numerator = <span class="number">60</span></span><br><span class="line">       <span class="keyword">var</span> denominator = <span class="number">4</span></span><br><span class="line">       repeat(<span class="number">5</span>) &#123;</span><br><span class="line">           Log.v(TAG, <span class="string">&quot;<span class="subst">$&#123;numerator / denominator&#125;</span>&quot;</span>)</span><br><span class="line">           denominator--</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行 app。觀察 app 是否如預期當機。</li>
</ol>
<img src="https://i.imgur.com/HK62bEE.png">

<hr>
<h3 id="使用-breakpoints-debug"><a href="#使用-breakpoints-debug" class="headerlink" title="使用 breakpoints debug"></a>使用 breakpoints debug</h3><p>瞭解 logging 後，您已學會如何有策略地放置 logs，以便識別錯誤及驗證問題是否已修正。然而，在面對並非您導入的 bugs 時，我們<u>未必能明確得知要將 log statements 放置在何處</u>，或是<u>要輸出哪些變數</u>。通常，您只能在<u>執行階段(runtime)</u>找到這項資訊。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">division</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numerator = <span class="number">60</span></span><br><span class="line">    <span class="keyword">var</span> denominator = <span class="number">4</span></span><br><span class="line">    repeat(<span class="number">5</span>) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;<span class="subst">$&#123;numerator / denominator&#125;</span>&quot;</span>)</span><br><span class="line">        denominator--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時，<u>中斷點(breakpoints)</u>就能發揮功效。即使您已根據<u>堆疊追蹤(stack trace)</u>中的資訊大致推斷出造成 bug 的原因，您仍可在某行程式碼<u>新增 breakpoints 做為停止訊號</u>。一旦觸及 breakpoints，系統就會暫停執行程式碼，讓您可以<u>在執行階段使用其他 debugging 工具</u>，以便詳細瞭解實際情況並判斷問題。</p>
<h4 id="附加-debugger"><a href="#附加-debugger" class="headerlink" title="附加 debugger"></a>附加 debugger</h4><p>Android Studio 會在背景使用名為 <b>Android Debug Bridge (ADB)</b> 的工具。這項指令列工具已整合至 Android Studio，可為執行中的 app 提供 <strong>breakpoints</strong> 等 debugging 功能。<u>進行 debugging 的工具</u>通常稱為 <strong>debugger</strong>。</p>
<p>如要將 debugger 用於或附加至 app，您無法像往常一樣依序點選「Run」&gt;「Run ‘app’」執行 app，而是改為「Run」 &gt;「Debug ‘app’」。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/340a8e850b3c86d3_1920.png?hl=zh-tw" width="80%">

<h4 id="在-project-中新增-breakpoints"><a href="#在-project-中新增-breakpoints" class="headerlink" title="在 project 中新增 breakpoints"></a>在 project 中新增 breakpoints</h4><p>請執行下列步驟，觀察 breakpoints 的實際運作情形：</p>
<ol>
<li>找到您希望中斷動作的 <strong>line number</strong>，<u>點選旁邊的空白以新增 breakpoint</u>。line number 旁邊會出現一個點，且該行程式碼會被 <strong>highlighted</strong>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/629ac33dfb3873e_1920.png?hl=zh-tw" width="70%">

<ol start="2">
<li>利用「Run」(執行) &gt;「Debug ‘app’」或工具列中的圖示執行附有 debugger 的 app：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/a71c8b295db5927d_1920.png?hl=zh-tw"> 
app 啟動後，您會看到像這樣的畫面：

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/3bd9cbe69d5a0d0e_1920.png?hl=zh-tw" width="40%">

<p>一旦啟動 app，系統會 highlighted 有效的 breakpoint。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/928fc1194966c9_1920.png?hl=zh-tw" width="70%">

<p>先前已開啟 Logcat 視窗的某個畫面底部已開啟「Debug」分頁。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/447d9743c118babd_1920.png?hl=zh-tw" width="90%">

<p>左側是 functions list，與堆疊追蹤(stack trace)中顯示的 list 相同。右側是一個窗格，可讓您查看目前 function (即 <code>division()</code>) 中個別變數(variables)的值(value)。您也可以透過頂端的按鈕，在程式暫停執行期間進行瀏覽。最常用的按鈕是「Step Over」(不進入)，用來執行 highlighted 的單行程式碼。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/48219b96d5ab6ba6_1920.png?hl=zh-tw" width="50%">

<p>請按照下列步驟操作，對程式碼進行 debug：</p>
<ol>
<li>到達 breakpoint 後，第 19 行 (宣告 <code>numerator</code> 變數) 會 highlighted，但尚未執行。使用「Step Over」(不進入) 按鈕執行第 19 行：<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/fbdcba647f9844c4_1920.png?hl=zh-tw" width="30px"> 
現在將 highlighted 第 20 行。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/eaacf76805166461_1920.png?hl=zh-tw" width="70%">

<ol start="2">
<li>在第 22 行設定 breakpoint。這就是發生除法的位置，也是堆疊追蹤(stack trace)回報 exception 的一行。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/1f18ab31dc58a1a7_1920.png?hl=zh-tw" width="70%">

<ol start="3">
<li>使用「Debug」視窗左側的「Resume Program」(繼續執行程式) 按鈕，前往下一個 breakpoint：<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/616d16841834ae2a_1920.png?hl=zh-tw" width="30px"></li>
</ol>
<p>執行 <code>division()</code> 函式的其餘部分。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/3a9c3edc893f9720_1920.png?hl=zh-tw" width="50%">

<ol start="4">
<li>請注意，執行作業在第 17 行停止，未執行該行。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/aa56331ad870cd40_1920.png?hl=zh-tw" width="70%">

<ol start="5">
<li>每個變數 <code>numerator</code> 和 <code>denominator</code> 的值會顯示在其宣告旁邊。變數值會顯示在「Variables」分頁的 debug 視窗中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/5b3515c5580ee7dd_1920.png?hl=zh-tw" width="50%">

<ol start="6">
<li>再按下「Debug」視窗左側的「Resume Program」(繼續執行程式) 按鈕四次。每次迴圈暫停時觀察 <code>numerator</code> 和 <code>denominator</code> 的值。在最後一個迭代作業中，<code>numerator</code> 應為 <code>60</code>，而 <code>denominator</code> 應為 <code>0</code>。然而將 <code>60</code> 除以 <code>0</code> 並不符合數學規則！</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/56ea223612b88125_1920.png?hl=zh-tw" width="50%">

<p>這樣一來，您就能得知造成 bug 的確切程式碼行，並瞭解確切原因。和先前一樣，只要將程式碼重複的次數從 <code>5</code> 變更為 <code>4</code>，即可修正 bug。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">division</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numerator = <span class="number">60</span></span><br><span class="line">    <span class="keyword">var</span> denominator = <span class="number">4</span></span><br><span class="line">    repeat(<span class="number">4</span>) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;<span class="subst">$&#123;numerator / denominator&#125;</span>&quot;</span>)</span><br><span class="line">        denominator--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>提示：</strong>如要移除<b>中斷點(breakpoints)</b>，請按一下 <u>line number</u> 旁邊的點。</p>
          </div>

<hr>
<h3 id="設定-breakpoints-conditions"><a href="#設定-breakpoints-conditions" class="headerlink" title="設定 breakpoints conditions"></a>設定 breakpoints conditions</h3><p>在上一節中，您必須逐一檢查迭代迴圈，直到分母為 <code>0</code>。在較為複雜的 app 中，如果您的錯誤資訊較少，可能會很繁瑣。不過，如果您有一個假設 (例如，<u>app 只有在分母為零時才會異常終止</u>)，則可以修改中斷點，<u>限制只有在符合假設時才會觸及中斷點</u>，這樣就不必逐一檢查迴圈迭代。</p>
<ol>
<li>如有需要，請在重複迴圈中將 <code>4</code> 變更為 <code>5</code>，以重新回報錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat(<span class="number">5</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在含有 <code>repeat</code> 陳述式的行上放置新的 breakpoints。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/47fcc3aeb814a9d7_1920.png?hl=zh-tw" width="70%">

<ol start="3">
<li>在紅色中斷點圖示上按一下滑鼠右鍵。選單會顯示數個選項，例如是否已啟用中斷點。停用的中斷點仍然存在，但不會在執行階段觸發。您也可以選擇<u>新增 Kotlin 運算式，如果運算結果為 <strong>True</strong>，就會觸發中斷點</u>。例如，如果使用 <code>denominator &gt; 3</code> 運算式，則<u>只有在初次疊代迴圈時，才會觸發中斷點</u>。如果<u>只想在 app 可能除以零時觸發中斷點</u>，請將運算式設為 <code>denominator == 0</code>。中斷點的選項會如下所示：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/76045ef783d5389b_1920.png?hl=zh-tw" width="70%">

<ol start="4">
<li>依序點選「Run」&gt;「Debug ‘app’」執行您的 app，並觀察是否已到達 breakpoints。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/74ba264a6eab7db7_1920.png?hl=zh-tw" width="70%">

<p>如您所見，分母已是 <code>0</code>。只有符合條件時才會觸發 breakpoints，因此您不必逐一檢查程式碼，可節省時間和精力。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/153be06e8a19e61d_1920.png?hl=zh-tw" width="50%">

<ol start="5">
<li>和先前一樣，您會看到錯誤是因為循環執行一行程式碼太多次所造成，此時分母設為 <code>0</code>。</li>
</ol>
<h4 id="新增-Watches"><a href="#新增-Watches" class="headerlink" title="新增 Watches"></a>新增 Watches</h4><p>如果想在 debugging 時監控<u>特定值</u>，並不需要在「Variables」分頁中搜尋該值，只要新增所謂的 <strong>Watches</strong> 即可<u>監控特定變數</u>。這些變數會顯示在 debug 窗格中。當<u>執行暫停</u>且<u>該變數位於範圍內</u>時，就會顯示在「Watches」窗格中。如此一來，處理大型 projects 時，就能提高 debugging 效率。您可以<u>集中追蹤所有相關變數</u>。</p>
<ol>
<li>在「Debug」view 中，「Variables」窗格右側會顯示另一個名為「Watches」的空白窗格。按一下左上角的加號按鈕：<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/c97b1f6a879b0563_1920.png?hl=zh-tw" width="30px">
您可能會看到顯示「New Watch」的選單選項。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-debugging-with-breakpoints/img/4d27cc7c5222377b_1920.png?hl=zh-tw" width="80%">

<ol start="2">
<li><p>在提供的欄位中輸入變數名稱 <code>denominator</code>，接著按一下 enter 鍵。</p>
</li>
<li><p>依序按一下「Run &gt;「Debug ‘app’」重新執行 app，這時您會發現以下情況：遇到 breakpoint 時，系統會在「Watches」窗格顯示 <code>denominator</code> 的值。</p>
</li>
</ol>
<img src="https://i.imgur.com/CjTjY3M.png">]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Connect to the internet</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Debugging</tag>
        <tag>Debugger</tag>
        <tag>Breakpoint</tag>
        <tag>Watches</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(35)-載入並顯示Internet上的images</title>
    <url>/2023/12/09/Android%E7%AD%86%E8%A8%98-35-%E8%BC%89%E5%85%A5%E4%B8%A6%E9%A1%AF%E7%A4%BAInternet%E4%B8%8A%E7%9A%84images/</url>
    <content><![CDATA[<blockquote>
<p>了解如何使用 <a href="https://coil-kt.github.io/coil/">Coil</a> library 從 URL 載入並顯示網路上的圖片。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何使用 <strong>Coil library</strong> <u>從 URL 載入及顯示 image</u>。</li>
<li>如何使用 <code>RecyclerView</code> 和 <strong>grid adapter</strong> 顯示<u>格狀(grid) images</u>。</li>
<li>如何處理 images <u>下載及顯示</u>時出現的<u>潛在 errors</u>。</li>
</ul>
<p><strong>建構項目</strong></p>
<ul>
<li>修改 MarsPhotos app 以<u>取得 Mars data 中的 image URL</u>，並<u>使用 Coil 載入並顯示該 image</u>。</li>
<li>在 app 中加入 <u>loading animation</u> 和 <u>error icon</u>。</li>
<li>使用 <code>RecyclerView</code> 顯示格狀(grid) Mars images。</li>
<li>為 <code>RecyclerView</code> 加入<u>狀態和錯誤處理機制(status and error handling)</u>。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="App-overview"><a href="#App-overview" class="headerlink" title="App overview"></a>App overview</h3><p>在本程式碼研究室中，您將繼續使用之前程式碼研究室中稱為 MarsPhotos app。MarsPhotos app 會<u>連線至 web service，以擷取並顯示使用 Retrofit 獲取的 Kotlin objects 數量</u>。這些 Kotlin objects 包含 NASA 的火星探測器擷取的火星表面真實相片的 URL。</p>
<p>您在本程式碼研究室中建構的 app 版本會填入 overview 頁面，此頁面以 images grid(格狀) 模式顯示 Mars photos。這些 images 來自您的 app 從 Mars web service 擷取的 data。您的 app 會<u>使用 <strong>Coil library</strong> 來載入並顯示 images</u>，也會<u>使用 <strong>RecyclerView</strong> 來建立 images 的 <strong>grid layout</strong></u>。此外，app 式還會妥善處理<u>網路錯誤(network errors)</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/243d21747dfb8999_1920.png?hl=zh-tw" width="40%">

<hr>
<h3 id="顯示-internet-image"><a href="#顯示-internet-image" class="headerlink" title="顯示 internet image"></a>顯示 internet image</h3><p>想要顯示某個 URL 的相片，聽起來可能很簡單，但其中需要經過很多程序才能順利完成。image 必須經過<u><b>下載(downloaded)</b></u>、<u><b>內部儲存(internally stored)</b></u>、<u><b>對壓縮格式進行解碼(decoded from its compressed format)</b></u>，才能供 Android 使用。image 應快取(cached)至<u><b>記憶體快取(in-memory cache)</b></u>或<u><b>儲存空間快取(storage-based cache)</b></u>，或同時存放在這兩個地方。系統只會在低優先順序的 <u>background threads</u> 中採取這些動作，以確保 UI 的靈敏度。此外，為獲得最佳 network 和 CPU 效能，建議您一次擷取多張圖片並解碼(decode)。</p>
<p>您可以使用社群開發的資料庫 <a href="https://coil-kt.github.io/coil/">Coil</a> ，<u><b>下載(download)</b></u>、<u><b>緩衝處理(buffer)</b></u>、<u><b>解碼(decode)</b></u>及<u><b>快取(cache)</b></u>您的 images。如果不使用 Coil，工作將會更多。</p>
<p>Coil 基本上需要下列兩項：</p>
<ul>
<li>要載入並顯示的 <u>image URL</u>。</li>
<li>用來顯示該 image 的 <u><code>ImageView</code> object</u>。</li>
</ul>
<p>在這項工作中，您會瞭解如何使用 Coil 顯示來自 Mars web service 的單張圖片。您會顯示 <u>web service 傳回的 photos list 中第一張 Mars photo</u>。以下是前後對照的螢幕截圖：</p>
<div style="display:flex; justify-content:center;">
    <div style="width:40%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/154f7a78fcf330d2_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/6b9a8183bcd961ab_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div>
</div>

<h4 id="新增-Coil-dependency"><a href="#新增-Coil-dependency" class="headerlink" title="新增 Coil dependency"></a>新增 Coil dependency</h4><ol>
<li>開啟先前程式碼研究室中的 <a href="https://developer.android.com/codelabs/basic-android-kotlin-training-getting-data-internet?hl=zh-tw#8">MarsPhotos solution</a> app。</li>
<li>執行 app 以查看其用途。(其中顯示擷取的 Mars photos 總數)。</li>
<li>開啟「build.gradle (Module: app)」。</li>
<li>在 <code>dependencies</code> 區段，為 Coil library 新增此行內容：</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Coil</span></span><br><span class="line">implementation <span class="string">&quot;io.coil-kt:coil:1.1.1&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>透過 <a href="https://coil-kt.github.io/coil/#download">Coil documentation 頁面</a>查看及更新最新版本的程式庫。</li>
</ul>
<p>Coil library 於 <code>mavenCentral()</code> repository 託管(hosted)並提供。在 <strong>build.gradle (Project: MarsPhotos)</strong> 的頂部 <code>repositories</code> 區塊中，新增 <code>mavenCentral()</code>。</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">   google()</span><br><span class="line">   mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>按一下「Sync Now」，使用新 dependency rebuild project。</li>
</ol>
<h4 id="更新-ViewModel"><a href="#更新-ViewModel" class="headerlink" title="更新 ViewModel"></a>更新 ViewModel</h4><p>在這個步驟中，您需要將 <code>LiveData</code> 屬性新增至 <code>OverviewViewModel</code> class，以儲存收到的 Kotlin object <code>MarsPhoto</code>。</p>
<ol>
<li>開啟 <code>overview/OverviewViewModel.kt</code>。在 <code>_status</code> 屬性宣告的正下方，新增 type 為 <code>MutableLiveData </code>的可變動屬性 <code>_photos</code>，其可儲存單個 <code>MarsPhoto</code> object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _photos = MutableLiveData&lt;MarsPhoto&gt;()</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>com.example.android.marsphotos.network.MarsPhoto</code>。</li>
</ul>
<ol start="2">
<li>在 <code>_photos</code> 宣告的正下方，新增 type 為 <code>LiveData&lt;MarsPhoto&gt;</code> 的 public backing field <code>photos</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> photos: LiveData&lt;MarsPhoto&gt; = _photos</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>getMarsPhotos()</code> 方法的 <code>try&#123;&#125;</code> 區塊中，找到以下一行內容，可用於將從 web service 擷取的 data 設為 <code>listResult</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>將擷取到的第一張 Mars photo 指派給新的變數 <code>_photos</code>。將 <code>listResult</code> 變更為 <code>_photos.value</code>。在 index <code>0</code> 處指派第一個 photos url。這將引發 error，您要在稍後修正它。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   _photos.value = MarsApi.retrofitService.getPhotos()[<span class="number">0</span>]</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在下一行中，將 <code>status.value</code> 更新為下列內容。請使用新屬性 (非 <code>listResult</code> 中) 的 data。顯示  photos List 中的第一個 image URL。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ...</span><br><span class="line">   _status.value = <span class="string">&quot;   First Mars image URL : <span class="subst">$&#123;_photos.value!!.imgSrcUrl&#125;</span>&quot;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>現在，完整的 <code>try&#123;&#125;</code> 區塊大致如下：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   _photos.value = MarsApi.retrofitService.getPhotos()[<span class="number">0</span>]</span><br><span class="line">   _status.value = <span class="string">&quot;   First Mars image URL : <span class="subst">$&#123;_photos.value!!.imgSrcUrl&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行 app。現在，<code>TextView</code> 會顯示第一張 Mars photo 的 URL。目前，您已設定好該 URL 的 <code>ViewModel</code> 和 <code>LiveData</code>。</li>
</ol>
<img src="https://i.imgur.com/kzizMxx.png" width="40%">

<h4 id="使用-Binding-Adapters"><a href="#使用-Binding-Adapters" class="headerlink" title="使用 Binding Adapters"></a>使用 Binding Adapters</h4><p><strong>Binding Adapters</strong> 是帶<u>註解</u>的方法，用於<u>為 <strong>view</strong> 的<b>自訂屬性</b>建立<b>自訂 setter</b></u>。</p>
<p>通常您會使用以下程式碼在 XML 中設定屬性：<code>android:text=&quot;Sample Text&quot;</code>。Android 系統會自動尋找由 <code>setText(String: text)</code> 方法 <u>setter、name 與 <code>text</code> 屬性</u>相同的 <u>setter 屬性</u>。<code>setText(String: text)</code> 方法是一種 <u>setter 方法</u>，適用於 Android 架構所提供之部分 view。您可使用  binding adapters 自訂類似行為；也可以提供由 Data binding library 呼叫的自訂屬性和自訂邏輯。</p>
<p>範例：<br>若想執行更為複雜的操作，而不只是在 Image view 上呼叫 setter，請設定 <strong>drawable image</strong>。請考慮<u>從 internet 載入 UI thread (main thread) 的 images</u>。首先，選擇<b>自訂屬性</b>用於<u>將 image 指派給 <code>ImageView</code></u>。在以下範例中為 <code>imageUrl</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:imageUrl</span>=<span class="string">&quot;@&#123;product.imageUrl&#125;&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果您未新增任何程式碼，系統將在 <code>ImageView</code> 中尋找 <code>setImageUrl(String)</code> 方法；如果找不到該方法，將會引發 error，因為這個自定屬性並非由架構提供。您<u>必須建立實作方式，並將 <code>app:imageUrl</code> 屬性設為 <code>ImageView</code></u>。請使用 <u><strong>Binding adapters (註解方法)</strong></u> 進行這項作業。</p>
<p>Binding Adapter 範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;imageUrl&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindImage</span><span class="params">(imgView: <span class="type">ImageView</span>, imgUrl: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    imgUrl?.let &#123;</span><br><span class="line">        <span class="comment">// Load the image in the background using Coil.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>@BindingAdapter</code> 註解會將<u>屬性名稱</u>做為<u>參數</u>。</li>
<li>在 <code>bindImage</code> 方法中，第一個方法參數是<u><b>目標 View 的 type</b></u>，第二個則是要設為<u><b>屬性的 value</b></u>。</li>
<li>在方法中，Coil library 會載入 <strong>UI thread</strong> 的 image 並將其設為 <code>ImageView</code>。</li>
</ul>
<h5 id="建立-binding-adapter-及使用-Coil"><a href="#建立-binding-adapter-及使用-Coil" class="headerlink" title="建立 binding adapter 及使用 Coil"></a>建立 binding adapter 及使用 Coil</h5><ol>
<li>在 <code>com.example.android.marsphotos.overview</code> 中，建立名稱為 <code>BindingAdapters</code> 的 Kotlin 檔案。這個檔案會保留您在 app 中使用的 binding adapters。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/a04afbd6ae8ccfcd_1920.png?hl=zh-tw" width="70%">

<ol start="2">
<li>在 <code>BindingAdapters.kt</code> 中，建立 <code>bindImage()</code> 函式做為頂層函式 (不在類別中)，並使用 <code>ImageView</code> 和 <code>String</code> 做為參數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindImage</span><span class="params">(imgView: <span class="type">ImageView</span>, imgUrl: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>android.widget.ImageView</code>。</li>
</ul>
<ol start="3">
<li>使用 <code>@BindingAdapter</code> 為函式加上註解。<code>@BindingAdapter</code> 註解會<u>通知 <strong>data binding</strong></u>，在 View item 擁有 <code>imageUrl</code> 屬性時執行此 binding adapter。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;imageUrl&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindImage</span><span class="params">(imgView: <span class="type">ImageView</span>, imgUrl: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>androidx.databinding.BindingAdapter</code>。</li>
</ul>
<h5 id="let-scope-function"><a href="#let-scope-function" class="headerlink" title="let scope function"></a>let scope function</h5><p><code>let</code> 是 Kotlin 的<a href="https://kotlinlang.org/docs/scope-functions.html">範圍函式(scope function)</a>之一，可讓您<u>在 <strong>object</strong> 的 <strong>context</strong> 內執行<b>程式碼區塊(code block)</b></u>。Kotlin 中有五個 scope function，詳情請參閱 <a href="https://kotlinlang.org/docs/scope-functions.html#functions">documentation</a>。</p>
<p>使用方式：</p>
<ul>
<li><code>let</code> 的用途是根據<u><b>呼叫鏈(call chains)</b>的結果</u><u>叫用一或多個函式</u>。</li>
<li><code>let</code> 函式和安全呼叫運算子 (<code>?</code>) 的用途是對 object 執行<u>空值安全運算(null safe operation)</u>。在這種情況下，只有在 <u>object 不是空值時，系統才會執行 <code>let</code> 程式碼區塊(code block)</u>。</li>
</ul>
<ol start="4">
<li>在 <code>bindImage()</code> 函式中，使用安全呼叫運算子 (<code>?.</code>) 將 <code>let&#123;&#125;</code> 區塊新增至 <code>imgUrl</code> 引數(argument)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">imgUrl?.let &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon primary">
            <p><strong>筆記：</strong></p><ul><li><u>傳遞出去</u>的是 <b>參數(parameter)</b> </li><li>可以被<u>傳進來</u>的是 <b>引數(argument)</b></li></ul><p><code>load(n)</code>，<code>n</code> 是參數<br><code>fun load(number: Int)</code>，<code>number</code> 是引數</p>
          </div>

<ol start="5">
<li>在 <code>let&#123;&#125;</code> 區塊內，新增以下一行內容來使用 <code>toUri()</code> 方法將  URL string 轉換為 <code>Uri</code> object。若要使用 HTTPS 配置，請將 <code>buildUpon.scheme(&quot;https&quot;)</code> 附加至 <code>toUri</code> builder。接著呼叫 <code>build()</code> 來建構(build) object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> imgUri = imgUrl.toUri().buildUpon().scheme(<span class="string">&quot;https&quot;</span>).build() </span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>androidx.core.net.toUri</code>。</li>
</ul>
<ol start="6">
<li>在 <code>let&#123;&#125;</code> 區塊內，宣告 <code>imgUri</code> 之後，使用 Coil 的 <code>load()&#123;&#125;</code> 將 <code>imgUri</code> object 的 image 載入 <code>imgView</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">imgView.load(imgUri)</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>coil.load</code>。</li>
</ul>
<ol start="7">
<li>完整方法大致如下：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;imageUrl&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindImage</span><span class="params">(imgView: <span class="type">ImageView</span>, imgUrl: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    imgUrl?.let &#123;</span><br><span class="line">        <span class="comment">// 使用 toUri() 將 URL string 轉換為 Uri object (將 buildUpon.scheme(&quot;https&quot;) 附加至 toUri builder)</span></span><br><span class="line">        <span class="keyword">val</span> imgUri = imgUrl.toUri().buildUpon().scheme(<span class="string">&quot;https&quot;</span>).build()</span><br><span class="line">        <span class="comment">// 使用 Coil 的 load()&#123;&#125; 將 imgUri object 的 image 載入 imgView</span></span><br><span class="line">        imgView.load(imgUri)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="更新-layout-和-fragments"><a href="#更新-layout-和-fragments" class="headerlink" title="更新 layout 和 fragments"></a>更新 layout 和 fragments</h4><p>在上一節中，您使用了 <strong>Coil image library</strong> <u>載入 image</u>。接著<u>使用<b>新屬性</b>更新 <code>ImageView</code></u>，以顯示單張 image，即可在螢幕上顯示 image。</p>
<p>稍後，在程式碼研究室中，您將使用 <code>res/layout/grid_view_item.xml</code> 做為 <code>RecyclerView</code> 中每個 grid item 的 layout resource 檔案。在這項工作中，您將暫時使用這個檔案，透過在前一項工作中擷取到的 <strong>image URL</strong> 來顯示 image。目前，您將使用這個 layout 檔案取代 <code>fragment_overview.xml</code>。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>在這項工作中，您將使用 <b>grid_view_item.xml</b> layout 來暫時顯示單張 image。藉此避免建立及刪除臨時 layout 檔案。產生的 binding class 名稱為 <b>GridViewItemBinding</b>，因為 class 的命名依據是 layout 檔案名稱，即 <b>grid_view_item.xml</b>。即使 binding class 名稱為 <b>GridViewItemBinding</b>，但在這項工作中的 <b>RecyclerView</b> 內，您將無法使用它來顯示 grid images。這屬於後續工作。</p>
          </div>

<ol>
<li>開啟 <code>res/layout/grid_view_item.xml</code>。</li>
<li>在 <code>&lt;ImageView&gt;</code> element 上方，為 data binding 新增 <code>&lt;data&gt;</code> element，並 bind 至 <code>OverviewViewModel</code> class：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;com.example.android.marsphotos.overview.OverviewViewModel&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>ImageView</code> element 中新增 <code>app:imageUrl</code> 屬性，即可使用新的 image 載入 binding adapter。請注意，<code>photos</code> 包含從 server 擷取的 list <code>MarsPhotos</code>。將第一個 item 的 URL 指派給 <code>imageUrl</code> 屬性。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/mars_image&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:imageUrl</span>=<span class="string">&quot;@&#123;viewModel.photos.imgSrcUrl&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>開啟 <code>overview/OverviewFragment.kt</code>。在 <code>onCreateView()</code> 方法中，註解加載(inflates) <code>FragmentOverviewBinding</code> class 並將其指派給 binding variable 的行。移除此行會發生錯誤。請放心，這是暫時現象，稍後就會修正。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">//val binding = FragmentOverviewBinding.inflate(inflater)</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>請改用 <code>grid_view_item.xml</code> 取代 <code>fragment_overview.xml</code>。在這種情況下，請改為新增以下一行內容，以加載(inflate) <code>GridViewItemBinding</code> class。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> binding = GridViewItemBinding.inflate(inflater)</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>com.example.android.marsphotos.databinding.GridViewItemBinding</code>。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong>這項變更可能會導致 Android Studio 發生 <b>data-binding errors</b>。clean 後再 rebuild project 即可解決這些錯誤。依序選取「Build」&gt;「Clean Project」&gt;「Build」&gt;「Rebuild Project」</p>
          </div>

<p>執行 app。現在螢幕上會顯示單張 Mars image。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/e59b6e849e63ae2b_1920.png?hl=zh-tw" width="40%">

<h4 id="新增-loading-和-error-images"><a href="#新增-loading-和-error-images" class="headerlink" title="新增 loading 和 error images"></a>新增 loading 和 error images</h4><p>使用 Coil，您可以在<u>載入 image 時顯示 <strong>placeholder image</strong></u>，並在<u>載入失敗（例如 image 遺失或損壞）時顯示 <strong>error image</strong></u>，從而改善使用者體驗。在此步驟中，您需將該功能新增至 <strong>binding adapter</strong>。</p>
<ol>
<li>開啟 <code>res/drawable/ic_broken_image.xml</code>，然後按一下右側的「Design」分頁標籤。如果出現 error image，表示您使用的是內建 icon library 中的 <u>broken-image icon</u>。此 <strong>vector drawable</strong> 使用 <code>android:tint</code> 屬性，將 icon 變為灰色。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/467c213c859e1904_1920.png?hl=zh-tw" width="20%">

<ol start="2">
<li>開啟 <code>res/drawable/loading_animation.xml</code>。這個 drawable 是 <strong>animation</strong>，可圍繞中心點旋轉(rotate) image drawable <code>loading_img.xml</code> (預覽畫面不會顯示 animation)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/6c1f87d1c932c762_1920.png?hl=zh-tw" width="20%">

<ol start="3">
<li>返回 <code>BindingAdapters.kt</code> 檔案。在 <code>bindImage()</code> 方法中，更新對 <code>imgView.load(imgUri)</code> 的呼叫即可新增<u>後置(trailing) lambda</u>，如下所示：此程式碼會<u>設定載入時使用的 <strong>placeholder loading image</strong> (<code>loading_animation</code> drawable)</u>。此程式碼也會<u>設定 image 載入失敗時要使用的 <strong>error image</strong> (<code>broken_image</code> drawable)</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">imgView.load(imgUri) &#123;</span><br><span class="line">   <span class="comment">// 使用 Coil 的 placeholder() 和 error() 設定 image 載入時和載入失敗時要使用的 drawable</span></span><br><span class="line">   placeholder(R.drawable.loading_animation)</span><br><span class="line">   error(R.drawable.ic_broken_image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>現在，完整的 <code>bindImage()</code> 方法大致如下：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;imageUrl&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindImage</span><span class="params">(imgView: <span class="type">ImageView</span>, imgUrl: <span class="type">String</span>?)</span></span> &#123;</span><br><span class="line">    imgUrl?.let &#123;</span><br><span class="line">        <span class="comment">// 使用 toUri() 將 URL string 轉換為 Uri object</span></span><br><span class="line">        <span class="keyword">val</span> imgUri = imgUrl.toUri().buildUpon().scheme(<span class="string">&quot;https&quot;</span>).build()</span><br><span class="line">        <span class="comment">// 使用 Coil 的 load()&#123;&#125; 將 imgUri object 的 image 載入 imgView</span></span><br><span class="line">        imgView.load(imgUri) &#123;</span><br><span class="line">            <span class="comment">// 使用 Coil 的 placeholder() 和 error() 設定 image 載入時和載入失敗時要使用的 drawable</span></span><br><span class="line">            placeholder(R.drawable.loading_animation)</span><br><span class="line">            error(R.drawable.ic_broken_image)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行 app。系統可能會在 Coil 下載並顯示屬性 image 時，暫時顯示 loading image，具體情況視網路連線速度而定。但即使您關閉網路，此刻仍不會顯示 broken-image icon。此問題會在程式碼研究室的最後一項工作中加以修正。</li>
</ol>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-internet-images/img/6dcecd205a0741a.gif" width="40%">

<ol start="6">
<li>還原您在 <code>overview/OverviewFragment.kt</code> 中做出的臨時變更。在方法 <code>onCreateview()</code> 中，取消註解加載(inflates) <code>FragmentOverviewBinding</code> 的行。刪除加載(inflates) <code>GridViewIteMBinding</code> 的行或設為註解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> binding = FragmentOverviewBinding.inflate(inflater)</span><br><span class="line"> <span class="comment">// val binding = GridViewItemBinding.inflate(inflater)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="使用-RecyclerView-顯示格狀的-images"><a href="#使用-RecyclerView-顯示格狀的-images" class="headerlink" title="使用 RecyclerView 顯示格狀的 images"></a>使用 RecyclerView 顯示格狀的 images</h3><p>現在，您的 app 會<u>從 internet 載入 Mars photo</u>。透過<u>使用第一個 <code>MarsPhoto</code>  list item 的 data</u>，您已<u>在 <code>ViewModel</code> 中建立 <code>LiveData</code> 屬性</u>，並<u>使用 Mars photo data 中的 image URL 填入 <code>ImageView</code></u>。但我們的目標是讓您的 app 顯示格狀的 images，因此在這項工作中，您將<u>使用 <code>RecyclerView</code> 搭配 <strong>Grid layout manager</strong> 來顯示格狀 images</u>。</p>
<h4 id="更新-view-model"><a href="#更新-view-model" class="headerlink" title="更新 view model"></a>更新 view model</h4><p>在先前的工作中，您在 <code>OverviewViewModel</code> 新增了名為 <code>_photos</code> 的 <u><code>LiveData </code> object</u>，該 object 存放了一個 <u><code>MarsPhoto</code> object</u>，即 web service 提供的 <u>response list 中的第一個 object</u>。在此步驟中，您必須變更這個 <code>LiveData</code>，使其存放 <u><code>MarsPhoto</code> object 的完整 list</u>。</p>
<ol>
<li>開啟 <code>overview/OverviewViewModel.kt</code>。</li>
<li>將 <code>_photos</code> type 變更為 <u><code>MarsPhoto</code> object 的 <strong>list</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _photos = MutableLiveData&lt;List&lt;MarsPhoto&gt;&gt;()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同時將 backing 屬性 <code>photos</code> type 變更為 <code>List&lt;MarsPhoto&gt;</code> type：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> photos: LiveData&lt;List&lt;MarsPhoto&gt;&gt; = _photos</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>向下捲動至 <code>getMarsPhotos()</code> 方法中的 <code>try &#123;&#125;</code> 區塊。<code>MarsApi.retrofitService.getPhotos()</code><br>會傳回 <u><code>MarsPhoto</code> objects 的 list</u>，您可以將它指派給 <code>_photos.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">_photos.value = MarsApi.retrofitService.getPhotos()</span><br><span class="line">_status.value = <span class="string">&quot;Success: Mars properties retrieved&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>現在整個 <code>try/catch</code> 區塊如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    _photos.value = MarsApi.retrofitService.getPhotos()</span><br><span class="line">    _status.value = <span class="string">&quot;Success: Mars properties retrieved&quot;</span></span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">    _status.value = <span class="string">&quot;Failure: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Grid-Layout"><a href="#Grid-Layout" class="headerlink" title="Grid Layout"></a>Grid Layout</h4><p><code>RecyclerView</code> 的 <code>GridLayoutManager</code> 會將 data 設為 <u>scrollable(可滑動的) grid</u>，如下所示。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/fcf0fc4b78f8650_1920.png?hl=zh-tw" width="80%">

<p>從設計的角度來看，<strong>Grid Layout</strong> 最適合用於<u>可透過 icons 或 images 表示的 lists</u>，例如 Mars photo 瀏覽 app 中的 list。</p>
<h5 id="Grid-layout-的-items-排列方式"><a href="#Grid-layout-的-items-排列方式" class="headerlink" title="Grid layout 的 items 排列方式"></a>Grid layout 的 items 排列方式</h5><p>Grid layout 透過由<u>列(rows)</u>和<u>欄(columns)</u>組成的<u>格線排列 items</u>。假設您預設為<u>垂直捲動(vertical scrolling)</u>，則<u>每一列(rows)中的每個 item 都會占用一個 <strong>span</strong></u>。一個 item 可以占用<u>多個 span</u>。在下列範例中，一個 span 等同於一欄的寬度 3。</p>
<p>在以下兩個範例中，<u>每列(rows)由三個 spans 組成</u>。根據預設，<code>GridLayoutManager</code> 會<u>將每個 item 放置在一個 span 中</u>，直到達到您指定的 <strong>span count</strong>。達到 span count 時，系統會<u>換行</u>到下一行。</p>
<div style="display:flex; justify-content:center;">
    <div style="width:35%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/2262933d015af49c_1920.png?hl=zh-tw">
    </div>
    <div style="width:35%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/b5744904f1a1d3fb_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div>
</div>

<h4 id="新增-Recycler-view"><a href="#新增-Recycler-view" class="headerlink" title="新增 Recycler view"></a>新增 Recycler view</h4><p>在這個步驟中，您需要變更 app 的 layout，改用採用 <u>grid layout 的 recycler view</u>，而非 single image view。</p>
<ol>
<li>開啟 <code>layout/grid_view_item.xml</code>。請移除 <code>viewModel</code> data variable。</li>
<li>在 <code>&lt;data&gt;</code> 標記中，新增下列 <u><code>MarsPhoto</code> type 的 <code>photo</code> variable</u>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;com.example.android.marsphotos.network.MarsPhoto&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>&lt;ImageView&gt;</code> 中，將 <code>app:imageUrl</code> 屬性變更為<u>引用 <code>MarsPhoto</code> object 中的 image URL</u>。這些變更會復原您在上一個工作中做出的臨時變更。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:imageUrl=&quot;@&#123;photo.imgSrcUrl&#125;&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>開啟 <code>layout/fragment_overview.xml</code>。刪除整個<code> &lt;TextView&gt;</code> element。</li>
<li>請改為新增下列 <u><code>&lt;RecyclerView&gt;</code> element</u>。將 <u>ID 設為 <code>photos_grid</code></u>，將 <u><code>width</code> 和 <code>height</code> 屬性設為 <code>0dp</code></u>，方便填充父項(parent) <code>ConstraintLayout</code>。您要使用的是 Grid layout，因此請<u>將 <code>layoutManager</code> 屬性設為 <code>androidx.recyclerview.widget.GridLayoutManager</code></u>。<u>將 <code>spanCount</code> 設為 <code>2</code></u>，即可擁有兩欄。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/photos_grid&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutManager</span>=<span class="string">&quot;androidx.recyclerview.widget.GridLayoutManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:spanCount</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如要預覽上述程式碼在「Design」view 中的外觀，請使用 <code>tools:itemCount</code> 將 layout 中顯示的 items 數量設為 <code>16</code>。<code>itemCount</code> 屬性可指定 layout editor 在「Preview」視窗中應顯示的 items 數量。使用 <code>tools:listitem</code> 將 list items 的 layout 設為 <code>grid_view_item</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:itemCount</span>=<span class="string">&quot;16&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/grid_view_item&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>切換為「Design」view 後，系統應會顯示類似下方螢幕截圖的預覽畫面。這個預覽畫面看起來不像 Mars photos，但您可以從中查看 recyclerview  grid layout 的外觀。對於 <code>recyclerview</code> 中每個 grid item，其預覽皆會顯示 padding 和 <code>grid_view_item</code> layout。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/20742824367c3952_1920.png?hl=zh-tw" width="40%">

<ol start="8">
<li>根據 <a href="https://m2.material.io/components/image-lists/#anatomy">Material Design guidelines</a>，list 頂端(top)、底部(bottom)和側邊(sides)應保留 <code>8dp</code> 的空間，而 items 之間應保留 <code>4dp</code> 的空間。搭配運用 <code>fragment_overview.xml</code> layout 和 <code>grid_view_item.xml</code> layout 中的 padding 可實現上述目標。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/a3561fa85fea7a8f_1920.png?hl=zh-tw" width="40%">

<ol start="9">
<li><p>開啟 <code>layout/grid_view_item.xml</code>。請注意，已設定 <code>padding</code> 屬性<u>在 item 外部和內容(content)之間留有 <code>2dp</code> 的 padding</u>。如此可在 item content 之間留出 <code>4dp</code> 的空間，而在外邊留出 <code>2dp</code> 的空間。也就是說，為了符合設計規範，外部需要留出額外 <code>6dp</code> 的 padding。</p>
</li>
<li><p>返回 <code>layout/fragment_overview.xml</code>。為 <code>RecyclerView</code> 新增 <code>6dp</code> 的 padding，這樣外部就有 <code>8dp</code>，內部則有 <code>4dp</code>，符合規範。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;6dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span>  /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li>完整的 <code>&lt;RecyclerView&gt;</code> element 應如下所示。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/photos_grid&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;6dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layoutManager</span>=<span class="string">&quot;androidx.recyclerview.widget.GridLayoutManager&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:spanCount</span>=<span class="string">&quot;2&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:itemCount</span>=<span class="string">&quot;16&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/grid_view_item&quot;</span>  /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="新增-photo-grid-adapter"><a href="#新增-photo-grid-adapter" class="headerlink" title="新增 photo grid adapter"></a>新增 photo grid adapter</h4><p>現在，<code>RecyclerView</code> 在 <code>fragment_overview.xml</code> layout 中採用 grid layout。在這個步驟中，您可以透過 <u><code>RecyclerView</code> adapter</u>，將從 web server 擷取的 <u>data bind 至 <code>RecyclerView</code></u>。</p>
<h5 id="ListAdapter-Refresher"><a href="#ListAdapter-Refresher" class="headerlink" title="ListAdapter(Refresher)"></a>ListAdapter(Refresher)</h5><p><a href="https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter"><code>ListAdapter</code></a> 是 <a href="https://developer.android.com/reference/androidx/recyclerview/widget/RecyclerView.Adapter"><code>RecyclerView.Adapter</code></a> class 的<u>子類別(subclass)</u>，用來在 <code>RecyclerView</code> 中<u>顯示 List data</u>，包括在 background thread 上計算 Lists 之間的差異。</p>
<p>在此 app 中，您將<u>在 <code>ListAdapter</code> 中使用 <code>DiffUtil</code> 實作</u>。使用 <code>DiffUtil</code> 的優勢在於，每當新增(added)、移除(removed)或變更(changed) <code>RecyclerView</code> 中的某些 item 時，系統<u>不會 refreshed 整個 list</u>。系統<u>只會 refreshed 已變更的 items</u>。</p>
<p>將 <code>ListAdapter</code> 新增至您的 app。</p>
<ol>
<li>在 <code>overview</code> package 中，建立名為 <code>PhotoGridAdapter</code> 的 Kotlin class。</li>
<li>使用如下所示的<u>建構函式(constructor)參數</u>，從 <code>ListAdapter</code> 繼承(extends) <code>PhotoGridAdapter</code> class。<code>PhotoGridAdapter</code> class 會繼承(extends) <code>ListAdapter</code>，其 constructor 需要 <u>list item type</u>、<u>view holder</u> 和<u>實作 <code>DiffUtil.ItemCallback</code></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PhotoGridAdapter</span> : <span class="type">ListAdapter</span>&lt;<span class="type">MarsPhoto,</span></span><br><span class="line"><span class="type">        PhotoGridAdapter.MarsPhotoViewHolder</span>&gt;(DiffCallback) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <b><code>androidx.recyclerview.widget.ListAdapter</code></b> 和 <code>com.example.android.marsphoto.network.MarsPhoto</code> 類別。在後續步驟中，您將導入此 constructor 缺少的其他實作，這些實作會產生錯誤。</li>
</ul>
<ol start="3">
<li>如要解決上述錯誤，請在這個步驟中新增必要的方法，並於這項工作的後續部分實作這些方法。依序按一下 <code>PhotoGridAdapter</code> class、紅色燈泡，然後從下拉式選單中選取「Implement members」。在彈出式視窗中，選取 <code>ListAdapter</code> 方法，也就是 <code>onCreateViewHolder()</code> 和 <code>onBindViewHolder()</code>。Android Studio 仍會顯示錯誤，您將於這項工作的結尾修正這些錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: PhotoGridAdapter.MarsPhotoViewHolder &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">PhotoGridAdapter</span>.<span class="type">MarsPhotoViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>實作 <code>onCreateViewHolder</code> 和 <code>onBindViewHolder</code> 方法時需要 <code>MarsPhotoViewHolder</code>，這個項目會在下一步中新增。</li>
</ul>
<ol start="4">
<li>在 <code>PhotoGridAdapter</code> 中，新增 <code>MarsPhotoViewHolder</code> 的內部類別(inner class)定義，該定義可繼承(extends) <code>RecyclerView.ViewHolder</code>。您需要<u>使用 <b><code>GridViewItemBinding</code></b> 變數將 <code>MarsPhoto</code>  binding 至 layout</u>，請將該變數傳送至 <code>MarsPhotoViewHolder</code>。基本 <code>ViewHolder</code> class 需要在其 constructor 中設定 view，而您要<u>將其傳送至 binding 的 <strong>root view</strong></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MarsPhotoViewHolder</span>(<span class="keyword">private</span> <span class="keyword">var</span> binding:</span><br><span class="line">                   GridViewItemBinding):</span><br><span class="line">       RecyclerView.ViewHolder(binding.root) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>androidx.recyclerview.widget.RecyclerView</code> 和 <code>com.example.android.marsrealestate.databinding.GridViewItemBinding</code>。</li>
</ul>
<ol start="5">
<li>在 <code>MarsPhotoViewHolder</code> 中建立 <code>bind()</code> 方法，<u>將 <code>MarsPhoto</code> object 做為引數(argument)</u>，並<u>將 <code>binding.property</code> 設為該 object</u>。設定屬性後，請<u>呼叫 <code>executePendingBindings()</code></u>，以立即執行更新作業。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bind</span><span class="params">(MarsPhoto: <span class="type">MarsPhoto</span>)</span></span> &#123;</span><br><span class="line">   binding.photo = MarsPhoto</span><br><span class="line">   binding.executePendingBindings()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>onCreateViewHolder()</code> 的 <code>PhotoGridAdapter</code> class 中，移除 TODO 並新增下列一行內容。<code>onCreateViewHolder()</code> 方法需要<u>傳回新的 <code>MarsPhotoViewHolder</code></u>，<u>加載 <code>GridViewItemBinding</code></u> 並<u>使用父項(parent) <code>ViewGroup</code> context 中的 <code>LayoutInflater</code></u> 即可建立。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> MarsPhotoViewHolder(GridViewItemBinding.inflate(</span><br><span class="line">   LayoutInflater.from(parent.context)))</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>android.view.LayoutInflater</code>。</li>
</ul>
<ol start="7">
<li>在 <code>onBindViewHolder()</code> 方法中，移除 TODO 並新增下列幾行內容。您可以在這裡呼叫 <code>getItem()</code>，<u>取得與目前 <code>RecyclerView</code> 位置相關的 <code>MarsPhoto</code> object</u>，然後將該屬性<u>傳遞至 <code>MarsPhotoViewHolder</code> 中的 <code>bind()</code> 方法</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> marsPhoto = getItem(position)</span><br><span class="line">holder.bind(marsPhoto)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>PhotoGridAdapter</code> 中，為 <code>DiffCallback</code> 新增 <u>companion object</u> 定義，如下所示。<br><code>DiffCallback</code> object 繼承 <code>DiffUtil.ItemCallback</code> 為要比較的 generic type：<code>MarsPhoto</code>。您需要在這項實作中<u>比較兩張 Mars photo objects</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> DiffCallback : DiffUtil.ItemCallback&lt;MarsPhoto&gt;() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>androidx.recyclerview.widget.DiffUtil</code>。</li>
</ul>
<ol start="9">
<li>按下紅色燈泡，為 <code>DiffCallback</code> object (<code>areItemsTheSame()</code> 和 <code>areContentsTheSame()</code>) 實作 comparator 方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">MarsPhoto</span>, newItem: <span class="type">MarsPhoto</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">MarsPhoto</span>, newItem: <span class="type">MarsPhoto</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   TODO(<span class="string">&quot;Not yet implemented&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>在 <code>areItemsTheSame()</code> 方法中，移除 TODO。<code>DiffUtil</code> 會呼叫此方法來<u>判定兩個 objects 是否代表同一個 item</u>。<code>DiffUtil</code> 會使用此方法來<u>判斷新的 <code>MarsPhoto</code> object 是否和舊的 <code>MarsPhoto</code> object 相同</u>。每個 item (<code>MarsPhoto</code> object) 的 <u>ID 皆不得重複</u>。<u>比較 <code>oldItem</code> 和 <code>newItem</code> 的 ID</u>，然後 return 結果。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areItemsTheSame</span><span class="params">(oldItem: <span class="type">MarsPhoto</span>, newItem: <span class="type">MarsPhoto</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> oldItem.id == newItem.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>在 <code>areContentsTheSame()</code> 中，移除 TODO。如果 <code>DiffUtil</code> 想<u>檢查兩個 items 是否擁有相同的 data</u>，便會呼叫此方法。<code>MarsPhoto</code> 中的重要 data 是 image URL。<u>比較 <code>oldItem</code> 和 <code>newItem</code> 的 URLs</u>，然後 return 結果。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">areContentsTheSame</span><span class="params">(oldItem: <span class="type">MarsPhoto</span>, newItem: <span class="type">MarsPhoto</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> oldItem.imgSrcUrl == newItem.imgSrcUrl</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>請確認您可以正常編譯並執行 app，但模擬器顯示空白畫面。r<code>ecyclerview</code> 已準備就緒，但尚未收到任何 data，您將在接下來的步驟中實作這部分內容。</li>
</ul>
<h4 id="新增-binding-adapter-並-connect-各個部分"><a href="#新增-binding-adapter-並-connect-各個部分" class="headerlink" title="新增 binding adapter 並 connect 各個部分"></a>新增 binding adapter 並 connect 各個部分</h4><p>在這個步驟中，您將使用 <b><code>BindingAdapter</code></b> 來<u>初始化</u>包含 <u><code>MarsPhoto</code> objects list</u> 的 <b><code>PhotoGridAdapter</code></b>。若使用 <code>BindingAdapter</code> 設定 <code>RecyclerView</code> data，data binding 將<u>自動監控 <code>LiveData</code> 的 <code>MarsPhoto</code> objects list</u>。當 <u><code>MarsPhoto</code> list 有所變更</u>時，系統會自動呼叫 <strong>binding adapter</strong>。</p>
<ol>
<li>開啟 <code>BindingAdapters.kt</code>。</li>
<li>在檔案結尾，新增 <code>bindRecyclerView()</code> 方法，以 <code>RecyclerView</code> 和 <code>MarsPhoto</code> objects list 做為引數。請使用帶有 <code>listData</code> 屬性的 <code>@BindingAdapter</code> 為該方法加上註解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;listData&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindRecyclerView</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">data</span>: <span class="type">List</span>&lt;<span class="type">MarsPhoto</span>&gt;?)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>androidx.recyclerview.widget.RecyclerView</code> 和 <code>com.example.android.marsphotos.network.MarsPhoto</code>。</li>
</ul>
<ol start="3">
<li>在 <code>bindRecyclerView()</code> 函式中，將 <code>recyclerView.adapter</code> 做為 <code>PhotoGridAdapter</code> 並指派給新的 <code>val</code> 屬性 <code>adapter</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = recyclerView.adapter <span class="keyword">as</span> PhotoGridAdapter</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>bindRecyclerView()</code> 函式結尾，呼叫 <code>adapter.submitList()</code> 可查看 <u>Mars photos list data</u>。出現新的 list 時，這個屬性會通知 <code>RecyclerView</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">adapter.submitList(<span class="keyword">data</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>com.example.android.marsrealestate.overview.PhotoGridAdapter</code>。</li>
</ul>
<ol start="5">
<li>完整的 <code>bindRecyclerView</code> binding adapter 應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;listData&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindRecyclerView</span><span class="params">(recyclerView: <span class="type">RecyclerView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">                    <span class="keyword">data</span>: <span class="type">List</span>&lt;<span class="type">MarsPhoto</span>&gt;?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> adapter = recyclerView.adapter <span class="keyword">as</span> PhotoGridAdapter</span><br><span class="line">   adapter.submitList(<span class="keyword">data</span>)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>如要連結所有 items，請開啟 <code>res/layout/fragment_overview.xml</code>。接著<u>將 <code>app:listData</code> 屬性新增至 <code>RecyclerView</code></u> element，然後使用 <strong>data binding</strong> <u>將屬性設為 <code>viewmodel.photos</code></u>。這類似於您在先前的工作中為 <code>ImageView</code> 完成的工作。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:listData=&quot;@&#123;viewModel.photos&#125;&quot;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>開啟 <code>overview/OverviewFragment.kt</code>。在 <code>onCreateView()</code> 中，於 <code>return</code> 陳述式之前，將 <u><code>binding.photosGrid</code> 中的 <code>RecyclerView</code> adapter</u> 初始化為<u>新的 <code>PhotoGridAdapter</code> object</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.photosGrid.adapter = PhotoGridAdapter()</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>執行 app。畫面上應該會顯示可滑動的(scrolling)格狀 Mars images。滑動畫面即可查看新 images，但看起來有點奇怪。當您滑動畫面時，邊框間距會維持在 <code>RecyclerView</code> 的頂端和底部，所以 list 看起來並不會在動作列下方捲動。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/5d03641aa1589842_1920.png?hl=zh-tw" width="40%">

<ol start="9">
<li>如要修正這個問題，您需要指示 <code>RecyclerView</code> 不要使用 <code>android:clipToPadding</code> 屬性將 inner contents clip 至 padding。這樣，它便會在 padding 區域中繪製 scrolling view。返回 <code>layout/fragment_overview.xml</code>。為 <code>RecyclerView</code> 新增 <code>android:clipToPadding</code> 屬性，並將其設為 <code>false</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:clipToPadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span>  /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>執行 app。請注意，app 在正常顯示 image 前還會顯示 loading-progress icon。這是您傳送給 Coil image library 的 <strong>placeholder loading image</strong>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/3128b84aa22ef97e_1920.png?hl=zh-tw" width="40%">

<ol start="11">
<li>執行 app 期間，請開啟飛航模式。在模擬器中滑動 image。尚未載入的 image 會顯示為 <strong>broken-image icons</strong>。這是您傳遞至 Coil library的 image drawable，用於在系統出現網路錯誤或無法擷取 image 時顯示。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/28d2cbba564f35ff_1920.png?hl=zh-tw" width="40%">

<p>恭喜您，就快完成了！在接下來的最後一項工作中，您需要在 app 中新增更多<u>錯誤處理機制(error handling)</u>，進一步改善使用者體驗。</p>
<hr>
<h3 id="在-RecyclerView-中新增-error-handling"><a href="#在-RecyclerView-中新增-error-handling" class="headerlink" title="在 RecyclerView 中新增 error handling"></a>在 RecyclerView 中新增 error handling</h3><p>MarsPhotos app 會將無法擷取的圖片顯示為 broken-image icon。但是<u>如果沒有網路連線，app 會顯示空白畫面</u>。您將在接下來的步驟中驗證空白畫面。</p>
<p>開啟裝置或模擬器上的飛航模式。透過 Android Studio 執行應用程式。請注意空白畫面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/492011786c2dd7f7_1920.png?hl=zh-tw" width="40%">

<p>這無法提供良好的使用者體驗。在這項工作中，您需要<u>新增基本的錯誤處理機制(error handling)</u>，讓使用者更好地瞭解發生的情況。<u>如果未連線到網際網路，app 將顯示 connection-error icon</u>；而在擷取 MarsPhoto list 時，app 會顯示 loading animation。</p>
<h4 id="在-ViewModel-中新增-status"><a href="#在-ViewModel-中新增-status" class="headerlink" title="在 ViewModel 中新增 status"></a>在 ViewModel 中新增 status</h4><p>在這項工作中，您會在 <code>OverviewViewModel</code> 中建立屬性來代表 web request 的狀態(status)。需要考慮的 status 有三種：<u><b>載入(loading)</b></u>、<u><b>成功(success)</b></u>和<u><b>失敗(failure)</b></u>。</p>
<ul>
<li><u>等待資料時</u>，畫面會顯示 <u>loading status</u>。</li>
<li>系統<u>成功從 web service 擷取資料時</u>會顯示 <u>success status</u>。</li>
<li>出現<u>網路或連線錯誤時</u>會顯示 <u>failure status</u>。</li>
</ul>
<h5 id="Kotlin-中的-Enum-Classes"><a href="#Kotlin-中的-Enum-Classes" class="headerlink" title="Kotlin 中的 Enum Classes"></a>Kotlin 中的 Enum Classes</h5><p>如要在 app 中表示這三個 status，請使用 <a href="https://kotlinlang.org/docs/enum-classes.html">enum</a>。<code>enum</code> 是<u>列舉(enumeration)</u>的縮寫，表示<u>集合(collection)中所有 items 已排序的 list</u>。每個 <u><code>enum</code> 常數</u>都是 <code>enum</code> class 的一個 <strong>object</strong>。</p>
<p>在 Kotlin 中，<code>enum</code> 這種 data type 可容納一組<u>常數(constants)</u>。其定義方式是在 class 定義前方加上 keyword <code>enum</code>，如下所示。列舉常數(Enum constants)會以半形逗號分隔。</p>
<p>定義：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">Direction</span> &#123;</span><br><span class="line">    NORTH, SOUTH, WEST, EAST</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用方式：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> direction : Direction = Direction.NORTH </span><br></pre></td></tr></table></figure>
<ul>
<li>如上所示，您可以使用 class 名稱後跟點 (<code>.</code>) 運算子和常數名稱來引用 <code>enum</code> object。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong>您可使用 class 定義中的<u>建構函式(constructor)參數</u>，以自訂 value 初始化列舉常數(Enum constants)。此內容目前不在這個程式碼研究室的範圍內，更多資訊請參閱 <a href="https://kotlinlang.org/docs/enum-classes.html#anonymous-classes">Kotlin 說明文件</a>。</p>
          </div>

<h5 id="在-Viewmodel-中新增帶有-status-values-的-enum-class-定義"><a href="#在-Viewmodel-中新增帶有-status-values-的-enum-class-定義" class="headerlink" title="在 Viewmodel 中新增帶有 status values 的 enum class 定義"></a>在 Viewmodel 中新增帶有 status values 的 enum class 定義</h5><ol>
<li>開啟 <code>overview/OverviewViewModel.kt</code>。然後在檔案頂端 (imports之後、class 定義之前) 新增 <code>enum</code>，代表所有可用狀態(available statuses)：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title class_">MarsApiStatus</span> &#123; LOADING, ERROR, DONE &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>捲動至<code> _status</code> 和 <code>status</code> 屬性的定義後，將 type 從 <code>String</code> 變更為 <code>MarsApiStatus. MarsApiStatus</code>。是您在上一步定義的 enum class。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _status = MutableLiveData&lt;MarsApiStatus&gt;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> status: LiveData&lt;MarsApiStatus&gt; = _status</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>getMarsPhotos()</code> 方法中，將 “Success: …” 字串變更為 <code>MarsApiStatus.DONE</code> status，並將 “Failure…” 字串變更為 <code>MarsApiStatus.ERROR</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    _photos.value = MarsApi.retrofitService.getPhotos()</span><br><span class="line">    _status.value = MarsApiStatus.DONE</span><br><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">     _status.value = MarsApiStatus.ERROR</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>try &#123;&#125;</code> 區塊上方將 status 設為 <code>MarsApiStatus.LOADING</code>。這是<b>協程(coroutine)</b><u>執行期間</u>以及您在<u>等待資料時</u>的<u>初始 status</u>。現在，完整的 <code>viewModelScope.launch &#123;&#125;</code> 區塊如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">            _status.value = MarsApiStatus.LOADING</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                _photos.value = MarsApi.retrofitService.getPhotos()</span><br><span class="line">                _status.value = MarsApiStatus.DONE</span><br><span class="line">            &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">                _status.value = MarsApiStatus.ERROR</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>catch &#123;&#125;</code> 區塊中的 error state 之後，將 <code>_photos</code> 設為 empty list。這項操作可清除 Recycler view。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">   _status.value = MarsApiStatus.ERROR</span><br><span class="line">   _photos.value = listOf()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>完整的 <code>getMarsPhotos()</code> 方法應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getMarsPhotos</span><span class="params">()</span></span> &#123;</span><br><span class="line">   viewModelScope.launch &#123;</span><br><span class="line">        _status.value = MarsApiStatus.LOADING</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">           _photos.value = MarsApi.retrofitService.getPhotos()</span><br><span class="line">           _status.value = MarsApiStatus.DONE</span><br><span class="line">        &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">           _status.value = MarsApiStatus.ERROR</span><br><span class="line">           _photos.value = listOf()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您已將 status 定義為 <strong>enum states</strong>，並完成了以下設定：</p>
<ol>
<li>在 <u>coroutine 開始時</u>顯示 <strong>loading</strong>。</li>
<li>在 app <u>從 web server 擷取好資料時</u>顯示 <strong>done</strong>。</li>
<li>在<u>出現 exception 時</u>顯示 <strong>error</strong>。</li>
</ol>
<p>在下一項工作中，您將使用 binding adapter 顯示對應的 icons。</p>
<h4 id="為-ImageView-status-新增-binding-adapter"><a href="#為-ImageView-status-新增-binding-adapter" class="headerlink" title="為 ImageView status 新增 binding adapter"></a>為 ImageView status 新增 binding adapter</h4><p>您已使用一組 <code>enum</code> status 在 <code>OverviewViewModel</code> 中設定了 <code>MarsApiStatus</code>。在這個步驟中，您需要在 app 中顯示它。您可以對 <code>ImageView</code> 使用 <strong>binding adapter</strong>，以<u>顯示 loading 和 error status 的 icon</u>。如果 app 處於 loading state 或 error state，則應顯示(visible) <code>ImageView</code>。app loading 完畢後，應不再顯示(invisible) <code>ImageView</code>。</p>
<ol>
<li>請開啟 <code>BindingAdapters.kt</code>，捲動至檔案結尾，即可新增其他 adaptor。新增名為 <code>bindStatus()</code> 的新 binding adapter，<u>以 <code>ImageView</code> 和 <code>MarsApiStatus</code> 值做為引數</u>。使用 <code>@BindingAdapter</code> 為方法加上注釋，<u>傳遞自訂屬性 <code>marsApiStatus</code> 做為參數</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@BindingAdapter(<span class="string">&quot;marsApiStatus&quot;</span>)</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">bindStatus</span><span class="params">(statusImageView: <span class="type">ImageView</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">          status: <span class="type">MarsApiStatus</span>?)</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>com.example.android.marsrealestate.overview.MarsApiStatus</code>。</li>
</ul>
<ol start="2">
<li>在 <code>bindStatus()</code> 方法中新增 <code>when &#123;&#125;</code> 區塊，即可在不同 status 之間切換。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (status) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>when &#123;&#125;</code> 中，新增 loading state 的 case <code>(MarsApiStatus.LOADING)</code>。對於這個 state，請將 <code>ImageView</code> 設為 visible，並指派 loading animation。這個 animation drawable 與先前工作中 Coil 採用的 drawable 相同。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">when</span> (status) &#123;</span><br><span class="line">   MarsApiStatus.LOADING -&gt; &#123;</span><br><span class="line">      statusImageView.visibility = View.VISIBLE</span><br><span class="line">      statusImageView.setImageResource(R.drawable.loading_animation)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>視需要 import <code>android.view.View</code>。</li>
</ul>
<ol start="4">
<li>新增 error state 的 case，即 <code>MarsApiStatus.ERROR</code>。如同 <code>LOADING</code> state，請將 state <code>ImageView</code> 設為 visible，並使用 connection-error drawable。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">MarsApiStatus.ERROR -&gt; &#123;</span><br><span class="line">   statusImageView.visibility = View.VISIBLE</span><br><span class="line">   statusImageView.setImageResource(R.drawable.ic_connection_error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>新增 done state 的 case，即 <code>MarsApiStatus.DONE</code>。您收到了正確的 response，請將 state  <code>ImageView</code> 的 visibility 設定為 <code>View.GONE</code> 以隱藏該 status。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">MarsApiStatus.DONE -&gt; &#123;</span><br><span class="line">   statusImageView.visibility = View.GONE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您已為 status image view 設定了 binding adapter，在下一個步驟中，您需要新增 image view ，該 view 使用新的 binding adapter。</p>
<h4 id="新增-status-ImageView"><a href="#新增-status-ImageView" class="headerlink" title="新增 status ImageView"></a>新增 status ImageView</h4><p>在這個步驟中，您將在 <code>fragment_overview.xml</code> 中新增 Image view，以顯示您先前定義的 status。</p>
<ol>
<li>開啟 <code>res/layout/fragment_overview.xml</code>。在 <code>ConstraintLayout</code> 的 <code>RecyclerView</code> element 下方，新增下方顯示的 <code>ImageView</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/status_image&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:marsApiStatus</span>=<span class="string">&quot;@&#123;viewModel.status&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>上述 <code>ImageView</code> 與 <code>RecyclerView</code> 具有相同的 constraints。不過，所設 width 和 height 會使用 <code>wrap_content</code> 將圖片置中，而不是延展圖片來填滿 view。另請注意，<code>app:marsApiStatus</code> 屬性已設為 <code>viewModel.status</code>，並在 <code>ViewModel</code> 中的 status 屬性變更時呼叫 <code>BindingAdapter</code>。</p>
<ol start="2">
<li>如要測試上述程式碼，請在模擬器或裝置上開啟飛航模式，模擬網路連線錯誤。接著編譯並執行 app，請注意，畫面上會顯示 error image：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-internet-images/img/a91ddb1c89f2efec_1920.png?hl=zh-tw" width="40%">

<ol start="3">
<li>輕觸返回按鈕即可關閉 app，並關閉飛航模式。使用最近畫面可返回 app。當 app 查詢 web service 時，圖片開始 load 之前，畫面上可能會極短暫地顯示 loading 旋轉 icon，具體視您的網路連線速度而定。</li>
</ol>
<p>恭喜您完成本程式碼研究室，並建構了 MarsPhotos app！現在就與親朋好友分享真實的火星圖片，炫耀一下您的 app 吧。</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><a href="https://coil-kt.github.io/coil/">Coil library</a> 可簡化在 app 中管理 image 的程序，例如download, buffer, decode, 和 cache image。</li>
<li><a href="https://developer.android.com/topic/libraries/data-binding/binding-adapters">Binding adapters</a> 是一種 extension methods，顯示在 view 與 view 綁定的 data 之間。data 變更時，binding adapters 會提供自訂行為，例如呼叫 Coil 將 URL 中的 image 載入 <code>ImageView</code>。</li>
<li>Binding adapters 是 extension methods，附有 <code>@BindingAdapter</code> 註解。</li>
<li>如要顯示格狀排列的 image，請將 <code>RecyclerView</code> 與 <code>GridLayoutManager</code> 搭配使用。</li>
<li>如要在屬性變更時更新屬性 list，請使用 <code>RecyclerView</code> 和 layout 之間的 binding adapter。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Connect to the internet</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>View Binding</tag>
        <tag>Material Design</tag>
        <tag>RecyclerView</tag>
        <tag>ImageView</tag>
        <tag>companion object</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Data Binding</tag>
        <tag>Enum Classes</tag>
        <tag>Coil</tag>
        <tag>Binding Adapters</tag>
        <tag>let</tag>
        <tag>Grid Layout</tag>
        <tag>ListAdapter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(34)-從Internet取得Data</title>
    <url>/2023/12/06/Android%E7%AD%86%E8%A8%98-34-%E5%BE%9EInternet%E5%8F%96%E5%BE%97Data/</url>
    <content><![CDATA[<blockquote>
<p>使用第三方 library <code>Retrofit</code> 將 app 連線至後端 server，並瞭解 <code>REST</code> web service。</p>
</blockquote>
<p>使用以 open source 開發的 libraries 建構<u>網路層(network layer)</u>，並<u>從後端 server 取得 data</u>。這樣可大幅簡化資料擷取作業，還可讓 app 符合 Android 最佳做法，例如在<u>背景執行緒(background thread)</u>上執行作業。若網際網路(internet)連線速度緩慢或無法使用，您也可更新 app 的 UI，以讓使用者隨時掌握任何網路連線問題。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>什麼是 <a href="https://en.wikipedia.org/wiki/REST"><code>REST</code></a> web service。</li>
<li>使用 <a href="https://square.github.io/retrofit/"><code>Retrofit</code></a> library 連線至 internet 上的 <code>REST</code> web service 並取得 response(回應)。</li>
<li>使用 <a href="https://github.com/square/moshi"><code>Moshi</code></a> library 將 <u><code>JSON</code> response</u> 解析(parse)成 <u>data object</u>。</li>
</ul>
<p><strong>建構項目</strong></p>
<ul>
<li>修改 starter app，以發出 <strong>web service API</strong> 的<u>要求(request)</u>和<u>處理回應(response)</u>。</li>
<li>使用 <code>Retrofit</code> library 為 app 實作<u>網路層(network layer)</u>。</li>
<li>使用 <code>Moshi</code> library，將 web service 中的 <u><code>JSON</code> response</u> 解析(parse)成 app 的 <u><code>LiveData</code> objects</u>。</li>
<li>使用 <code>Retrofit</code> 提供的 <b>coroutines(協程)</b>來簡化程式碼。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="App-總覽"><a href="#App-總覽" class="headerlink" title="App 總覽"></a>App 總覽</h3><p>在本課程中，您將使用名為 <code>MarsPhotos</code> 的範例 app，顯示火星表面的圖片。此 app 會連線至 web service，以擷取和顯示火星的相片。這些圖片是自 NASA 火星漫遊者擷取的火星實景相片。以下是最後一個 app 的螢幕截圖，其中包含以 <code>RecyclerView</code> 建構的縮圖屬性圖片。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/ea967f35fa98d72b_1920.png?hl=zh-tw" width="40%">

<div class="note no-icon success">
            <p><strong>注意：</strong>以上螢幕截圖是您在下個程式碼研究室結束時，於課程結束時所建構最終 app 的螢幕截圖。本程式碼研究室中顯示的螢幕截圖，可協助您更加瞭解整體的app功能。</p>
          </div>

<p>您在本程式碼研究室中建構的 app 版本不會採用大量視覺閃光特效：其著重於 app 的網路層部分，以<u>連線至 <strong>internet</strong> 並透過 <strong>web service</strong> 下載<b>原始屬性資料(raw property data)</b></u>。為確保系統正確擷取和剖析資料，請直接<u>在 text view 輸出從後端 server 接收的相片數量</u>：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/1a7e99791caf8d96_1920.png?hl=zh-tw" width="40%">

<hr>
<h3 id="探索-MarsPhotos-starter-app"><a href="#探索-MarsPhotos-starter-app" class="headerlink" title="探索 MarsPhotos starter app"></a>探索 MarsPhotos starter app</h3><h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>如果您使用 GitHub 中的範例程式碼，請注意資料夾名稱是 <code>android-basics-kotlin-mars-photos-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-mars-photos-app/tree/starter">https://github.com/google-developer-training/android-basics-kotlin-mars-photos-app/tree/starter</a><br><strong>分支版本名稱：</strong><b>starter</b></p>
          </div>

<p>當您編譯和執行 app 時，應會在下列畫面畫面中央看見預留位置文字。完成本程式碼研究室後，您會將此預留位置文字更新為已擷取的相片數量。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/406c7bcc0f07267c_1920.png?hl=zh-tw" width="40%">

<h4 id="範例程式碼逐步操作說明"><a href="#範例程式碼逐步操作說明" class="headerlink" title="範例程式碼逐步操作說明"></a>範例程式碼逐步操作說明</h4><p>在此工作中，您將會熟悉專案的結構。以下是關於專案中重要檔案與資料夾的逐步操作說明。</p>
<ol>
<li><code>OverviewFragment</code>:</li>
</ol>
<ul>
<li>此為 <u><code>MainActivity</code> 中顯示的 fragment</u>。您在上個步驟中看到的 placeholder text 會顯示於此 fragment。</li>
<li>在下一個程式碼研究室中，此 fragment 會<u>顯示自 Mars photos 後端 server 接收的 data</u>。</li>
<li>此類別會保留 <code>OverviewViewModel</code> 物件的引用。</li>
<li><code>OverviewFragment</code> 的 <code>onCreateView()</code> 函式會<u>使用 Data Binding 來加載 <code>fragment_overview</code> layout</u>，將 binding lifecycle owner 設定為自己，並<u>在其 binding object 中設定 <code>viewModel</code> 變數</u>。</li>
<li>指派 lifecycle owner 後，系統會<u>自動觀察 Data Binding 中使用的任何 <code>LiveData</code> 是否有任何變更，並據以更新 UI</u>。</li>
</ul>
<ol start="2">
<li><code>OverviewViewModel</code>:</li>
</ol>
<ul>
<li>此為 <u><code>OverviewFragment</code> 的對應 view model</u>。</li>
<li>此類別包含名為 <code>_status</code> 的 <u><code>MutableLiveData</code> 屬性</u>及其 <u>backing 屬性</u>。更新此屬性的值時，會一併更新畫面上顯示的 <u>placeholder text</u>。</li>
<li><code>getMarsPhotos()</code> 方法會<u>更新 placeholder response</u>。稍後在程式碼研究室中，您將使用此程式碼來顯示從 server 擷取(fetched)的 data。本程式碼研究室的目標，在於<u>使用從 internet 取得的 real data 來更新 <code>ViewModel</code> 中的 <code>status</code> <code>LiveData</code></u>。</li>
</ul>
<ol start="3">
<li><code>res/layout/fragment_overview.xml</code>：</li>
</ol>
<ul>
<li>此 layout 已設為使用 <strong>data binding</strong>，且由單一 <code>TextView</code> 組成。</li>
<li>其會宣告 <code>OverviewViewModel</code> 變數，然後<u>將 <code>status</code> 從 <code>ViewModel</code> binds 至 <code>TextView</code></u>。</li>
</ul>
<ol start="4">
<li><p><code>MainActivity.kt</code>：<br>此 activity 的唯一工作是<u>載入(load)該 activity 的 layout <code>activity_main</code></u>。</p>
</li>
<li><p><code>layout/activity_main.xml</code>:<br>main activity layout <u>具有指向 <code>fragment_overview</code> 的單一 <code>FragmentContainerView</code></u>，overview fragment 會在 app 啟動(launched)時執行個體化(instantiated)。</p>
</li>
</ol>
<h4 id="App-Overview"><a href="#App-Overview" class="headerlink" title="App Overview"></a>App Overview</h4><p>在本程式碼研究室中，您會<u>建立網路服務層來與後端 server 進行溝通</u>，以及<u>擷取(fetch)必要的 data</u>。您將使用名為 <code>Retrofit</code> 的第三方 library 實作此步驟。您將在稍後進一步瞭解相關資訊。<u><code>ViewModel</code> 會直接與該網路層進行通訊</u>，app 的其餘部分則會對此實作公開。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/1c2493b9e9e1eef_1920.png?hl=zh-tw" width="40%">

<p><code>OverviewViewModel</code> 負責<u>執行 <strong>network call</strong> 以取得 <strong>Mars photos data</strong></u>。在 <code>ViewModel</code> 中，您會使用 <code>LiveData</code> 搭配<u>生命週期感知(lifecycle-aware) data binding</u>，在 data 變更時更新 app UI。</p>
<hr>
<h3 id="Web-services-與-Retrofit"><a href="#Web-services-與-Retrofit" class="headerlink" title="Web services 與 Retrofit"></a>Web services 與 Retrofit</h3><p>Mars photos data 會儲存在 web server 中。如要讓 app 取得此 data，您必須建立連線(establish a connection)並與 internet 上的 server 通訊(communicate)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/37f7c367e182b4f9_1920.png?hl=zh-tw" width="70%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/d99aca47f5947a78_1920.png?hl=zh-tw" width="70%">

<p>現今的大部分 web servers 會使用稱為 <a href="https://en.wikipedia.org/wiki/REST">REST</a> 的一般無狀態網路架構(stateless web architecture)，其中 <strong>RE</strong> 為<u>「Representational」(表示法)</u> 的縮寫，<strong>S</strong> 為<u>「State」(狀態)</u> 的縮寫，<strong>T</strong> 為<u>「Transfer」(傳輸)</u> 的縮寫。提供此架構的 web services，稱為 <strong>RESTful services</strong>。</p>
<p>系統會透過 <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier">URI</a> 以規範的方式向 <strong>RESTful web services</strong> 發出<u>請求(requests)</u>。<strong>URI (Uniform Resource Identifier&#x2F;統一資源標識符)</strong> 會<u>依 name 來識別 server 中的資源(resource)，而不會暗示其位置(location)或存取方式(access)</u>。舉例來說，在本課程的 app 中，您將使用下列 <strong>server URI</strong> 來擷取(retrieve) <strong>image urls</strong> (此 server 會代管(hosts) Mars real-estate 和 Mars photos)：<br><a href="https://android-kotlin-fun-mars-server.appspot.com/?hl=zh-tw">android-kotlin-fun-mars-server.appspot.com</a></p>
<p><strong>URL (Uniform Resource Locator&#x2F;統一資源定位符)</strong> 是一種 <strong>URI</strong>，其<u>會指定運作或取得資源(resource)表示法的方式</u>，亦即同時指定的主要<u>存取機制(access mechanism)</u>與<u>網路位置(network location)</u>。</p>
<div class="note no-icon primary">
            <p><strong>URI vs URL</strong><br>假設我要設計一個API</p><ul><li>URI 為：<br><code>/auth/sound/:name</code></li><li>URL 為：<br><code>music.com/auth/sound/bird</code><br>(URL 可讓其他人來使用)</li></ul><p>在以上的例子中，<code>/auth/sound/:name</code> 是一個 URI，它用於<u>識別和定位一個資源</u>，其中 <code>:name</code> 是一個路由參數，可以在實際使用時被具體的值替換。</p><p>而提供給他人使用的 <code>music.com/auth/sound/bird</code> 是一個 URL，它是一個<u>具體的資源位址</u>，包含了協定 (http 或 https)、主機名稱 (music.com)、路徑 (&#x2F;auth&#x2F;sound&#x2F;bird) 等元素，用於<u>定位並存取資源</u>。</p><p>因此，URI 是用於<u>識別和定位資源的通用概念</u>，而 <u>URL 是 URI 的一種具體實現方式</u>，用於指定資源的位址和定位方式，則 <code>/auth/sound/:name</code> 是 URI，<code>music.com/auth/sound/bird</code> 是其對應的 URL。</p><p><a href="https://hackmd.io/@Si-Fi-Life/BJMfdJ2O2">點此了解更多</a></p>
          </div>

<p>例如：<br>下列 URL 會列出 Mars 上所有可用的 real estate list！<br><a href="https://android-kotlin-fun-mars-server.appspot.com/realestate">https://android-kotlin-fun-mars-server.appspot.com/realestate</a></p>
<p>下列 URL 會取得 Mars photos 的 list：<br><a href="https://android-kotlin-fun-mars-server.appspot.com/photos">https://android-kotlin-fun-mars-server.appspot.com/photos</a></p>
<p>這些 URLs 是指識別的資源(resource identified)，例如 <a href="https://android-kotlin-fun-mars-server.appspot.com/realestate?hl=zh-tw">&#x2F;realestate</a> 或 <a href="https://android-kotlin-fun-mars-server.appspot.com/photos?hl=zh-tw">&#x2F;photos</a>，您可透過 <strong>Hypertext Transfer Protocol (http:)</strong> 從網路(network)中取得。您將在本程式碼研究室中使用 <a href="https://android-kotlin-fun-mars-server.appspot.com/photos?hl=zh-tw">&#x2F;photos</a> 端點(endpoint)。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>熟悉的 <b>web URL</b> 實際上屬於 <b>URI</b> 類型。在本課程中會取決於<u>呼叫 API 的方式</u>，交替使用 URL 和 URI。</p>
          </div>

<h4 id="Web-service-request"><a href="#Web-service-request" class="headerlink" title="Web service request"></a>Web service request</h4><p>每個 <strong>web service request</strong> 都包含一個 <strong>URI</strong>，並透過 Chrome 等網路瀏覽器使用的 <strong>HTTP</strong> 通訊協定傳輸至 <strong>server</strong>。HTTP 要求包含<u>指示 server 處置方式的作業</u>。</p>
<p>常見的 HTTP 作業包括：</p>
<ul>
<li><code>GET</code> 用於抓取 server data</li>
<li><code>POST</code> 或 <code>PUT</code> 用於 add&#x2F;create&#x2F;update server 的 new data</li>
<li><code>DELETE</code> 用於刪除 server 中的 data</li>
</ul>
<p>App 會向 server 傳送包含 <u>Mars photos 資訊(information)</u>的 <u><strong>HTTP GET request</strong></u>，接著 server 會對 app 傳回 response，包括 <u>image urls</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/bcd50e389186fa98_1920.png?hl=zh-tw" width="70%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/1e08dbc82558a7cd_1920.png?hl=zh-tw" width="70%">

<p>Web service 的 response 通常會採用 <strong>XML</strong> 或 <strong>JSON</strong> 這種常見的網路格式進行格式化 (在 <strong>key-value</strong> 組合中代表<u>結構化資料(structured data)</u> 格式)。我們將在後續工作中進一步瞭解 JSON。</p>
<p>在這項工作中，您要<u>建立與 server 的連線(network connection)</u>、<u>與 server 通訊(communicate)</u>，以及<u>接收 JSON response</u>。您將使用已寫入的後端 server。在本程式碼研究室中，您將使用第三方 library <strong>Retrofit</strong> 來與後端 server 進行通訊(communicate)。</p>
<h4 id="External-Libraries"><a href="#External-Libraries" class="headerlink" title="External Libraries"></a>External Libraries</h4><p><u>外部程式庫(External Libraries)</u>或<u>第三方 libraries</u> 就像是 <b>core Android API</b> 的<u>擴充功能(extensions)</u>。這些 libraries 大多為 open source、由社群開發，並由全球廣大 Android 社群集體貢獻心力負責維護。這讓包括您在內的 Android developers 能夠打造出更優異的 app。</p>
<h4 id="Retrofit-Library"><a href="#Retrofit-Library" class="headerlink" title="Retrofit Library"></a>Retrofit Library</h4><p>在本程式碼研究室中，您會使用 <strong>Retrofit library</strong> 來與 <strong>RESTful Mars web service</strong> 通訊，其為具備完善支援和維護的理想範例 library。只要瀏覽其 <a href="https://github.com/square/retrofit">GitHub</a> 網頁，查看尚未解決的問題 (部分為功能要求) 和已解決的問題，即可感受上述優勢。若 developers 有在解決問題並定期回應功能要求，表示此 library 維護良好，且極為適合在 app 中使用。此外，亦提供 <a href="https://square.github.io/retrofit/">Retrofit</a> documentation 網頁。</p>
<p><strong>Retrofit library</strong> 將<u>與後端(backend)通訊</u>。其會根據<u>傳遞的參數(parameters)</u>，<u>建立 web service 的 URI</u>。您將在稍後的章節中看到更多內容。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/a8f10b735ad998ac_1920.png?hl=zh-tw" width="80%">

<h4 id="新增-Retrofit-dependencies"><a href="#新增-Retrofit-dependencies" class="headerlink" title="新增 Retrofit dependencies"></a>新增 Retrofit dependencies</h4><p><strong>Android Gradle</strong> 可讓您<u>將外部 libraries 新增至 project</u>。除了 library dependency 外，亦應包括<u>代管(hosted) library 的 repository</u>。例如來自 <strong>Jetpack libraries</strong> 的 <code>ViewModel</code> 和 <code>LiveData</code> 等 <strong>Google libraries</strong>，是由 Google repository 負責代管(hosted)。大部分的 community libraries (例如 Retrofit) 皆是由 <u><b>Google</b> 和 <b>MavenCentral</b> repositories</u> 代管。</p>
<ol>
<li>開啟 project 的頂層 <code>build.gradle(Project: MarsPhotos)</code> 檔案。請注意在 repositories 區塊下方列出的 <code>repositories</code>。您應該會看到以下兩個 repositories：<code>google()</code>、<code>mavenCentral()</code>。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">repositories</span> &#123;</span><br><span class="line">   google()</span><br><span class="line">   mavenCentral()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>開啟 module 層級 Gradle 檔案 <code>build.gradle (Module: MarsPhots.app)</code>。</li>
<li>在 <code>dependencies</code> 區段中，為 Retrofit libraries 新增以下幾行：</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Retrofit</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span></span><br><span class="line"><span class="comment">// Retrofit with Scalar Converter</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:converter-scalars:2.9.0&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>第一個 dependency 針對 Retrofit2 library 本身提供，第二個 dependency 則用於 Retrofit scalar converter(純量轉換工具)。<u>此 converter 可讓 Retrofit 以 <code>String</code> 的形式傳回 JSON 結果</u>。這兩個 libraries 會搭配運作。</li>
</ul>
<ol start="4">
<li>按一下「Sync Now」，使用新的 dependencies rebuild project。</li>
</ol>
<h4 id="新增-Java-8-語言功能支援"><a href="#新增-Java-8-語言功能支援" class="headerlink" title="新增 Java 8 語言功能支援"></a>新增 Java 8 語言功能支援</h4><p>包括 Retrofit2 在內的眾多第三方 libraries，皆使用 Java 8 語言功能(features)。Android Gradle 外掛程式(plugin)提供使用特定 Java 8 語言功能的內建支援。</p>
<ol>
<li>如要使用內建功能(built-in features,)，您必須在 module 的 <code>build.gradle</code> 檔案中加入下列程式碼。系統已為您完成此步驟，請確認在您的 <code>build.gradle(Module: MarsPhotos.app)</code> 中顯示下列程式碼。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  compileOptions &#123;</span><br><span class="line">    <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  kotlinOptions &#123;</span><br><span class="line">    jvmTarget = <span class="string">&#x27;1.8&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="連線至-Internet"><a href="#連線至-Internet" class="headerlink" title="連線至 Internet"></a>連線至 Internet</h3><p>您會使用 Retrofit library 與 <u><strong>Mars web service</strong></u> 進行通訊，並將原始 <u><strong>JSON response</strong></u> 顯示為 <code>String</code>。預留位置 <code>TextView</code> 會<u>顯示傳回的 JSON response 字串，或顯示連線錯誤的訊息</u>。</p>
<p>Retrofit <u>會根據 web service 的內容為 app 建立 <strong>network API</strong></u>。其會<u>從 web service 擷取 data</u>，並透過獨立的<u><strong>轉換工具(converter) library</strong> 執行 data 轉送</u> ，該 library 瞭解 <u>data 解碼</u>方式，且會<u>以 <code>String</code> 等 objects 形式傳回 data</u>。Retrofit 提供諸如 XML 和 JSON 等熱門 data 格式的內建支援。Retrofit 最終會建立程式碼來呼叫和耗用這項服務，包括<u>在 background threads 執行 requests</u> 之類的重要詳細資訊。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/deb437805232f6a_1920.png?hl=zh-tw" width="80%">

<p>在此工作中，您會將<u>網路層</u>新增至 MarsPhotos project，以供 <code>ViewModel</code> 用於<u>與 web service 通訊</u>。您必須按照下列步驟實作 <u><strong>Retrofit service API</strong></u>。</p>
<ul>
<li>建立網路層 (<u><strong><code>MarsApiService</code> class</strong></u>)。</li>
<li>使用 <u>base URL</u> 和 <u>converter factory</u> 來建立 <u><strong>Retrofit object</strong></u>。</li>
<li>建立用於說明 <u>Retrofit 如何與 web server 通訊</u>的 <u><strong>interface</strong></u>。</li>
<li>建立 <u><strong>Retrofit service</strong></u>，並向 app 的其餘部分<u>公開 API service instance</u>。</li>
</ul>
<p>實作上述步驟：</p>
<ol>
<li>建立名為 network 的新 package。在「Android」project 案窗格中，以滑鼠右鍵按一下套件 <code>com.example.android.marsphotos</code>。依序選取「New」(新增) &gt;「Package」(套件)。在彈出式視窗中，將 network 附加至建議的 package name 結尾處。</li>
<li>在新 package network 中，建立新的 Kotlin 檔案。將其命名為 <code>MarsApiService</code>。</li>
<li>開啟 <code>network/MarsApiService.kt</code>。為 web service 的 <u>base URL</u> 新增下列常數(constant)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> BASE_URL =</span><br><span class="line">   <span class="string">&quot;https://android-kotlin-fun-mars-server.appspot.com&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在該常數下方，新增 <u>Retrofit builder</u> 來 <u>建立和新增<b>Retrofit object</b></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br></pre></td></tr></table></figure>
<ul>
<li>在系統提示時 import <code>retrofit2.Retrofit</code>。</li>
</ul>
<ol start="5">
<li>Retrofit 需要 <u>web service 的 <strong>base URI</strong> 和 <strong>converter factory</strong></u>，以 <u>build <b>web services API</b></u>。converter 會向 Retrofit 告知如何處理從 web service 傳回的 data。在此範例中，您希望 Retrofit 從 web service 擷取 JSON response，並以 <code>String</code> 形式傳回。Retrofit 具備支援字串(strings)和其他原始類型(primitive types)的 <code>ScalarsConverter</code>，因此您會<u>在具有 <code>ScalarsConverterFactory</code> instance 的 builder 上呼叫 <code>addConverterFactory()</code></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">   .addConverterFactory(ScalarsConverterFactory.create())</span><br></pre></td></tr></table></figure>
<ul>
<li>在系統提示時 import <code>retrofit2.converter.scalars.ScalarsConverterFactory</code>。</li>
</ul>
<ol start="6">
<li>使用 <code>baseUrl()</code> 方法<u>新增 web service 的 <strong>base URI</strong></u>。最後，呼叫 <code>build()</code> 以建立 Retrofit object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">   .addConverterFactory(ScalarsConverterFactory.create())</span><br><span class="line">   .baseUrl(BASE_URL)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 Retrofit builder 的呼叫下方，定義名為 <code>MarsApiService</code> 的 interface，此 interface 會定義 Retrofit <u>使用 <strong>HTTP requests</strong> 與 <strong>web server</strong> 通訊的方式</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MarsApiService</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>MarsApiService</code> interface 當中，新增名為 <code>getPhotos()</code> 的函式，以<u>從 web service 取得 response 字串</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MarsApiService</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPhotos</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>使用 <code>@GET</code> 註解，向 Retrofit 表明此為 <u>GET request</u>，並指定該 web service 方法的端點(endpoint)。在此範例中，endpoint 就是 <code>photos</code>。如上個工作中所述，您可在本程式碼研究室中使用 <a href="https://android-kotlin-fun-mars-server.appspot.com/photos?hl=zh-tw">&#x2F;photos</a> endpoint。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MarsApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;photos&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPhotos</span><span class="params">()</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>retrofit2.http.GET</code>。</li>
</ul>
<ol start="10">
<li>叫用 <code>getPhotos()</code> 方法時，Retrofit 會將 endpoint <code>photos</code> 附加至在 Retrofit builder 中定義的 base URL，以用於啟動 request。將函式的 return type 新增至 <code>String</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MarsApiService</span> &#123;</span><br><span class="line">    <span class="meta">@GET(<span class="string">&quot;photos&quot;</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getPhotos</span><span class="params">()</span></span>: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="物件宣告"><a href="#物件宣告" class="headerlink" title="物件宣告"></a>物件宣告</h4><p>在 Kotlin 中，<a href="https://kotlinlang.org/docs/object-declarations.html#object-declarations">物件宣告(object declarations)</a>是用來<u>宣告單例模式物件(singleton objects)</u>。<a href="https://en.wikipedia.org/wiki/Singleton_pattern">單例模式(singleton pattern)</a>可確保<u>僅建立一個 <b>object instance</b></u>，且對該 object <u>僅有一個<b>全域存取點(global point of access)</b></u>。物件宣告的初始化為<u>執行緒安全(thread-safe)</u>，且會在<u>初次存取</u>時完成。</p>
<p>Kotlin 可讓您輕鬆宣告 singletons。以下是 object 宣告及其存取權的示例。object 宣告在 <code>object</code> 關鍵字後方一律帶有 name。</p>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Object declaration</span></span><br><span class="line"><span class="keyword">object</span> DataProviderManager &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">registerDataProvider</span><span class="params">(provider: <span class="type">DataProvider</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">​</span><br><span class="line">    <span class="keyword">val</span> allDataProviders: Collection&lt;DataProvider&gt;</span><br><span class="line">        <span class="keyword">get</span>() = <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// To refer to the object, use its name directly.</span></span><br><span class="line">DataProviderManager.registerDataProvider(...)</span><br></pre></td></tr></table></figure>

<p>在 Retrofit object 上呼叫 <code>create()</code> 函式的代價非常高，且 app 只需要<u>單一 <strong>Retrofit API service instance</strong></u>。因此，您可以<u>使用物件宣告，向 app 的其餘部分公開 service</u>。</p>
<ol>
<li>在 <code>MarsApiService</code> interface 宣告之外，定義名為 <code>MarsApi</code> 的 <strong>public object</strong>，以<u>初始化 Retrofit service</u>。這是可從 app 其餘部分存取的 public singleton object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> MarsApi &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>MarsApi</code> object 宣告當中，新增名為 <code>retrofitService</code> 的 type <code>MarsApiService</code> 延遲(lazy)初始化 Retrofit object 屬性。執行此延遲初始化的用意，在於確保其在第一次使用時已初始化。您將在後續步驟中修正錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> MarsApi &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofitService : MarsApiService <span class="keyword">by</span> lazy &#123;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>透過 <code>MarsApiService</code> interface，使用 <code>retrofit.create()</code> 方法初始化 <code>retrofitService</code> 變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> MarsApi &#123;</span><br><span class="line">    <span class="keyword">val</span> retrofitService : MarsApiService <span class="keyword">by</span> lazy &#123;</span><br><span class="line">       retrofit.create(MarsApiService::<span class="keyword">class</span>.java) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>::</code> 表示把一個方法當作一個參數，傳遞到另一個方法中進行使用(通俗來說就是引用一個方法)。</li>
</ul>
<p>Retrofit 設定完成！每當 app 呼叫 <code>MarsApi.retrofitService</code> 時，呼叫端就會<u>存取在第一次存取時建立的同個 <strong>singleton Retrofit object</strong> 來實作 <code>MarsApiService</code></u>。在下一個工作中，您將使用先前實作的 Retrofit object。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>提醒您，<b>延遲執行個體(lazy instantiation)</b>是指<u>在實際需要 object 之前特意延遲建立該 object</u>，以<u>避免不必要的運算或使用其他運算資源</u>。Kotlin 針對延遲執行個體化(lazy instantiation)提供<a href="https://kotlinlang.org/docs/delegated-properties.html#lazy">一流的支援</a>。</p>
          </div>

<h4 id="在-OverviewViewModel-中呼叫-web-service"><a href="#在-OverviewViewModel-中呼叫-web-service" class="headerlink" title="在 OverviewViewModel 中呼叫 web service"></a>在 OverviewViewModel 中呼叫 web service</h4><p>在此步驟中，您會<u>實作 <code>getMarsPhotos()</code> 方法來呼叫 <strong>Retrofit service</strong></u>，然後<u>處理傳回的 JSON 字串(string)</u>。</p>
<h4 id="ViewModelScope"><a href="#ViewModelScope" class="headerlink" title="ViewModelScope"></a>ViewModelScope</h4><p><a href="https://developer.android.com/topic/libraries/architecture/coroutines?hl=zh-tw#viewmodelscope"><code>ViewModelScope</code></a> 是在 app 中為每個 <code>ViewModel</code> 定義的<u>內建 <strong>coroutine scope</strong></u>。若已清除 <code>ViewModel</code>，系統就會<u>自動取消此範圍內啟動(launched)的所有協程(coroutine)</u>。</p>
<p>您會<u>使用 <code>ViewModelScope</code> 來啟動協程(coroutine)</u>，並<u>在背景執行 <strong>Retrofit network 呼叫</strong></u>。</p>
<ol start="4">
<li>在 <code>MarsApiService</code> 中，將 <code>getPhotos()</code> 設為 <u>suspend 函式</u>。這樣就能在 coroutine 中呼叫此方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@GET(<span class="string">&quot;photos&quot;</span>)</span></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPhotos</span><span class="params">()</span></span>: String</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>開啟 <code>overview/OverviewViewModel</code>。向下捲動至 <code>getMarsPhotos()</code> 方法。刪除將 status response 設為 “Set the Mars API Response here!”. 的行。方法 <code>getMarsPhotos()</code> 應已空白。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getMarsPhotos</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>getMarsPhotos()</code> 當中，使用 <code>viewModelScope.launch</code> 啟動 coroutine。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getMarsPhotos</span><span class="params">()</span></span> &#123;</span><br><span class="line">    viewModelScope.launch &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在系統提示時 import <code>androidx.lifecycle.viewModelScope</code> 和 <code>kotlinx.coroutines.launch</code>。</li>
</ul>
<ol start="7">
<li>在 <code>viewModelScope</code> 當中，使用 <u>singleton object <code>MarsApi</code></u> <u>從 <code>retrofitService</code> interface 呼叫 <code>getPhotos()</code> 方法</u>。將傳回的 response 儲存於名為 <code>listResult</code> 的 <code>val</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">    <span class="keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在系統提示時 import <code>com.example.android.marsphotos.network.MarsApi</code>。</li>
</ul>
<ol start="8">
<li>將剛從後端 server 收到的結果指派至 <code>_status.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()</span><br><span class="line">_status.value = listResult</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>執行 app，請注意 app 會立即關閉，且不一定會顯示錯誤彈出式視窗。</p>
</li>
<li><p>按一下 Android Studio 中的「Logcat」分頁標籤，會顯示錯誤「missing INTERNET permission」。</p>
</li>
</ol>
<img src="https://i.imgur.com/JkHklos.png">

<p>此錯誤訊息代表 app 可能缺少 <code>INTERNET</code> 權限(permissions)。在下一個工作中，您會新增 app 的 internet permissions 來解決這個問題。</p>
<hr>
<h3 id="新增-Internet-權限與處理-Exception"><a href="#新增-Internet-權限與處理-Exception" class="headerlink" title="新增 Internet 權限與處理 Exception"></a>新增 Internet 權限與處理 Exception</h3><h4 id="Android-Permissions"><a href="#Android-Permissions" class="headerlink" title="Android Permissions"></a>Android Permissions</h4><p>Android 系統的<u>權限(permissions)</u>旨在保護 Android 使用者的隱私權。Android apps 必須宣告或要求權限，以存取諸如聯絡人、通話記錄等敏感使用者資料，以及例如 camera 或 internet 等特定系統功能。</p>
<p>您必須具備 <strong>INTERNET permissions</strong>，才可讓 apps 存取 internet。連線至 internet 後會引發安全性疑慮，因此根據預設，apps 無 internet 連線。您必須<u>明確宣告 app 需要存取 internet</u>。這視為<u>一般權限</u>。如要進一步瞭解 Android permissions 及其類型，請參閱<a href="https://developer.android.com/guide/topics/permissions/overview?hl=zh-tw">說明文件</a>。</p>
<p>在此步驟中，app 會在 <code>AndroidManifest</code> 檔案中加入<code> &lt;uses-permission&gt;</code> 標記，以宣告所需的權限。</p>
<ol>
<li>開啟 <code>manifests/AndroidManifest.xml</code>。在 <code>&lt;application&gt;</code> 標記前方加上這一行：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.INTERNET&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>編譯並再次執行 app。若您有可用的 internet 連線，應會看到內含 Mars photos 相關資料的 <strong>JSON text</strong>。稍後您可在程式碼研究室中進一步瞭解 JSON 格式。</li>
</ol>
<img src="https://i.imgur.com/68ByRSb.png" width="40%">

<ol start="3">
<li><p>輕觸裝置或模擬器中的「Back」按鈕，關閉 app。</p>
</li>
<li><p>將裝置或模擬器設為飛航模式，以模擬網路連線錯誤。從最近用過的選單重新開啟 app，或從 Android Studio 重新啟動 app。</p>
</li>
<li><p>按一下 Android Studio 中的「Logcat」分頁標籤，然後記下 Log 中的<u>嚴重例外狀況(fatal exception)</u>，如下所示：</p>
</li>
</ol>
<img src="https://i.imgur.com/LhZcXhH.png">

<h4 id="處理-Exception"><a href="#處理-Exception" class="headerlink" title="處理 Exception"></a>處理 Exception</h4><p><a href="https://developer.android.com/reference/java/lang/Exception">例外狀況(Exception)</a> 是指在<u>執行階段期間(runtime)</u>【非<u>編譯期間(compile time)</u>】 可能發生的錯誤，會在未通知使用者的情況下突然終止 app。這會對使用者體驗造成負面影響。<u>例外狀況處理(Exception handling)</u>是一種機制，可<u>避免 app 突然終止</u>，並<u>以使用者容易理解的方式處理</u>。</p>
<p>發生 exceptions 的原因可能很單純，例如以零為除數或網路發生錯誤。這些 exceptions 與您在先前程式碼研究室中學到的 <code>NumberFormatException</code> 類似。</p>
<p>連線至 server 時可能發生的問題範例：</p>
<ul>
<li>API 使用的 <u>URL 或 URI 不正確</u>。</li>
<li><u>server 無法使用</u>，且 <u>app 無法連線至 server</u>。</li>
<li><u>網路延遲(Network latency)</u>問題。</li>
<li>裝置的<u>網際網路(internet)連線狀況不良</u>或<u>無網際網路(internet)連線</u>。</li>
</ul>
<p>在<u>編譯期間(compile time)</u>無法擷取這些 exceptions。您可以使用 <code>try-catch</code> 區塊來處理<u>執行階段(runtime)</u>中的 exceptions。如要進一步瞭解，請參閱<a href="https://kotlinlang.org/docs/exceptions.html">說明文件</a>。</p>
<p><strong>Try-catch 區塊的範例語法</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// some code that can cause an exception.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (e: SomeException) &#123;</span><br><span class="line">    <span class="comment">// handle the exception to avoid abrupt termination.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>try</code> 區塊當中，執行預期發生 exception 的所在程式碼，這在 app 中稱為 network call。您必須在 <code>catch</code> 區塊中實作程式碼，以避免 app 突然終止。若發生 exception，系統將執行 <code>catch</code> 區塊來復原錯誤，而不會突然終止 app。</p>
<ol>
<li>開啟 <code>overview/OverviewViewModel.kt</code>。向下捲動至 <code>getMarsPhotos()</code> 方法。在啟動區塊當中，在 <code>MarsApi</code> 呼叫周圍新增 <code>try</code> 區塊來處理 exception。在 <code>try</code> 區塊後方新增 <code>catch</code> 區塊：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModelScope.launch &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="keyword">val</span> listResult = MarsApi.retrofitService.getPhotos()</span><br><span class="line">       _status.value = listResult</span><br><span class="line">   &#125; <span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>catch &#123;&#125;</code> 區塊當中處理 failure response。將 <code>e.message</code> 設為 <code>_status.value</code>，以向使用者顯示 error message。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span> (e: Exception) &#123;</span><br><span class="line">   _status.value = <span class="string">&quot;Failure: <span class="subst">$&#123;e.message&#125;</span>&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>開啟飛航模式，並再次執行 app。此時不會突然關閉 app，但會改為顯示 error message。</li>
</ol>
<img src="https://i.imgur.com/2JIw5Gl.png" width="40%">

<ol start="4">
<li>關閉手機或模擬器的飛航模式。執行並測試您的 app，確定一切運作正常，且您能夠查看 JSON 字串。</li>
</ol>
<hr>
<h3 id="使用-Moshi-剖析-JSON-response"><a href="#使用-Moshi-剖析-JSON-response" class="headerlink" title="使用 Moshi 剖析 JSON response"></a>使用 Moshi 剖析 JSON response</h3><h4 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h4><p>requested data 通常為常用的資料格式，例如 <strong>XML</strong> 或 <strong>JSON</strong>。每次呼叫都會傳回<u>結構化資料(structured data)</u>，而 app 必須瞭解該結構的內容，才能讀取 response 中的 data。</p>
<p>舉例來說，您將在此 app 中從下列 server 擷取 data：<a href="https://android-kotlin-fun-mars-server.appspot.com/photos">https://android-kotlin-fun-mars-server.appspot.com/photos</a> 。若您在瀏覽器中輸入此 URL，即會顯示 JSON 格式的 <u>Mars surface <strong>IDs</strong> 和 <strong>image URLs</strong> list</u>！</p>
<p>範例 JSON 回應結構：<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/fde4f6f199990ae8_1920.png?hl=zh-tw"></p>
<ul>
<li><strong>JSON response</strong> 為<u>陣列(array)</u>，以方括號 <code>[]</code> 表示。陣列(array)包含 <strong>JSON objects</strong>。</li>
<li><strong>JSON objects</strong> 會以大括號 <code>&#123;&#125;</code> 括住。</li>
<li>每個 <strong>JSON objects</strong> 皆內含一組 <strong>name-value</strong> 配對，並以半形逗號 <code>,</code> 分隔。</li>
<li>配對的 <strong>name</strong> 和 <strong>value</strong> 會以半形冒號 <code>:</code> 分隔。</li>
<li><strong>name</strong> 會以引號 <code>&quot;&quot;</code> 括住。</li>
<li><strong>value</strong> 可以是數字(numbers)、字串(strings)、布林值(boolean)、陣列(array)、物件 (JSON object) 或空值(null)。</li>
</ul>
<p>舉例來說，<code>img_src</code> 是一個 url 字串。若將 url 貼至網路瀏覽器中，就會看到 Mars surface image。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-getting-data-internet/img/b4f9f196c64f02c3_1920.png?hl=zh-tw" width="50%">

<p>您現可從 Mars web service 取得 JSON response，這是個不錯的起點。但您真正需要的是 <strong>Kotlin objects</strong>，而非大型 JSON 字串。此外還有一個名為 <a href="https://github.com/square/moshi">Moshi</a> 的外部 library，這個 Android <b>JSON 剖析器(parser)</b>可<u>將 JSON 字串轉換為 Kotlin objects</u>。Retrofit 具備可與 Moshi 搭配使用的<u>轉換工具(converter)</u>，是非常適合在這裡使用的優異 library。</p>
<p>在此工作中，您會<u>使用 Moshi library 搭配 Retrofit</u>，將 web service 中的 <u><strong>JSON response</strong> 剖析為呈現 Mars photos 的實用 <strong>Kotlin objects</strong></u>。App 會改為顯示<u>傳回的 Mars photos 數量</u>，而非顯示原始 JSON。</p>
<h4 id="新增-Moshi-library-dependencies"><a href="#新增-Moshi-library-dependencies" class="headerlink" title="新增 Moshi library dependencies"></a>新增 Moshi library dependencies</h4><ol>
<li>開啟 <code>build.gradle (Module: app)</code>。</li>
<li>在 dependencies 區段新增以下程式碼，以包含 Moshi dependency。此 dependency 會新增使用 Kotlin support 的 Moshi JSON library support。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Moshi</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.moshi:moshi-kotlin:1.13.0&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>dependencies</code> 區塊中找出 Retrofit scalar converter 行，並將以下 dependencies 變更為使用 <code>converter-moshi</code>：</li>
</ol>
<p>將以下</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Retrofit</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:retrofit:2.9.0&quot;</span></span><br><span class="line"><span class="comment">// Retrofit with scalar Converter</span></span><br><span class="line">implementation <span class="string">&quot;com.squareup.retrofit2:converter-scalars:2.9.0&quot;</span></span><br></pre></td></tr></table></figure>

<p>替換為</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Retrofit with Moshi Converter</span></span><br><span class="line">implementation <span class="string">&#x27;com.squareup.retrofit2:converter-moshi:2.9.0&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>按一下「Sync Now」(立即同步處理)，使用新 dependencies rebuild project。</li>
</ol>
<div class="note no-icon success">
            <p><strong>注意：</strong>Project 可能會顯示與已移除 <u>Retrofit scalar dependency</u> 相關的<u>編譯器錯誤</u>。您會在接下來的步驟中修正這些錯誤。</p>
          </div>

<h4 id="實作-Mars-Photos-data-class"><a href="#實作-Mars-Photos-data-class" class="headerlink" title="實作 Mars Photos data class"></a>實作 Mars Photos data class</h4><p>從 web service 取得的 JSON response 範例項目看起來會像這樣，如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">    <span class="string">&quot;id&quot;</span>:<span class="string">&quot;424906&quot;</span>,</span><br><span class="line">    <span class="string">&quot;img_src&quot;</span>:<span class="string">&quot;http://mars.jpl.nasa.gov/msl-raw-images/msss/01000/mcam/1000ML0044631300305227E03_DXXX.jpg&quot;</span></span><br><span class="line">&#125;,</span><br><span class="line">...]</span><br></pre></td></tr></table></figure>

<p>在上述範例中，請注意每個 Mars photo 項目皆具有以下的 JSON key 與 value 配對：</p>
<ul>
<li><code>id</code>：屬性的 ID，以 string 表示。由於其已納入 <code>&quot; &quot;</code>，因此屬於 <code>String</code> 類型而非 <code>Integer</code>。</li>
<li><code>img_src</code>：image 的 URL，以 string 表示。</li>
</ul>
<p>Moshi 會剖析此 JSON data，然後將其轉換為 Kotlin objects。如要這麼做，Moshi 必須具有 Kotlin <strong>data class</strong> 以<u>儲存剖析結果(將轉換完成的 Kotlin objects 儲存在 data class)</u>，因此您會在此步驟中<u>建立 data class <code>MarsPhoto</code></u>。</p>
<ol>
<li>在 network 套件上按一下滑鼠右鍵，然後依序選取「New」&gt;「Kotlin File&#x2F;Class」。</li>
<li>在彈出式視窗中選取「Class」，然後輸入 <code>MarsPhoto</code> 做為 class name。這麼做會在 <code>network</code> package 中建立名為 <code>MarsPhoto.kt</code> 的新檔案。</li>
<li>在 class 定義前方新增 <code>data</code> keyword，以將 <code>MarsPhoto</code> 設為 data class。將 <code>&#123;&#125;</code> 括號變更為 <code>()</code> 括號。這樣會發生錯誤，因為 data class 必須定義至少一個屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">MarsPhoto</span>(</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>將下列屬性新增至 <code>MarsPhoto</code> 類別定義。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">MarsPhoto</span>(</span><br><span class="line">   <span class="keyword">val</span> id: String, <span class="keyword">val</span> img_src: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，<u><code>MarsPhoto</code> class 中的每個變數皆會對應至 <strong>JSON object</strong> 中的 <strong>key name</strong></u>。如要比對特定 JSON response 中的 types，請為所有 value 使用 <code>String</code> object。</li>
</ul>
<p>Moshi 剖析 JSON 時，會<u>根據 name 比對 key</u>，並<u>在 data object 中填入適當的 value</u>。</p>
<h4 id="Json-註解"><a href="#Json-註解" class="headerlink" title="@Json 註解"></a>@Json 註解</h4><p>有時，JSON response 中的 <strong>key name</strong> 可能導致 Kotlin 屬性有所混淆，或與建議的程式設計樣式不符；舉例來說，在 JSON 檔案中，<code>img_src</code> key 會使用<u>底線</u>，而屬性的 Kotlin 慣例會使用大小寫字母 (<u>駝峰式大小寫</u>)。</p>
<p>如要在 data class 中使用與 JSON response 中 key name 不同的變數名稱，請使用 <code>@Json</code> 註解。在此範例中，data class 中的變數名稱為 <code>imgSrcUrl</code>。您可使用<code> @Json(name = &quot;img_src&quot;)</code> 將變數對應至 JSON 屬性 <code>img_src</code>。</p>
<ol start="5">
<li>將 <code>img_src</code> key 這行替換為以下顯示的行。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Json(name = <span class="string">&quot;img_src&quot;</span>)</span> <span class="keyword">val</span> imgSrcUrl: String</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>com.squareup.moshi.Json</code>。</li>
</ul>
<h4 id="更新-MarsApiService-和-OverviewViewModel"><a href="#更新-MarsApiService-和-OverviewViewModel" class="headerlink" title="更新 MarsApiService 和 OverviewViewModel"></a>更新 MarsApiService 和 OverviewViewModel</h4><p>在此工作中，您會<u>使用 <strong>Moshi builder</strong> 來建立 <strong>Moshi object</strong></u>，做法與 Retrofit builder 類似。</p>
<p>您會<u>將 <code>ScalarsConverterFactory</code> 替換為 <code>KotlinJsonAdapterFactory</code></u>，以讓 Retrofit 知道可以使用 Moshi 將 JSON response 轉換為 Kotlin object。接著會<u>更新 <strong>network API</strong> 和 <code>ViewModel</code></u>，以使用 <strong>Moshi object</strong>。</p>
<ol>
<li>開啟 <code>network/MarsApiService.kt</code>。注意 <code>ScalarsConverterFactory</code> 的未解決 reference 錯誤。這是因為您在先前的步驟中已變更 Retrofit dependency。刪除 <code>ScalarConverterFactory</code> 的 import 作業。您會在不久之後修正其他錯誤。</li>
</ol>
<p>移除：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> retrofit2.converter.scalars.ScalarsConverterFactory</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在檔案頂端 (在 Retrofit builder 之前)，新增下列程式碼以<u>建立 Moshi object</u>，類似 Retrofit object。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> moshi = Moshi.Builder()</span><br></pre></td></tr></table></figure>
<ul>
<li>依照要求 import <code>com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory</code> 和 <code>com.squareup.moshi.Moshi</code>。</li>
</ul>
<ol start="3">
<li>若要讓 Moshi 註解與 Kotlin 順利搭配運作，請<u>在 Moshi builder 中新增 <code>KotlinJsonAdapterFactory</code></u>，然後<u>呼叫 <code>build()</code></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> moshi = Moshi.Builder()</span><br><span class="line">   .add(KotlinJsonAdapterFactory())</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>retrofit</code> object 宣告中，<u>將 Retrofit builder 變更為使用 <code>MoshiConverterFactory</code></u> 而非 <code>ScalarConverterFactory</code>，並傳遞您剛建立的 <u><code>moshi</code> instance</u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">   .addConverterFactory(MoshiConverterFactory.create(moshi))</span><br><span class="line">   .baseUrl(BASE_URL)</span><br><span class="line">   .build()</span><br></pre></td></tr></table></figure>
<ul>
<li>依要求 import <code>retrofit2.converter.moshi.MoshiConverterFactory</code>。</li>
</ul>
<ol start="5">
<li>您已將 <code>MoshiConverterFactory</code> 設定妥當，現在可以要求 Retrofit 從 <strong>JSON array</strong> 傳回 <u><code>MarsPhoto</code> objects list</u>，而非傳回 JSON string。更新 <code>MarsApiService</code> interface，讓 Retrofit 傳回 <code>MarsPhoto</code> objects list，而非傳回 <code>String</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">MarsApiService</span> &#123;</span><br><span class="line">   <span class="meta">@GET(<span class="string">&quot;photos&quot;</span>)</span></span><br><span class="line">   <span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPhotos</span><span class="params">()</span></span>: List&lt;MarsPhoto&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>對 <code>viewModel</code> 進行類似的變更，開啟 <code>OverviewViewModel.kt</code>。向下捲動至 <code>getMarsPhotos()</code> 方法。</p>
</li>
<li><p>在方法 <code>getMarsPhotos()</code> 中，<code>listResult</code> 為 <code>List&lt;MarsPhoto&gt;</code> 而不再是 <code>String</code>。該 list 大小為已接收和剖析的 photos 數量。如要輸出已擷取的 photos 數量，請按照下列方式更新 <code>_status.value</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">_status.value = <span class="string">&quot;Success: <span class="subst">$&#123;listResult.size&#125;</span> Mars photos retrieved&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在系統提示時 import <code>com.example.android.marsphotos.network.MarsPhoto</code>。</li>
</ul>
<ol start="8">
<li>確認裝置或模擬器已關閉飛航模式。編譯並執行 app。此時 message 應會顯示從 web service 傳回的屬性數量，而非大型 JSON string：</li>
</ol>
<img src="https://i.imgur.com/gDTRyZL.png" width="40%">

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><p><strong>REST web services</strong></p>
<ul>
<li>web service 是透過 internet 提供的軟體功能，，可<u>讓 app 傳送 requests 和傳回 data</u>。</li>
<li>一般的 web service 使用 <u>REST 架構</u>。<u>提供 REST 架構的 web service 稱為 <strong>RESTful services</strong></u>。符合 RESTful web services，均使用標準 <u>web 元件(components)</u>和<u>通訊協定(protocols)</u>建構而成。</li>
<li>透過 <strong>URIs</strong> 以標準化方式<u>向 REST web service 傳送 request</u>。</li>
<li>如要使用 web service，app 必須<u>建立 network connection，並與 service 通訊</u>。接著，app 必須<u>接收 response data</u>，並將其<u>剖析</u>為可供 app 使用的格式。</li>
<li><strong>Retrofit library</strong> 是一個 client library，可<u>讓 app 向 REST web service 發出 requests</u>。</li>
<li>使用 <strong>converters</strong> 向 Retrofit 告知該<u>如何處理傳送至 web service 的 data</u>，以及<u>從 web service 傳回的 data</u>。舉例來說， <code>ScalarsConverter</code> converter 會將 web service data 視為 <code>String</code> 或其他原始檔案(primitive)。</li>
<li>如要讓 app 連上 internet，請在 Android manifest 中新增 <code>&quot;android.permission.INTERNET&quot;</code> 權限。</li>
</ul>
<p><strong>JSON 剖析</strong></p>
<ul>
<li>web service 的 response 通常會以 JSON 格式表示，這是一種代表結構化資料的常用格式。</li>
<li><strong>JSON object</strong> 是一組 <u>key-value</u> 組合。</li>
<li><u>一組 <b>JSON object</b> 稱為 <b>JSON array</b></u>。您可以<u>從 web service 取得 JSON array 做為 response</u>。</li>
<li>key-value 組合的 keys 前後會加上半形引號 <code>&quot;&quot;</code>。values 可以是 <u>numbers 或 strings</u>。</li>
<li><strong>Moshi library</strong> 為 Android <u>JSON 剖析器(parser)</u>，可<u>將 <strong>JSON string</strong> 轉換為 <strong>Kotlin objects</strong></u>。Retrofit 具備可與 Moshi 搭配使用的 <strong>converter</strong>。</li>
<li>Moshi 會比對 JSON response 中的 <u>keys 與 data object 中的同名屬性</u>。</li>
<li>如要為某個 <u>key 使用不同的屬性名稱</u>，請為該屬性加上 <u><code>@Json</code> 註解</u>和 <u>JSON key name</u>。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Connect to the internet</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Data Class</tag>
        <tag>singleton</tag>
        <tag>suspend function</tag>
        <tag>Internet</tag>
        <tag>Web Service</tag>
        <tag>REST</tag>
        <tag>RESTful</tag>
        <tag>URI</tag>
        <tag>URL</tag>
        <tag>Retrofit</tag>
        <tag>Moshi</tag>
        <tag>Converter</tag>
        <tag>JSON</tag>
        <tag>Permission</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(33)-Coroutines簡介</title>
    <url>/2023/12/05/Android%E7%AD%86%E8%A8%98-33-Coroutines%E7%B0%A1%E4%BB%8B/</url>
    <content><![CDATA[<blockquote>
<p>瞭解關於<b>執行緒(threads)</b>的資訊，以及如何使用稱為<b>協程(coroutines)</b>的 Kotlin 功能撰寫<u>乾淨(clear)</u>、<u>非阻塞(non-blocking)</u>的<b>並行(concurrent)</b>程式碼。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>何謂<b>並行(concurrency)</b>，以及其重要性</li>
<li>如何使用<b>協程(coroutines)</b>和<b>執行緒(threads)</b>，撰寫<u>非阻塞(non-blocking)</u>的<u>並行(concurrent)</u>程式碼</li>
<li>如何在 background 工作(performing tasks)時存取 <b>main thread</b>，安全地更新<b>UI</b></li>
<li>不同<b>並行模式(concurrency pattern)</b>「<b> 範圍(Scope) &#x2F; 調度工具(Dispatchers) &#x2F; 延遲(Deferred)</b> 」的使用方式與使用時機</li>
<li>如何撰寫與<b>網路資源(network resources)</b>互動(interacts)的程式碼</li>
</ul>
<span id="more"></span>

<p><strong>Responsive UI</strong> 是 great app 的關鍵要素。您過去建構 app 時可能都採用此做法並視為標準程序，但隨著您開始新增更多進階功能 (例如<u>網路(networking)</u>或<u>資料庫(database)</u>功能)，可能會越來越<u>難撰寫可正常運作又兼具效能(performant)的程式碼</u>。</p>
<p>以下範例說明若在長時間執行 tasks (例如從 Internet 下載圖片) 時未正確處理，可能會發生什麼情況。當圖片功能運作時，scrolling 操作會變得不穩定而導致 UI 沒有回應。</p>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-introduction-coroutines/img/fcf3738b61270a1f.gif">

<p>為避免上述 app 發生問題，您必須對<b>執行緒(threads)</b>有一些瞭解。<b>Thread</b> 是一種略為<b>抽象(abstract)</b>的概念，但您可以將其視為 app 中程式碼的<u>單一執行路徑(single path of execution)</u>。您撰寫的每一行程式碼皆是要在同一 thread 上依序執行的指令(instruction)。</p>
<p>您已在 Android 中使用 thread。每個 Android app 都有預設的 <b>main thread</b>。這通常是 <b>UI thread</b>。您到目前為止撰寫的所有程式碼皆位於 main thread。每個指令 (亦即一行程式碼) 都會接續先前的指令，直到執行下一行為止。</p>
<p>但在執行中的 app 中，除了 main thread 之外還有更多 thread。就技術原理而言，處理者實際上不會操作個別(separate) thread，而是<u>在各個不同序列(series)的指令(instructions)之間來回切換</u>，以呈現<b>多工(multitasking)</b>處理樣貌。</p>
<p>★Thread 是一種抽象概念，可在編寫程式碼時用來<u>判斷每個指令的<b>執行路徑(path of execution)</b></u>。<u>使用 <b>main thread</b> 以外的 <b>thread</b></u>，可讓 app thread 如<u>在<b>背景(background)</b>運作下載圖片等複雜的工作</u>，並讓 app 的 <u>UI 保持回應(responsive)</u>。這就是所謂的<b>並行(concurrent&#x2F;concurrency)</b>程式碼。</p>
<hr>
<h3 id="簡介-Intoduction"><a href="#簡介-Intoduction" class="headerlink" title="簡介(Intoduction)"></a>簡介(Intoduction)</h3><h4 id="多執行緒-multithreading-與並行-concurrency"><a href="#多執行緒-multithreading-與並行-concurrency" class="headerlink" title="多執行緒(multithreading)與並行(concurrency)"></a>多執行緒(multithreading)與並行(concurrency)</h4><p>截至目前為止，我們已將 Android app 視為具備<u>單一執行路徑(single path of execution)</u>的程式。只要透過<u>單一執行路徑(single path of execution)</u>即可完成大量工作，但隨著 app 增長，您必須思考的是<b>並行(concurrency)</b>問題。</p>
<p><b>並行(Concurrency)</b>可讓多個程式碼單元執行時<u>跳脫順序(order)</u>或<u>看似平行(parallel)執行</u>，提高<b>資源(resources)</b>使用效率。<b>作業系統(operating system)</b>可運用<u>系統特性</u>、<y>程式語言</u>和<u>並行單元(concurrency unit)</u>來管理<b>多工處理(multitasking)</b>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-introduction-coroutines/img/966e300fad420505_1920.png?hl=zh-tw" width="80%">

<p>為什麼需要使用<b>並行(concurrency)</b>？隨著 app 越發複雜，程式碼也必須處於<b>非阻塞(non-blocking)狀態</b>。也就是說，thread 如 <b>network request</b> 等<u>長時間執行的 task</u>，並不會讓 app 停止執行其他工作。若<u>未正確實作 concurrency</u>，可能會導致 <u>app 無法回應使用者</u>。</p>
<p>以下為您提供幾個範例，在 Kotlin 中演示 concurrent 程式設計。所有範例皆可在 <a href="https://developer.android.com/training/kotlinplayground?hl=zh-tw">Kotlin Playground</a> 中執行。</p>
<p>Thread 是程式碼的最小單位，可在程式的限定範圍(confines)內執行。以下是可讓我們執行 concurrent 程式碼的小範例。<br>您可透過提供 lambda 來建立簡易 thread。在 Playground 中嘗試下列做法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> thread = Thread &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> has run.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    thread.start()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>系統不會在呼叫 <code>start()</code> function 之前執行 thread。</li>
</ul>
<p>Output 應該看起來像這樣。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[Thread-0,5,main] has run.</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，<code>currentThread()</code> 會 returns 一個 <b>Thread instance</b>，其會轉換為<b>字串(string)</b>格式，並傳回 thread 的<u>名稱(name)</u>、<u>優先順序(priority)</u>和<u>執行緒群組(thread group)</u>。以上的 output 可能會略有不同。</li>
</ul>
<h4 id="建立與執行多執行緒-multiple-threads"><a href="#建立與執行多執行緒-multiple-threads" class="headerlink" title="建立與執行多執行緒(multiple threads)"></a>建立與執行多執行緒(multiple threads)</h4><p>為了示範簡易的 concurrency，我們可以建立兩個 thread 來執行。程式碼會建立 3 個 thread，並 printing 上一個範例的 information line。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> states = arrayOf(<span class="string">&quot;Starting&quot;</span>, <span class="string">&quot;Doing Task 1&quot;</span>, <span class="string">&quot;Doing Task 2&quot;</span>, <span class="string">&quot;Ending&quot;</span>)</span><br><span class="line">   repeat(<span class="number">3</span>) &#123;</span><br><span class="line">       Thread &#123;</span><br><span class="line">           println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> has started&quot;</span>)</span><br><span class="line">           <span class="keyword">for</span> (i <span class="keyword">in</span> states) &#123;</span><br><span class="line">               println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> - <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">               Thread.sleep(<span class="number">50</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.start()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Playground 中的 output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[Thread-2,5,main] has started Thread[Thread-2,5,main] - Starting Thread[Thread-0,5,main] - Doing Task 1 Thread[Thread-1,5,main] - Doing Task 1 Thread[Thread-2,5,main] - Doing Task 1 Thread[Thread-0,5,main] - Doing Task 2 Thread[Thread-1,5,main] - Doing Task 2 Thread[Thread-2,5,main] - Doing Task 2 Thread[Thread-0,5,main] - Ending Thread[Thread-2,5,main] - Ending Thread[Thread-1,5,main] - Ending Thread[Thread-0,5,main] has started</span><br><span class="line">Thread[Thread-0,5,main] - Starting</span><br><span class="line">Thread[Thread-1,5,main] has started</span><br><span class="line">Thread[Thread-1,5,main] - Starting</span><br></pre></td></tr></table></figure>

<p>AS(console) 中的 output：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread[Thread-0,5,main] has started</span><br><span class="line">Thread[Thread-1,5,main] has started</span><br><span class="line">Thread[Thread-2,5,main] has started</span><br><span class="line">Thread[Thread-1,5,main] - Starting</span><br><span class="line">Thread[Thread-0,5,main] - Starting</span><br><span class="line">Thread[Thread-2,5,main] - Starting</span><br><span class="line">Thread[Thread-1,5,main] - Doing Task 1</span><br><span class="line">Thread[Thread-0,5,main] - Doing Task 1</span><br><span class="line">Thread[Thread-2,5,main] - Doing Task 1</span><br><span class="line">Thread[Thread-0,5,main] - Doing Task 2</span><br><span class="line">Thread[Thread-1,5,main] - Doing Task 2</span><br><span class="line">Thread[Thread-2,5,main] - Doing Task 2</span><br><span class="line">Thread[Thread-0,5,main] - Ending</span><br><span class="line">Thread[Thread-2,5,main] - Ending</span><br><span class="line">Thread[Thread-1,5,main] - Ending</span><br></pre></td></tr></table></figure>
<ul>
<li>執行程式碼數次。畫面上會顯示不同的 output。Thread 有時會以連續順序(sequence)執行，有時內容會散置(interspersed)。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong>此<b>不變性(invariability)</b>是由於 thread 的<u>執行方式</u>所致。<b>排程器(scheduler)</b>會為每個 thread 分配<u>一段時間</u>，並會在指定<u>時間範圍</u>內完成，或是在收到另一個<u>時間片段(time slice)</u>前遭到停用。</p>
          </div>

<hr>
<h3 id="Threads-相關挑戰"><a href="#Threads-相關挑戰" class="headerlink" title="Threads 相關挑戰"></a>Threads 相關挑戰</h3><p>使用 threads 可讓您輕鬆開始處理<u>多項 tasks</u> 和 <u>concurrency</u>，但並非完美無缺。當您直接在程式碼中使用 thread 時，可能會發生一些問題。</p>
<h4 id="Threads-需要大量資源-resources"><a href="#Threads-需要大量資源-resources" class="headerlink" title="Threads 需要大量資源(resources)"></a>Threads 需要大量資源(resources)</h4><p>建立、切換和管理 threads 會佔用<u>系統資源(system resources)</u>，而可同時管理的原始 <u>threads 數量</u>會受<u>時間</u>所限。建立成本著實可能會激增。</p>
<p>執行中的 app 會有多個 threads，而<u>每個 app 皆有一個專屬 thread，專供 app 的 UI 來使用</u>。此 thread 通常稱為 <strong>main thread</strong> 或 <strong>UI thread</strong>。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>在某些情況下，<b>UI thread</b> 與 <b>main thread</b> 可能會有所不同。</p>
          </div>

<p>這個 thread 負責<u>執行 app 的 UI</u>，因此 <u>main thread 必須維持高效能</u>，確保 app 能順暢運作。<u>所有長時間執行的 tasks 在完成之前都會 <b>block</b></u>，導致 app 無法回應。</p>
<p>作業系統(operating system)會盡力維持使用者的<u>響應式(responsive)體驗</u>。目前的手機嘗試將 UI 更新至<u>每秒 60 至 120 次</u> (至少 60 次)。準備及繪製 UI 需要一小段時間 (<u>每秒 60 個影格(frames)</u>，<u>每個畫面更新不超過 16 毫秒(ms)</u>)。Android 會<u>捨棄影格(frames)</u>或<u>取消嘗試完成單一更新週期</u>，以嘗試掌握運作情況。有些影格(frames)發生流失和波動是正常現象，但<u>影格(frames)過多會導致 app 無法回應</u>。</p>
<h5 id="競爭狀況與無法預測的行為"><a href="#競爭狀況與無法預測的行為" class="headerlink" title="競爭狀況與無法預測的行為"></a>競爭狀況與無法預測的行為</h5><p>如上所述，thread 是一種關於<u>處理者如何一次處理多項工作(multiple tasks)</u>的抽象概念。由於處理者會針對不同 threads 切換指令組合，因此 <u>thread 的確切執行時間與暫停時間不在控制範圍內</u>。當您直接處理 thread 時，<u>系統可能會產生非預期的 output</u>。</p>
<p>舉例來說，下列程式碼使用簡易迴圈來計算 1 至 50 的次數，但每計數一次，系統就會建立新 thread。請設想您所希望的 output，然後執行數次程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">var</span> count = <span class="number">0</span></span><br><span class="line">   <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1.</span><span class="number">.50</span>) &#123;</span><br><span class="line">       Thread &#123;</span><br><span class="line">           count += <span class="number">1</span></span><br><span class="line">           println(<span class="string">&quot;Thread: <span class="variable">$i</span> count: <span class="variable">$count</span>&quot;</span>)</span><br><span class="line">       &#125;.start()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Output 是否符合您的預期？是否每次皆相同？</li>
</ul>
<p>以下是我們收到的 output 範例。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread: 50 count: 49 Thread: 43 count: 50 Thread: 1 count: 1</span><br><span class="line">Thread: 2 count: 2</span><br><span class="line">Thread: 3 count: 3</span><br><span class="line">Thread: 4 count: 4</span><br><span class="line">Thread: 5 count: 5</span><br><span class="line">Thread: 6 count: 6</span><br><span class="line">Thread: 7 count: 7</span><br><span class="line">Thread: 8 count: 8</span><br><span class="line">Thread: 9 count: 9</span><br><span class="line">Thread: 10 count: 10</span><br><span class="line">Thread: 11 count: 11</span><br><span class="line">Thread: 12 count: 12</span><br><span class="line">Thread: 13 count: 13</span><br><span class="line">Thread: 14 count: 14</span><br><span class="line">Thread: 15 count: 15</span><br><span class="line">Thread: 16 count: 16</span><br><span class="line">Thread: 17 count: 17</span><br><span class="line">Thread: 18 count: 18</span><br><span class="line">Thread: 19 count: 19</span><br><span class="line">Thread: 20 count: 20</span><br><span class="line">Thread: 21 count: 21</span><br><span class="line">Thread: 23 count: 22</span><br><span class="line">Thread: 22 count: 23</span><br><span class="line">Thread: 24 count: 24</span><br><span class="line">Thread: 25 count: 25</span><br><span class="line">Thread: 26 count: 26</span><br><span class="line">Thread: 27 count: 27</span><br><span class="line">Thread: 30 count: 28</span><br><span class="line">Thread: 28 count: 29</span><br><span class="line">Thread: 29 count: 41</span><br><span class="line">Thread: 40 count: 41</span><br><span class="line">Thread: 39 count: 41</span><br><span class="line">Thread: 41 count: 41</span><br><span class="line">Thread: 38 count: 41</span><br><span class="line">Thread: 37 count: 41</span><br><span class="line">Thread: 35 count: 41</span><br><span class="line">Thread: 33 count: 41</span><br><span class="line">Thread: 36 count: 41</span><br><span class="line">Thread: 34 count: 41</span><br><span class="line">Thread: 31 count: 41</span><br><span class="line">Thread: 32 count: 41</span><br><span class="line">Thread: 44 count: 42</span><br><span class="line">Thread: 46 count: 43</span><br><span class="line">Thread: 45 count: 44</span><br><span class="line">Thread: 47 count: 45</span><br><span class="line">Thread: 48 count: 46</span><br><span class="line">Thread: 42 count: 47</span><br><span class="line">Thread: 49 count: 48</span><br></pre></td></tr></table></figure>

<p>有別於此程式碼的呈現結果，我們似乎<u>優先執行最後一個 thread</u>，其他部分 ，<u>threads 的執行順序也不正確</u>。若查看某些迭代的 <code>count</code>，會發現多個 threads 仍維持不變。更弔詭的是，即使 ouput 表明這只是第二個執行的 thread，thread 43 的計數仍達到 50。<u>單就 output 判斷，無法得知 <code>count</code> 的最終值</u>。</p>
<p>這只是 thread 可能導致發生無法預測行為的其中一種形式。在使用多個 threads 時，您也可以執行所謂的「<b>競爭狀況(race condition)</b>」。這會導致<u>多個 threads 嘗試同時存取記憶體中的相同值</u>。競爭狀況(Race conditions)可能會<u>導致系統難以重現隨機查詢錯誤，進而導致 app 異常終止</u>。</p>
<p>建議您<u>不要直接使用 thread</u>，以免出現<u>效能問題</u>、<u>競爭狀況(Race conditions)</u>，或是<u>難以重現錯誤的狀況</u>。您將會學習一項名為「<b>協程(coroutines)</b>」的 Kotlin 功能，以協助您撰寫 <b>並行(concurrent)</b> 程式碼。</p>
<hr>
<h3 id="Kotlin-中的協程-coroutines"><a href="#Kotlin-中的協程-coroutines" class="headerlink" title="Kotlin 中的協程(coroutines)"></a>Kotlin 中的協程(coroutines)</h3><p>您可在 Android 上直接<u>建立和使用 threads 處理 background tasks</u>，但 Kotlin 亦提供<b>協程(coroutines)</b>，讓您以更靈活彈性的方式<u>管理<b>並行(concurrency)</b></u>。</p>
<p><strong>Coroutines</strong> 可讓您處理 <strong>multitasking</strong>，但也提供超越處理 threads 的另一層抽象概念。Coroutines 的其中一項主要功能是<u>可儲存狀態(state)</u>，以便<u>暫停(halted)</u>和<u>繼續運作(resumed)</u>。Coroutine 不一定會執行。</p>
<p>以<b>連續(continuations)</b>呈現的狀態，可讓部分程式碼指出何時需要<u>移交控制權(control)</u>，或<u>等待(wait)其他 coroutine 完成工作</u>後再繼續。此流程(flow)稱為<b>合作多工(cooperative multitasking)</b>。Kotlin 實作 coroutines 後，新增了眾多功能來協助執行 multitasking。除了<u>連續作業(continuations)</u>外，建立 coroutine 包括 <u><code>Job</code> 中的作業(work)</u>，以及在 <code>CoroutineScope</code> 中具<u>生命週期(lifecycle)</u>的<u>可取消(cancelable)作業(work)</u>。</p>
<p><code>CoroutineScope</code> 是一種 <b>context</b>，可針對其<u>子項(children)</u>以及<u>子項(children)當中的子項(children)</u>，週期性地<u>強制(enforces)執行取消(cancellation)和其他規則(rules)</u>。<code>Dispatcher</code> 會<u>管理</u> coroutine 用於執行的<u>備用執行緒(backing thread)</u>，讓開發人員<u>無須處理新 thread 的使用時間和位置</u>。</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Job</td>
<td align="left"><u><b>可取消(cancelable)</b>的作業單元(unit of work)</u>，例如使用 <code>launch()</code> function 建立的作業單元。</td>
</tr>
<tr>
<td align="left">CoroutineScope</td>
<td align="left"><u>用來建立新 coroutines 的 function</u>，例如 <code>launch()</code> 和 <code>async()</code> 繼承(extend) <code>CoroutineScope</code>。</td>
</tr>
<tr>
<td align="left">Dispatcher</td>
<td align="left"><u>決定 coroutine 將要使用的 thread</u>。<strong>Main dispatcher</strong> 會一律在 <strong>main thread</strong> 上執行 coroutine，而 <strong>Default</strong>、<strong>IO</strong> 或 <strong>Unconfined</strong> 等 dispatcher 會使用其他 threads。</td>
</tr>
</tbody></table>
<p>您可以在稍後深入瞭解這些資訊，但 <code>Dispatchers</code> 是能讓 coroutines 展現高效能的其中一種方法。其<u>可避免初始化(initializing)新 thread 產生的效能成本</u>。</p>
<p>讓我們舉個更早的 coroutines 使用範例。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    repeat(<span class="number">3</span>) &#123;</span><br><span class="line">        GlobalScope.launch &#123;</span><br><span class="line">            println(<span class="string">&quot;Hi from <span class="subst">$&#123;Thread.currentThread()&#125;</span>&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hi from Thread[DefaultDispatcher-worker-2@coroutine#2,5,main]</span><br><span class="line">Hi from Thread[DefaultDispatcher-worker-1@coroutine#1,5,main]</span><br><span class="line">Hi from Thread[DefaultDispatcher-worker-1@coroutine#3`,5,main]</span><br></pre></td></tr></table></figure>

<p>以上程式碼片段(snippet)使用<u>預設(default) <strong>dispatcher</strong></u>，在 <code>GlobalScope</code> 中建立三個 coroutines。<u><code>GlobalScope</code> 允許在 app 處於執行中(running)狀態期間，執行其中的任何 coroutines</u>。由於我們在此討論的是 main thread，因此不建議在超出範例程式碼範圍下採取此做法。在 app 中使用 coroutines 時，我們會使用其他範圍(scopes)。</p>
<p><strong><code>launch()</code> function</strong> 會建立包裝成<u>可取消(cancelable)的 Job object 的封閉程式碼(enclosed code)</u>。若 return value 不需超出 coroutine 限制範圍，請使用 <code>launch()</code>。</p>
<p>讓我們來看看 <code>launch()</code> 的 full signature，瞭解關於 coroutines 的下一個重要概念。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">launch</span><span class="params">()</span></span> &#123;</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: <span class="keyword">suspend</span> CoroutineScope.() -&gt; <span class="built_in">Unit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>您在<u>幕後</u>傳遞 <u>launch</u> 的，<u>程式碼區塊(code block)</u>會標有 <code>suspend</code> 關鍵字。<u><strong>Suspend</strong> 訊號(signals)</u>可以<u>暫停(paused)或繼續(resumed)執行程式碼或函式區塊</u>。</li>
</ul>
<h4 id="關於-runBlocking"><a href="#關於-runBlocking" class="headerlink" title="關於 runBlocking"></a>關於 runBlocking</h4><p>接下來的範例會使用 <code>runBlocking()</code>，如名稱所示，其會啟動新的 <strong>coroutine</strong>，並在完成之前封鎖目前的 <strong>thread</strong>。其主要用於連結<u><b>主函式(main functions)</b></u>與測試中的<u><b>阻塞(blocking)</b></u>與<u><b>非阻塞(non-blocking)</b></u>程式碼。您不常在一般 Android 程式碼中使用此項目。</p>
<div class="note no-icon primary">
            <p><strong>阻塞 (Blocking) 與非阻塞 (Non-Blocking)</strong></p><blockquote><p>阻塞 (Blocking) 與非阻塞 (Non-Blocking) 描述的是 <mark>請求</mark> 在等待結果時的 <mark>狀態</mark>。</p></blockquote><ul><li><mark>阻塞 (Blocking)</mark>：調用的程序或者應用程式發起請求，在獲得結果之前，調用方的程序會<u>懸 (Hang)</u> 住不動，無法回應，直到獲得結果。</li><li><mark>非阻塞 (Non-Blocking)</mark>：概念與阻塞相同，但是調用方不會因為等待結果，而懸著不動。後續通常透過<u>輪詢機制 (Polling)</u> 取得結果。</li></ul>
          </div>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"><span class="keyword">import</span> java.time.LocalDateTime</span><br><span class="line"><span class="keyword">import</span> java.time.format.DateTimeFormatter</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> formatter = DateTimeFormatter.ISO_LOCAL_TIME</span><br><span class="line"><span class="keyword">val</span> time = &#123; formatter.format(LocalDateTime.now()) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">suspend</span> <span class="function"><span class="keyword">fun</span> <span class="title">getValue</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    println(<span class="string">&quot;entering getValue() at <span class="subst">$&#123;time()&#125;</span>&quot;</span>)</span><br><span class="line">    delay(<span class="number">3000</span>)</span><br><span class="line">    println(<span class="string">&quot;leaving getValue() at <span class="subst">$&#123;time()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> Math.random()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> num1 = getValue()</span><br><span class="line">        <span class="keyword">val</span> num2 = getValue()</span><br><span class="line">        println(<span class="string">&quot;result of num1 + num2 is <span class="subst">$&#123;num1 + num2&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>getValue()</code> 會在設定的<u>延遲時間後傳回隨機數字</u>。其使用 <code>DateTimeFormatter</code>。說明適當的進入與離開時間。主函式會呼叫兩次 <code>getValue()</code> 並傳回總和。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entering getValue() at 17:44:52.311</span><br><span class="line">leaving getValue() at 17:44:55.319</span><br><span class="line">entering getValue() at 17:44:55.32</span><br><span class="line">leaving getValue() at 17:44:58.32</span><br><span class="line">result of num1 + num2 is 1.4320332550421415</span><br></pre></td></tr></table></figure>

<p>如要實際查看，請將 <code>main()</code> 函式 (保留其他所有程式碼) 替換為下列函式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    runBlocking &#123;</span><br><span class="line">        <span class="keyword">val</span> num1 = async &#123; getValue() &#125;</span><br><span class="line">        <span class="keyword">val</span> num2 = async &#123; getValue() &#125;</span><br><span class="line">        println(<span class="string">&quot;result of num1 + num2 is <span class="subst">$&#123;num1.await() + num2.await()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>getValue()</code> 的兩次呼叫各自獨立，且無須停用 coroutine。</li>
</ul>
<p>Kotlin 採用的非同步函式與啟動作業類似。<code>async()</code> 函式的定義如下。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> CoroutineScope.<span class="title">async</span><span class="params">()</span></span> &#123;</span><br><span class="line">    context: CoroutineContext = EmptyCoroutineContext,</span><br><span class="line">    start: CoroutineStart = CoroutineStart.DEFAULT,</span><br><span class="line">    block: <span class="keyword">suspend</span> CoroutineScope.() -&gt; T</span><br><span class="line">&#125;: Deferred&lt;T&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>async() </code>函式會傳回 <code>Deferred</code> 類型的值。</li>
</ul>
<p><code>Deferred</code>(延遲) 是一個<u>可取消的 Job</u>，其<u>可保留未來值的引用</u>。使用 <code>Deferred</code> 時，您還是可以呼叫函式，就如同函式會立即傳回值一般，但由於您無法確定<b>非同步工作(asynchronous task)</b>的傳回時間，因此 <code>Deferred</code> 只是預留位置。</p>
<p><code>Deferred</code> (在其他語言中亦稱為 <code>Promise</code> 或 <code>Future</code>) 會<u>確保稍後對此物件傳回值</u>。另一方面，<b>非同步工作(asynchronous task)</b>依預設<u>不會封鎖或等待執行</u>。如要啟動目前這行程式碼，必須等候 <code>Deferred</code> (可在其上呼叫 <code>await()</code>(等待)) 的輸出內容。其會傳回原始值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">entering getValue() at 22:52:25.025</span><br><span class="line">entering getValue() at 22:52:25.03</span><br><span class="line">leaving getValue() at 22:52:28.03</span><br><span class="line">leaving getValue() at 22:52:28.032</span><br><span class="line">result of num1 + num2 is 0.8416379026501276</span><br></pre></td></tr></table></figure>

<h4 id="何時將函式標示為-suspend"><a href="#何時將函式標示為-suspend" class="headerlink" title="何時將函式標示為 suspend"></a>何時將函式標示為 suspend</h4><p>在上述範例中，您可能會發現 <code>getValue()</code> 函式亦定義了 <code>suspend</code> 關鍵字。原因在於呼叫 <code>delay()</code>，其也為 <code>suspend</code> 函式。<u>每當函式呼叫另一個 <code>suspend</code> 函式時，其也應為 <code>suspend</code> 函式</u>。</p>
<p><strong>Q:</strong> 若確實如此，範例中的 <code>main()</code> 函式為何未標示為 <code>suspend</code>？畢竟，其確實呼叫了 <code>getValue()</code>。</p>
<p><strong>A:</strong> 不一定。<code>getValue()</code> 函式實際上是<u>在傳遞至 <code>runBlocking()</code> 的 lambda 中呼叫</u>，而 lambda 是 <code>suspend</code> 函式，類似傳遞至 <code>launch()</code> 和 <code>async()</code> 的函式。不過，<u><code>runBlocking()</code> 本身並不是 <code>suspend</code> 函式</u>。</p>
<p>➔ <u>由於並未在 <code>main()</code> 本身當中呼叫 <code>getValue()</code> 函式</u>，<u><code>runBlocking()</code> 也不是 <code>suspend</code> 函式</u>，因此未將 <code>main()</code> 標示為 <code>suspend</code>。<u>若函式未呼叫 <code>suspend 函式</code>，則其不必然會是 <code>suspend</code> 函式本身</u>。</p>
<hr>
<h3 id="自行練習"><a href="#自行練習" class="headerlink" title="自行練習"></a>自行練習</h3><p>您已在本程式碼研究室的開頭，看到下列使用多個執行緒(multiple threads)的範例。您可運用習得的 coroutines 知識，重新撰寫程式碼來<u>使用 coroutines 而非 Thread</u>。</p>
<p>注意：即使 <code>println()</code> 陳述式引用 Thread，也無須進行編輯。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> states = arrayOf(<span class="string">&quot;Starting&quot;</span>, <span class="string">&quot;Doing Task 1&quot;</span>, <span class="string">&quot;Doing Task 2&quot;</span>, <span class="string">&quot;Ending&quot;</span>)</span><br><span class="line">   repeat(<span class="number">3</span>) &#123;</span><br><span class="line">       Thread &#123;</span><br><span class="line">           println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> has started&quot;</span>)</span><br><span class="line">           <span class="keyword">for</span> (i <span class="keyword">in</span> states) &#123;</span><br><span class="line">               println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> - <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">               Thread.sleep(<span class="number">50</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;.start()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlinx.coroutines.*</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> states = arrayOf(<span class="string">&quot;Starting&quot;</span>, <span class="string">&quot;Doing Task 1&quot;</span>, <span class="string">&quot;Doing Task 2&quot;</span>, <span class="string">&quot;Ending&quot;</span>)</span><br><span class="line">   repeat(<span class="number">3</span>) &#123;</span><br><span class="line">       GlobalScope.launch &#123;</span><br><span class="line">           println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> has started&quot;</span>)</span><br><span class="line">           <span class="keyword">for</span> (i <span class="keyword">in</span> states) &#123;</span><br><span class="line">               println(<span class="string">&quot;<span class="subst">$&#123;Thread.currentThread()&#125;</span> - <span class="variable">$i</span>&quot;</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>為何需要採用<b>並行(concurrency)</b></li>
<li>什麼是<b>執行緒(thread)</b>，以及為何 thread 對<b>並行作業(concurrency)</b>如此重要</li>
<li>如何使用<b>協程(coroutines)</b>在 Kotlin 中撰寫<b>並行concurrent</b>程式碼</li>
<li>將函式標示為 <code>suspend</code> 的時機</li>
<li><b>CoroutineScope</b>、<b>Job</b> 和 <b>Dispatcher</b> 扮演的角色</li>
<li><b>延遲(Deferred)</b>與<b>等待(Await)</b>的差異</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Connect to the internet</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Thread</tag>
        <tag>Coroutine</tag>
        <tag>Concurrent</tag>
        <tag>suspend function</tag>
        <tag>CoroutineScope</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(32)-專案：Lunch Tray應用程式</title>
    <url>/2023/12/04/Android%E7%AD%86%E8%A8%98-32-%E5%B0%88%E6%A1%88%EF%BC%9ALunch-Tray%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>建構一款名為「Lunch Tray」的新應用程式</p>
</blockquote>
<p><strong>建構項目</strong><br>您會建構一個名為 Lunch Tray 的訂餐應用程式、透過 data binding 實作 <code>ViewModel</code>，並在 fragment 之間加入 navigation 功能。</p>
<span id="more"></span>

<hr>
<h3 id="專案說明"><a href="#專案說明" class="headerlink" title="專案說明"></a>專案說明</h3><p>本程式碼研究室將說明如何自行建構一款名為「Lunch Tray」的新應用程式。我們會引導您逐步完成 Lunch Tray 應用程式專案，包括在 Android Studio 中設定和測試專案。</p>
<p>本程式碼研究室與本課程中的其他部分不同。與先前的程式碼研究室不同，本程式碼研究室的目的並不是逐步說明如何建構應用程式，而是設定將由您獨力完成的專案，提供自行完成應用程式及檢查工作成果的相關指示。</p>
<p>我們改為一併在您將下載的應用程式中提供測試套件，而非程式碼解答。您將在 Android Studio 中執行這些測試 (本程式碼研究室稍後會說明操作方法)，並查看程式碼是否通過測試。這可能需要多試幾次，即使是專業開發人員也很難第一次嘗試就通過所有測試！程式碼通過所有測試後，您就能將這項專案視為完成。</p>
<p>我們瞭解，您可能只是想獲得解答來對照檢查。我們特意不提供程式碼解答，是因為希望您能透過練習，體驗專業開發人員的作業環境。您可能會需要用到較不嫻熟的其他技能，例如：</p>
<ul>
<li>在 Google 上搜尋您在應用程式中不認得的字詞、錯誤訊息和程式碼片段。</li>
<li>測試程式碼、解讀錯誤，然後變更程式碼並重複測試。</li>
<li>回去閱讀先前 Android 基本概念中的內容，溫故知新。</li>
<li>將您知道可順利執行的程式碼 (例如專案內提供的程式碼，或是單元 3 中其他應用程式先前的解決方案程式碼) 與您編寫的程式碼進行比對。</li>
</ul>
<p>乍看之下可能很困難，但我們百分之百相信如果您能夠完成單元 3，就已經對這項專案做好準備了。請按照自己的步調進行，不要放棄，我們對您有信心。</p>
<hr>
<h3 id="完成的應用程式總覽"><a href="#完成的應用程式總覽" class="headerlink" title="完成的應用程式總覽"></a>完成的應用程式總覽</h3><p>歡迎來到專案：Lunch Tray！</p>
<p>您或許已經知道，navigation 是 Android 開發作業的基本要素。無論是使用應用程式瀏覽食譜、尋找前往喜愛餐廳的路線，還是訂餐這件最重要的事，您都很有可能需要瀏覽多個畫面的內容。在這個專案中，您會運用在單元 3 中學到的技巧，建構一個名為 Lunch Tray 的午餐訂購應用程式，並且<u>實作 view model、data binding，以及多個畫面間的 navigation 功能</u>。</p>
<p>以下是應用程式最終的螢幕截圖。初次啟動 Lunch Tray 應用程式時，系統會向使用者顯示歡迎畫面，內含一個「Start Order」按鈕。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/20fa769d4ba93ef3_1920.png?hl=zh-tw" width="40%">

<p>按一下「Start Order」後，使用者就能從可用的選項中選擇主餐。使用者可以變更所選項目，進而更新底部顯示的「Subtotal」部分。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/438b61180d690b3a_1920.png?hl=zh-tw" width="40%">

<p>下一個畫面可讓使用者新增配菜。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/768352680759d3e2_1920.png?hl=zh-tw" width="40%">

<p>之後的畫面可讓使用者選取小菜。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/8ee2bf41e9844614_1920.png?hl=zh-tw" width="40%">

<p>最後，系統會向使用者顯示訂單費用的摘要，並細分為小計、銷售稅和總費用。使用者也可以提交或取消訂單。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/61c883c34d94b7f7_1920.png?hl=zh-tw" width="40%">

<p>這兩種選項都會帶使用者返回第一個畫面。如果使用者提交了訂單，畫面底部應會顯示浮動式訊息，讓他們知道訂單已提交。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/acb7d7a5d9843bac_1920.png?hl=zh-tw" width="40%">

<hr>
<h3 id="開始操作"><a href="#開始操作" class="headerlink" title="開始操作"></a>開始操作</h3><h4 id="下載專案程式碼"><a href="#下載專案程式碼" class="headerlink" title="下載專案程式碼"></a>下載專案程式碼</h4><p>請注意，資料夾名稱是 <code>android-basics-kotlin-lunch-tray-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-lunch-tray-app/tree/main">https://github.com/google-developer-training/android-basics-kotlin-lunch-tray-app/tree/main</a><br><strong>具有範例程式碼的分支版本名稱：</strong><b>main</b></p>
          </div>

<p>在開始實作 <code>ViewModel</code> 和 navigation 功能前，請花點時間確認專案已順利完成建構，並熟悉該專案。首次執行應用程式時，您會看到空白畫面。這是因為您尚未設定 navigation graph，因此 <code>MainActivity</code> 不會顯示任何 fragment。</p>
<p>專案結構應與您處理的其他專案類似。系統會提供 <u>data、model和 ui 的個別 package</u>，以及 resource 的個別目錄。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/a19fd8a4bc92f2fc_1920.png?hl=zh-tw" width="80%">

<h4 id="data-class-MenuItem"><a href="#data-class-MenuItem" class="headerlink" title="data class MenuItem"></a>data class MenuItem</h4><p>使用者可以訂購的所有午餐選項 (主餐、配菜和小菜) 會以「model」package 的 <code>MenuItem</code> 類別呈現。<code>MenuItem</code> 物件包含<u>菜品名稱(name)、菜品說明(description)、價格(price)和菜品類型(type)</u>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">MenuItem</span>(</span><br><span class="line">    <span class="keyword">val</span> name: String, <span class="comment">// 菜品名稱</span></span><br><span class="line">    <span class="keyword">val</span> description: String, <span class="comment">// 菜品說明</span></span><br><span class="line">    <span class="keyword">val</span> price: <span class="built_in">Double</span>, <span class="comment">// 價格</span></span><br><span class="line">    <span class="keyword">val</span> type: <span class="built_in">Int</span> <span class="comment">// 類型(主餐、配菜和小菜)</span></span><br><span class="line">) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">getFormattedPrice</span><span class="params">()</span></span>: String = NumberFormat.getCurrencyInstance().format(price)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-ItemType"><a href="#object-ItemType" class="headerlink" title="object ItemType"></a>object ItemType</h4><p>type 是以「constants」package 中 <code>ItemType</code> 物件的 Int 呈現。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> ItemType &#123;</span><br><span class="line">    <span class="keyword">val</span> ENTREE = <span class="number">1</span> <span class="comment">// 主餐</span></span><br><span class="line">    <span class="keyword">val</span> SIDE_DISH = <span class="number">2</span> <span class="comment">// 配菜</span></span><br><span class="line">    <span class="keyword">val</span> ACCOMPANIMENT = <span class="number">3</span> <span class="comment">// 小菜</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="object-DataSource"><a href="#object-DataSource" class="headerlink" title="object DataSource"></a>object DataSource</h4><p>您可以在 data package 的 <code>DataSource.kt</code> 中找到個別 <code>MenuItem</code> 物件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> DataSource &#123;</span><br><span class="line">    <span class="keyword">val</span> menuItems = mapOf(</span><br><span class="line">        <span class="string">&quot;cauliflower&quot;</span> to</span><br><span class="line">        MenuItem(</span><br><span class="line">            name = <span class="string">&quot;Cauliflower&quot;</span>,</span><br><span class="line">            description = <span class="string">&quot;Whole cauliflower, brined, roasted, and deep fried&quot;</span>,</span><br><span class="line">            price = <span class="number">7.00</span>,</span><br><span class="line">            type = ItemType.ENTREE</span><br><span class="line">        ),</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個物件只包含一個 <strong>map</strong>，其中有<u>索引 key 以及對應的 value <code>MenuItem</code></u>。您將從 <code>ObjectViewModel</code> 存取 <code>DataSource</code>，您必須先實作 <code>ObjectViewModel</code>。</p>
<h4 id="ViewModel-class-OrderViewModel"><a href="#ViewModel-class-OrderViewModel" class="headerlink" title="ViewModel - class OrderViewModel"></a>ViewModel - class OrderViewModel</h4><p>正如前一頁的螢幕截圖所示，應用程式會要求使用者提供以下三樣資訊：主餐、配菜和小菜。接著，訂單摘要畫面會顯示小計，並根據所選餐點計算銷售稅，然後用來算出訂單總金額。</p>
<p>在「model」package 中開啟 <code>OrderViewModel.kt</code>，您就會看到幾個已經定義的變數。<code>menuItems</code> 屬性可讓您從 <code>ViewModel</code> 存取 <code>DataSource</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DataSource 中 menuItems 的 Map</span></span><br><span class="line"><span class="keyword">val</span> menuItems = DataSource.menuItems</span><br></pre></td></tr></table></figure>

<p>首先，<code>previousEntreePrice</code>、<code>previousSidePrice</code> 和 <code>previousAccompanimentPrice</code> 也有一些變數。小計會在使用者做出選擇時更新 (而不是在最後加總)，因此如果使用者在前往下一個畫面之前變更了所選項目，系統就會透過這些變數來追蹤使用者先前的選項。這些變數可確保小計反映了先前和目前選取項目的價差。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> previousEntreePrice = <span class="number">0.0</span> <span class="comment">// 先前主餐價格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> previousSidePrice = <span class="number">0.0</span> <span class="comment">// 先前配菜價格</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> previousAccompanimentPrice = <span class="number">0.0</span> <span class="comment">// 先前小菜價格</span></span><br></pre></td></tr></table></figure>

<p>此外，還有<code> _entree</code>、<code>_side</code> 和 <code>_accompaniment</code> 這類 private 變數，可用於儲存目前選取的選項。這些都屬於 <code>MutableLiveData&lt;MenuItem?&gt;</code> 類型。每個類型都伴隨 public backing 屬性 <code>entree</code>、<code>side</code> 和 <code>accompaniment</code> (屬於不可變動的 <code>LiveData&lt;MenuItem?&gt;</code> 類型)。您可以透過 fragment 的 layout 來存取這些內容，讓所選 item 顯示在畫面上。<code>LiveData</code> 物件中包含的 <code>MenuItem</code> 也可以是空值，因為使用者也可以不選取主餐、配菜和&#x2F;或小菜。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用者選取的主餐</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _entree = MutableLiveData&lt;MenuItem?&gt;()</span><br><span class="line"><span class="keyword">val</span> entree: LiveData&lt;MenuItem?&gt; = _entree</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 使用者選取的配菜</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _side = MutableLiveData&lt;MenuItem?&gt;()</span><br><span class="line"><span class="keyword">val</span> side: LiveData&lt;MenuItem?&gt; = _side</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用者選取的小菜</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _accompaniment = MutableLiveData&lt;MenuItem?&gt;()</span><br><span class="line"><span class="keyword">val</span> accompaniment: LiveData&lt;MenuItem?&gt; = _accompaniment</span><br></pre></td></tr></table></figure>

<p>小計、總計與稅金也有 <code>LiveData</code> 變數，其採<u>數字格式(number formatting)</u>設定，因此能以貨幣形式顯示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 訂單小計(預設0.0元)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _subtotal = MutableLiveData(<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 使用 Transformations.map() 設定 subtotal 顯示的格式(當地幣別)</span></span><br><span class="line"><span class="keyword">val</span> subtotal: LiveData&lt;String&gt; = Transformations.map(_subtotal) &#123;</span><br><span class="line">    NumberFormat.getCurrencyInstance().format(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 訂單總計(預設0.0元)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _total = MutableLiveData(<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 使用 Transformations.map() 設定 total 顯示的格式(當地幣別)</span></span><br><span class="line"><span class="keyword">val</span> total: LiveData&lt;String&gt; = Transformations.map(_total) &#123;</span><br><span class="line">    NumberFormat.getCurrencyInstance().format(it)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 訂單稅金(預設0.0元)</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _tax = MutableLiveData(<span class="number">0.0</span>)</span><br><span class="line"><span class="comment">// 使用 Transformations.map() 設定 tax 顯示的格式(當地幣別)</span></span><br><span class="line"><span class="keyword">val</span> tax: LiveData&lt;String&gt; = Transformations.map(_tax) &#123;</span><br><span class="line">    NumberFormat.getCurrencyInstance().format(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後，tax rate 是硬式編碼(hardcoded)的 0.08 (8%)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> taxRate = <span class="number">0.08</span></span><br></pre></td></tr></table></figure>

<p>您必須實作 <code>OrderViewModel</code> 中的六個方法。</p>
<p>■ <code>setEntree()</code>、<code>setSide()</code> 和 <code>setAccompaniment()</code><br>這些方法應該以相同方式適用於主餐、配菜和小菜。舉例來說，<code>setEntree()</code> 應執行以下操作：</p>
<ol>
<li>如果 <code>_entree</code> 不是 <code>null</code> (也就是使用者已選取主餐，但後來變更了選項)，請將 <code>previousEntreePrice</code> 設為 <code>current _entree</code> 的價格。</li>
<li>如果 <code>_subtotal</code> 不是 <code>null</code>，請從 subtotal 減去 <code>previousEntreePrice</code>。</li>
<li>將 <code>_entree</code> 的值更新為傳遞至函式的 entree (使用 <code>menuItems</code> 存取 <code>MenuItem</code>)。</li>
<li>呼叫 <code>updateSubtotal()</code>，傳遞新選取的主餐價格。</li>
</ol>
<p><code>setSide()</code> 和 <code>setAccompaniment()</code> 的邏輯與 <code>setEntree()</code> 的實作相同。</p>
<p>■ <code>updateSubtotal()</code><br>系統會呼叫 <code>updateSubtotal()</code>，並加上應加入小計的新價格參數。這個方法需要執行以下三件事：</p>
<ol>
<li>如果 <code>_subtotal</code> 不是 <code>null</code>，請將 <code>itemPrice</code> 新增至 <code>_subtotal</code>。</li>
<li>如果 <code>_subtotal</code> 是 <code>null</code>，請將 <code>_subtotal</code> 設為 <code>itemPrice</code>。</li>
<li>設定或更新 <code>_subtotal</code> 後，呼叫 <code>calculateTaxAndTotal()</code> 即可更新這些值，以反映新的小計。</li>
</ol>
<p>■ <code>calculateTaxAndTotal()</code><br><code>calculateTaxAndTotal()</code> 應根據小計(subtotal)來更新稅金(tax)的變數和總金額(total)。實作如下方法：</p>
<ol>
<li>將 <code>_tax</code> 設為 tax rate 乘上 subtotal。</li>
<li>將 <code>_total</code> 設為 subtotal 加上 tax。</li>
</ol>
<p>■ <code>resetOrder()</code><br>使用者提交或取消訂單時，系統會呼叫 <code>resetOrder()</code>。當使用者建立新訂單時，請確保應用程式不會留下任何資料。<br>建議您將在 <code>OrderViewModel</code> 修改的所有變數設回原始值 (0.0 或空值)，藉此實作 <code>resetOrder()</code>。</p>
<h4 id="建立-data-binding-變數"><a href="#建立-data-binding-變數" class="headerlink" title="建立 data binding 變數"></a>建立 data binding 變數</h4><p>在 layout 檔案中實作 data binding。開啟 layout 檔案，並<u>新增 <code>OrderViewModel</code> type</u> 和&#x2F;或<u>對應 fragment class 的 data binding 變數</u>。</p>
<p>您需要實作所有 <code>TODO</code> 註解，才能在四個 layout 檔案中設定 <strong>text</strong> 和 <strong>click listeners</strong>：</p>
<ol>
<li><code>fragment_entree_menu.xml</code></li>
<li><code>fragment_side_menu.xml</code></li>
<li><code>fragment_accompaniment_menu.xml</code></li>
<li><code>fragment_checkout.xml</code></li>
</ol>
<p>系統會在 layout 檔案中的 <code>TODO</code> 註解標示每個特定工作，步驟摘要如下。</p>
<ol>
<li><p>在 <code>fragment_entree_menu.xml</code> 的 <code>&lt;data&gt;</code> 標記中，新增 <code>EntreeMenuFragment</code> 的 binding 變數。對於每個 radio button，您需在按鈕已選取的情況下，於 <code>ViewModel</code> 中設定主餐。subtotal text view 的 text 應隨之更新。此外，您也需設定 <code>cancel_button</code> 和 <code>next_button</code> 的 <code>onClick</code> 屬性，以便分別取消訂單或前往下一個畫面。</p>
</li>
<li><p>在 <code>fragment_side_menu.xml</code> 中執行相同操作，新增 <code>SideMenuFragment</code> 的 binding 變數，但在點選每個 radio button 時，於 view model 中設定配菜。subtotal text 也會需要更新，而您也需為 cancel 和 next button 設定 <code>onClick</code> 屬性。</p>
</li>
<li><p>再次執行相同的操作，但在 <code>fragment_accompaniment_menu.xml</code> 中，這次使用 <code>AccompanimentMenuFragment</code> 的 binding 變數，在每個 radio button 皆已選取時設定小菜。此外，您也需設定 subtotal text、cancel button 和 next button 的屬性。</p>
</li>
<li><p>在 <code>fragment_checkout.xml</code> 中，您需要新增 <code>&lt;data&gt;</code> 標記，以便定義 binding 變數。而在 <code>&lt;data&gt;</code> 標記內，請新增兩個 binding 變數：一個用於 <code>OrderViewModel</code>，另一個用於 <code>CheckoutFragment</code>。在 text view 中，您需從 <code>OrderViewModel</code> 設定所選主餐、配菜和小菜的名稱與價格。您還需要設定 <code>OrderViewModel</code> 中的小計、稅金和總金額。接著，使用 <code>CheckoutFragment</code> 中的適當函式，設定訂單提交和取消時的 <code>onClickAttributes</code>。</p>
</li>
</ol>
<h4 id="初始化-fragment-中的-data-binding-變數"><a href="#初始化-fragment-中的-data-binding-變數" class="headerlink" title="初始化 fragment 中的 data binding 變數"></a>初始化 fragment 中的 data binding 變數</h4><p>初始化 <code>onViewCreated()</code> 方法中對應 fragment 檔案內的 data binding 變數。</p>
<ol>
<li><code>EntreeMenuFragment</code></li>
<li><code>SideMenuFragment</code></li>
<li><code>AccompanimentMenuFragment</code></li>
<li><code>CheckoutFragment</code></li>
</ol>
<h4 id="建立-navigation-graph"><a href="#建立-navigation-graph" class="headerlink" title="建立 navigation graph"></a>建立 navigation graph</h4><p>單元 3 中已說明，activity 中的 <code>FragmentContainerView</code> 會代管 navigation graph。開啟 <code>activity_main.xml</code> 並使用以下程式碼來取代 <code>TODO</code>，以宣告 <code>FragmentContainerView</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_host_fragment&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;androidx.navigation.fragment.NavHostFragment&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:defaultNavHost</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:navGraph</span>=<span class="string">&quot;@navigation/mobile_navigation&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>mobile_navigation.xml</code> navigation graph 位於 <code>res/navigation</code> package 中。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/e3381215c35c1726_1920.png?hl=zh-tw" width="50%">

<p>這是應用程式的 navigation graph，但此檔案目前為空白。您的工作是為 navigation graph 新增目的地，並建立以下在不同畫面之間導覽的模型。</p>
<ol>
<li>從 <code>StartOrderFragment</code> 前往 <code>EntreeMenuFragment</code></li>
<li>從 <code>EntreeMenuFragment</code> 前往 <code>SideMenuFragment</code></li>
<li>從 <code>SideMenuFragment</code> 前往 <code>AccompanimentMenuFragment</code></li>
<li>從 <code>AccompanimentMenuFragment</code> 前往 <code>CheckoutFragment</code></li>
<li>從 <code>CheckoutFragment</code> 前往 <code>StartOrderFragment</code></li>
<li>從 <code>EntreeMenuFragment</code> 前往 <code>StartOrderFragment</code></li>
<li>從 <code>SideMenuFragment</code> 前往 <code>StartOrderFragment</code></li>
<li>從 <code>AccompanimentMenuFragment</code> 前往 <code>StartOrderFragment</code></li>
<li>起始目的地 應為 <code>StartOrderFragment</code></li>
</ol>
<p>設定 navigation graph 後，您需在 fragment 類別中執行導覽。在 fragment 中實作剩餘的 <code>TODO</code> 和 <code>MainActivity.kt</code> 註解。</p>
<ol>
<li>針對 <code>EntreeMenuFragment</code>、<code>SideMenuFragment</code> 和 <code>AccompanimentMenuFragment</code> 中的 <code>goToNextScreen()</code> 方法，前往應用程式中的下一個畫面。</li>
<li>針對 <code>EntreeMenuFragment</code>、<code>SideMenuFragment</code>、<code>AccompanimentMenuFragment</code> 和 <code>CheckoutFragment</code> 中的 <code>cancelOrder()</code> 方法，首先在 <code>sharedViewModel</code> 上呼叫 <code>resetOrder()</code>，然後前往 <code>StartOrderFragment</code>。</li>
<li>在 <code>StartOrderFragment</code> 中，實作 <code>setOnClickListener()</code> 以前往 <code>EntreeMenuFragment</code>。</li>
<li>在 <code>CheckoutFragment</code> 中實作 <code>submitOrder()</code> 方法。在 <code>sharedViewModel</code> 上呼叫 <code>resetOrder()</code>，然後前往 <code>StartOrderFragment</code>。</li>
<li>最後在 <code>MainActivity.kt</code> 中，將 <code>NavHostFragment</code> 的 <code>navController</code> 設為 <code>navController</code>。</li>
</ol>
<div class="note no-icon success">
            <p><strong>注意：</strong><b>OrderViewModel</b> 會處理這個應用程式的所有資料。您不需要傳送任何參數給目的地 fragment。</p>
          </div>

<h4 id="完成結果"><a href="#完成結果" class="headerlink" title="完成結果"></a>完成結果</h4><p>完成後的 Lunch Tray App 執行結果如下：</p>
<div class="video-container"><iframe src="https://player.vimeo.com/video/891345910" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<div class="note no-icon primary">
            <p>可以至我的 Github 查看程式碼：<br><a href="https://github.com/linglingdr00/Lunch-Tray-App-Practice">https://github.com/linglingdr00/Lunch-Tray-App-Practice</a></p>
          </div>

<hr>
<h3 id="測試應用程式"><a href="#測試應用程式" class="headerlink" title="測試應用程式"></a>測試應用程式</h3><p>Lunch Tray 專案包含一個「androidTest」目標，有多種測試案例：<code>MenuContentTests</code>、<code>NavigationTests</code> 和 <code>OrderFunctionalityTests</code>。</p>
<h4 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h4><p>如要執行測試，您可以執行下列其中一項操作：</p>
<p>若是單一測試案例，請開啟測試案例類別，然後按一下類別宣告左側的綠色箭頭。接著從選單中選取「Run」選項。這麼做將會執行測試案例中的所有測試。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/8ddcbafb8ec14f9b_1920.png?hl=zh-tw" width="70%">

<p>您通常只需要執行一項測試，例如在只有一個測試失敗，而其他測試都通過時。執行單一測試的做法，與執行整個測試案例一樣。請按一下綠色箭頭，並選取「Run」選項。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/335664b7fc8b4fb5_1920.png?hl=zh-tw" width="80%">

<p>如果您有多個測試案例，也可以執行整個測試套件。就像執行應用程式一樣，您可以在「Run」選單中找到這個選項。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/80312efedf6e4dd3_1920.png?hl=zh-tw" width="80%">

<p>請注意，Android Studio 預設會執行您執行的最後一個目標 (應用程式、測試目標等)，因此如果選單仍顯示「Run」&gt;「Run ‘app’」，您可以依序選取「Run」&gt;「Run」執行測試目標。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/95aacc8f749dee8e_1920.png?hl=zh-tw" width="80%">

<p>然後從彈出式選單中選擇測試目標。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lunch-tray/img/8b702efbd4d21d3d_1920.png?hl=zh-tw" width="40%">

<h4 id="測試結果"><a href="#測試結果" class="headerlink" title="測試結果"></a>測試結果</h4><ul>
<li><p><code>MenuContentTests</code></p>
<img src="https://i.imgur.com/gy2L4Fr.png" width="80%">
</li>
<li><p><code>NavigationTests</code></p>
<img src="https://i.imgur.com/9zVYjnt.png" width="80%">
</li>
<li><p><code>OrderFunctionalityTests</code></p>
<img src="https://i.imgur.com/Dbk8Q2C.png" width="80%"></li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Layout</tag>
        <tag>View Binding</tag>
        <tag>Automated Testing</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
        <tag>Navigation</tag>
        <tag>Fragment</tag>
        <tag>MutableLiveData</tag>
        <tag>Data Binding</tag>
        <tag>Shared ViewModel</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(31)-自動調整版面配置</title>
    <url>/2023/12/02/Android%E7%AD%86%E8%A8%98-31-%E8%87%AA%E5%8B%95%E8%AA%BF%E6%95%B4%E7%89%88%E9%9D%A2%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p><b>版面配置(layout)</b>應<u>配合不同的螢幕大小和方向而彈性調整</u>，而不是以特定顯示比例和螢幕大小的硬性尺寸來指定版面配置(layout)。因此，建議將 app 設計成在可順利在各種類型的裝置 (小螢幕或大螢幕裝置) 上執行。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/aecb59fc49fb4abf_1920.png?hl=zh-tw" width="50%">

<p><strong>學習目標</strong></p>
<ul>
<li>如何在 app 中加入 <code>SlidingPaneLayout</code>。</li>
</ul>
<p><strong>建構項目</strong></p>
<ul>
<li>更新 Sports app，配合大螢幕進行調整。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h3><div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/basic-android-kotlin-training-sports/tree/starter">https://github.com/google-developer-training/basic-android-kotlin-training-sports/tree/starter</a></p><p><strong>分支版本名稱：</strong><b>starter</b></p>
          </div>

<hr>
<h3 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h3><p>Sports app 由兩個畫面組成。<u>第一個畫面</u>會顯示 <u>sports lists</u> 。使用者可以<u>選取特定 sport item</u>，系統便會<u>顯示第二個畫面</u>。<u>第二個畫面</u>會顯示所選 <u>sports news 的詳細資料</u>。詳細資料畫面會顯示預留位置文字，以簡化實作。</p>
<div style="display:flex; justify-content:center;">
    <div style="width:40%; float:left; margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/d9af155f87ddbcdf_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/73a5e6de1c337b1d_1920.png?hl=zh-tw">
    </div>
    <div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<h4 id="範例程式碼逐步操作說明"><a href="#範例程式碼逐步操作說明" class="headerlink" title="範例程式碼逐步操作說明"></a>範例程式碼逐步操作說明</h4><p>您下載的範例程式碼包含預先設計的 list 畫面和詳細資料畫面 layout。在本課程中，您只需瞭解如何讓 app 配合大螢幕自動調整即可。您將用 <code>SlidingPaneLayout</code> 來利用大螢幕。以下是一些檔案的簡短逐步操作說明，以協助您快速上手。</p>
<p><code>fragment_sports_list.xml</code></p>
<ul>
<li>在「Design」檢視畫面中開啟 <code>res/layout/fragment_sports_list.xml</code>。</li>
<li>這包含 app 中第一個畫面的版面配置(layout)，也就是 sports lists 。</li>
<li>這個版面配置(layout)包含顯示 sports news list 的 Recyclerview。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/f50d3e7b41fcb338_1920.png?hl=zh-tw">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/d9af155f87ddbcdf_1920.png?hl=zh-tw" width="30%">

<p><code>sports_list_item.xml</code></p>
<ul>
<li>在「Design」檢視畫面中開啟 <code>res/layout/sports_list_item.xml</code>。</li>
<li>這包含每個項目(item)在 Recyclerview 中版面配置(layout)。</li>
<li>這個版面配置(layout)包含 sport item 的縮圖、新聞標題和 sports news 摘要的預留位置文字。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/b19fd0e779c1d7c3_1920.png?hl=zh-tw" width="50%">

<p><code>fragment_sports_news.xml</code></p>
<ul>
<li>在「Design」檢視畫面中開啟 <code>res/layout/fragment_sports_news.xml</code>。</li>
<li>這包含 app 中第二個畫面的版面配置(layout)。當使用者從 Recyclerview 選擇運動時，就會顯示這個畫面。</li>
<li>這個版面配置(layout)包含 sport item 的圖片橫幅和 sports news 的預留位置文字。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/c2073b1752342d97_1920.png?hl=zh-tw" width="40%">

<p><code>main_activity.xml</code> 和 <code>content_main.xml</code></p>
<ul>
<li>這兩個函式數用 <strong>single fragment</strong> 定義了 main activity 的版面配置(layout)。</li>
</ul>
<p><code>navigation/nav_graph.xml</code></p>
<ul>
<li>導覽圖包含兩個目的地，一個用於 <strong>sports lists</strong>，另一個用於 <strong>sports news</strong>。</li>
</ul>
<p>res&#x2F;values 資料夾</p>
<ul>
<li><code>colors.xml</code> 包含 app 中使用的主題顏色。</li>
<li><code>strings.xml</code> 包含 app 所需的所有字串。</li>
<li><code>themes.xml</code> 包含您為 app 產生的 UI 自訂項目。</li>
</ul>
<p><code>MainActivity.kt</code><br>這個檔案包含預設範本產生的程式碼，可<u>將 activity 的 content view 設為 <code>main_activity.xml</code></u>。為了處理 app bar 的預設 <strong>Up navigation</strong>，我們<u>覆寫了 <code>onSupportNavigateUp()</code> 方法</u>。</p>
<p><code>model/Sport.kt</code><br>這是一種<b>資料類別(data class)</b>，用來<u>存放 sports list Recyclerview 顯示的各列資料</u>。</p>
<p><code>data/SportsData.kt</code><br>這個檔案內含名為 <code>getSportsData()</code> 的函式，此函式會<u>傳回預先填入硬式編碼 sports data 的 <code>ArrayList</code></u>。</p>
<p>★ <code>SportsViewModel.kt</code><br>這是 app 的 <b>shared <code>ViewModel</code></b>。您可以<u>透過 <code>SportsListFragment</code> 來分享 <code>ViewModel</code></u>，第一個畫面包含 <u>sports lists 和 <code>NewsDetailsFragment</code></u>，第二個畫面含有<u>detailed sports news</u>。</p>
<ul>
<li><code>_currentSport</code> 屬性為 <code>MutableLiveData</code>, 類型，此類型會<u>儲存使用者選取的 current sport</u>。</li>
<li><code>currentSport</code> 屬性是 <code>_currentSport</code> 的 backing property，並以 <u>public 唯讀(read-only)</u>版本的形式公開，方便其他類別使用。</li>
<li><code>_sportsData</code> 屬性包含 <b>sports data list</b>。與上一個屬性類似，<code>sportsData</code> 是這項屬性的 <u>public 唯讀</u>版本。</li>
<li>初始化器 <code>init&#123;&#125;</code> 區塊會<b>初始化 <code>_currentSport</code> 和 <code>_sportsData</code></b>。<ul>
<li><code>_sportsData</code> 會透過<u>來自 <code>data/SportsData.kt</code> 的完整 sports lists</u> 進行初始化。</li>
<li><code>_currentSport</code> 會使用 <u>list 中的第一個 item</u> 進行初始化。</li>
</ul>
</li>
<li>函式 <code>updateCurrentSport()</code> 包含 <b><code>Sports</code> 執行個體(instance)</b>，並<u>以傳送的值(value)更新 <code>_currentSport</code></u>。</li>
</ul>
<p><code>SportsAdapter.kt</code><br>這是 <b>RecyclerView 的 adapter</b>。在<u>建構函式(constructor)</u>中，會<u>傳入 click listener</u>。這個檔案中的大部分程式碼都是先前的程式碼研究室介紹過的樣板程式碼。</p>
<p>★ <code>SportsListFragment.kt</code><br>這是<u>第一個畫面 fragment</u> ，是<u><b>顯示 sports lists</b></u> 之處。</p>
<ul>
<li><code>onCreateView()</code> 函式會使用 <b>binding object</b> <u>加載(inflates) <code>fragment_sports_list</code> 版面配置(layout) XML</u>。</li>
<li><code>onViewCreated()</code> 函式會設定 <b>RecyclerView adapter</b>。這個函式會<u>將使用者選取的 sport 更新為 <b>shared <code>ViewModel</code></b> (<code>SportsViewModel</code>) 中的 current sport</u>，並導覽至內含 sports news 的詳細資料畫面，<u>使用 <code>submitList(List)</code> 將要顯示的 sports lists 提交至 <b>adapter</b></u>。</li>
</ul>
<p><code>NewsDetailsFragment.kt</code><br>這是您 app 的第二個畫面，其中會<u>顯示 sports news</u> 的預留位置文字。</p>
<ul>
<li><code>onCreateView()</code> 函式會使用 <b>binding object</b> <u>加載(inflates) <code>fragment_sports_news</code> 版面配置(layout) XML</u>。</li>
<li><code>onViewCreated()</code> 函式會<u>在 <code>SportsViewModel</code> 的屬性上附加觀察器(observer) <code>currentSport</code></u>，在<u>資料有變時自動更新 UI</u>。運動標題(sports title)、圖片(image)和新聞(news)會在<b>觀察器(observer)</b>中更新。</li>
</ul>
<h4 id="建立應用程式並加以執行"><a href="#建立應用程式並加以執行" class="headerlink" title="建立應用程式並加以執行"></a>建立應用程式並加以執行</h4><p>在模擬器或裝置上建構並執行應用程式。選取體育清單中的任何項目，應用程式應該就會進入第二個畫面，畫面上包含新聞的預留位置文字。</p>
<div style="display:flex; justify-content:center;">
    <div style="width:40%; float:left; margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/d9af155f87ddbcdf_1920.png?hl=zh-tw">
    </div>
    <div style="width:40%; float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/73a5e6de1c337b1d_1920.png?hl=zh-tw">
    </div>
    <div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<hr>
<h3 id="List-Detail-模式"><a href="#List-Detail-模式" class="headerlink" title="List-Detail 模式"></a>List-Detail 模式</h3><p>目前的範例應用程式無法充分運用大螢幕裝置 (如平板電腦) 的螢幕空間。為解決這個問題，您稍後會透過本程式碼研究室介紹的「List-Detail」模式來顯示應用程式 UI。</p>
<h4 id="在平板電腦上執行應用程式"><a href="#在平板電腦上執行應用程式" class="headerlink" title="在平板電腦上執行應用程式"></a>在平板電腦上執行應用程式</h4><p>在這項工作中，您會建立一個具平板電腦設定檔的模擬器。模擬器建立完畢後，您將執行 Sports 應用程式範例程式碼並觀察 UI。</p>
<ol>
<li>在 Android Studio 中，依序前往「Tools」&gt;「AVD Manager」。</li>
<li>系統會隨即顯示「Android Virtual Device Manager」視窗。按一下底部顯示的「+ Create New Virtual Device…」。</li>
<li>系統隨即會顯示「Virtual Device Configuration」視窗。請在此處設定模擬器硬體和 OS。按一下左側窗格中的「Tablet」。選取中間窗格內的「Pixel C」或任何其他類似的硬體設定檔。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/8303f9b3e70321eb_1920.png?hl=zh-tw">

<ol start="4">
<li>按一下「Next」。</li>
<li>在撰寫這個程式碼研究室時，選取最新的系統映像檔 R (API 級別 30)。</li>
<li>按一下「Next」。</li>
<li>您現在可以選擇是否要重新命名虛擬裝置，這不是必須選項。</li>
<li>按一下「Finish」。</li>
<li>系統會將您帶回「Android Virtual Device Manager」視窗。在新建的虛擬裝置旁邊按一下啟動圖示。</li>
<li>這應會啟動具平板電腦設定檔的模擬器。請耐心等候，這可能需要一點時間。</li>
<li>關閉「Android Virtual Device Manager」視窗。</li>
<li>在新建的模擬器上執行運動應用程式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/200e209de7a2f0ad_1920.png?hl=zh-tw" width="80%">

<p>請注意，在大型裝置上，應用程式不會使用整個螢幕。在大螢幕上，清單詳細資料模式會較清單模式更為有效。清單詳細資料模式又稱為「主控制項詳細資料」模式，這種模式會在版面配置的其中一側顯示項目清單，而當您輕觸項目時，便會在項目一旁顯示詳細資料。一般情況下，這類檢視畫面只會在大螢幕 (例如平板電腦) 上顯示，因為大螢幕的空間足以顯示更多的內容。</p>
<p>以下是 list-detail 模式的範例圖片：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/71698910dd129a91_1920.png?hl=zh-tw" width="50%">

<p>如上所示，list-detail 模式會在左側顯示 list of items，在右側則會顯示所選 item 的 details。</p>
<p>同理，如果您在 sports app 中使用上述模式，則 news fragment 將成為 details 畫面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/51c9542717d2f875_1920.png?hl=zh-tw" width="80%">

<p>在本程式碼研究室中，您將瞭解如何使用 <code>SlidingPaneLayout</code> 實作 list-detail UI。</p>
<hr>
<h3 id="SlidingPaneLayout-模式"><a href="#SlidingPaneLayout-模式" class="headerlink" title="SlidingPaneLayout 模式"></a>SlidingPaneLayout 模式</h3><p>list-detail UI 可能需要根據螢幕大小而採取不同的行為。大螢幕有足夠的空間，可並排顯示 list 和 detail panes。在 list item 上點擊，即可在 detail pane 中顯示詳細資料。不過在小螢幕上，這樣的安排就會相當擁擠。與其同時顯示這兩個窗格，不如逐一顯示。一開始，list 窗格(pane)會填滿整個畫面。輕觸某個 item，會以該 item 的 detail pane 取代 list pane，同時填滿整個畫面。</p>
<p>您將瞭解如何使用 <code>SlidingPaneLayout</code> 來管理邏輯，進一步根據目前的螢幕大小選取適當的使用者體驗。</p>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-adaptive-layouts/img/b0a205de3494e95d.gif" width="40%">

<p>請注意 details pane 在小螢幕上滑過 list pane 的方式。</p>
<p>下方圖片說明 <code>SlidingPaneLayout</code> 在小螢幕上的顯示方式。請在 list item 處於選取狀態時，觀察 details pane 與 list pane 如何重疊，才能讓這兩個窗格(pane)始終存在！</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/e26f94d9579b6121_1920.png?hl=zh-tw" width="80%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/471b0b38d4dfa95a_1920.png?hl=zh-tw" width="40%">

<p>因此，<code>SlidingPaneLayout</code> 支援在大型裝置上並排顯示兩個窗格(pane)，而在手機之類的小型裝置上，則會自動調整為只顯示一個窗格(pane)。</p>
<hr>
<h3 id="新增-library-dependencies"><a href="#新增-library-dependencies" class="headerlink" title="新增 library dependencies"></a>新增 library dependencies</h3><ol>
<li>開啟 <code>build.gradle (Module: Sports.app)</code>。</li>
<li>在 <code>dependencies</code> 區段中，加入下列 dependency，即可在應用程式中使用 <code>SlidingPaneLayout</code>。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">...</span><br><span class="line">    implementation <span class="string">&quot;androidx.slidingpanelayout:slidingpanelayout:1.2.0-beta01&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong>您可以前往 <b><a href="https://developer.android.com/jetpack/androidx/versions?hl=zh-tw">AndroidX</a></b> 版本頁面，取得最新的版本號碼。</p>
          </div>

<hr>
<h3 id="設定-sports-list-fragment-的-XML"><a href="#設定-sports-list-fragment-的-XML" class="headerlink" title="設定 sports list fragment 的 XML"></a>設定 sports list fragment 的 XML</h3><p>在這項工作中，您將 <code>fragment_sports_list</code> 的根版面配置轉換為 <code>SlidingPaneLayout</code>。前面介紹過，<code>SlidingPaneLayout</code> 提供水平的雙窗格版面配置，可在 UI 頂層使用。這個版面配置將第一個窗格用作內容清單或瀏覽器，並對應到主要詳細資料檢視畫面，以在另一個窗格中顯示內容。</p>
<p>在 Sports app 中，第一個窗格會是顯示 sports list 的 <code>RecyclerView</code>，第二個窗格則顯示 sports news。</p>
<h4 id="新增-SlidingPaneLayout"><a href="#新增-SlidingPaneLayout" class="headerlink" title="新增 SlidingPaneLayout"></a>新增 SlidingPaneLayout</h4><ol>
<li>開啟 <code>fragment_sports_list.xml</code>。請注意根版面配置為 <code>FrameLayout</code>。</li>
<li>將 <code>FrameLayout</code> 變更為 <code>androidx.slidingpanelayout.widget.SlidingPaneLayout</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.slidingpanelayout.widget.SlidingPaneLayout</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:context</span>=<span class="string">&quot;.SportsListFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView...</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.slidingpanelayout.widget.SlidingPaneLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>SlidingPaneLayout</code> 中加入 <code>android:id</code> 屬性，並指定一個 <code>@+id/sliding_pane_layout</code> 的值。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.slidingpanelayout.widget.SlidingPaneLayout</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/sliding_pane_layout&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="在-SlidingPaneLayout-中新增第二個窗格"><a href="#在-SlidingPaneLayout-中新增第二個窗格" class="headerlink" title="在 SlidingPaneLayout 中新增第二個窗格"></a>在 SlidingPaneLayout 中新增第二個窗格</h4><p>在這個工作中，您會在 <code>SlidingPaneLayout</code> 中新增第二個子項。這會顯示為右側的內容窗格。</p>
<ol>
<li>在 <code>fragment_sports_list.xml</code> 中的 <code>RecyclerView</code> 下新增第二個子項 <code>androidx.fragment.app.FragmentContainerView</code>。</li>
<li>在 <code>FragmentContainerView</code> 中加入必要屬性 <code>layout_height</code> 和 <code>layout_width</code>，並指定 <code>match_parent</code> 這個屬性值。請注意，您稍後會更新這些值。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>FragmentContainerView</code> 中加入 <code>android:id</code> 屬性，並指定一個 <code>@+id/detail_container</code> 的值。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:id=&quot;@+id/detail_container&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用 <code>android:name</code> 屬性在 <code>FragmentContainerView</code> 中新增 <code>NewsDetailsFragment</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:name=&quot;com.example.android.sports.NewsDetailsFragment&quot;</span><br></pre></td></tr></table></figure>

<h4 id="更新-layout-width-屬性"><a href="#更新-layout-width-屬性" class="headerlink" title="更新 layout_width 屬性"></a>更新 layout_width 屬性</h4><p><code>SlidingPaneLayout</code> 會依據兩個窗格的寬度來判斷是否要並排顯示窗格(pane)。舉例來說，如果經過測量後，list pane 的最小尺寸為 <code>300dp</code>，而 detail pane 需要 <code>400dp</code>，那麼只要可用寬度至少為 <code>700dp</code>，<code>SlidingPaneLayout</code> 就會自動並排顯示這兩個窗格(pane)。</p>
<p>如果子項檢視畫面(view)的組合寬度超過 <code>SlidingPaneLayout</code> 中的可用寬度，子項 view 會發生重疊。在本範例中，子項 view 會展開來填滿 <code>SlidingPaneLayout</code> 中的可用寬度。</p>
<p>為了判斷子項 view 的寬度，建議您瞭解裝置螢幕寬度相關的基本資訊。下表列出了幾個主觀的中斷點，可讓您針對各種可調整大小的應用程式版面配置來進行設計、開發及測試。這些中斷點經過特別挑選，目的是讓您兼顧版面配置的簡單與靈活，進一步根據獨特的情境需求來最佳化應用程式。</p>
<table>
<thead>
<tr>
<th align="left">寬度</th>
<th align="left">中斷點</th>
<th align="left">裝置佔比</th>
</tr>
</thead>
<tbody><tr>
<td align="left">Compact width(精簡寬度)</td>
<td align="left">&lt; 600dp</td>
<td align="left">99.96% 直向模式的手機</td>
</tr>
<tr>
<td align="left">Medium width(中等寬度)</td>
<td align="left">600dp+</td>
<td align="left">93.73% 以 portraitLarge 顯示的平板電腦，會以直向展開內部的顯示項目</td>
</tr>
<tr>
<td align="left">Expanded width(展開寬度)</td>
<td align="left">840dp+</td>
<td align="left">97.22% 以 landscapeLarge 顯示的平板電腦，會橫向展開內部的顯示項目</td>
</tr>
</tbody></table>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/a247a843310d061a_1920.png?hl=zh-tw">

<p>在運動應用程式中，建議您在手機 (寬度小於 <code>600dp</code> 的裝置) 上顯示單一窗格 (也就是體育項目清單)。如要在平板電腦上顯示這兩個窗格，加總的寬度必須大於 <code>840dp</code>。您可以將第一個子項 (<code>RecyclerView</code>) 的寬度設為 <code>550dp</code>，第二個子項 (<code>FragmentContainerView</code>) 則設為 <code>300dp</code>。</p>
<ol>
<li>在 <code>fragment_sports_list.xml</code> 中，將 <code>RecyclerView</code> 的版面配置寬度變更為 <code>550dp</code>，再將 <code>FragmentContainerView</code> 的版面配置寬度變更為 <code>300dp</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;550dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;300dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>分別在採用平板電腦設定檔和手機設定檔的模擬器上執行應用程式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/ad148a96d7487e66_1920.png?hl=zh-tw" width="80%">

<ul>
<li>請注意，平板電腦會顯示兩個窗格。您將在後續步驟中將平板電腦上的第二個窗格設為固定寬度。</li>
</ul>
<ol start="3">
<li>具手機設定檔的模擬器上執行應用程式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/a6be6d199d2975ac_1920.png?hl=zh-tw" width="40%">

<h4 id="新增-layout-weight"><a href="#新增-layout-weight" class="headerlink" title="新增 layout_weight"></a>新增 layout_weight</h4><p>在這項工作中，您將針對平板電腦調整 UI，讓第二個窗格(pane)占滿剩餘的全部空間。</p>
<p>如果檢視畫面(view)未重疊，則在透過版面配置參數 <code>layout_weight</code> 測量子項檢視畫面(view)之後，<code>SlidingPaneLayout</code> 可定義剩餘空間的分割方式。這個參數僅適用於寬度。</p>
<ol>
<li>在 <code>fragment_sports_list.xml</code> 中，將 <code>layout_weight</code> 加入 <code>FragmentContainerView</code> 並指定其值為 <code>1</code>。這樣一來，在測量 list 窗格(pane)之後，第二個窗格(pane)就會展開並填滿剩餘空間。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:layout_weight=&quot;1&quot;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行應用程式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/ce3a93fe501ee5dc_1920.png?hl=zh-tw" width="80%">

<p>恭喜！您已成功新增 <code>SlidingPaneLayout</code>。但這項設定尚未完成。從清單選擇項目之後，您必須導入返回導覽功能並更新第二個窗格。您將於後續工作中實作這些項目。</p>
<hr>
<h3 id="切換-details-pane"><a href="#切換-details-pane" class="headerlink" title="切換 details pane"></a>切換 details pane</h3><p>在具平板電腦設定檔的模擬器上執行應用程式。從 sports list 中選取 list item。請注意，應用程式會導航(navigates)至 details pane。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/8fedee8d4837909_1920.png?hl=zh-tw" width="80%">

<p>在這項工作中，您會修正這個問題。目前，系統會先以選取的 sports item 更新雙窗格的內容，接著應用程式會轉至 <code>NewsDetailsFragment</code>。</p>
<ol>
<li>在 <code>SportsListFragment</code> 檔案的 <code>onViewCreated()</code> 函式中，找到以下程式行以前往 details 畫面。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Navigate to the details screen</span></span><br><span class="line"><span class="keyword">val</span> action = SportsListFragmentDirections.actionSportsListFragmentToNewsFragment()</span><br><span class="line"><span class="keyword">this</span>.findNavController().navigate(action)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用下列程式碼取代以上這幾行：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.slidingPaneLayout.openPane()</span><br></pre></td></tr></table></figure>
<ul>
<li>對 <code>SlidingPaneLayout</code> 呼叫 <code>openPane()</code>，將第一個窗格(pane)切換至第二個窗格(pane)。如果兩個窗格(pane)皆處於顯示狀態 (例如在平板電腦上)，這項操作不會造成任何可見的影響。</li>
</ul>
<ol start="3">
<li>在平板電腦和手機模擬器上執行應用程式。請注意，雙窗格(pane)內容會不斷正確更新。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/b0d3c8c263be15f8_1920.png?hl=zh-tw" width="80%">

<p>在下一個工作中，您將為應用程式新增自訂返回導覽功能(custom back navigation)。</p>
<hr>
<h3 id="新增-custom-back-navigation"><a href="#新增-custom-back-navigation" class="headerlink" title="新增 custom back navigation"></a>新增 custom back navigation</h3><p>小型裝置上的 list 和 detail pane 會重疊，因此您必須確保系統 back 按鈕可讓使用者從 detail pane 返回 list pane。方法是 提供 <b><a href="https://developer.android.com/guide/navigation/navigation-custom-back?hl=zh-tw">custom back navigation</a></b>，並將 <a href="https://developer.android.com/reference/androidx/activity/OnBackPressedCallback"><code>OnBackPressedCallback</code></a> 連結到 <code>SlidingPaneLayout</code> 目前的狀態。</p>
<h4 id="Back-navigation"><a href="#Back-navigation" class="headerlink" title="Back navigation"></a>Back navigation</h4><p><strong>Back navigation</strong> 是指<u>使用者依據瀏覽歷史記錄返回先前瀏覽過的畫面</u>。所有 Android 裝置都會針對這類導覽提供 <strong>Back button</strong>。視使用者的 Android 裝置而定，該按鈕可能是實體按鈕或軟體按鈕。</p>
<h4 id="Custom-back-navigation"><a href="#Custom-back-navigation" class="headerlink" title="Custom back navigation"></a>Custom back navigation</h4><p>當使用者導覽應用程式時，Android 系統會保留目的地的<b>返回堆疊(back stack)</b>。一般情況下，使用者按下 Back button 時，Android 可以導覽至之前的目的地。不過在少數情況下，您可能必須為應用程式<u>實作專屬的<b>返回行為(Back behavior)</b></u>，盡可能提供最佳使用者體驗。</p>
<p>舉例來說，在使用 WebView (例如 Chrome 瀏覽器) 時，您可能要覆寫預設的 Back button 行為，讓使用者返回先前的網頁瀏覽記錄，而不是回到先前的應用程式畫面。</p>
<p>同樣地，您必須在 <code>SlidingPaneLayout</code> 中提供 <b>custom back navigation</b> 功能，<u>將應用程式從 detail pane 導航回 list pane</u>。</p>
<h4 id="實作-custom-back-navigation"><a href="#實作-custom-back-navigation" class="headerlink" title="實作 custom back navigation"></a>實作 custom back navigation</h4><p>如要在 Sports 應用程式中實作 custom back navigation，需要執行以下作業：</p>
<ul>
<li>定義一個 <strong>custom callback</strong> 來<u>處理返回鍵(back key)的動作</u>，這會<u>覆寫 <code>OnBackPressedCallback</code></u>。</li>
<li>註冊並新增 <strong>callback instance</strong>。</li>
</ul>
<p>首先，請定義 custom callback。</p>
<ol>
<li>在 <code>SportsListFragment</code> 檔案中的 <code>SportsListFragment</code> 類別定義下方新增類別。將其命名為 <code>SportsListOnBackPressedCallback</code>。</li>
<li>傳入 <code>SlidingPaneLayout</code> 的 <code>private</code> instance 做為建構函式(constructor)參數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>透過 <code>OnBackPressedCallback</code> 繼承類別。<code>OnBackPressedCallback</code> 類別會處理 <code>onBackPressed</code> callbacks。您會在不久之後修正這項建構函式(constructor)參數錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">): OnBackPressedCallback()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>OnBackPressedCallback</code> 的建構函式(constructor)會<u>以布林值(boolean)表示初始啟用狀態</u>。只有在<u>已啟用 callback 的情況下</u> (即 <code>isEnabled()</code> 傳回 <code>true</code>)，<b>分派器(dispatcher)</b>才會<u>呼叫 callback 的 <code>handleOnBackPressed()</code> 來處理 Back button event</u>。</li>
</ul>
<ol start="4">
<li>將 <code>slidingPaneLayout.isSlideable &amp;&amp; slidingPaneLayout.isOpen</code> 做為建構函式參數傳入 <code>OnBackPressedCallback</code>。只有在第二個窗格可滑動的情況下，布林值 <code>isSlideable</code> 才會為 <code>true</code>；這種情況可能會發生在顯示單一窗格的小螢幕裝置上。如果第二個窗格 (內容窗格) 完全開啟，則 <code>isOpen</code> 的值將為 <code>true</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">): OnBackPressedCallback(slidingPaneLayout.isSlideable &amp;&amp; slidingPaneLayout.isOpen)</span><br></pre></td></tr></table></figure>
<ul>
<li>這段程式碼可確保只有在小螢幕裝置上且內容窗格開啟的情況下，才會啟用這個 callback。</li>
</ul>
<ol start="5">
<li><p>如要修正未實作方法造成的錯誤，請按一下紅色燈泡圖示，然後選取「Implement members」。</p>
</li>
<li><p>在「Implement members」彈出式視窗中按一下「OK」，覆寫 <code>handleOnBackPressed</code> 方法。</p>
</li>
</ol>
<p>您的類別應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">): OnBackPressedCallback(slidingPaneLayout.isSlideable &amp;&amp; slidingPaneLayout.isOpen) &#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Callback for handling the [OnBackPressedDispatcher.onBackPressed] event.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">       TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 <code>handleOnBackPressed()</code> 函式中刪除 TODO 陳述式，然後新增下列程式碼來關閉 content(內容) pane 並返回 list pane。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">slidingPaneLayout.closePane()</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong><b>SlidingPaneLayout</b> 會一律允許您手動呼叫 <b>open()</b> 和 <b>close()</b>，讓您可在手機的 list pane 和 detail pane 之間切換。<u>如果兩個窗格(pane)都顯示且未重疊，這些方法就不會生效</u>。</p>
          </div>

<h4 id="監控-SlidingPaneLayout-的事件"><a href="#監控-SlidingPaneLayout-的事件" class="headerlink" title="監控 SlidingPaneLayout 的事件"></a>監控 SlidingPaneLayout 的事件</h4><p>除了處理 back press events 外，您也必須<u>監聽及監控與 sliding pane 相關的事件</u>。<u>內容窗格(content pane)滑動時，應視滑動情況啟用或停用 callback</u>。您將使用 <a href="https://developer.android.com/reference/androidx/slidingpanelayout/widget/SlidingPaneLayout.PanelSlideListener"><code>PanelSlideListener</code></a> 進行這項操作。</p>
<p><a href="https://developer.android.com/reference/androidx/slidingpanelayout/widget/SlidingPaneLayout.PanelSlideListener"><code>SlidingPaneLayout.PanelSlideListener</code></a> 介面包含三個<u>抽象方法</u>：</p>
<ul>
<li><code>onPanelSlide()</code></li>
<li><code>onPanelOpened()</code> </li>
<li><code>onPanelClosed()</code></li>
</ul>
<p>details pane <b>滑動(slides)</b>、<b>開啟(opens)</b>及<b>關閉(closes)</b>時，系統會呼叫這些方法。</p>
<ol>
<li><p>從 <code>SlidingPaneLayout.PanelSlideListener</code> 展開 <code>SportsListOnBackPressedCallback</code> 類別。</p>
</li>
<li><p>如要解決錯誤，請導入這三種方法。按一下紅色燈泡，然後在 Android Studio 中選取「Implement members」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-adaptive-layouts/img/ad52135eecbee09f_1920.png?hl=zh-tw" width="60%">

<p>您的 <code>SportsListOnBackPressedCallback</code> 類別應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">): OnBackPressedCallback(slidingPaneLayout.isSlideable &amp;&amp; slidingPaneLayout.isOpen),</span><br><span class="line">  SlidingPaneLayout.PanelSlideListener&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">       slidingPaneLayout.closePane()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelSlide</span><span class="params">(panel: <span class="type">View</span>, slideOffset: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">       TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelOpened</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelClosed</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>移除 TODO 陳述式。</p>
</li>
<li><p>在 details pane 開啟 (visible) 時，啟用 <code>OnBackPressedCallback</code> callback。實際做法為呼叫 <code>setEnabled()</code> 函式並傳入 <code>true</code>。在 <code>onPanelOpened()</code> 中編寫以下程式碼：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setEnabled(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>使用屬性存取語法可以簡化上述的程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelOpened</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">   isEnabled = <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>同樣地，當 details pane 關閉(closed)時，請將 <code>isEnabled</code> 設為 <code>false</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelClosed</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">   isEnabled = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>如要完成 callback，最後一個步驟是將 <code>SportsListOnBackPressedCallback</code> 的 <strong>listener class</strong> 新增至 <strong>listeners</strong> 的 <strong>list</strong> 中，該 list 將會<u>收到 details pane 滑動事件(slide events)的通知</u>。將 <code>init</code> 區塊新增至 <code>SportsListOnBackPressedCallback</code> 類別。在 <code>init</code> 區塊內，呼叫 <code>slidingPaneLayout.addPanelSlideListener()</code> 以傳入 <code>this</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">   slidingPaneLayout.addPanelSlideListener(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成的 <code>SportsListOnBackPressedCallback</code> 類別看起來應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SportsListOnBackPressedCallback</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> slidingPaneLayout: SlidingPaneLayout</span><br><span class="line">): OnBackPressedCallback(slidingPaneLayout.isSlideable &amp;&amp; slidingPaneLayout.isOpen),</span><br><span class="line">  SlidingPaneLayout.PanelSlideListener&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">       slidingPaneLayout.addPanelSlideListener(<span class="keyword">this</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleOnBackPressed</span><span class="params">()</span></span> &#123;</span><br><span class="line">       slidingPaneLayout.closePane()</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelSlide</span><span class="params">(panel: <span class="type">View</span>, slideOffset: <span class="type">Float</span>)</span></span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelOpened</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       isEnabled = <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPanelClosed</span><span class="params">(panel: <span class="type">View</span>)</span></span> &#123;</span><br><span class="line">       isEnabled = <span class="literal">false</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="註冊-callback"><a href="#註冊-callback" class="headerlink" title="註冊 callback"></a>註冊 callback</h4><p>如要查看 callback 的實際效果，請使用 <strong>dispatcher</strong> <a href="https://developer.android.com/reference/androidx/activity/OnBackPressedDispatcher"><code>OnBackPressedDispatcher</code></a> 註冊 callback。</p>
<p><a href="https://developer.android.com/reference/androidx/fragment/app/FragmentActivity"><code>FragmentActivity</code></a> 的基礎類別可讓您<u>透過 <code>OnBackPressedDispatcher</code> 控制 Back button 的行為</u>。<code>OnBackPressedDispatcher</code> 可控管系統如何<u>將 Back button events 分派到一或多個 <a href="https://developer.android.com/reference/androidx/activity/OnBackPressedCallback"><code>OnBackPressedCallback</code></a> 物件</u>。</p>
<p>使用 <a href="https://developer.android.com/reference/androidx/activity/OnBackPressedDispatcher#addCallback(androidx.lifecycle.LifecycleOwner,%20androidx.activity.OnBackPressedCallback)"><code>addCallback()</code></a> 方法新增 callback。這個方法需要使用 <a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner"><code>LifecycleOwner</code></a>。此方法可確保只有在 <code>LifecycleOwner</code> 為 <a href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.State#STARTED"><code>Lifecycle.State.STARTED</code></a> 時，才會新增 <code>OnBackPressedCallback</code>。<u>當相關 <code>LifecycleOwner</code> 遭到刪除時</u>，<u>activity 或 fragment 也會移除已註冊的 callbacks</u>，藉此<u>防止記憶體流失</u>，並讓 callbacks 適合用於 fragments 或其他 lifecycle owners (生命週期較短時)。</p>
<p><code>addCallback()</code> 方法也會採用<u>將 callback class 做為第二個參數的 instance</u>。請按照下列步驟註冊 callback：</p>
<ol>
<li>在 <code>SportsListFragment</code> 檔案的 <code>onViewCreated()</code> 函式中，於 binding 變數宣告的下方為 <code>SlidingPaneLayout</code> 建立 instance，並為其指派 <code>binding.slidingPaneLayout</code> 的值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> slidingPaneLayout = binding.slidingPaneLayout</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>SportsListFragment</code> 檔案的 <code>onViewCreated()</code> 函式中，緊接在 <code>slidingPaneLayout</code> 宣告下方，新增下列程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Connect the SlidingPaneLayout to the system back button.</span></span><br><span class="line">requireActivity().onBackPressedDispatcher.addCallback(</span><br><span class="line">   viewLifecycleOwner,</span><br><span class="line">   SportsListOnBackPressedCallback(slidingPaneLayout)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>上述程式碼使用了 <code>addCallback()</code>，並傳入 <code>viewLifecycleOwner</code> 和 <code>SportsListOnBackPressedCallback</code> 的 instance。這個 callback 的有效期間僅限於 fragment 的生命週期。</li>
</ul>
<ol start="3">
<li>您現在可以在具手機設定檔的模擬器上執行應用程式，看看 custom back button 的實際運作情形。</li>
</ol>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-adaptive-layouts/img/33967fa8fde5b902.gif" width="40%">

<hr>
<h3 id="鎖定模式-Lock-mode"><a href="#鎖定模式-Lock-mode" class="headerlink" title="鎖定模式(Lock mode)"></a>鎖定模式(Lock mode)</h3><p>根據預設，在手機等小螢幕裝置上，當 list 和 detail panes 重疊時，使用者可以左右滑動，不必使用手勢操作即可切換這兩個窗格。您可以設定 <code>SlidingPaneLayout</code> 的鎖定模式(lock mode)，鎖定或解鎖 details pane。</p>
<ol>
<li>在具手機設定檔的模擬器中，嘗試將 details pane 在畫面中滑開。</li>
<li>你也可以在 details pane 中滑動，請自行嘗試。</li>
<li>在 Sports 應用程式中，您不必使用這項功能。建議您鎖定 <code>SlidingPaneLayout</code>，防止使用者透過手勢向內及向外滑動。如要實作這項功能，請在 <code>onViewCreated()</code> 方法的 <code>slidingPaneLayout</code> 定義下方，將 <code>lockMode</code> 設為 <code>LOCK_MODE_LOCKED</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">slidingPaneLayout.lockMode = SlidingPaneLayout.LOCK_MODE_LOCKED</span><br></pre></td></tr></table></figure>
<ul>
<li>如要進一步瞭解其他 lock mode，請參閱<a href="https://developer.android.com/reference/androidx/slidingpanelayout/widget/SlidingPaneLayout#LOCK_MODE_LOCKED">說明文件</a>。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong><b>鎖定模式(lock mode)</b>只能控制哪些是可用的使用者手勢。無論設定哪一種鎖定模式，您隨時都能透過程式化方式開啟或關閉 <b>SlidingPaneLayout</b>。</p>
          </div>

<ol start="4">
<li>再次執行應用程式，注意 detail pane 現已鎖定。</li>
</ol>
<p>恭喜！您已成功將 <code>SlidingPaneLayout</code> 新增至應用程式！</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Layout</tag>
        <tag>View Binding</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
        <tag>Navigation</tag>
        <tag>Fragment</tag>
        <tag>ViewModel</tag>
        <tag>MutableLiveData</tag>
        <tag>Observer</tag>
        <tag>Shared ViewModel</tag>
        <tag>SlidingPaneLayout</tag>
        <tag>Custom Back Navigation</tag>
        <tag>Callback</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(30)-測試ViewModel和LiveData</title>
    <url>/2023/11/15/Android%E7%AD%86%E8%A8%98-30-%E6%B8%AC%E8%A9%A6ViewModel%E5%92%8CLiveData/</url>
    <content><![CDATA[<blockquote>
<p>在先前的程式碼研究室中，您已學會如何使用 <code>ViewModel</code> 處理商業邏輯，以及使用 <code>LiveData</code> 處理 reactive UI。在本程式碼研究室中，您將學習如何編寫單元測試(unit tests)，以檢查 <code>ViewModel</code> 程式碼是否正常運作。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>學會如何設定 <code>LiveData</code> 測試。</li>
<li>學會如何測試 <code>LiveData</code> 本身。</li>
<li>學會如何測試已完成轉換(transformed)的 <code>LiveData</code>。</li>
<li>學會如何在單元測試中觀察(observe) <code>LiveData</code>。</li>
</ul>
<p><strong>建構項目</strong></p>
<ul>
<li>編寫 <code>ViewModel</code> 和 <code>LiveData</code> 單元測試(unit tests)。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="建立單元測試目錄"><a href="#建立單元測試目錄" class="headerlink" title="建立單元測試目錄"></a>建立單元測試目錄</h3><p>單元測試一律位於 <code>test</code> 目錄中：</p>
<ol>
<li>從「Android」切換至「Project」。</li>
<li>按一下第一個下拉式選單，然後依序點選「app」-&gt;「src」。</li>
<li>用滑鼠右鍵按一下「src」，然後選取「New」-&gt;「Directory」。</li>
</ol>
<img src="https://i.imgur.com/KQwG4fC.png" width="90%">

<ol start="4">
<li>輸入並選取 <code>test/java</code>。</li>
</ol>
<img src="https://i.imgur.com/XCpZreH.png" width="40%">

<ol start="5">
<li>現在會在專案結構中看到「src」-&gt;「test」目錄。</li>
</ol>
<img src="https://i.imgur.com/9Q6G56K.png" width="40%">

<ol start="6">
<li>用滑鼠右鍵按一下「java」目錄，然後依序選取「New」-&gt;「Package」。</li>
</ol>
<img src="https://i.imgur.com/sFkQ38z.png" width="90%">

<ol start="7">
<li>在視窗中輸入 <code>com.example.cupcake</code>，然後按下 Return 鍵。</li>
</ol>
<img src="https://i.imgur.com/9977Lc4.png" width="40%">

<ol start="8">
<li>最後，建立名為 <code>ViewModelTests.kt</code> 的新 class。用滑鼠右鍵按一下 <code>com.example.cupcake</code>，然後依序選取「New」-&gt;「Kotlin Class&#x2F;File」。</li>
</ol>
<img src="https://i.imgur.com/rtne9Xv.png" width="90%">

<ol start="9">
<li>在出現的視窗中輸入 <code>ViewModelTests</code>，然後從下拉式選單中選取「Class」。</li>
</ol>
<img src="https://i.imgur.com/3uhe7a5.png" width="40%">

<hr>
<h3 id="新增必要的-dependencies"><a href="#新增必要的-dependencies" class="headerlink" title="新增必要的 dependencies"></a>新增必要的 dependencies</h3><p>將下列 dependencies 新增至專案：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;junit:junit:4.+&#x27;</span></span><br><span class="line">testImplementation <span class="string">&#x27;androidx.arch.core:core-testing:2.1.0&#x27;</span></span><br></pre></td></tr></table></figure>

<p>接著同步(sync)專案。</p>
<hr>
<h3 id="編寫和執行-ViewModel-測試"><a href="#編寫和執行-ViewModel-測試" class="headerlink" title="編寫和執行 ViewModel 測試"></a>編寫和執行 ViewModel 測試</h3><h4 id="編寫單元測試"><a href="#編寫單元測試" class="headerlink" title="編寫單元測試"></a>編寫單元測試</h4><p>讓我們先從簡單的測試開始。當我們在裝置(device)或模擬器(emulator)上與 app 互動時，首先會<u>選取杯子蛋糕(cupcakes)的數量(quantity)</u>。因此，我們會<u>在 <code>OrderViewModel</code> 中測試 <code>setQuantity()</code> 方法</u>，並<u>檢查 <code>quantity</code> <code>LiveData</code> 物件的 value</u>。</p>
<p>我們要測試的 <code>quantity</code> 變數是 <u><code>LiveData</code> instance</u>。測試 <code>LiveData</code> 物件需要執行額外步驟，因此，我們所新增的 <u>dependency</u> 就能派上用場。<u>只要 value 有變更，我們就會使用 <code>LiveData</code> 更新 UI</u>。<u>UI 於「<b>主執行緒(main thread)</b>」上運作</u>。如果您不熟悉<b>執行緒(threading)</b>和<b>並行(concurrency)</b>的概念，別擔心，我們會在其他程式碼研究室中深入介紹。</p>
<p>就 Android 應用程式而言，請<u>暫時將主執行緒(main thread)視為 UI 執行緒(thread)</u>。向使用者顯示 UI 的程式碼會在此執行緒(thread)上運作。除非另有指定，否則<u>單元測試(unit test)會假設所有項目皆在主執行緒(main thread)上運作</u>。不過，由於 <u><code>LiveData</code> 物件無法存取主執行緒(main thread)</u>，因此必須明確指出 <u><code>LiveData</code> 物件不得呼叫主執行緒(main thread)</u>。</p>
<ol>
<li>如要指定 <u><code>LiveData</code> 物件不得呼叫主執行緒(main thread)</u>，我們需在每次測試 <code>LiveData</code> 物件時提供專用<u><b>測試規則(test rule)</b></u>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@get:Rule</span></span><br><span class="line"><span class="keyword">var</span> instantTaskExecutorRule = InstantTaskExecutorRule()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>現在可建立名為 <code>quantity_twelve_cupcakes()</code> 的 function。在 method 中，建立 <code>OrderViewModel</code> instance。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> quantity_twelve_cupcakes &#123;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>在本測試中，您需確認 <code>OrderViewModel</code> 中的 <code>quantity</code> 物件在 <code>setQuantity</code> 呼叫時已更新。但在呼叫任何 method 或處理 <code>OrderViewModel</code> 中的任何資料前，請注意測試 <code>LiveData</code> 物件的 value 時，必須先觀察(observed)物件，才能發出變更。方法很簡單，只要使用 <code>observeForever</code> method 即可。呼叫 <code>quantity</code> 物件的 <code>observeForever</code> method 。這個 method 需要 <strong>lambda</strong> 運算式，但可以留空(empty)。</p>
</li>
<li><p>然後呼叫 <code>setQuantity()</code> method，將 <code>12</code> 傳入做為參數。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在 method 中，建立 OrderViewModel instance</span></span><br><span class="line"><span class="keyword">val</span> viewModel = OrderViewModel()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 確認 OrderViewModel 中的 quantity 物件在 setQuantity 呼叫時已更新</span></span><br><span class="line"><span class="comment">// 測試 LiveData 物件的 value 時，須先使用 observeForever method 觀察(observed)物件，才能發出變更</span></span><br><span class="line">viewModel.quantity.observeForever &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 呼叫 setQuantity() method，將 12 傳入做為參數</span></span><br><span class="line">viewModel.setQuantity(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>我們可以放心推論 <code>quantity</code> 物件的 value 為 <code>12</code>。請注意，<code>LiveData</code> 物件本身並不是 value。value 包含在名為 <code>value</code> 的屬性中。指定以下斷言(assertion)：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="number">12</span>, viewModel.quantity.value)</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，嘗試呼叫 <code>assertEquals()</code> 方法時，文字會先顯示為紅色。這是因為找不到這個方法的宣告，所以您必須 import 宣告(option+enter)，然後選擇來自 <code>org.junit.Assert</code> package 的選項。<img src="https://i.imgur.com/iXIWd50.png"></li>
</ul>
<p>Test code 的編寫方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">quantity_twelve_cupcakes</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> viewModel = OrderViewModel()</span><br><span class="line">   viewModel.quantity.observeForever &#123;&#125;</span><br><span class="line">   viewModel.setQuantity(<span class="number">12</span>)</span><br><span class="line">   assertEquals(<span class="number">12</span>, viewModel.quantity.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>補充：</strong><b><a href="https://zh.wikipedia.org/zh-tw/%E6%96%B7%E8%A8%80_(%E7%A8%8B%E5%BC%8F)">斷言(assertion)</a></b>是一種放在程式中的一階邏輯（如一個結果為真或是假的邏輯判斷式），目的是為了標示與驗證程式開發者預期的結果－當程式執行到斷言的位置時，對應的斷言應該為真。若斷言不為真時，程式會中止執行，並給出錯誤訊息。<br><a href="https://linglingdr00.github.io/2023/08/23/Android%E7%AD%86%E8%A8%98-6-%E7%B7%A8%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/#%E5%87%BD%E5%BC%8F%E5%AE%A3%E5%91%8A">點此查看常見的斷言(assertion)</a></p>
          </div>

<h4 id="執行單元測試"><a href="#執行單元測試" class="headerlink" title="執行單元測試"></a>執行單元測試</h4><ol>
<li>點選 Run Test 執行 <code>ViewModelTests</code>。</li>
</ol>
<img src="https://i.imgur.com/IJNuI4L.png">

<ol start="2">
<li>查看測試結果，顯示 <strong>Tests passed</strong> 即代表測試通過。</li>
</ol>
<img src="https://i.imgur.com/kG1dwHG.png">

<p>執行測試！恭喜！您剛剛已編寫第一個 <code>LiveData</code> 單元測試(unit test)，這是 <strong>Modern Android Development</strong> 的重要技能。這種方式並未測試到大部分的商業邏輯，因此我們要設計較為深入的測試。</p>
<p>計算訂單價格是 <code>OrderViewModel</code> 的主要功能之一。當我們選取杯子蛋糕數量，並選取取貨日期時，就會執行此功能。價格計算是以 private method 進行，因此我們的測試無法直接呼叫此 method。只有 <code>OrderViewModel</code> 中的其他 method 可以進行呼叫。這些是 public method，因此我們會呼叫此類 method 觸發價格計算作業，以便確認價格值是否符合預期。</p>
<h4 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h4><p>選取杯子蛋糕數量及日期時，價格將會隨之更新。儘管兩者都應進行測試，但我們通常建議針對單一功能進行測試。因此，我們會針對各測試建立不同的方法：</p>
<ul>
<li><u>在<b>數量(quantity)</b>更新時用於測試<b>價格(price)</b>的 function</u></li>
<li><u>在更新<b>日期(date)</b>時用於測試<b>價格(price)</b>的 function</u></li>
</ul>
<p>我們不希望測試結果因為另一項測試失敗而失敗。</p>
<ol>
<li><p>建立名為 <code>price_twelve_cupcakes()</code> 的方法，並將其做為測試加上註解(加上 <code>@Test</code>)。</p>
</li>
<li><p>在方法中，建立 <code>OrderViewModel</code> instance，並呼叫 <code>setQuantity()</code> 方法，將 12 傳入做為參數。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> viewModel = OrderViewModel()</span><br><span class="line">viewModel.setQuantity(<span class="number">12</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>查看 <code>OrderViewModel</code> 中的 <code>PRICE_PER_CUPCAKE</code> 時，可看見每個杯子蛋糕的售價為 <strong>$2.00 美元</strong>。還可以看到每次 <code>ViewModel</code> 初始化時都會呼叫 <code>resetOrder()</code>，在此方法中，預設日期為今天的日期，<code>PRICE_FOR_SAME_DAY_PICKUP</code> 為 <strong>$3.00 美元</strong>。因此，<strong>12 * 2 + 3 &#x3D; 27</strong>。選擇 12 個杯子蛋糕後，我們預期 <code>price</code> 變數的 value 應為 <strong>$27.00 美元</strong>。接著做出斷言，假設 <strong>$27.00 美元</strong>的預期值等於 <code>price</code> <code>LiveData</code> 物件的 value。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="string">&quot;$27.00&quot;</span>, viewModel.price.value)</span><br></pre></td></tr></table></figure>

<p>現在請執行測試，測試應會失敗！</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-test-viewmodel-and-livedata/img/17c8a24e4d7d635d_1920.png?hl=zh-tw">

<p>測試結果顯示，實際值是 <code>null</code>。以下為相關說明。如果您查看 <code>OrderViewModel</code> 中的 <code>price</code> 變數，可看見：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> price: LiveData&lt;String&gt; = Transformations.map(_price) &#123;</span><br><span class="line">   <span class="comment">// Format the price into the local currency and return this as LiveData&lt;String&gt;</span></span><br><span class="line">   NumberFormat.getCurrencyInstance().format(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此範例是應在測試中觀察(observed)到 <code>LiveData</code> 的原因。系統會使用 <code>Transformation</code> 設定 <code>price</code> 的 value。基本上，此程式碼會使用我們指派給 <code>price</code> 的 value，並將其轉換成貨幣格式，使我們不必手動執行。但這個程式碼還有其他含意。轉換 <code>LiveData</code> 物件時，除非有必要進行呼叫，否則系統不會呼叫程式碼，而會將資源(resources)儲存到行動裝置(mobile device)。只有在觀察(observe)到物件變更時，系統才會呼叫程式碼。當然，此操作是在 app 中執行，但我們也需要為測試進行相同操作。</p>
<ol start="4">
<li>在測試方法中，請先新增下列程式碼，再設定數量(quantity)：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.price.observeForever &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>測試程式碼的編寫方式如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">price_twelve_cupcakes</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> viewModel = OrderViewModel()</span><br><span class="line">   viewModel.price.observeForever &#123;&#125;</span><br><span class="line">   viewModel.setQuantity(<span class="number">12</span>)</span><br><span class="line">   assertEquals(<span class="string">&quot;$27.00&quot;</span>, viewModel.price.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果現在進行測試，應可通過測試。</p>
<img src="https://i.imgur.com/7t5rnKR.png">]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Automated Testing</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>Observer</tag>
        <tag>Unit Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(29)-Navigation和back stack</title>
    <url>/2023/11/14/Android%E7%AD%86%E8%A8%98-29-Navigation%E5%92%8Cback-stack/</url>
    <content><![CDATA[<blockquote>
<p>瞭解 Android 如何處理應用程式的 tasks 和 back stack。這可讓您操控各種情況下的 back stack (例如取消訂單)，讓使用者返回應用程式的第一個畫面，而非訂購流程的前一個畫面。</p>
</blockquote>
<p>在先前的程式碼研究室中，您已開始實作 <strong>Cupcake</strong> app，現將在本程式碼研究室中完成其餘步驟。<strong>Cupcake</strong> app 有多個畫面，且會顯示杯子蛋糕的訂購流程。完成的 app 必須讓使用者能夠瀏覽 app，以執行下列操作：</p>
<ul>
<li>建立杯子蛋糕訂單</li>
<li>使用 <strong>Up</strong> 或 <strong>Back</strong> button 前往訂購流程的上一個步驟</li>
<li>取消訂單</li>
<li>將訂單傳送至其他 app (例如 email app)</li>
</ul>
<p><strong>學習目標</strong></p>
<ul>
<li>navigation 對於 app back stack 的影響</li>
<li>如何實作自訂(custom) back stack 行為</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="實作-Up-button-行為"><a href="#實作-Up-button-行為" class="headerlink" title="實作 Up button 行為"></a>實作 Up button 行為</h3><p>在 <strong>Cupcake</strong> app 中，app bar 會顯示可返回上一個畫面的箭頭，此為「Up」button，您在先前的程式碼研究室中曾學過。「Up」button 目前沒有任何作用，因此請先在 app 中修正此 navigation bug。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/fbdc1793f9fea6da_1920.png?hl=zh-tw" width="50%">

<ol>
<li>您的 <code>MainActivity</code> 中應該已有使用 nav controller 設定 app bar (也稱為 action bar) 的程式碼。將 <code>navController</code> 設為 class 變數，以利於其他方法中使用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(R.layout.activity_main) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> navController: NavController</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> navHostFragment = supportFragmentManager</span><br><span class="line">                .findFragmentById(R.id.nav_host_fragment) <span class="keyword">as</span> NavHostFragment</span><br><span class="line">        navController = navHostFragment.navController</span><br><span class="line"></span><br><span class="line">        setupActionBarWithNavController(navController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在同一個 class 中，新增程式碼來覆寫 <code>onSupportNavigateUp()</code> 函式。此程式碼會要求 <code>navController</code> 處理 app 的 navigating up。否則，請返回至處理「Up」button 的父類別實作 (在 <code>AppCompatActivity</code> 中)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSupportNavigateUp</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> navController.navigateUp() || <span class="keyword">super</span>.onSupportNavigateUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行應用程式。「Up」button 現在應可在 <code>FlavorFragment</code>、<code>PickupFragment</code> 和 <code>SummaryFragment</code> 中運作。前往訂購流程中的上一個步驟時，fragments 應透過 view model 顯示正確的口味（flavor)和取貨日期(pickup date)。</li>
</ol>
<img src="https://i.imgur.com/DauAFkp.gif" width="30%">

<hr>
<h3 id="瞭解-tasks-和-back-stack"><a href="#瞭解-tasks-和-back-stack" class="headerlink" title="瞭解 tasks 和 back stack"></a>瞭解 tasks 和 back stack</h3><p>現在，請在 app 的訂購流程中加入「Cancel」button。在訂購過程中的任何時間點取消訂單，會讓使用者返回 <code>StartFragment</code>。若要處理此行為，您需瞭解 Android 中的 tasks 和 back stack。</p>
<h4 id="Tasks"><a href="#Tasks" class="headerlink" title="Tasks"></a>Tasks</h4><p>Android 的 activities 存在於 tasks 中。首次從 launcher icon 開啟 app 時，Android 會建立一個包含 main activity 的新 task。「task」是使用者執行特定工作 (例如查看 email、建立杯子蛋糕訂單、拍照) 時，可進行互動的一系列 activities。</p>
<p>系統會以 back stack 的排列方式來顯示 activities，此方式會將使用者造訪的新 activity 推送至 task 的 back stack 上。您可以將上述過程看成鬆餅的堆疊(stack)，每一份新的鬆餅皆會添加於堆疊(stack)頂端。堆疊(stack)頂端的 activity 是指使用者目前正在互動的 activity。堆疊(stack)中，位於該 activity 下方的 activity 已移至背景且停止。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/517054e483795b46_1920.png?hl=zh-tw" width="50%">

<p>使用者想要往回瀏覽時，back stack 功能就能派上用場。Android 可以從 stack 頂端移除目前 activity、將其刪除，並重新啟動其下方的 activity。這稱為從 stack 中移除 activity，並將先前的 activity 移至前景(foreground)，以便使用者進行互動。如果使用者想要反覆返回查看，Android 會持續將 activity 從 stack 頂端移除，直到接近 stack 底部為止。如果返回 stack 中沒有任何 activity，系統會將使用者導回至裝置的啟動器畫面(launcher screen)（或至啟動此 app）。</p>
<p>讓我們看看您透過以下 2 個 activities 實作的 <strong>Words</strong> app 版本：<code>MainActivity</code> 和 <code>DetailActivity</code>。</p>
<p>初次啟動 app 時，<code>MainActivity</code> 會開啟，並新增至 task 的 back stack 中。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/4bc8f5aff4d5ee7f_1920.png?hl=zh-tw" width="50%">

<p>只要按一下字母，<code>DetailActivity</code> 就會啟動，然後推送到 back stack 上。這表示已建立、啟動並重新啟用 <code>DetailActivity</code>，因此使用者可與其互動。系統會將 <code>MainActivity</code> 置於背景(background)，並以灰色的背景顏色顯示於圖表(diagram)中。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/80f7c594ae844b84_1920.png?hl=zh-tw" width="50%">

<p>若輕觸「Back」button，系統就會從 back stack 中彈出 <code>DetailActivity</code>，並刪除及結束 <code>DetailActivity</code> instance。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/80f532af817191a4_1920.png?hl=zh-tw" width="50%">

<p>接著，back stack 頂端的下一個 item (<code>MainActivity</code>) 就會移至前景(foreground)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/85004712d2fbcdc1_1920.png?hl=zh-tw" width="50%">

<div class="note no-icon success">
            <p><strong>注意：</strong>開啟應用程式後，若輕觸裝置上的「主畫面(Home)」，系統會將 app 的所有 task 移至背景(background)。若再次輕觸該 app 的啟動器圖示(launcher icon)，Android 會確認 app 中是否存在現有 task ，並將該 task 移至前景(foreground) (包含完整 back stack)。如果沒有現有 task，Android 會為您建立新 task 並啟動 main activity，然後將其推送至 back stack。</p>
          </div>

<p>如同 back stack 可追蹤使用者已開啟的 activities，只要與 <strong>Jetpack Navigation component</strong> 搭配運作，back stack 也可透過相同方式追蹤使用者造訪過的 fragment 目的地(destinations)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/fe417ac5cbca4ce7_1920.png?hl=zh-tw" width="50%">

<p>只要使用 Navigation library，即可在使用者每次點選「Back」button 時，從返 back stack 中彈出  fragment 目的地(destination)。此預設行為無需實作任何設定。如果您需要自訂(custom) back stack 行為，才需要編寫程式碼，您將為 <strong>Cupcake</strong> app 進行此操作。</p>
<h4 id="Cupcake-app-的預設行為"><a href="#Cupcake-app-的預設行為" class="headerlink" title="Cupcake app 的預設行為"></a>Cupcake app 的預設行為</h4><p>讓我們看看 back stack 在 Cupcake app 中的運作方式。App 中只有一個 activity，但使用者會瀏覽多個 fragment 目的地。因此，「Back」button 在使用者輕觸時才返回上一個 fragment 目的地較為理想。</p>
<p>初次開啟 app 時，系統會顯示 <code>StartFragment</code> 目的地。該目的地會推送至 stack 頂端。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/cf0e80b4907d80dd_1920.png?hl=zh-tw" width="50%">

<p>選取要訂購的杯子蛋糕數量後，將會前往 <code>FlavorFragment</code>，這個目的地會推送至返回 back stack 上。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/39081dcc3e537e1e_1920.png?hl=zh-tw" width="50%">

<p>當您選取口味並輕觸「Next」後，將會前往 <code>PickupFragment</code>，並推送至 back stack 上。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/37dca487200f8f73_1920.png?hl=zh-tw" width="50%">

<p>最後，選取自取日期並輕觸「Next」後，將會前往 <code>SummaryFragment</code>，這個目的地會新增至 back stack 頂端。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/d67689affdfae0dd_1920.png?hl=zh-tw" width="50%">

<p>如果您從 <code>SummaryFragment</code> 中輕觸「Back」或「Up」button，<code>SummaryFragment</code> 會從 stack 中移除並刪除。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/215b93fd65754017_1920.png?hl=zh-tw" width="50%">

<p><code>PickupFragment</code> 現在位於 back stack 頂端，並向使用者顯示。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/37dca487200f8f73_1920.png?hl=zh-tw" width="50%">

<p>再次輕觸「Back」或「Up」按鈕，將會從 stack 中移除 <code>PickupFragment</code>，接著顯示 <code>FlavorFragment</code>。</p>
<p>再次輕觸「Back」或「Up」按鈕，將會從 stack 中移除 <code>FlavorFragment</code>，接著顯示 <code>StartFragment</code>。</p>
<p>當您在訂購流程中返回到上一個步驟時，一次只會移除一個目的地。但在下一個工作中，您會在 app 中新增<u>取消訂單</u>功能。為此，您必須<u>一次移除 back stack 中的多個目的地，讓使用者返回 <code>StartFragment</code></u> 建立新訂單。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/e3dae0f492450207_1920.png?hl=zh-tw" width="50%">

<h4 id="修改-Cupcake-app-中的-back-stack"><a href="#修改-Cupcake-app-中的-back-stack" class="headerlink" title="修改 Cupcake app 中的 back stack"></a>修改 Cupcake app 中的 back stack</h4><p>修改 <code>FlavorFragment</code>、<code>PickupFragment</code> 和 <code>SummaryFragment</code> class 和 layout 檔案，為使用者提供取消訂單按鈕。</p>
<h5 id="新增-navigation-action"><a href="#新增-navigation-action" class="headerlink" title="新增 navigation action"></a>新增 navigation action</h5><p>請先在 app 的 navigation graph 中加入 navigation actions，讓使用者能從後續目的地返回 <code>StartFragment</code>。</p>
<ol>
<li>前往「res」&gt;「navigation」&gt;「nav_graph.xml」檔案，然後選取「Design」檢視畫面，以開啟 Navigation Editor。</li>
<li>目前有 <code>startFragment</code> 至 <code>flavorFragment</code> 的 action、<code>flavorFragment</code> 至 <code>pickupFragment</code> 的 action，以及 <code>pickupFragment</code> 至 <code>summaryFragment</code> 的 action。</li>
<li>按住並拖曳即可建立從 <code>summaryFragment</code> 至 <code>startFragment</code> 的新 navigation action。如想複習如何在 navigation graph 中連結目的地，請參閱<a href="https://developer.android.com/guide/navigation/get-started?hl=zh-tw#connect">這些操作說明</a>。</li>
<li>按住並拖曳 <code>pickupFragment</code> 即可建立至 <code>startFragment</code> 的新 action。</li>
<li>按住並拖曳 <code>flavorFragment</code> 即可建立至 <code>startFragment</code> 的新 action。</li>
<li>完成後，navigation graph 應如下所示。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/dcbd27a08d24cfa0_1920.png?hl=zh-tw">

<p>進行上述變更後，使用者即可從訂購流程中較後方的某個 fragments 返回至訂購流程的起始處。現在，您需要實際使用這些 action 進行 navigates 的程式碼。輕觸「Cancel」按鈕處即為適當位置。</p>
<h5 id="在-layout-中新增「Cancel」按鈕"><a href="#在-layout-中新增「Cancel」按鈕" class="headerlink" title="在 layout 中新增「Cancel」按鈕"></a>在 layout 中新增「Cancel」按鈕</h5><p>首先，請在所有 fragments (<code>StartFragment</code> 除外) 的 layout 檔案中新增「Cancel」按鈕。如果您已位於訂購流程的第一個畫面，便無需取消訂單。</p>
<ol>
<li>開啟 <code>fragment_flavor.xml</code> layout 檔案。</li>
<li>您可以使用「Split」view 直接編輯 XML，且並排 view 預覽畫面。</li>
<li>在 subtotal text view 和「Next」按鈕之間新增「Cancel」按鈕。為其指派 resource ID <code>@+id/cancel_button</code>，並以 text 顯示 <code>@string/cancel</code>。</li>
</ol>
<p>該按鈕應與「Next」按鈕平行放置，以一列按鈕的形式呈現。針對 vertical constraint，請將「Cancel」按鈕 top constraint 與「Next」按鈕 top 同高。針對 horizontal constraints，請將「Cancel」按鈕的 start 處限制於 parent 中，並將其 end 處限制於「Next」按鈕的 start 處。</p>
<p>此外，請將「Cancel」按鈕的 height 設為 <code>wrap_content</code>，width 設為 <code>0dp</code>，以便將螢幕寬度平均分配給另一個按鈕。請注意，進入下一個步驟前，「Preview」窗格不會顯示此按鈕。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/subtotal&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/cancel&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/next_button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>fragment_flavor.xml</code> 中，您也需將「Next」按鈕的 start constraint 從 <code>app:layout_constraintStart_toStartOf=&quot;parent&quot;</code> 變更為 <code>app:layout_constraintStart_toEndOf=&quot;@id/cancel_button&quot;</code>。此外，在「Cancel」按鈕上新增 end margin，讓兩個按鈕之間留有空白。現在，Android Studio 的「Preview」窗格中應會顯示「Cancel」按鈕。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;@dimen/side_margin&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/cancel_button&quot;</span><span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 visual style 方面，請使用 <a href="https://m3.material.io/components/buttons/overview">Material Outlined Button</a> 樣式 (使用屬性 <code>style=&quot;?attr/materialButtonOutlinedStyle&quot;</code>)，使「Cancel」按鈕不會過於醒目，因「Next」按鈕是您希望使用者專注的主要動作。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;?attr/materialButtonOutlinedStyle&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>按鈕和位置現在看起來十分完美！</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/1fb41763cc255c05_1920.png?hl=zh-tw" width="40%">

<ol start="6">
<li>以同樣的方式，在 <code>fragment_pickup.xml</code> layout 檔案中新增「Cancel」按鈕。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/subtotal&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;?attr/materialButtonOutlinedStyle&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginEnd</span>=<span class="string">&quot;@dimen/side_margin&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/cancel&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toStartOf</span>=<span class="string">&quot;@id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/next_button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>請一併更新「Next」按鈕的 start constraint。接著，預覽畫面中會顯示「Cancel」按鈕。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/cancel_button&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>對 <code>fragment_summary.xml</code> 檔案套用類似的變更，但這個 fragment 的 layout 稍有不同。您將在 parent vertical <code>LinearLayout</code> 中的「Send」按鈕下方新增「Cancel」按鈕，並在兩個按鈕之間保留一定間距。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/741c0f034397795c_1920.png?hl=zh-tw" width="40%">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/send_button&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">style</span>=<span class="string">&quot;?attr/materialButtonOutlinedStyle&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;@dimen/margin_between_elements&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/cancel&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>執行並測試 app。現在，<code>FlavorFragment</code>、<code>PickupFragment</code> 和 <code>SummaryFragment</code> 的 layouts 中應該會顯示「Cancel」按鈕。不過，輕觸該按鈕目前並不會執行任何動作。請在下一個步驟中為這些按鈕設定 click listeners。</li>
</ol>
<h5 id="新增「Cancel」按鈕的-click-listener"><a href="#新增「Cancel」按鈕的-click-listener" class="headerlink" title="新增「Cancel」按鈕的 click listener"></a>新增「Cancel」按鈕的 click listener</h5><p>在每個 fragment class (StartFragment 除外) 中新增 Helper 方法，以便在使用者點選「Cancel」按鈕時進行處理。</p>
<ol>
<li>將這個 <code>cancelOrder()</code> 方法新增至 <code>FlavorFragment</code>。如果使用者在看到 flavor 選項時決定取消訂單，請呼叫 <code>sharedViewModel.resetOrder()</code> 清除 view model。接著，使用 ID 為 <code>R.id.action_flavorFragment_to_startFragment</code> 的 navigation action 返回 <code>StartFragment</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sharedViewModel.resetOrder()</span><br><span class="line">    findNavController().navigate(R.id.action_flavorFragment_to_startFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果您看到與 action resource ID 相關的錯誤，可能需要返回 <code>nav_graph.xml</code> 檔案，確認您的 navigation actions 也命名為相同名稱 (<code>action_flavorFragment_to_startFragment</code>)。</li>
</ul>
<ol start="2">
<li>如要在 <code>fragment_flavor.xml</code> layout 的「Cancel」按鈕上設定 click listener，請使用 listener binding。點選此按鈕可叫用您剛才在 <code>FragmentFlavor</code> class 中建立的 <code>cancelOrder()</code> 方法。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; flavorFragment.cancelOrder()&#125;&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>針對 <code>PickupFragment</code> 重複執行相同的程序(process)。在 fragment class 中新增 <code>cancelOrder()</code> 方法，藉此重設訂單，並從 <code>PickupFragment</code> 瀏覽至 <code>StartFragment</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sharedViewModel.resetOrder()</span><br><span class="line">    findNavController().navigate(R.id.action_pickupFragment_to_startFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>fragment_pickup.xml</code> 中，於「Cancel」按鈕上設定 click listener，以便在使用者點選時呼叫 <code>cancelOrder()</code> 方法。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; pickupFragment.cancelOrder()&#125;&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>為 <code>SummaryFragment</code> 中的「Cancel」按鈕新增類似的程式碼，讓使用者可以返回 <code>StartFragment</code>。如果 <code>androidx.navigation.fragment.findNavController</code> 未自動 import，您可能需要自行 import。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">cancelOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    sharedViewModel.resetOrder()</span><br><span class="line">    findNavController().navigate(R.id.action_summaryFragment_to_startFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>fragment_summary.xml</code> 中按下「Cancel」按鈕時，將隨即呼叫 <code>SummaryFragment</code> 的 <code>cancelOrder()</code> 方法。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cancel_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; summaryFragment.cancelOrder()&#125;&quot;</span> <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行並測試 app，確認您剛才新增至每個 fragment 的邏輯。建立杯子蛋糕訂單時，輕觸 <code>FlavorFragment</code>、<code>PickupFragment</code> 或 <code>SummaryFragment</code> 上的「Cancel」按鈕，即可返回 <code>StartFragment</code>。繼續建立新訂單時，請注意系統已清除先前訂單中的資訊。</li>
</ol>
<p>成效看起來不錯，但返回 <code>StartFragment</code> 後，向後 navigating 實際上有錯誤。請按照下列步驟重現錯誤。</p>
<ol start="8">
<li><p>按照訂購流程建立新的杯子蛋糕訂單，直到到達 summary 畫面為止。舉例來說，您可以訂購 12 個巧克力口味的杯子蛋糕，並選擇未來的取貨日期。</p>
</li>
<li><p>接著，輕觸「Cancel」。您應該會返回 <code>StartFragment</code>。</p>
</li>
<li><p>這看起來沒問題，但如果您輕觸系統自帶的「Back」按鈕，就會回到訂單 summary 畫面，其中將顯示訂單摘要：訂購 0 個杯子蛋糕，未選擇任何口味。這是錯誤現象，不應向使用者顯示。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/1a9024cd58a0e643_1920.png?hl=zh-tw" width="30%">

<p>使用者可能不想回到訂購流程。此外，view model 中的所有訂單資料均已清除，因此這項資訊不實用。反之，輕觸 <code>StartFragment</code> 中的「Back」按鈕，應離開 Cupcake app。</p>
<p>以下我們將介紹  back stack 目前的情況，以及修正 bug 的方法。透過訂單 summary 畫面建立訂單時，每個目的地(destination)都會推送至 back stack 上。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/fc88100cdf1bdd1_1920.png?hl=zh-tw" width="50%">

<p>您在 <code>SummaryFragment</code> 取消了訂單。當您使用 <code>SummaryFragment</code> 至 <code>StartFragment</code> 的 action 進行 navigated 時，Android 會新增另一個 <code>StartFragment</code> instance，做為 back stack 上的新目的地(destination)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/5616cb0028b63602_1920.png" width="50%">

<p>因此，當您輕觸 <code>StartFragment</code> 中的「Back」按鈕時，app 最終會重新顯示 <code>SummaryFragment</code> (包含空白訂單資訊)。</p>
<p>如要修正這個 navigation bug，請瞭解 Navigation component 如何讓使用者在使用 action 進行 navigating 時，從返 back stack 中移除其他目的地(destination)。</p>
<h5 id="從-back-stack-中移除其他目的地"><a href="#從-back-stack-中移除其他目的地" class="headerlink" title="從 back stack 中移除其他目的地"></a>從 back stack 中移除其他目的地</h5><h6 id="★Navigation-action：popUpTo-屬性"><a href="#★Navigation-action：popUpTo-屬性" class="headerlink" title="★Navigation action：popUpTo 屬性"></a>★Navigation action：popUpTo 屬性</h6><p><u>在 <b>navigation graph</b> 的 <b>navigation action</b> 中加入 <code>app:popUpTo</code> 屬性後，即可從 <b>back stack</b> 中移除多個目的地，直到到達指定目的地為止</u>。如果指定 <code>app:popUpTo=&quot;@id/startFragment&quot;</code>，則會移除 back stack 中的目的地，直到到達 <code>StartFragment</code> 為止，此片段會保留在 stack 中。</p>
<p>將此變更新增至程式碼並執行 app 時，您將會發現只要取消訂單，就會回到 <code>StartFragment</code>。但這次，當您輕觸 <code>StartFragment</code> 的「Back」按鈕時，會再次看到 <code>StartFragment</code> (而不是結束 app)。這也不是預期出現的行為。如先前所述，由於您正在前往 <code>StartFragment</code>，Android 實際上會在 back stack 中新增 <code>StartFragment</code> 做為新目的地，因此現在 back stack 會有 2 個 <code>StartFragment</code> instances。因此，您必須輕觸「Back」按鈕兩次才能結束 app。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/dd0fedc6e231e595_1920.png?hl=zh-tw" width="50%">

<h6 id="★Navigation-action：popUpToInclusive-屬性"><a href="#★Navigation-action：popUpToInclusive-屬性" class="headerlink" title="★Navigation action：popUpToInclusive 屬性"></a>★Navigation action：popUpToInclusive 屬性</h6><p>為修正這個新 bug，請要求<u>將所有目的地從 back stack 中移除，直到 (且包含) <code>StartFragment</code> 為止</u>。請在適當的 <strong>navigation actions</strong> 指定 <code>app:popUpTo=&quot;@id/startFragment&quot;</code> 和 <code>app:popUpToInclusive=&quot;true&quot;</code>，以達到此目標。如此一來，back stack 中就只會有一個新的 <code>StartFragment</code> instance。接著輕觸 <code>StartFragment</code> 中的「Back」按鈕，結束 app。我們現在要進行這項變更。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/cf0e80b4907d80dd_1920.png?hl=zh-tw" width="50%">

<h6 id="修改-navigation-action"><a href="#修改-navigation-action" class="headerlink" title="修改 navigation action"></a>修改 navigation action</h6><ol>
<li><p>開啟「res」&gt;「navigation」&gt;「nav_graph.xml」檔案，前往 Navigation Editor。</p>
</li>
<li><p>選取從 <code>summaryFragment</code> 至 <code>startFragment</code> 的 action，使其以藍色 highlighted。</p>
</li>
<li><p>展開右側的「Attributes」(如果尚未開啟)。在可修改的 attributes list 中尋找「Pop Behavior」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/8c87589f9cc4d176_1920.png?hl=zh-tw">

<ol start="4">
<li>透過下拉式選單(dropdown)的選項，將 <code>popUpTo</code> 設為 <code>startFragment</code>。這表示 back stack 中的所有目的地皆會移除 (從 stack 頂端開始往下移除)，直到 <code>startFragment</code> 為止。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/a9a17493ed6bc27f_1920.png?hl=zh-tw" width="40%">

<ol start="5">
<li>接著按一下「popUpToInclusive」checkbox，直到畫面上顯示勾號和「true」label 為止。這表示您想要移除目的地，直到 (且包含) back stack 中已經存在的 <code>startFragment</code> instance 為止。透過此方式，back stack 中就不會出現兩個 <code>startFragment</code> instance。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/4a403838a62ff487_1920.png?hl=zh-tw" width="40%">

<ol start="6">
<li>針對將 <code>pickupFragment</code> 連結到 <code>startFragment</code> 的 action 重複以上變更。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/4a403838a62ff487_1920.png?hl=zh-tw" width="40%">

<ol start="7">
<li><p>針對將 <code>flavorFragment</code> 連結到 <code>startFragment</code> 的 action 重複以上操作。</p>
</li>
<li><p>完成後，請查看 navigation graph 檔案的「Code」view，確認 app 變更內容正確無誤。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_graph&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/startFragment&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/flavorFragment&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_flavorFragment_to_startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpTo</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpToInclusive</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/pickupFragment&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_pickupFragment_to_startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpTo</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpToInclusive</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/summaryFragment&quot;</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_summaryFragment_to_startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:destination</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpTo</span>=<span class="string">&quot;@id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:popUpToInclusive</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，這 3 項 actions (<code>action_flavorFragment_to_startFragment</code>、<code>action_pickupFragment_to_startFragment</code> 和 <code>action_summaryFragment_to_startFragment</code>) 應新增 <code>app:popUpTo=&quot;@id/startFragment&quot;</code> 和 <code>app:popUpToInclusive=&quot;true&quot;</code> 屬性。</li>
</ul>
<ol start="9">
<li>接著執行 app。請按照訂購流程中的步驟操作，然後輕觸「Cancel」。返回 <code>StartFragment</code> 時，請輕觸「Back」按鈕 (僅限一次！) 退出 app。</li>
</ol>
<p>簡而言之，當您取消訂單並返回 app 的第一個畫面時， back stack 中的所有 fragment 目的地都會移除，包括第一個出現的 <code>StartFragment</code>。完成 navigation action 後，<code>StartFragment</code> 會做為新目的地新增至 back stack。輕觸該處的「Back」後，會從 stack 移除 <code>StartFragment</code>，使 back stack 中完全沒有 fragment。Android 即完成 activity，且使用者離開 app。</p>
<p>app 應如下所示：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/2e0599d9b55401f1_1920.png?hl=zh-tw">

<hr>
<h3 id="送出訂單"><a href="#送出訂單" class="headerlink" title="送出訂單"></a>送出訂單</h3><p>到目前為止，app 看起來很棒！但還剩下一部分。當您輕觸 <code>SummaryFragment</code> 上的「send order」按鈕時，仍會彈出 <code>Toast</code> 訊息。</p>
<p>如果訂單能夠自 app 發出，即可打造更加實用的體驗。善用在先前程式碼研究室中學到的知識，運用 implicit intent 將 app 資訊分享至其他 app。如此一來，使用者就可以在裝置上與 email app 分享杯子蛋糕訂單資訊，讓系統將訂單透過 email 傳送到杯子蛋糕店。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/170d76b64ce78f56_1920.png?hl=zh-tw">

<p>如要實作這項功能，請參閱上方的螢幕截圖，瞭解 email 主旨和 email 內文的結構。</p>
<p>您將會使用 <code>strings.xml</code> 檔案中已包含的字串。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;new_cupcake_order&quot;</span>&gt;</span>New Cupcake Order<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;order_details&quot;</span>&gt;</span>Quantity: %1$s cupcakes \n Flavor: %2$s \nPickup date: %3$s \n Total: %4$s \n\n Thank you!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>order_details</code> 是一個字串資源，其中包含 4 種不同的格式參數(format arguments)，此為<u>杯子蛋糕實際數量(quantity)</u>、<u>所需口味(flavor)</u>、<u>所需取貨日期(pickup date)</u>和<u>總金額(total price)</u>的預留位置。參數編號為 1 到 4，語法為 <code>%1</code> 到 <code>%4</code>。參數類型也已指定 (<code>$s</code> 代表字串預期在此處)。</p>
<p>在 Kotlin 程式碼中，您可以在 <code>R.string.order_details</code> 上呼叫 <code>getString()</code>，後接 4 個參數 (順序很重要！)。舉例來說，呼叫 <code>getString(R.string.order_details, &quot;12&quot;, &quot;Chocolate&quot;, &quot;Sat Dec 12&quot;, &quot;$24.00&quot;)</code> 會建立下列字串，而這正是您所需的 email 內文。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Quantity: 12 cupcakes</span><br><span class="line">Flavor: Chocolate</span><br><span class="line">Pickup date: Sat Dec 12</span><br><span class="line">Total: $24.00</span><br><span class="line"></span><br><span class="line">Thank you!</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong>您可能會憶起已經學習過含有<b>格式參數(format arguments)</b>的字串資源。舉例來說，您在 app 中使用的 subtotal 和 total price 會宣告為：</p><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;subtotal_price&quot;</span>&gt;</span>Subtotal %s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;total_price&quot;</span>&gt;</span>Total %s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中 <b>%s</b> 是經過格式化(formatted)的 price 字串預留位置。</p>
          </div>

<ol>
<li>在 <code>SummaryFragment.kt</code> 中修改 <code>sendOrder()</code> 方法。移除現有的 <code>Toast</code> 訊息。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>sendOrder()</code> 方法中，建構 order summary 文字。從 shared view model 取得訂單數量、口味、日期和價格，建立格式化的 <code>order_details</code> 字串。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> orderSummary = getString(</span><br><span class="line">    R.string.order_details,</span><br><span class="line">    sharedViewModel.quantity.value.toString(),</span><br><span class="line">    sharedViewModel.flavor.value.toString(),</span><br><span class="line">    sharedViewModel.date.value.toString(),</span><br><span class="line">    sharedViewModel.price.value.toString()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>sendOrder()</code> 方法中，建立將訂單分享至其他 app 的 implicit intent。請參閱<a href="https://developer.android.com/guide/components/intents-common#Email">說明文件</a>，瞭解如何建立 email intent。請為 intent action 指定 <code>Intent.ACTION_SEND</code>、將 type 設為 <code>&quot;text/plain&quot;</code>，並加入 email 主旨 (<code>Intent.EXTRA_SUBJECT</code>) 和 email 內文 (<code>Intent.EXTRA_TEXT</code>) 的 intent extras。視需要 import <code>android.content.Intent</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_SEND)</span><br><span class="line">    .setType(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">    .putExtra(Intent.EXTRA_SUBJECT, getString(R.string.new_cupcake_order))</span><br><span class="line">    .putExtra(Intent.EXTRA_TEXT, orderSummary)</span><br></pre></td></tr></table></figure>
<ul>
<li>另提供額外 tip，如果您將此 app 調整為個人用途，可將 email 收件者預先填入為杯子蛋糕店的 email 地址。在 intent 中，您將以 intent extra <code>Intent.EXTRA_EMAIL</code> 指定 email 收件者。</li>
</ul>
<ol start="4">
<li>由於此為 implicit intent，您不必事先得知哪個特定 component 或 app 會處理這項 intent。使用者會決定要使用哪一款 app 來達到 intent。但是，在使用這項 intent 啟動(launching) activity 前，請先檢查是否有 app 能處理此 intent。如果沒有能處理此 intent 的 app，這項檢查可防止 Cupcake app 當機，讓程式碼更加安全。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (activity?.packageManager?.resolveActivity(intent, <span class="number">0</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">    startActivity(intent)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>透過存取 <code>PackageManager</code> 執行這項檢查，其具備裝置上所安裝 app packages 的相關資訊。只要 activity 和 <code>packageManager</code> 並非空值(null)，就可以透過 fragment 的 <code>activity</code> 存取 <code>PackageManager</code>。使用您建立的 intent 呼叫 <code>PackageManager</code> 的 <code>resolveActivity()</code> 方法。如果結果不是空值(null)，可以放心使用 intent 呼叫 <code>startActivity()</code>。</p>
<ol start="5">
<li>執行 app 以測試程式碼。建立杯子蛋糕訂單，然後輕觸「Send Order to Another App」。畫面上顯示分享 dialog pops up 時，即可選取 Gmail app。如有需要，亦可選擇其他 app。如果您選擇 Gmail app，可能需要在裝置上設定帳戶 (如果尚未設定，例如您正在使用 emulator)。如果 email 內文中未顯示最新的杯子蛋糕訂單，您可能需要先捨棄目前的 email 草稿。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/170d76b64ce78f56_1920.png?hl=zh-tw">

<p>在不同情況下進行測試時，如果只有 1 個杯子蛋糕，可能會發現錯誤。order summary 顯示「1 cupcakes」，但是這種說法在英文中屬於文法錯誤。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-navigation-backstack/img/ef046a100381bb07_1920.png?hl=zh-tw" width="50%">

<p>反之，應顯示「1 cupcake」(非複數型態)。如要根據數量值選擇單數或複數型態的字詞，可以在 Android 中使用 <a href="https://developer.android.com/guide/topics/resources/string-resource#Plurals">quantity strings</a>。只要宣告 <code>plurals</code> resource，即可根據數量指定不同的 string resources，例如單數或複數型態。</p>
<ol start="6">
<li>在 <code>strings.xml</code> 檔案中新增 cupcakes 複數資源(plurals resource)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plurals</span> <span class="attr">name</span>=<span class="string">&quot;cupcakes&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">&quot;one&quot;</span>&gt;</span>%d cupcake<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">quantity</span>=<span class="string">&quot;other&quot;</span>&gt;</span>%d cupcakes<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plurals</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在單數(singular)情況 (<code>quantity=&quot;one&quot;</code>) 下，會使用單數字串(singular string)。在所有其他情況下 (<code>quantity=&quot;other&quot;</code>)，將會使用複數字串(plural string)。請注意，<code>%d</code> 為整數參數，而非 <code>%s</code> 的字串參數，當您格式化字串時，將會傳入此參數。</li>
</ul>
<p>在 Kotlin 程式碼中呼叫：</p>
<ul>
<li><code>getQuantityString(R.plurals.cupcakes, 1, 1)</code> 會傳回 <code>1 cupcake</code> 字串</li>
<li><code>getQuantityString(R.plurals.cupcakes, 6, 6)</code> 會傳回 6 <code>cupcakes</code> 字串</li>
<li><code>getQuantityString(R.plurals.cupcakes, 0, 0)</code> 會傳回 0 <code>cupcakes</code> 字串</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong>呼叫 <b>getQuantityString()</b> 時，您必須傳入數量兩次，因為第一個數量參數用於選取正確的複數字串(plural string)。第二個數量參數則用於實際字串資源的 <b>%d</b> 預留位置。</p>
          </div>

<ol start="7">
<li>前往 Kotlin 程式碼前，請更新 <code>strings.xml</code> 中的 <code>order_details</code> 字串資源，使杯子蛋糕的複數(plural)版本不再以 hardcoded 的方式寫入。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;order_details&quot;</span>&gt;</span>Quantity: %1$s \n Flavor: %2$s \nPickup date: %3$s \n</span><br><span class="line">        Total: %4$s \n\n Thank you!<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>SummaryFragment</code> class 中，更新 <code>sendOrder()</code> 方法以使用新的數量字串。最簡單的方式是先從 view model 找出數量，然後儲存在變數中。由於 view model 中的 <code>quantity</code> 屬於 <code>LiveData&lt;Int&gt;</code> 類型，因此 <code>sharedViewModel.quantity.value</code> 可能為空值。如果為空值，請使用 <code>0</code> 做為 <code>numberOfCupcakes</code> 的預設值。</li>
</ol>
<p>請將此新增為 <code>sendOrder()</code> 方法中的第一行程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numberOfCupcakes = sharedViewModel.quantity.value ?: <span class="number">0</span></span><br></pre></td></tr></table></figure>
<ul>
<li>elvis 運算子 (<code>?:</code>) 表示左側的運算式並非空值時，請使用該運算式。如果左側的運算式為空值，請使用 elvis 運算子右側的運算式 (本例中為 <code>0</code>)。</li>
</ul>
<ol start="9">
<li>接著和先前一樣，將 <code>order_details</code> 字串格式化。請勿以 <code>numberOfCupcakes</code> 做為數量參數直接傳入，而是使用 <code>resources.getQuantityString(R.plurals.cupcakes, numberOfCupcakes, numberOfCupcakes)</code> 建立格式化的杯子蛋糕字串。</li>
</ol>
<p>完整的 <code>sendOrder()</code> 方法如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">sendOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numberOfCupcakes = sharedViewModel.quantity.value ?: <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> orderSummary = getString(</span><br><span class="line">        R.string.order_details,</span><br><span class="line">        resources.getQuantityString(R.plurals.cupcakes, numberOfCupcakes, numberOfCupcakes),</span><br><span class="line">        sharedViewModel.flavor.value.toString(),</span><br><span class="line">        sharedViewModel.date.value.toString(),</span><br><span class="line">        sharedViewModel.price.value.toString()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> intent = Intent(Intent.ACTION_SEND)</span><br><span class="line">        .setType(<span class="string">&quot;text/plain&quot;</span>)</span><br><span class="line">        .putExtra(Intent.EXTRA_SUBJECT, getString(R.string.new_cupcake_order))</span><br><span class="line">        .putExtra(Intent.EXTRA_TEXT, orderSummary)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activity?.packageManager?.resolveActivity(intent, <span class="number">0</span>) != <span class="literal">null</span>) &#123;</span><br><span class="line">        startActivity(intent)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>執行並測試程式碼。檢查 email 內文中的訂單摘要是否顯示 1 個杯子蛋糕、6 個杯子蛋糕或 12 個杯子蛋糕。</li>
</ol>
<p>透過此方法，您已完成 Cupcake app 的所有功能！恭喜！！這是一款極具挑戰性的 app，而您在成為 Android 開發人員的旅程中，獲得大幅的進展！您已成功整合目前為止學到的所有概念，同時在過程中整理出一些新的問題解決方式。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Navigation</tag>
        <tag>Back Stack</tag>
        <tag>Jetpack Navigation Component</tag>
        <tag>Navigation Graph</tag>
        <tag>Navigation Action</tag>
        <tag>Implicit Intent</tag>
        <tag>plurals</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(28)-在各Fragment之間共用ViewModel</title>
    <url>/2023/11/11/Android%E7%AD%86%E8%A8%98-28-%E5%9C%A8%E5%90%84Fragment%E4%B9%8B%E9%96%93%E5%85%B1%E7%94%A8ViewModel/</url>
    <content><![CDATA[<blockquote>
<p>瞭解如何使用共用 <code>ViewModel</code> 在相同 activity 的 fragment 之間共用資料，還有 <code>LiveData</code> 轉換等新概念。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何在更進階用途中導入建議的應用程式架構做法</li>
<li>如何在 activity 的各個 fragment 中使用共用的 <code>ViewModel</code></li>
<li>如何套用 <code>LiveData</code> 轉換</li>
</ul>
<p><strong>建構項目</strong><br>此杯子蛋糕應用程式會顯示杯子蛋糕的訂單流程，讓使用者選擇杯子蛋糕口味、數量和取貨日期。</p>
<span id="more"></span>

<hr>
<h3 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h3><h4 id="杯子蛋糕應用程式總覽"><a href="#杯子蛋糕應用程式總覽" class="headerlink" title="杯子蛋糕應用程式總覽"></a>杯子蛋糕應用程式總覽</h4><p>杯子蛋糕應用程式示範如何設計及導入線上訂購應用程式。本課程結束時，您將完成有下列畫面的杯子蛋糕應用程式。使用者可以選擇杯子蛋糕訂單的數量、口味和其他選項。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/732881cfc463695d_1920.png?hl=zh-tw">

<h4 id="下載本程式碼研究室的範例程式碼"><a href="#下載本程式碼研究室的範例程式碼" class="headerlink" title="下載本程式碼研究室的範例程式碼"></a>下載本程式碼研究室的範例程式碼</h4><p>本程式碼研究室提供範例程式碼，讓您以本程式碼研究室所教授的功能擴充應用程式。範例程式碼含有您先前在程式碼研究室中熟悉的程式碼。</p>
<p>請注意，如果您從 GitHub 下載範例程式碼，專案的資料夾名稱會是 <code>android-basics-kotlin-cupcake-app-starter</code>。在 Android Studio 中開啟專案時，請選取此資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-cupcake-app/tree/starter">https://github.com/google-developer-training/android-basics-kotlin-cupcake-app/tree/starter</a></p>
          </div>

<h4 id="範例程式碼逐步操作說明"><a href="#範例程式碼逐步操作說明" class="headerlink" title="範例程式碼逐步操作說明"></a>範例程式碼逐步操作說明</h4><ol>
<li>在 Android Studio 中開啟已下載的專案。專案的資料夾名稱為 <code>android-basics-kotlin-cupcake-app-starter</code>。然後執行應用程式。</li>
<li>瀏覽檔案以瞭解範例程式碼。針對 layout 檔案，您可以使用右上角的「Split」選項，同時查看 layout 和 XML 的預覽畫面。</li>
<li>編譯並執行應用程式時，您會發現應用程式並不完整。除了顯示 Toast 訊息外，這些按鈕的作用不大，而且無法導覽至其他 fragment。</li>
</ol>
<p>以下說明專案裡的重要檔案。</p>
<p><strong>MainActivity：</strong><br><code>MainActivity</code> 和預設產生的程式碼相似，用於將 activity 的內容檢視設定為 <code>activity_main.xml</code>。此程式碼使用參數化建構函式 <code>AppCompatActivity(@LayoutRes int contentLayoutId)</code>，其 layout 會加載為 <code>super.onCreate(savedInstanceState)</code> 的一部分。</p>
<p><code>MainActivity</code> 類別的程式碼</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(R.layout.activity_main)</span><br></pre></td></tr></table></figure>

<p>與使用預設 <code>AppCompatActivity</code> 建構函式的下列程式碼相同：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">       <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">       setContentView(R.layout.activity_main)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>Layout (res&#x2F;layout 資料夾)：</strong><br><code>layout</code> 資源資料夾含有 activity 和 fragment layout 檔案。這些是較簡單的 layout 檔案，而在先前的程式碼研究室中已熟悉 XML。</p>
<ul>
<li><code>fragment_start.xml</code> 是應用程式中顯示的第一個畫面。這項產品提供杯子蛋糕圖片和三個按鈕，可供選擇想要訂購的杯子數量：一個杯子蛋糕、六個杯子蛋糕和十二個杯子蛋糕。</li>
<li><code>fragment_flavor.xml</code> 會顯示以圓形按鈕選項呈現的杯子蛋糕口味清單，以及「Next」按鈕。</li>
<li><code>fragment_pickup.xml</code> 提供選擇取貨日的選項，按一下「Next」按鈕即可前往摘要畫面。</li>
<li><code>fragment_summary.xml</code> 會顯示訂單詳細資料摘要，例如數量、口味，以及可將訂單傳送至其他應用程式的按鈕。</li>
</ul>
<p><strong>Fragment 類別：</strong></p>
<ul>
<li><code>StartFragment.kt</code> 是應用程式中顯示的第一個畫面。此類別含有三個按鈕的 view binding 程式碼和 click handler。</li>
<li><code>FlavorFragment.kt</code>、<code>PickupFragment.kt</code> 和 <code>SummaryFragment.kt</code> 類別主要包含樣板程式碼，以及「Next」或「Send Order to Another App」按鈕的 click handler，且會顯示 toast 訊息。</li>
</ul>
<hr>
<h3 id="完成導覽圖-Navigation-Graph"><a href="#完成導覽圖-Navigation-Graph" class="headerlink" title="完成導覽圖(Navigation Graph)"></a>完成導覽圖(Navigation Graph)</h3><p>在這項工作中，我們將連結杯子蛋糕應用程式的畫面，並在應用程式中導入適當的 navigation 功能。<br>您記得必須使用 Navigation component 嗎？請按照<a href="https://developer.android.com/guide/navigation/navigation-getting-started?hl=zh-tw">這份指南</a>中的複習，瞭解如何設定專案和應用程式，目標是：</p>
<ul>
<li>加入 <a href="https://developer.android.com/jetpack/androidx/releases/navigation?hl=zh-tw">Jetpack Navigation library</a></li>
<li>在 activity 中新增 <code>NavHost</code></li>
<li>建立 navigation graph</li>
<li>在 navigation graph 中新增 fragment 目的地</li>
</ul>
<h4 id="在-navigation-graph-中連接目的地-destinations"><a href="#在-navigation-graph-中連接目的地-destinations" class="headerlink" title="在 navigation graph 中連接目的地(destinations)"></a>在 navigation graph 中連接目的地(destinations)</h4><ol>
<li><p>在 Android Studio 的「Project」視窗中，開啟 <strong>res &gt; navigation &gt; nav_graph.xml</strong> 檔案。如果尚未選取「Design」分頁標籤，請予以選取。</p>
</li>
<li><p>選取後即可開啟「Navigation Editor」，以視覺化方式呈現應用程式中的 navigation graph。您應該會看到應用程式中已有四個 fragments。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/fdce89b318218ea6_1920.png?hl=zh-tw">

<div class="note no-icon success">
            <p><strong>注意：</strong>如果<b>目的(destination) fragments</b> 在 Android Studio 中以不同方式排列，請點擊並拖曳<b>目的地(destinations)</b>，以類似上述螢幕截圖的方式重新排列，您在程式碼研究室中則能更輕鬆設定 <b>navigation 動作(actions)</b>。</p>
          </div>

<ol start="3">
<li><p>連結導覽圖中的 fragment 目的地。建立從 <code>startFragment</code> 到 <code>flavorFragment</code> 的動作、從 <code>flavorFragment</code> 到 <code>pickupFragment</code> 的連接，以及從 <code>pickupFragment</code> 到 <code>summaryFragment</code> 的連接。如需更詳細的操作說明，請按照下列後續步驟操作。</p>
</li>
<li><p>將滑鼠游標懸停在 <code>startFragment</code> 上，直到 fragment 周圍顯示灰色框線，且 fragment 右側邊緣的中心顯示灰色圓圈圖示。按一下圓圈並拖曳至 <code>flavorFragment</code>，然後放開滑鼠。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/d014c1b710c1088d_1920.png?hl=zh-tw" width="60%">

<ol start="5">
<li>兩個 fragment 之間的箭頭表示已成功連接，因此您將可以從 <code>startFragment</code> 前往 <code>flavorFragment</code>。這就是「Navigation」動作，您可以在先前的程式碼研究室中學到。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/65c7d993b98c9dea_1920.png?hl=zh-tw" width="60%">

<ol start="6">
<li>同樣地，將新增從 <code>flavorFragment</code> 到 <code>pickupFragment</code>，以及從 <code>pickupFragment</code> 到 <code>summaryFragment</code> 的導覽動作(navigation actions)。建立 navigation actions 後，完成的 navigation graph 看起來會如下所示。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/724eb8992a1a9381_1920.png?hl=zh-tw">

<ol start="7">
<li>您建立的三個新動作(actions)應該也會顯示在「Component Tree」窗格中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/e4ee54469f5ff1a4_1920.png?hl=zh-tw" width="60%">

<ol start="8">
<li>定義 navigation graph 時，建議您也指定開始目的地(start destination)。目前您可以看到 startFragment 旁有一個小型房屋圖示。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/739d4ddac561c478_1920.png?hl=zh-tw" width="30%">

<ul>
<li>這表示 <code>startFragment</code> 將是第一個顯示在 <code>NavHost</code> 中的 fragment。設定為應用程式所需的預期行為。日後只要在任一 fragment 上按一下滑鼠右鍵，然後選取「Set as Start Destination」選單選項，即可隨時變更起點的位置。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/bf3cfa7841476892_1920.png?hl=zh-tw" width="70%">

<h4 id="從-start-fragment-前往-flavor-fragment"><a href="#從-start-fragment-前往-flavor-fragment" class="headerlink" title="從 start fragment 前往 flavor fragment"></a>從 start fragment 前往 flavor fragment</h4><p>接下來，您必須新增程式碼，目的是在第一個 fragment 中輕觸按鈕時從 <code>startFragment</code> 前往 <code>flavorFragment</code>，而非顯示 <code>Toast</code> 訊息。以下是 start fragment layout 的參考資料。您在之後的任務中，必須將杯子蛋糕的數量(quantity)傳遞至 flavor fragment。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/867d8e4c72078f76_1920.png?hl=zh-tw" width="30%">

<ol>
<li><p>在「Project」視窗中，依序開啟 <strong>app &gt; java &gt; com.example.cupcake &gt; StartFragment.kt</strong> 檔案。</p>
</li>
<li><p>在 <code>onViewCreated()</code> 方法中，請留意， click listeners 設定在三個按鈕上。輕觸各個按鈕時，系統會呼叫 <code>orderCupcake()</code> 方法，並以杯子蛋糕數量 (1、6 或 12 個杯子蛋糕) 做為參數。</p>
</li>
</ol>
<p>參考 code：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">orderOneCupcake.setOnClickListener &#123; orderCupcake(<span class="number">1</span>) &#125;</span><br><span class="line">orderSixCupcakes.setOnClickListener &#123; orderCupcake(<span class="number">6</span>) &#125;</span><br><span class="line">orderTwelveCupcakes.setOnClickListener &#123; orderCupcake(<span class="number">12</span>) &#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>orderCupcake()</code> 方法中，將顯示 toast 訊息的程式碼替換成前往  flavor fragment 的程式碼。使用 <code>findNavController()</code> 方法取得 <code>NavController</code>，並呼叫此方法的 <code>navigate()</code>，並在傳入動作 ID <code>R.id.action_startFragment_to_flavorFragment</code>。請確認這項動作 ID 與您在 <code>nav_graph.xml</code> 中宣告的動作相符。</li>
</ol>
<p>將</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderCupcake</span><span class="params">(quantity: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    Toast.makeText(activity, <span class="string">&quot;Ordered <span class="variable">$quantity</span> cupcake(s)&quot;</span>, Toast.LENGTH_SHORT).show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取代為</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderCupcake</span><span class="params">(quantity: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">   findNavController().navigate(R.id.action_startFragment_to_flavorFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增「Import」<code>import</code> <code>androidx.navigation.fragment.findNavController</code>，或從 Android Studio 提供的選項中選擇。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/2a087f53a77765a6_1920.png?hl=zh-tw">

<h4 id="在-flavor-和-pickup-fragments-中新增-Navigation"><a href="#在-flavor-和-pickup-fragments-中新增-Navigation" class="headerlink" title="在 flavor 和 pickup fragments 中新增 Navigation"></a>在 flavor 和 pickup fragments 中新增 Navigation</h4><p>這項工作與上一個工作類似，您要在其他 fragment (<strong>flavor</strong> 和 <strong>pickup fragment</strong>) 中新增 <strong>navigation</strong>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/3b351067bf4926b7_1920.png?hl=zh-tw">

<ol>
<li><p>開啟 <strong>app &gt; java &gt; com.example.cupcake &gt; FlavorFragment.kt</strong>。請注意，「Next」按鈕 click listener 內呼叫的方法為 <code>goToNextScreen()</code> 方法。</p>
</li>
<li><p>在 <strong>FlavorFragment.kt</strong> 的 <code>goToNextScreen()</code> 方法中，取代顯示 Toast 訊息的程式碼，前往 pickup fragment。使用 action ID <code>R.id.action_flavorFragment_to_pickupFragment</code> 並確認此 ID 與 <code>nav_graph.xml</code> 中宣告的 action 相符。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">goToNextScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    findNavController().navigate(R.id.action_flavorFragment_to_pickupFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>記得 import <code>androidx.navigation.fragment.findNavController</code>。</li>
</ul>
<ol start="3">
<li>同樣地，在 <strong>PickupFragment.kt</strong> 的 <code>goToNextScreen()</code> 方法中，取代現有的程式碼以前往 summary fragment。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">goToNextScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">    findNavController().navigate(R.id.action_pickupFragment_to_summaryFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Import <code>androidx.navigation.fragment.findNavController</code>。</li>
</ul>
<ol start="4">
<li>執行應用程式。確認按鈕可供切換畫面瀏覽。每個 fragment 顯示的資訊可能不完整，但請放心，您會在後續步驟中填入正確的 fragment。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/96b33bf7a5bd8050_1920.png">

<h4 id="更新-app-bar-中的標題"><a href="#更新-app-bar-中的標題" class="headerlink" title="更新 app bar 中的標題"></a>更新 app bar 中的標題</h4><p>瀏覽應用程式時，app bar 中的標題永遠顯示為杯子蛋糕。<br>根據目前 fragment 的功能提供更相關的標題，有助於改善使用者體驗。<br>使用 <code>NavController</code> 變更 app bar (也稱為 action bar) 中各 fragment 的標題，並使用「Up」 (←) 按鈕。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/b7657cdc50cfeab0_1920.png?hl=zh-tw">

<ol>
<li><p>在 <strong>MainActivity.kt</strong> 中覆寫 <code>onCreate()</code> 方法來設定 navigation controller。從 <code>NavHostFragment</code> 取得 <code>NavController</code> 的 instance。</p>
</li>
<li><p>呼叫 <code>setupActionBarWithNavController(navController)</code> 以傳入 <code>NavController</code> 的 instance。操作方式如下：在 app bar 中，根據目的地(destination)的 label 顯示標題；即使沒有頂層(top-level)目的地，也會顯示「Up」 按鈕。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>(R.layout.activity_main) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> navHostFragment = supportFragmentManager</span><br><span class="line">                .findFragmentById(R.id.nav_host_fragment) <span class="keyword">as</span> NavHostFragment</span><br><span class="line">        <span class="keyword">val</span> navController = navHostFragment.navController</span><br><span class="line"></span><br><span class="line">        setupActionBarWithNavController(navController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 Android Studio 顯示提示時新增必要的 import 項目。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.fragment.NavHostFragment</span><br><span class="line"><span class="keyword">import</span> androidx.navigation.ui.setupActionBarWithNavController</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>設定每個 fragment 的 app bar 標題。開啟 <code>navigation/nav_graph.xml</code> 並切換至「Code」分頁標籤。</p>
</li>
<li><p>在 <code>nav_graph.xml</code> 中，修改每個 fragment 目的地的 <code>android:label</code> 屬性。使用已在範例應用程式中宣告的下列字串資源。</p>
</li>
</ol>
<ul>
<li>如果是 <strong>start fragment</strong>，請使用 <code>@string/app_name</code>，其 value 為 <code>Cupcake</code>。</li>
<li>如果是 <strong>flavor fragment</strong>，請使用 <code>@string/choose_flavor</code>，其 value 為 <code>Choose Flavor</code>。</li>
<li>如果是 <strong>pickup fragment</strong>，請使用 <code>@string/choose_pickup_date</code>，其 value 為 <code>Choose Pickup Date</code>。</li>
<li>如果是 <strong>summary fragment</strong>，請使用 <code>@string/order_summary</code>，其 value 為 <code>Order Summary</code>。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">navigation</span> <span class="attr">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/startFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/app_name&quot;</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/flavorFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/choose_flavor&quot;</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/pickupFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/choose_pickup_date&quot;</span> <span class="attr">...</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">action</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">fragment</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/summaryFragment&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">&quot;@string/order_summary&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">navigation</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行應用程式。請注意，在您前往各個 fragment 目的地時，app bar 中的標題會隨之變更。另請注意，app bar 上會顯示「Up」按鈕 (箭頭 ←)。如果輕觸按鈕，則不會採取任何行動。在下一個程式碼研究室中，您會實作「Up」按鈕行為。</li>
</ol>
<hr>
<h3 id="建立共用-ViewModel"><a href="#建立共用-ViewModel" class="headerlink" title="建立共用 ViewModel"></a>建立共用 ViewModel</h3><p>現在要開始在各個 fragments 中填入正確 data。您將使用共用 <code>ViewModel</code> 將 app data 儲存在單一 <code>ViewModel</code> 中。app 中的多個 fragments 會使用其 activity 範圍(scope)來存取共用的(shared) <code>ViewModel</code>。</p>
<p>在大部分 production app 中，不同 fragments 間共用 data 是常見的用途。舉例來說，在 <strong>Cupcake</strong> app 的(本程式碼實驗室)最終版本中(請注意下方螢幕截圖)，使用者在第一個畫面選取杯子蛋糕數量，系統在第二個畫面依杯子蛋糕的數量計算並顯示價格。同樣地，summary 畫面也使用口味和取貨日期等其他 app data。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/3b6a68cab0b9ee2_1920.png?hl=zh-tw">

<p>從 app 功能的角度來看，您可以選擇將這筆訂單資訊儲存在單一 <code>ViewModel</code> 中，即可在此 activity 中的各 fragments 之間共用。請記得 <code>ViewModel</code> 是 Android 架構元件的一部分。在設定變更期間，會保留儲存在 <code>ViewModel</code> 中的 app data。若要在 app 中新增 <code>ViewModel</code>，您必須建立可從 <code>ViewModel</code> class 擴充的新 class。</p>
<h4 id="建立-OrderViewModel"><a href="#建立-OrderViewModel" class="headerlink" title="建立 OrderViewModel"></a>建立 OrderViewModel</h4><p>在這項工作中，您會為稱為 <code>OrderViewModel</code> 的 Cupcake app 建立共用的 <code>ViewModel</code>。您也會將 app data 新增為 <code>ViewModel</code> 及方法中的屬性，用於更新及修改資料。以下是類別的屬性：</p>
<ul>
<li>Order quantity(訂單數量)：<code>Integer</code></li>
<li>Cupcake flavor(杯子蛋糕口味)：<code>String</code></li>
<li>Pickup date(取貨日期)：<code>String</code></li>
<li>Price(價格)：<code>Double</code></li>
</ul>
<h5 id="採用-ViewModel-最佳做法"><a href="#採用-ViewModel-最佳做法" class="headerlink" title="採用 ViewModel 最佳做法"></a>採用 ViewModel 最佳做法</h5><p>在 <code>ViewModel</code>，建議您勿將 view model data 設為 <code>public</code> 變數。否則，app data 可能會被外部 class 以意想不到的方式修改，並造成 app 無法預料的情況。應將這些可變動(mutable)的屬性設為 <code>private</code>，並導入 backing property，並視需要公開每個屬性的 <code>public</code> 不可變動(immutable)版本。慣例是在 <code>private</code> 可變動屬性名稱前面加上 (<code>_</code>) 作為前綴。</p>
<p>請根據使用者的選擇，採用下列方式更新上述屬性：</p>
<ul>
<li><code>setQuantity(numberCupcakes: Int)</code></li>
<li><code>setFlavor(desiredFlavor: String)</code></li>
<li><code>setDate(pickupDate: String)</code></li>
</ul>
<p><code>Price</code> 不需要 <code>setter</code> 方法，因為您將使用其他屬性在 <code>OrderViewModel</code> 內計算價格。下列步驟將說明如何導入共用 <code>ViewModel</code>。</p>
<p>您將在專案中建立名為 <code>model</code> 的新 package，並新增 <code>OrderViewModel</code> class。如此一來，系統會分隔 view model 程式碼與 UI 程式碼(fragment 和 activity)。根據功能，將程式碼分隔為不同 package 是程式設計的最佳做法。</p>
<ol>
<li><p>在 Android Studio 的「Project」視窗中，以滑鼠右鍵按一下「com.example.cupcake」 &gt;「New」 &gt;「Package」。</p>
</li>
<li><p>系統會開啟「New Package」對話方塊，將套件命名為 <code>com.example.cupcake.model</code>。</p>
</li>
<li><p>在 <code>model</code> package 之下建立 <code>OrderViewModel</code> Kotlin class。在「Project」視窗中，以滑鼠右鍵按一下 <code>model</code> package，然後選取「New」&gt;「Kotlin File&#x2F;Class」。在新 dialog 中，給予檔案名稱 <code>OrderViewModel</code>。</p>
</li>
<li><p>在 <code>OrderViewModel.kt</code> 中，變更 class signature 以從 <code>ViewModel</code> 擴展&#x2F;延伸。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.lifecycle.ViewModel</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>在 <code>OrderViewModel</code> class 中，將上述討論的屬性新增為 <code>private</code> <code>val</code>。</p>
</li>
<li><p>請將屬性 type 變更為 <code>LiveData</code>，然後在屬性中加入 backing fields，這樣這些屬性就可觀察(observable)，當 view model 中的 source data 發生變化時，UI 就會更新。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 杯子蛋糕數量 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _quantity = MutableLiveData&lt;<span class="built_in">Int</span>&gt;(<span class="number">0</span>) <span class="comment">// 內部可變動(mutable)</span></span><br><span class="line"><span class="keyword">val</span> quantity: LiveData&lt;<span class="built_in">Int</span>&gt; = _quantity <span class="comment">// 外部不可變動(immutable)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 杯子蛋糕口味 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _flavor = MutableLiveData&lt;String&gt;(<span class="string">&quot;&quot;</span>) <span class="comment">// 內部可變動(mutable)</span></span><br><span class="line"><span class="keyword">val</span> flavor: LiveData&lt;String&gt; = _flavor <span class="comment">// 外部不可變動(immutable)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 取貨日期 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _date = MutableLiveData&lt;String&gt;(<span class="string">&quot;&quot;</span>) <span class="comment">// 內部可變動(mutable)</span></span><br><span class="line"><span class="keyword">val</span> date: LiveData&lt;String&gt; = _date <span class="comment">// 外部不可變動(immutable)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 價格 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _price = MutableLiveData&lt;<span class="built_in">Double</span>&gt;(<span class="number">0.0</span>) <span class="comment">// 內部可變動(mutable)</span></span><br><span class="line"><span class="keyword">val</span> price: LiveData&lt;<span class="built_in">Double</span>&gt; = _price <span class="comment">// 外部不可變動(immutable)</span></span><br></pre></td></tr></table></figure>

<p>您必須 import 以下 class：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.lifecycle.LiveData</span><br><span class="line"><span class="keyword">import</span> androidx.lifecycle.MutableLiveData</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>在 <code>OrderViewModel</code> class 中，新增上述方法。在方法中，傳入可變動屬性(mutable)的參數。</p>
</li>
<li><p>由於這些 <code>setter</code> 方法需要從 view model 外呼叫，因此請將其保留為 <code>public</code> 方法，也就是不需要在 <code>fun</code> 關鍵字之前使用 <code>private</code> 或其他瀏覽權限修飾符。Kotlin 中的預設瀏覽權限修飾符設定為 <code>public</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setQuantity</span><span class="params">(numberCupcakes: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    _quantity.value = numberCupcakes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setFlavor</span><span class="params">(desiredFlavor: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    _flavor.value = desiredFlavor</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setDate</span><span class="params">(pickupDate: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    _date.value = pickupDate</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>建構並執行應用程式，確保不會發生編譯錯誤。UI 不應出現任何可見的變更。</li>
</ol>
<p>做得好！現在，您已經開始使用 view model。隨著您在 app 中建構更多功能，您會逐漸向此 class 添加更多程式碼。</p>
<p>如果您在 Android Studio 中看到以灰色字型顯示的類別名稱、屬性名稱或方法名稱，這是正常現象。這表示類別、屬性或方法或是目前未使用，但一定會存在！</p>
<hr>
<h3 id="使用-ViewModel-更新-UI"><a href="#使用-ViewModel-更新-UI" class="headerlink" title="使用 ViewModel 更新 UI"></a>使用 ViewModel 更新 UI</h3><p>在這項工作中，您將使用所建立的共用 view model 來更 app 的 UI。導入共用 view model 的主要差異，就是<u>從 <b>UI Controller</b> 存取該 model 的方式</u>。您將使用 <strong>activity instance</strong> 而非 <strong>fragment instance</strong>，後續章節將示範如何執行這項作業。</p>
<p>意指<u>可在各 <b>fragment</b> 之間共用 <b>view model</b></u>。<u>每個 <b>fragment</b> 都可以存取 <b>view model</b></u>，藉此查看訂單的部分詳細資訊，或是在 view model 中更新部分 <strong>data</strong>。</p>
<h4 id="★更新-StartFragment-即可使用-view-model"><a href="#★更新-StartFragment-即可使用-view-model" class="headerlink" title="★更新 StartFragment 即可使用 view model"></a>★更新 StartFragment 即可使用 view model</h4><p>如要在 <code>StartFragment</code> 中使用共用 view model，您必須使用 <code>activityViewModels()</code> 而非 <code>viewModels()</code> 委派類別來初始化 <code>OrderViewModel</code>。</p>
<ul>
<li><code>viewModels()</code> <b>範圍(scope)</b>：限定於<u>目前 <b>fragment</b> 的 <code>ViewModel</code> instance</u>。不同 fragment 各有所不同。</li>
<li><code>activityViewModels()</code> <b>範圍(scope)</b>：限定於<u>目前 <b>activity</b> 的 <code>ViewModel</code> instance</u>。因此，<span class="label primary">在相同 <b>activity</b> 中的多個 <b>fragment</b> 中，<b>instance</b> 會保持不變</span>。</li>
</ul>
<h5 id="使用-Kotlin-property-delegate"><a href="#使用-Kotlin-property-delegate" class="headerlink" title="使用 Kotlin property delegate"></a>使用 Kotlin property delegate</h5><p>在 Kotlin 中，每個可變動 (<code>var</code>) 屬性都會自動產生屬性的 <code>getter</code> 和 <code>setter</code> 函式。當您設定屬性的 value 或讀取屬性的 value 時，會呼叫 <code>setter</code> 和 <code>getter</code> 函式。(針對唯讀屬性 (<code>val</code>)，根據預設只會產生 <code>getter</code> 函式。在讀取唯讀屬性的 value 時，會呼叫 <code>getter</code> 函式。)</p>
<ul>
<li>Kotlin 中的 <strong>property delegate</strong> 功能可協助您將 <code>getter-setter</code> 責任移交給其他 class。</li>
<li>此 class (稱為「<strong>delegate class</strong>」) 可提供屬性的 <code>getter</code> 和 <code>setter</code> 函式，並處理其變更。</li>
</ul>
<p>delegate property 是使用 <code>by</code> 子句和 delegate class instance 來定義：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Syntax for property delegation</span></span><br><span class="line"><span class="keyword">var</span> &lt;property-name&gt; : &lt;property-type&gt; <span class="keyword">by</span> &lt;delegate-<span class="keyword">class</span>&gt;()</span><br></pre></td></tr></table></figure>

<ol>
<li>在 <code>StartFragment</code> class 中，取得共用 view model 的引用做為 class 變數。使用 <code>fragment-ktx</code> library 中的 <code>by activityViewModels()</code> Kotlin property delegate。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> sharedViewModel: OrderViewModel <span class="keyword">by</span> activityViewModels()</span><br></pre></td></tr></table></figure>

<p>您可能需要 import 以下新資料：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.fragment.app.activityViewModels</span><br><span class="line"><span class="keyword">import</span> com.example.cupcake.model.OrderViewModel</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>針對 <code>FlavorFragment</code>、<code>PickupFragment</code>、<code>SummaryFragment</code> class 重複上述步驟，您將在程式碼研究室的後續章節中使用此 <code>sharedViewModel</code> instance。</p>
</li>
<li><p>返回 <code>StartFragment</code> class 後，即可使用 view model。在 <code>orderCupcake()</code> 方法的開頭，先在共用 view model 中呼叫 <code>setQuantity()</code> 方法來更新數量，之後再前往 flavor fragment。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderCupcake</span><span class="params">(quantity: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    sharedViewModel.setQuantity(quantity)</span><br><span class="line">    findNavController().navigate(R.id.action_startFragment_to_flavorFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>OrderViewModel</code> class 中新增下列方法以檢查是否已設定訂單的口味。您將在後續步驟中在 <code>StartFragment</code> class 中使用此方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasNoFlavorSet</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> _flavor.value.isNullOrEmpty()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>StartFragment</code> class 中的 <code>orderCupcake()</code> 方法中，在設定數量後，若未設定口味，則先將預設口味設定為「Vanilla」(香草)，之後再前往 flavor fragment。完整的方法看起來會像這樣：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">orderCupcake</span><span class="params">(quantity: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    sharedViewModel.setQuantity(quantity)</span><br><span class="line">    <span class="keyword">if</span> (sharedViewModel.hasNoFlavorSet()) &#123;</span><br><span class="line">        sharedViewModel.setFlavor(getString(R.string.vanilla))</span><br><span class="line">    &#125;</span><br><span class="line">    findNavController().navigate(R.id.action_startFragment_to_flavorFragment)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>建構 app 以確保不會發生編譯錯誤。但 UI 並不會出現任何可見的變更。</li>
</ol>
<hr>
<h3 id="搭配使用-ViewModel-與-data-binding"><a href="#搭配使用-ViewModel-與-data-binding" class="headerlink" title="搭配使用 ViewModel 與 data binding"></a>搭配使用 ViewModel 與 data binding</h3><p>接下來，您需要使用 <strong>data binding</strong> 將 <strong>view model data</strong> 綁定(bind)至 <strong>UI</strong>。系統也會根據使用者在 UI 中的選擇，更新共用 view model。</p>
<p><strong>複習 data binding</strong><br>請注意，<strong>data binding library</strong> 是 <strong>Android Jetpack</strong> 的一部分。data binding 使用宣告式格式，<u>將 layout 中的 ，<b>UI 元件</b> bind 至 app 中的 <b>resource data</b></u>。簡單來說，<strong>data binding</strong> 將 <strong>data</strong> (從程式碼)  bind 至 <strong>views + view binding</strong> (binding views to code)。設定這些 bindings，並啟用自動進行更新後，即使您忘記從程式碼手動更新 UI，也能降低錯誤發生的機率。</p>
<h4 id="用使用者的選擇來更新-flavor"><a href="#用使用者的選擇來更新-flavor" class="headerlink" title="用使用者的選擇來更新 flavor"></a>用使用者的選擇來更新 flavor</h4><ol>
<li>在 <code>layout/fragment_flavor.xml</code> 中，在根 <code>&lt;layout&gt;</code> 標記內新增　<code>&lt;data&gt;</code> 標記。新增 <code>name</code> 為 <code>viewModel</code> 且 <code>type</code> 為 <code>com.example.cupcake.model.OrderViewModel</code> 的 layout 變數。請確認 <code>type</code> 屬性中的 package name 與 app 內共用 view model class <code>OrderViewModel</code> 的 package name 相同。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.model.OrderViewModel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>同樣地，請針對 <code>fragment_pickup.xml</code> 及 <code>fragment_summary.xml</code> 重複上率步驟以新增 <code>viewModel</code> layout 變數。您將在接下來幾節中使用此變數。<code>fragment_start.xml</code> 未使用共用 view model，因此您不需要在此 layout 中加入這段程式碼。</p>
</li>
<li><p>在 <code>FlavorFragment</code> class 的 <code>onViewCreated()</code> 中，將 view model instance 與 layout model 中的共用 view model instance 綁定(bind)。在 <code>binding?.apply</code> 區塊中加入以下程式碼。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding?.apply &#123;</span><br><span class="line">    <span class="comment">// 設定 viewModel 為共用 view model</span></span><br><span class="line">    <span class="keyword">this</span>.viewModel = sharedViewModel</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="套用-scope-函式"><a href="#套用-scope-函式" class="headerlink" title="套用 scope 函式"></a>套用 scope 函式</h5><p>這可能是您首次在 Kotlin 中看到 <code>apply</code> 函式。<code>apply</code> 是 Kotlin 標準 library 中的 <a href="https://kotlinlang.org/docs/scope-functions.html">scope function</a>。會在物件 context 內執行 code block。這樣可以建立<b>臨時範圍(temporary scope)</b>，而且您可以<u>在該<b>範圍(scope)</b>中即可存取物件而無需物件名稱</u>。<code>apply</code> 的常見用途是<u>設定物件</u>。這類呼叫可以解讀為「套用下列指派作業(assignments)至物件」。</p>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">clark.apply &#123;</span><br><span class="line">    firstName = <span class="string">&quot;Clark&quot;</span></span><br><span class="line">    lastName = <span class="string">&quot;James&quot;</span></span><br><span class="line">    age = <span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 沒有套用 scope function 的程式碼如下所示。</span></span><br><span class="line">clark.firstName = <span class="string">&quot;Clark&quot;</span></span><br><span class="line">clark.lastName = <span class="string">&quot;James&quot;</span></span><br><span class="line">clark.age = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>PickupFragment</code> 和 <code>SummaryFragment</code> class 中，針對 <code>onViewCreated()</code> 方法重複上述步驟。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding?.apply &#123;</span><br><span class="line">    <span class="comment">// 設定 viewModel 為共用 view model</span></span><br><span class="line">    <span class="keyword">this</span>.viewModel = sharedViewModel</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>fragment_flavor.xml</code> 中，使用新的 layout 變數 <code>viewModel</code>，根據 view model 的 flavor 值，設定 radio button 的 <code>checked</code> 屬性。如果 radio button 表示的 flavor 與儲存在 view model 中的 flavor 相同，則 radio button 顯示為已選取 (<code>checked = true</code>)。已選取「Vanilla」(香草) <code>RadioButton</code> 的 binding 運算式如下所示：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">@&#123;viewModel.flavor.equals(@string/vanilla)&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>基本上，您會使用 <code>equals</code> 函式來比較 <code>viewModel.flavor</code> 屬性與對應的字串資源，藉此判定已檢查狀態是 <code>True</code> 還是 <code>False</code>。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong> 請記得，binding 運算式以 <code>@</code> 符號開頭，並放在大括號 <code>{}</code> 內。</p>
          </div>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/vanilla&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.flavor.equals(@string/vanilla)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/chocolate&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.flavor.equals(@string/chocolate)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/red_velvet&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.flavor.equals(@string/red_velvet)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/salted_caramel&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.flavor.equals(@string/salted_caramel)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/coffee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.flavor.equals(@string/coffee)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="Listener-bindings"><a href="#Listener-bindings" class="headerlink" title="Listener bindings"></a>Listener bindings</h4><p><strong>Listener bindings</strong> 是指在 event 發生 (例如 <code>onClick</code> event) 時執行的 <code>lambda</code> 運算式。做法類似於 method 引用 (例如 <code>textview.setOnClickListener(clickListener))</code>，但 listener bindings 可讓您執行任意 data binding 運算式。</p>
<ol>
<li>在 <code>fragment_flavor.xml</code> 中，使用 <strong>listener bindings</strong> 將 <strong>event listeners</strong> 新增至 <strong>radio buttons</strong>。使用不含參數的 <code>lambda</code> 運算式，並呼叫 <code>viewModel</code>。<code>setFlavor()</code> method 藉由傳入對應的 <u>flavor 字串資源(string resource)</u>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/vanilla&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setFlavor(@string/vanilla)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/chocolate&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setFlavor(@string/chocolate)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/red_velvet&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setFlavor(@string/red_velvet)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/salted_caramel&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setFlavor(@string/salted_caramel)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/coffee&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setFlavor(@string/coffee)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行 app，並注意在 flavor fragment 中如何依據預設選取的「Vanilla」(香草) 選項。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/3095e824b4817b98_1920.png?hl=zh-tw" width="30%">

<p>漂亮！現在可以移到下一個 fragments。</p>
<hr>
<h3 id="更新-pickup-和-summary-fragment-以使用-view-model"><a href="#更新-pickup-和-summary-fragment-以使用-view-model" class="headerlink" title="更新 pickup 和 summary fragment 以使用 view model"></a>更新 pickup 和 summary fragment 以使用 view model</h3><p>Navigate 應用程式，並留意，在 pickup fragment 中的 radio button option labels 為空白。在這項工作中，會計算 4 個可用的<b>取貨日期(pickup dates)</b>，並顯示在 <b>pickup fragment</b> 中。有很多種顯示<b>格式化(formatted)日期</b>的方法，Android 提供多種實用的公用程式(utilities)來執行此動作。</p>
<h4 id="建立-pickup-options-list"><a href="#建立-pickup-options-list" class="headerlink" title="建立 pickup options list"></a>建立 pickup options list</h4><h5 id="Date-formatter"><a href="#Date-formatter" class="headerlink" title="Date formatter"></a>Date formatter</h5><p>Android 架構提供一個稱為 <code>SimpleDateFormat</code> 的 class，該 class 會以區分地區設定方式來格式化並剖析 date。這允許 date 進行<span class="label primary">格式化 (date → text)</span> 及<span class="label primary">剖析 (text → date)</span>。</p>
<p>您可以傳入<u>格式字串(pattern string)</u>和<u>地區設定(locale)</u>，以建立 <code>SimpleDateFormat</code> 的 instance：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">SimpleDateFormat(<span class="string">&quot;E MMM d&quot;</span>, Locale.getDefault())</span><br></pre></td></tr></table></figure>

<p><code>&quot;E MMM d&quot;</code> 等格式字串(pattern string)表示 <code>Date</code> 和 <code>Time</code> 格式(formats)。從 <code>&#39;A&#39;</code> 到 <code>&#39;Z&#39;</code> 和 <code>&#39;a&#39;</code> 到 <code>&#39;z&#39;</code> 的字母都會視為 pattern letters，代表 date 或 time string 的元件(components)。例如，<code>d</code> 代表一個月中的日期(day in a month)、<code>y</code> 代表年份(year)，<code>M</code> 代表月份(month)。如果 date 是 2018 年 1 月 4 日，則 pattern string <code>&quot;EEE, MMM d&quot;</code> 會剖析為 <code>&quot;Wed, Jul 4&quot;</code>。若需完整的 pattern letters 清單，請參閱<a href="https://developer.android.com/reference/java/text/SimpleDateFormat#date-and-time-patterns">說明文件</a>。</p>
<p><a href="https://developer.android.com/reference/java/util/Locale">Locale</a> 物件代表特定的地理區域、政治或文化區域。代表語言&#x2F;國家&#x2F;地區&#x2F;變化版本(variant)組合。Locales 會根據當地慣例來改變資訊 (例如 numbers 或 dates) 的顯示方式。由於世界不同地區表達日期和時間的格式不同，因此日期和時間會依地區設定而有所不同。您將使用 <code>Locale.getDefault()</code> 方法擷取使用者裝置上設定的 locale 資訊，並傳遞至 <code>SimpleDateFormat</code> 建構函式(constructor)中。</p>
<p>Android 中的 Locale 是 language 和 country code 的組合。 language codes 是兩個小寫英文字母 ISO language codes，例如「en」表示英文。country codes 是由兩個大寫英文字母組成的 ISO country codes，例如美國為「US」。</p>
<p>現在使用 <code>SimpleDateFormat</code> 和 <code>Locale</code> 來判斷 Cupcake app 的可取貨日期(pickup date)。</p>
<ol>
<li>在 <code>OrderViewModel</code> class 中新增名為 <code>getPickupOptions()</code> 的函式，以便建立並回傳(return) pickup dates list。在方法中，建立一個名為 <code>options</code> 的 <code>val</code> 變數，然後初始化為 <code>mutableListOf&lt;String&gt;()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPickupOptions</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> options = mutableListOf&lt;String&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>SimpleDateFormat</code> 傳遞 pattern string <code>&quot;E MMM d&quot;</code> 和 locale 來建立 formatter string。在 pattern string 中，<code>E</code> 代表星期幾，且會剖析為「Tue Dec 10」。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> formatter = SimpleDateFormat(<span class="string">&quot;E MMM d&quot;</span>, Locale.getDefault())</span><br></pre></td></tr></table></figure>
<ul>
<li>當 Android Studio 出現提示時，import <code>java.text.SimpleDateFormat</code> 和 <code>java.util.Locale</code>。</li>
</ul>
<ol start="3">
<li>取得 <code>Calendar</code> instance 並 assign 給新的變數(variable)，將其設定為 <code>val</code>。此變數會包含目前的日期(date)和時間(time)。而且 import <code>java.util.Calendar</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> calendar = Calendar.getInstance()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>建置當天日期(current date)加上後續三個日期(following three dates)的 <strong>date list</strong>。由於這需要 4 個 date options，請重複此程式碼區塊 4 次。此 <code>repeat</code> 區塊會格式化日期(format a date)，將其加到 date options list 中，然後將日曆(calendar)增加 1 天。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">repeat(<span class="number">4</span>) &#123;</span><br><span class="line">    options.add(formatter.format(calendar.time))</span><br><span class="line">    calendar.add(Calendar.DATE, <span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 method 的結尾 return 更新後的 <code>options</code>。以下是已完成的 method：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getPickupOptions</span><span class="params">()</span></span>: List&lt;String&gt; &#123;</span><br><span class="line">   <span class="keyword">val</span> options = mutableListOf&lt;String&gt;()</span><br><span class="line">   <span class="keyword">val</span> formatter = SimpleDateFormat(<span class="string">&quot;E MMM d&quot;</span>, Locale.getDefault())</span><br><span class="line">   <span class="keyword">val</span> calendar = Calendar.getInstance()</span><br><span class="line">   <span class="comment">// Create a list of dates starting with the current date and the following 3 dates</span></span><br><span class="line">   repeat(<span class="number">4</span>) &#123;</span><br><span class="line">       options.add(formatter.format(calendar.time))</span><br><span class="line">       calendar.add(Calendar.DATE, <span class="number">1</span>)</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>OrderViewModel</code> class 中，新增名為 <code>val</code> 的 class 屬性 <code>dateOptions</code>。使用您剛剛建立的 <code>getPickupOptions()</code> 方法進行初始化。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> dateOptions = getPickupOptions()</span><br></pre></td></tr></table></figure>

<h4 id="更新-layout-以顯示-pickup-options"><a href="#更新-layout-以顯示-pickup-options" class="headerlink" title="更新 layout 以顯示 pickup options"></a>更新 layout 以顯示 pickup options</h4><p>現在 view model 中有四個可用的 pickup dates，更新 <code>fragment_pickup.xml</code> layout 以顯示這些日期。您還可以使用 data binding 來顯示每個 radio button 的已勾選(checked)狀態，並在選取不同 radio button 時更新 view model 的日期。實作方式類似於 flavor fragment 中的 data binding。</p>
<p>在 <code>fragment_pickup.xml</code> 中：</p>
<ul>
<li>在 <code>viewModel</code> 中，radio button <code>option0</code> 代表 <code>dateOptions[0]</code> (今天)</li>
<li>在 <code>viewModel</code> 中，radio button <code>option1</code> 代表 <code>dateOptions[1]</code> (明天)</li>
<li>在 <code>viewModel</code> 中，radio button <code>option2</code> 代表 <code>dateOptions[2]</code> (後天)</li>
<li>在 <code>viewModel</code> 中，radio button <code>option3</code> 代表 <code>dateOptions[3]</code> (大後天)</li>
</ul>
<ol>
<li>在 <code>fragment_pickup.xml</code> 中，針對 <code>option0</code> radio button 使用新的 layout 變數 <code>viewModel</code>，以便根據 view model 中的 <code>date</code> 值來設定 <code>checked</code> 屬性。比較 <code>viewModel.date</code> 屬性與 <code>dateOptions</code> list 中的第一個字串 (也就是當天日期)。使用 <code>equals</code> 函式進行比較，最終 binding 運算式如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">@&#123;viewModel.date.equals(viewModel.dateOptions[<span class="number">0</span>])&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>針對相同的 radio button，使用 listener binding 新增 event listener 至 <code>onClick</code> 屬性。按一下此按鈕後，<code>viewModel</code> 就會呼叫 <code>setDate()</code>，傳入 <code>dateOptions[0]</code>。</p>
</li>
<li><p>如果是相同的 radio button，請將 <code>text</code> 屬性值設定為 <code>dateOptions</code> list 中的第一個字串。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/option0&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.date.equals(viewModel.dateOptions[0])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setDate(viewModel.dateOptions[0])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.dateOptions[0]&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>針對其他 radio button 重複上述步驟，並據此變更 <code>dateOptions</code> 的索引(index)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/option1&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.date.equals(viewModel.dateOptions[1])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setDate(viewModel.dateOptions[1])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.dateOptions[1]&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/option2&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.date.equals(viewModel.dateOptions[2])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setDate(viewModel.dateOptions[2])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.dateOptions[2]&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/option3&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:checked</span>=<span class="string">&quot;@&#123;viewModel.date.equals(viewModel.dateOptions[3])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; viewModel.setDate(viewModel.dateOptions[3])&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.dateOptions[3]&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行應用程式後，當 pickup options 可用時就會看到未來幾天。螢幕截圖取決於您的目前日期而有所不同。請注意，依據預設不會選取任何選項。您將在下一個步驟中導入此動作。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/b55b3a36e2aa7be6_1920.png?hl=zh-tw" width="30%">

<ol start="6">
<li>在 <code>OrderViewModel</code> class 中，建立名為 <code>resetOrder()</code> 的函式，重設 view model 中的 <code>MutableLiveData</code> 屬性。將 <code>dateOptions</code> list 中的現在日期值(current date value)指派給 <code>_date.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">resetOrder</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _quantity.value = <span class="number">0</span></span><br><span class="line">   _flavor.value = <span class="string">&quot;&quot;</span></span><br><span class="line">   _date.value = dateOptions[<span class="number">0</span>]</span><br><span class="line">   _price.value = <span class="number">0.0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在 class 中新增 <code>init</code> 區塊，並呼叫新 method <code>resetOrder()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">   resetOrder()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>從 class 中的屬性宣告移除初始值(initial value)。現在，您可以在建立 <code>OrderViewModel</code> instance 時使用 <code>init</code> 區塊來初始化屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _quantity = MutableLiveData&lt;<span class="built_in">Int</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> quantity: LiveData&lt;<span class="built_in">Int</span>&gt; = _quantity</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _flavor = MutableLiveData&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> flavor: LiveData&lt;String&gt; = _flavor</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _date = MutableLiveData&lt;String&gt;()</span><br><span class="line"><span class="keyword">val</span> date: LiveData&lt;String&gt; = _date</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _price = MutableLiveData&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> price: LiveData&lt;<span class="built_in">Double</span>&gt; = _price</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>再次執行應用程式。請注意，依據預設會選取今天的日期。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/bfe4f1b82977b4bc_1920.png?hl=zh-tw" width="30%">

<h4 id="更新-summary-fragment-以使用-view-model"><a href="#更新-summary-fragment-以使用-view-model" class="headerlink" title="更新 summary fragment 以使用 view model"></a>更新 summary fragment 以使用 view model</h4><p>現在介紹最後一個 fragment 。訂單 summary fragment 是用來顯示訂單詳細資料的摘要(summary)。在這項工作中，請妥善利用共用 view model 中的所有訂單資訊，並使用 data binding 來更新螢幕上的訂單詳細資料(order details)。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/78f510e10d848dd2_1920.png?hl=zh-tw" width="30%">

<ol>
<li>請務必在 <code>fragment_summary.xml</code> 中宣告 view model data 變數 <code>viewModel</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.model.OrderViewModel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 <code>SummaryFragment</code> 中，在 <code>onViewCreated()</code> 中確認 <code>binding.viewModel</code> 已初始化。</p>
</li>
<li><p>在 <code>fragment_summary.xml</code> 中，從 view model 中讀取，以更新畫面中的 order summary 詳細資料(details)。新增下列 <code>text</code> 屬性來更新<b>數量(quantity)</b>、<b>口味(flavor)</b>和<b>日期(date)</b> TextViews。<b>quantity</b> 為 <code>Int</code> type，因此您必須將其轉換為 <code>String</code>。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/quantity&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.quantity.toString()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/flavor&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.flavor&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/date&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;viewModel.date&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行並測試應用程式，確認您所選的訂單選項已顯示在訂單摘要中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/7091453fa817b55_1920.png?hl=zh-tw" width="30%">

<hr>
<h3 id="根據-order-detail-計算-price"><a href="#根據-order-detail-計算-price" class="headerlink" title="根據 order detail 計算 price"></a>根據 order detail 計算 price</h3><p>查看本程式碼研究室的最終應用程式螢幕截圖時，您會注意到價格確實顯示在每個片段 (StartFragment 除外) 上，因此使用者在建立訂單時即可得知價格。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/3b6a68cab0b9ee2_1920.png?hl=zh-tw">

<p>以下是我們的杯子蛋糕專賣店如何計算價格的規則。</p>
<ul>
<li>每個杯子蛋糕 $2.00 美元</li>
<li>對於當天取貨，訂單中會再增加 $3.00 美元</li>
</ul>
<p>因此，6 個杯子蛋糕訂單的價格為 6 個杯子蛋糕 x 每個 $2 美元 &#x3D; $12 美元。如果同一位使用者想要當天取貨，$3 美元的附加費用會讓訂單總價變成 $15 美元。</p>
<h4 id="更新-view-model-中的-price"><a href="#更新-view-model-中的-price" class="headerlink" title="更新 view model 中的 price"></a>更新 view model 中的 price</h4><p>若要在應用程式中支援這項功能，請先處理杯子蛋糕的價格(price)，並先忽略當天取貨費用。</p>
<ol>
<li>開啟 <code>OrderViewModel.kt</code>，然後將每杯子蛋糕的價格(price)儲存在變數中。在 class 定義之外 (但在 import 陳述式之後)，將此變數宣告在檔案頂端的 top-level <code>private</code> 常數。使用 <code>const</code> 修飾符，並使用 <code>val</code> 設定為唯讀。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PRICE_PER_CUPCAKE = <span class="number">2.00</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OrderViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>
<ul>
<li>請記得，常數值 (在 Kotlin 中以 <code>const</code> 關鍵字標記) 不會變更，而且會在編譯期間知道該值。若要進一步瞭解常數，請參閱<a href="https://kotlinlang.org/docs/properties.html#compile-time-constants">說明文件</a>。</li>
</ul>
<ol start="2">
<li>您已經定義了每杯子蛋糕的 price，請建立計算 price 的輔助方法。此方法可能是 <code>private</code>，因為只能在此 class 中使用。您會在下一個工作中變更 price 邏輯，以便納入當天取貨費用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePrice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    _price.value = (quantity.value ?: <span class="number">0</span>) * PRICE_PER_CUPCAKE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note primary">
            <p><strong>筆記：</strong> <b>A ?: B</b> 意思是「當 <b>A</b> 不為 <b>null</b> 時就返回 <b>A</b>，當 <b>A</b> 為 <b>null</b> 時就返回 <b>B</b>」。</p>
          </div>

<p>這段程式碼會將每杯子蛋糕的 price 乘以所訂購的杯子蛋糕 quantity。關於括號中的程式碼，因為 <code>quantity.value</code> 的值可以是空值，所以使用 elvis 運算子 (<code>?:</code>)。elvis 運算子 (<code>?:</code>) 表示左側運算式不是空值時，則使用該運算子。如果左側運算式是空值，則使用 elvis 運算子右側的運算式 (本例中為 <code>0</code>)。</p>
<ol start="3">
<li>在相同 <code>OrderViewModel</code> class 中，在設定 quantity 時更新 price 變數。在 <code>setQuantity()</code> 函式中呼叫新函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setQuantity</span><span class="params">(numberCupcakes: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    _quantity.value = numberCupcakes</span><br><span class="line">    updatePrice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="將-price-屬性-bind-到-UI"><a href="#將-price-屬性-bind-到-UI" class="headerlink" title="將 price 屬性 bind 到 UI"></a>將 price 屬性 bind 到 UI</h4><ol>
<li>在 <code>fragment_flavor.xml</code>、<code>fragment_pickup.xml</code> 和 <code>fragment_summary.xml</code> 的 layouts 中，確認已定義 type 為 <code>com.example.cupcake.model.OrderViewModel</code> 的 data variable <code>viewModel</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;viewModel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.model.OrderViewModel&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在每個 fragment class 的 <code>onViewCreated()</code> 方法中，請務必將 fragment 中的 view model 物件 instance bind 至 layout 中的 view model 資料變數(data variable)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">binding?.apply &#123;</span><br><span class="line">    viewModel = sharedViewModel</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在每個 fragment layout 中，如果在 layout 中有顯示 price，則使用 <code>viewModel</code> 變數來設定 price。以修改 <code>fragment_flavor.xml</code> 檔案開始。舉例而言，如果是 <code>subtotal</code> text view，請將 <code>android:text</code> 屬性的值設定為 <code>&quot;@&#123;@string/subtotal_price(viewModel.price)&#125;&quot;</code>。此 data binding layout 運算式使用字串資源 <code>@string/subtotal_price</code>，並傳入參數，亦即來自 view model 的 price，因此輸出會顯示「Subtotal 12.0」(小計 12.0)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/subtotal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/subtotal_price(viewModel.price)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>您正在使用 <code>strings.xml</code> 檔案所宣告的此字串資源：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;subtotal_price&quot;</span>&gt;</span>Subtotal %s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式。如果您在 start fragment 中選取「One cupcake」(一個杯子蛋糕)，flavor fragment 會顯示「Subtotal 2.0」(小計 2.0)。如果您選取「Six cupcake」(六個杯子蛋糕)，flavor fragment 會顯示「Subtotal 12.0」(小計 12.0)，以此類推。您稍後會將 price 格式化為適當的貨幣格式，因此此行為目前是正常現象。</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/13e316e13779d3c2_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/adb9342d3a0da64e_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<ol start="5">
<li>現在針對 pickup 和 summary fragments 進行類似的變更。在 <code>fragment_pickup.xml</code> 和 <code>fragment_summary.xml</code> layouts 中，也修改 text views 以使用 <code>viewModel</code> <code>price</code> 屬性。</li>
</ol>
<p><code>fragment_pickup.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/subtotal&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/subtotal_price(viewModel.price)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>fragment_summary.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/total&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/total_price(viewModel.price)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行應用程式。確認 order summary 中顯示的價格是按 order quantity 1、6 和 12 個杯子蛋糕正確計算所得。如前所述，預期此刻 price 格式不正確 ($2 會顯示為 2.0，$12 會顯示為 12.0)。</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/f53d06e5a3c12e96_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/f6eda1308338db23_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<h4 id="當天取貨附加費"><a href="#當天取貨附加費" class="headerlink" title="當天取貨附加費"></a>當天取貨附加費</h4><p>在這項工作中，您將導入第二項規則，就是當天取貨會額外收取 $3.00 美元。</p>
<ol>
<li>在 <code>OrderViewModel</code> 類別中，針對當天取貨費用定義新 top-level private 常數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> PRICE_FOR_SAME_DAY_PICKUP = <span class="number">3.00</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>updatePrice()</code> 中，檢查使用者是否選取了當天取貨。檢查 view model (<code>_date.value</code>) 中的日期是否與 <code>dateOptions</code> list 中的第一個項目相同 (current day)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePrice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// price = quantity * 每個杯子蛋糕的價錢</span></span><br><span class="line">    _price.value = (quantity.value ?: <span class="number">0</span>) * PRICE_PER_CUPCAKE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查使用者是否選取了當天取貨</span></span><br><span class="line">    <span class="keyword">if</span> (dateOptions[<span class="number">0</span>] == _date.value) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>為了簡化這些計算，請引入 temporary 變數 <code>calculatedPrice</code>。計算更新的價格，然後將其重新指派給 <code>_price.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updatePrice</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// price = quantity * 每個杯子蛋糕的價錢</span></span><br><span class="line">    <span class="keyword">var</span> calculatedPrice = (quantity.value ?: <span class="number">0</span>) * PRICE_PER_CUPCAKE</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 檢查使用者是否選取了當天取貨</span></span><br><span class="line">    <span class="keyword">if</span> (dateOptions[<span class="number">0</span>] == _date.value) &#123;</span><br><span class="line">        <span class="comment">// 將目前價格加上當天取貨費</span></span><br><span class="line">        calculatedPrice += PRICE_FOR_SAME_DAY_PICKUP</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 設 _price 的值為 calculatedPrice</span></span><br><span class="line">    _price.value = calculatedPrice</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>從 <code>setDate()</code> method 呼叫 <code>updatePrice()</code> helper method，即可指定當天取貨費用。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setDate</span><span class="params">(pickupDate: <span class="type">String</span>)</span></span> &#123;</span><br><span class="line">    _date.value = pickupDate</span><br><span class="line">    updatePrice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行應用程式，navigate 應用程式。您會發現，變更取貨日期不會從 total price 中扣除當天取貨費用。這是因為在 view model 中 price 有所變更，但不會通知 binding layout。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/2ea8e000fb4e6ec8_1920.png?hl=zh-tw" width="30%">

<h4 id="設定-Lifecycle-owner-以觀察-LiveData"><a href="#設定-Lifecycle-owner-以觀察-LiveData" class="headerlink" title="設定 Lifecycle owner 以觀察 LiveData"></a>設定 Lifecycle owner 以觀察 LiveData</h4><p><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner"><code>LifecycleOwner</code></a> 是一個具有 Android lifecycle 的 class，例如 activity 或 fragment。唯有 lifecycle owner 處於 active 狀態 (<code>STARTED</code> 或 <code>RESUMED</code>)，<code>LiveData</code> observer 才會觀測 app data 的變更。</p>
<p>在 app 中，<code>LiveData</code> 物件或可觀察 data 是 view model 中的 <code>price</code> 屬性。lifecycle owners 是flavor、pickup 和 summary fragments。<code>LiveData</code> observers 是 layout 檔案中的 binding 運算式，當中包含可觀察 data，例如 price。透過 Data Binding，可觀察值(observable value)變更時，也會自動更新其 bind 的 UI elements。</p>
<p>binding 運算式範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;@string/subtotal_price(viewModel.price)&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>為了<span class="label primary">自動更新 UI elements</span>，您必須在 app 中<u>建立 <code>binding.lifecycleOwner</code> 與 <b>lifecycle owners</b> 的關聯</u>。</p>
<ol>
<li>在 <code>FlavorFragment</code>、<code>PickupFragment</code>、<code>SummaryFragment</code> class 的 <code>onViewCreated()</code> 方法中，在 <code>binding?.apply</code> 區塊中加入下列內容。這項操作會設定 binding 物件的 lifecycle owner。設定 lifecycle owner，app 將能觀察(observe) <code>LiveData</code> 物件。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding?.apply &#123;</span><br><span class="line">    lifecycleOwner = viewLifecycleOwner</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>再次執行應用程式。在 pickup 畫面中，變更取貨日期(pickup date)，並留意自動變更 price 方式的差異。且在 summary 畫面中正確反映取貨費用。</p>
</li>
<li><p>請注意，當您<u>選取當天取貨時，訂單價格會增加「$3.00 美元」</u>。<u>選取未來日期的價格應是「杯子蛋糕數量 x $2.00 美元」</u>。</p>
</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/905d8c8df1bfd5f2_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/7629d8a884304866_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<ol start="4">
<li>使用不同杯子蛋糕 quantities、flavors 和 pickup dates 來測試不同情況。現在，您應該會在每個 fragment 上看到 view model 的更新 price。最棒的是，您不用撰寫額外的 Kotlin 程式碼，就能讓 UI 每次都更新 price。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/f4c0a3c5ea916d03_1920.png?hl=zh-tw" width="30%">

<p>如要完成 price 功能的導入，您必須將 price 格式設定為當地幣別。</p>
<h4 id="使用-LiveData-transformation-將-price-格式化"><a href="#使用-LiveData-transformation-將-price-格式化" class="headerlink" title="使用 LiveData transformation 將 price 格式化"></a>使用 LiveData transformation 將 price 格式化</h4><p><code>LiveData transformation</code> 方法可讓您針對 source <code>LiveData</code> 執行資料操縱，並傳回產生的 <code>LiveData</code> 物件。簡單來說，此會將 <code>LiveData</code> 的值轉換為其他值。除非 <code>observer</code> 觀測到 <code>LiveData</code> 物件，否則不會計算這些轉換。</p>
<p><a href="https://developer.android.com/reference/androidx/lifecycle/Transformations.html#map(androidx.lifecycle.LiveData%3CX%3E,%20androidx.arch.core.util.Function%3CX,%20Y%3E)"><code>Transformations.map()</code></a> 其中一種是轉換函式，此方法採用 <code>LiveData</code> 和函式做為參數。函式會操控 source <code>LiveData</code>，並傳回可觀測的更新值。</p>
<p>以下列舉幾個可使用 LiveData transformation 的範例：</p>
<ul>
<li>設定 date、time strings 的顯示格式</li>
<li>排序 items 的 list</li>
<li>篩選 items 或將 items 分組</li>
<li>從 list 計算結果，例如所有 items 的加總、items 數目、傳回的最後一個 items 等等。</li>
</ul>
<p>在這項工作中，您必須使用 <code>Transformations.map()</code> 方法將設定 price 的格式為使用當地幣別。這會將原始價格從十進位(decimal)值 (<code>LiveData&lt;Double&gt;</code>) 轉換為字串(string)值 (<code>LiveData&lt;String&gt;</code>)。</p>
<ol>
<li>在 <code>OrderViewModel</code> class 中，將 backing property type 變更為 <code>LiveData&lt;String&gt;</code>，而不是 <code>LiveData&lt;Double&gt;</code>。price 的格式將為包含貨幣符號 (例如「<code>$</code>」) 的字串。您將在下一步驟修正初始化錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _price = MutableLiveData&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> price: LiveData&lt;String&gt;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>Transformations.map()</code> 初始化新變數，並傳入 <code>_price</code> 和 <code>lambda</code> 函式。請在 <code>NumberFormat</code> class 中使用 <code>getCurrencyInstance()</code> 方法，以將 price 轉換成當地幣別格式(local currency format)。transformation code 看起來會像這樣。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _price = MutableLiveData&lt;<span class="built_in">Double</span>&gt;()</span><br><span class="line"><span class="keyword">val</span> price: LiveData&lt;String&gt; = Transformations.map(_price) &#123;</span><br><span class="line">   NumberFormat.getCurrencyInstance().format(it)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>請 import <code>androidx.lifecycle.Transformations</code> 和 <code>java.text.NumberFormat</code>。</li>
</ul>
<ol start="3">
<li>執行應用程式。現在畫面上應會顯示 subtotal 及 total 的字串格式價格。更容易使用！</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-shared-viewmodel/img/1853bd13a07f1bc7_1920.png?hl=zh-tw">

<ol start="4">
<li>測試是否正常運作。測試範例：訂購一個杯子蛋糕、訂購六個杯子蛋糕、訂購 12 個杯子蛋糕。確認每個螢幕上的價格正確無誤。Flavor 和 Pickup fragments 中應顯示「Subtotal $2.00」，而 order summary 中應顯示「Total $2.00」。也請確認 order summary 顯示正確的 order details。</li>
</ol>
<hr>
<h3 id="使用-listener-binding-來設定-click-listeners"><a href="#使用-listener-binding-來設定-click-listeners" class="headerlink" title="使用 listener binding 來設定 click listeners"></a>使用 listener binding 來設定 click listeners</h3><p>在這項工作中，您將使用 <strong>listener binding</strong>  來將 <strong>fragment classes</strong> 中的 <strong>button click listeners</strong> bind 至 <strong>layout</strong>。</p>
<ol>
<li>在 layout 檔案 <code>fragment_start.xml</code> 中，新增名為 <code>startFragment</code> 且 type 為 <code>com.example.cupcake.StartFragment</code> 的 data variable。確認 fragment 的 package name 與應用程式的 package name 相符。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;startFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.StartFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>StartFragment.kt</code> 的 <code>onViewCreated()</code> 方法中，將新的 <strong>data variable</strong> bind 至 <strong>fragment instance</strong>。您可以使用 <code>this</code> 關鍵字來存取 fragment 中的 fragment instance。移除 <code>binding?.apply</code> 區塊以及區塊內的程式碼。已完成的方法應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line">    binding?.startFragment = <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>fragment_start.xml</code> 中，使用 <strong>listener binding</strong> 新增 <strong>event listeners</strong> 到 <strong>button</strong> 的 <code>onClick</code> 屬性，在 <code>startFragment</code> 上呼叫 <code>orderCupcake()</code>，並傳遞杯子蛋糕的數量。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/order_one_cupcake&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; startFragment.orderCupcake(1)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/order_six_cupcakes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; startFragment.orderCupcake(6)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/order_twelve_cupcakes&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; startFragment.orderCupcake(12)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>執行應用程式。請注意，start fragment 中的 button click handlers 運作正常。</p>
</li>
<li><p>同樣地，您也可以在其他 layouts 中加入上述 <strong>data variable</strong>，以便 bind <strong>fragment instance</strong> <code>fragment_flavor.xml</code>、<code>fragment_pickup.xml</code> 和 <code>fragment_summary.xml</code>。</p>
</li>
</ol>
<p>在 <code>fragment_flavor.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;flavorFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.FlavorFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>fragment_pickup.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;pickupFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.PickupFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>fragment_summary.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">            <span class="attr">name</span>=<span class="string">&quot;summaryFragment&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">type</span>=<span class="string">&quot;com.example.cupcake.SummaryFragment&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">ScrollView</span> <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>在其餘 fragment class 中的 <code>onViewCreated()</code> 中，刪除可手動設定 buttons 上 <strong>click listener</strong> 的程式碼。</p>
</li>
<li><p>在 <code>onViewCreated()</code> 方法中，會 bind <strong>fragment data variable</strong> 與 <strong>fragment instance</strong>。您必須在這裡以不同方式使用 <code>this</code> 關鍵字，因為在 <code>binding?.apply</code> 區塊中，關鍵字 <code>this</code> 是指 <strong>binding instance</strong>，而不是 <strong>fragment instance</strong>。使用 <code>@</code> 並明確指定 <strong>fragment class name</strong>，例如 <code>this@FlavorFragment</code>。已完成的 <code>onViewCreated()</code> 方法如下所示：</p>
</li>
</ol>
<p><code>FlavorFragment</code> class 中的 <code>onViewCreated()</code> method 應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">    binding?.apply &#123;</span><br><span class="line">        lifecycleOwner = viewLifecycleOwner</span><br><span class="line">        viewModel = sharedViewModel</span><br><span class="line">        flavorFragment = <span class="keyword">this</span><span class="symbol">@FlavorFragment</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>PickupFragment</code> class 中的 <code>onViewCreated()</code> method 應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">   binding?.apply &#123;</span><br><span class="line">       lifecycleOwner = viewLifecycleOwner</span><br><span class="line">       viewModel = sharedViewModel</span><br><span class="line">       pickupFragment = <span class="keyword">this</span><span class="symbol">@PickupFragment</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>SummaryFragment</code> class method 中產生的 <code>onViewCreated()</code> method 應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">   binding?.apply &#123;</span><br><span class="line">       lifecycleOwner = viewLifecycleOwner</span><br><span class="line">       viewModel = sharedViewModel</span><br><span class="line">       summaryFragment = <span class="keyword">this</span><span class="symbol">@SummaryFragment</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>同樣地，在其他 layout 檔案中，新增 <strong>listener binding</strong> 運算式至 <strong>buttons</strong> 的 <code>onClick</code> 屬性。</li>
</ol>
<p>在 <code>fragment_flavor.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; flavorFragment.goToNextScreen()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>fragment_pickup.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/next_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; pickupFragment.goToNextScreen()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>fragment_summary.xml</code> 中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/send_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:onClick</span>=<span class="string">&quot;@&#123;() -&gt; summaryFragment.sendOrder()&#125;&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="9">
<li>執行應用程式以驗證 <strong>buttons</strong> 是否正常運作。您應該不會發現行為變更，但已使用 <strong>listener bindings</strong> 設定 <strong>click listeners</strong>！</li>
</ol>
<p>恭喜您完成程式碼研究室，打造 Cupcake app！但是應用程式尚未處理完畢。在接下來的程式碼研究室中，您將新增 <b>Cancel</b> button 並修改<u>返回堆疊(backstack)</u>。您也會瞭解什麼是返回堆疊(backstack)和其他新主題。到時見！</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel?hl=zh-tw"><code>ViewModel</code></a> 是 <a href="https://developer.android.com/topic/architecture">Android 架構元件</a> 的一部分，在設定變更期間會保留儲存在 <code>ViewModel</code> 中的應用程式資料。若要在應用程式中加入 <code>ViewModel</code>，請建立新 class，並從 <code>ViewModel</code> class extend 該 class。</li>
<li><a href="https://developer.android.com/topic/libraries/architecture/viewmodel.html?hl=zh-tw#sharing">共用 <code>ViewModel</code></a> 會將應用程式的資料從多個 fragments 儲存在單一 <code>ViewModel</code> 中。應用程式中的多個 fragments 會使用其 activity 範圍(scope)來存取共用的 <code>ViewModel</code>。</li>
<li><a href="https://developer.android.com/reference/androidx/lifecycle/LifecycleOwner"><code>LifecycleOwner</code></a> 是一個具有 Android 生命週期的 class，例如 activity 或 fragment。</li>
<li>唯有 lifecycle owner 處於 active 狀態 (<code>STARTED</code> 或 <code>RESUMED</code>)，<code>LiveData</code> observer 才會觀察應用程式 data 的變更。</li>
<li>Listener bindings 是指在事件發生時 (例如 <code>onClick</code> 事件) 執行的 lambda 運算式。做法類似於 method 引用 (例如 <code>textview.setOnClickListener(clickListener)</code>)，但 listener bindings 可讓您執行任意 data binding 運算式。</li>
<li><code>LiveData</code> transformation 方法可讓您針對 source <code>LiveData</code> 執行 data 操縱，並傳回產生的 <code>LiveData</code> 物件。</li>
<li>Android frameworks 提供了一個名為 <code>SimpleDateFormat</code> 的 class，該 class 會以區分地區設定方式來格式化(formatting)並剖析(parsing)日期。這允許進行 dates <u>格式化 (date → text)</u> 及<u>剖析 (text → date)</u>。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>View Binding</tag>
        <tag>Navigation</tag>
        <tag>UI Controller</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>MutableLiveData</tag>
        <tag>Observer</tag>
        <tag>Data Binding</tag>
        <tag>Shared ViewModel</tag>
        <tag>LifecycleOwner</tag>
        <tag>SimpleDateFormat</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(27)-搭配ViewModel使用LiveData</title>
    <url>/2023/11/06/Android%E7%AD%86%E8%A8%98-27-%E6%90%AD%E9%85%8DViewModel%E4%BD%BF%E7%94%A8LiveData/</url>
    <content><![CDATA[<blockquote>
<p>將 <code>ViewModel</code> 中的應用程式資料轉換為 <code>LiveData</code>，並觀察自動更新 UI 所出現的變化。</p>
</blockquote>
<p>在先前的程式碼研究室中，您已瞭解如何使用 <code>ViewModel</code> 儲存應用程式資料。<code>ViewModel</code> 可在設定變更時保留應用程式資料。在本程式碼研究室中，您將瞭解如何整合 <code>LiveData</code> 與 <code>ViewModel</code> 中的資料。</p>
<p><code>LiveData</code> 類別也屬於 Android 架構元件的一部分，為可觀察的資料容器類別。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>如何在應用程式中使用 <code>LiveData</code> 和 <code>MutableLiveData</code>。</li>
<li>如何使用 <code>LiveData</code> 來封裝儲存在 <code>ViewModel</code> 中的資料。</li>
<li>如何新增觀察器(observer)方法以觀察 <code>LiveData</code> 中的變化。</li>
<li>如何在版面配置檔案中編寫 binding 表達式。</li>
</ul>
<p><strong>建構項目</strong></p>
<ul>
<li>針對 <code>Unscramble</code> 應用程式中的應用程式資料 (字詞、字詞計數和分數) 使用 <code>LiveData</code>。</li>
<li>新增觀察器(observer)方法，在資料變更時接收通知，並自動更新打散字詞的 text view。</li>
<li>在 layout 檔案中編寫 binding 表達式，在基礎 <code>LiveData</code> 變更時觸發。分數、字詞計數和打散字詞 text view 會自動更新。</li>
</ul>
<span id="more"></span>
<hr>
<h3 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h3><p>本程式碼研究室會使用您在先前程式碼研究室中熟悉的 <code>Unscramble</code> 解決方案程式碼。應用程式會顯示打散的字詞，讓玩家進行重組。玩家可以嘗試任意次數來猜測正確字詞。目前字詞、玩家分數和字詞計數等應用程式資料會儲存在 <code>ViewModel</code> 中。不過，該應用程式的 UI 不會反映新的分數和字詞計數值。在本程式碼研究室中，您將使用 <code>LiveData</code> 實作缺少的功能。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-livedata/img/a20e6e45e0d5dc6f_1920.png?hl=zh-tw" width="30%">

<hr>
<h3 id="什麼是-Livedata"><a href="#什麼是-Livedata" class="headerlink" title="什麼是 Livedata"></a>什麼是 Livedata</h3><p><code>LiveData</code> 是可觀察的資料容器類別，可感知生命週期。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 當 <b>LiveData</b> 的 <b>value</b> 更新時，<b>UI</b> 會自動更新。</p>
          </div>

<p><code>LiveData</code> 特性如下：</p>
<ul>
<li><code>LiveData</code> 可保存資料；<code>LiveData</code> 包裝函式可與任何類型的資料搭配使用。</li>
<li><code>LiveData</code> 可觀察，這表示當 <code>LiveData</code> 物件保存的資料變更時，<code>observer</code> 會接收通知。</li>
<li><code>LiveData</code> 可感知生命週期。將 <code>observer</code> 附加至 <code>LiveData</code> 時，<code>observer</code> 會與 <code>LifecycleOwner</code> 建立關聯 (通常是 activity 或 fragment )。<code>LiveData</code> 只會更新處於有效生命週期狀態 (例如 <code>STARTED</code> 或 <code>RESUMED</code>) 的 <code>observer</code>。如要進一步瞭解 <code>LiveData</code> 與 <code>observer</code>，請參閱<a href="https://developer.android.com/topic/libraries/architecture/livedata?hl=zh-cn">這篇文章</a>。</li>
</ul>
<h4 id="範例程式碼中的-UI-更新"><a href="#範例程式碼中的-UI-更新" class="headerlink" title="範例程式碼中的 UI 更新"></a>範例程式碼中的 UI 更新</h4><p>在範例程式碼中，每當您想在 UI 中顯示新的打散字詞時，系統都會明確呼叫 <code>updateNextWordOnScreen()</code> 方法。您可在遊戲初始化期間，以及玩家按下「提交」或「略過」按鈕時呼叫此方法。將從 <code>onViewCreated()</code>、<code>restartGame()</code>、<code>onSkipWord()</code> 和 <code>onSubmitWord()</code> 方法呼叫此方法。使用 <code>Livedata</code> 時，您不必從多個位置呼叫此方法來更新 UI。您只會在 observer 中執行一次。</p>
<hr>
<h3 id="將-LiveData-新增至-currentScrambledWord"><a href="#將-LiveData-新增至-currentScrambledWord" class="headerlink" title="將 LiveData 新增至 currentScrambledWord"></a>將 LiveData 新增至 currentScrambledWord</h3><p>在這項工作中，您會學習如何將 <code>GameViewModel</code> 中的目前字詞轉換為 <code>LiveData</code>，以使用 <code>LiveData</code>, 包裝任何資料。在後續工作中，您會將 observer 新增至此類 <code>LiveData</code> 物件，並瞭解如何觀察 <code>LiveData</code>。</p>
<h4 id="MutableLiveData"><a href="#MutableLiveData" class="headerlink" title="MutableLiveData"></a>MutableLiveData</h4><p><code>MutableLiveData</code> 是 <code>LiveData</code> 的可變動版本，也就是可以變更儲存在其中的資料值。</p>
<ol>
<li><p>在 <code>GameViewModel</code> 中，將變數<code> _currentScrambledWord</code> 的類型變更為 <code>MutableLiveData&lt;String&gt;</code>。<code>LiveData</code> 和 <code>MutableLiveData</code> 屬於一般類別，因此您需要指定其保存的資料類型。</p>
</li>
<li><p>將 <code>_currentScrambledWord</code> 的變數類型變更為 <code>val</code>，因為 <code>LiveData/MutableLiveData</code> 物件的值會保持不變，只有儲存在物件中的資料會改變。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String改成 LiveData</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _currentScrambledWord = MutableLiveData&lt;String&gt;()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將支援欄位 <code>currentScrambledWord</code> 類型變更為 <code>LiveData&lt;String&gt;</code>，因為此欄位不可變動。Android Studio 會顯示某些錯誤，您將在後續步驟中進行修正。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// String改成 LiveData</span></span><br><span class="line"><span class="keyword">val</span> currentScrambledWord: LiveData&lt;String&gt;</span><br><span class="line">   <span class="keyword">get</span>() = _currentScrambledWord</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如要存取 <code>LiveData</code> 物件中的資料，請使用 <code>value</code> 屬性。在 <code>getNextWord()</code> 方法的 <code>GameViewModel</code> 中，於 <code>else</code> 區塊內，將 <code>_currentScrambledWord</code> 引用變更為 <code>_currentScrambledWord.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextWord</span><span class="params">()</span></span> &#123;</span><br><span class="line"> ...</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 因 _currentScrambledWord 為 LiveData，需使用 value 屬性來存取 LiveData 物件中的資料</span></span><br><span class="line">       _currentScrambledWord.value = String(tempWord)</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="將-Observer-附加至-LiveData-物件"><a href="#將-Observer-附加至-LiveData-物件" class="headerlink" title="將 Observer 附加至 LiveData 物件"></a>將 Observer 附加至 LiveData 物件</h3><p>在這項工作中，您將會在應用程式元件 <code>GameFragment</code> 中設定觀察器(observer)。您新增的 observer 會觀察應用程式資料 <code>currentScrambledWord</code> 的變更。<code>LiveData</code> 具備生命週期感知功能，代表其只會更新處於有效生命週期狀態的 observer。因此，<code>GameFragment</code> 中的 observer 只會在 <code>GameFragment</code> 處於 <code>STARTED</code> 或 <code>RESUMED</code> 狀態時收到通知。</p>
<ol>
<li><p>在 <code>GameFragment</code> 中，刪除 <code>updateNextWordOnScreen()</code> 方法及其所有呼叫。您將會在 <code>LiveData</code> 中附加 observer，因此不需要使用此方法。</p>
</li>
<li><p>在 <code>onSubmitWord()</code> 中，按照下列步驟修改空的 <code>if-else</code> 區塊。完整方法應如下所示。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubmitWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> playerWord = binding.textInputEditText.text.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModel.isUserWordCorrect(playerWord)) &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (!viewModel.nextWord()) &#123;</span><br><span class="line">            showFinalScoreDialog()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>為 <code>currentScrambledWord</code> <code>LiveData</code> 附加 observer。在 <code>GameFragment</code> 的 <code>onViewCreated()</code> callback 結尾中，於 <code>currentScrambledWord</code> 上呼叫 <code>observe()</code> 方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 觀察 currentScrambledWord 的 LiveData</span></span><br><span class="line">viewModel.currentScrambledWord.observe()</span><br></pre></td></tr></table></figure>
<ul>
<li>Android Studio 會顯示缺少參數的相關錯誤。您將在下一個步驟中修正錯誤。</li>
</ul>
<ol start="4">
<li><p>將 <code>viewLifecycleOwner</code> 做為第一個參數傳遞至 <code>observe()</code> 方法。<code>viewLifecycleOwner</code> 代表fragment 的 view 生命週期。此參數可協助 <code>LiveData</code> 留意 <code>GameFragment</code> 生命週期，且只有在 <code>GameFragment</code> 處於有效狀態 (<code>STARTED</code> 或 <code>RESUMED</code>) 時，才通知 observer。</p>
</li>
<li><p>使用 <code>newWord</code> 函式參數將 <code>lambda</code> 新增為第二個參數。<code>newWord</code> 將包含新的打散字詞值。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 觀察 scrambledCharArray LiveData，傳入 LifecycleOwner 和 observer</span></span><br><span class="line">viewModel.currentScrambledWord.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newWord -&gt;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>lambda</code> 運算式是未宣告的匿名函式，但會立即以運算式的形式傳遞。<code>lambda</code> 運算式一律會加上大括號 <code>&#123; &#125;</code>。</li>
</ul>
<ol start="6">
<li>在 <code>lambda</code> 運算式的函式主體中，將 <code>newWord</code> 指派至打散字詞 text view。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Observe the scrambledCharArray LiveData, passing in the LifecycleOwner and the observer.</span></span><br><span class="line">viewModel.currentScrambledWord.observe(viewLifecycleOwner,</span><br><span class="line">    <span class="comment">// 使用 newWord 函式參數將 lambda 新增為第二個參數，將 newWord 設為打散字詞 text view 的文字</span></span><br><span class="line">   &#123; newWord -&gt;</span><br><span class="line">       binding.textViewUnscrambledWord.text = newWord</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>編譯並執行應用程式。您的遊戲應用程式應可照常運作，但現在會在 <code>LiveData</code> observer 中 (而非在 <code>updateNextWordOnScreen()</code> 方法中) 自動更新打散字詞 text view。</li>
</ol>
<hr>
<h3 id="將-Observer-附加至分數和字詞計數"><a href="#將-Observer-附加至分數和字詞計數" class="headerlink" title="將 Observer 附加至分數和字詞計數"></a>將 Observer 附加至分數和字詞計數</h3><p>如同前一個工作，在這項工作中，您會將 <code>LiveData</code> 新增至應用程式的其他資料、分數和字詞計數中，使 UI 在遊戲期間能夠更新分數和字詞計數的正確值。</p>
<h4 id="步驟-1：使用-LiveData-包裝分數和字詞計數"><a href="#步驟-1：使用-LiveData-包裝分數和字詞計數" class="headerlink" title="步驟 1：使用 LiveData 包裝分數和字詞計數"></a>步驟 1：使用 LiveData 包裝分數和字詞計數</h4><ol>
<li><p>在 <code>GameViewModel</code> 中，將 <code>_score</code> 和 <code>_currentWordCount</code> 類別變數的類型變更為 <code>val</code>。</p>
</li>
<li><p>將變數 <code>_score</code> 和 <code>_currentWordCount</code> 的資料類型變更為 <code>MutableLiveData</code>，並將其初始化為 <code>0</code>。</p>
</li>
<li><p>將支援欄位類型變更為 <code>LiveData&lt;Int&gt;</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _score = MutableLiveData(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> score: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">   <span class="keyword">get</span>() = _score</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> _currentWordCount = MutableLiveData(<span class="number">0</span>)</span><br><span class="line"><span class="keyword">val</span> currentWordCount: LiveData&lt;<span class="built_in">Int</span>&gt;</span><br><span class="line">   <span class="keyword">get</span>() = _currentWordCount</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>reinitializeData()</code> 方法開頭的 <code>GameViewModel</code> 中，將 <code>_score</code> 和 <code>_currentWordCount</code> 的引用變更為 <code>_score.value</code> 和 <code>_currentWordCount.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reinitializeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _score.value = <span class="number">0</span></span><br><span class="line">   _currentWordCount.value = <span class="number">0</span></span><br><span class="line">   wordsList.clear()</span><br><span class="line">   getNextWord()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>nextWord()</code> 方法內的 <code>GameViewModel</code> 中，將 <code>_currentWordCount</code> 的參照變更為 <code>_currentWordCount.value!!</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nextWord</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (_currentWordCount.value!! &lt; MAX_NO_OF_WORDS) &#123;</span><br><span class="line">           getNextWord()</span><br><span class="line">           <span class="literal">true</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>在 <code>GameViewModel</code> 的 <code>increaseScore()</code> 和 <code>getNextWord()</code> 方法中，分別將 <code>_score</code> 和 <code>_currentWordCount</code> 的參照變更為 <code>_score.value</code> 和 <code>_currentWordCount.value</code>。Android Studio 會顯示錯誤，因為 <code>_score</code> 已不再是整數，而是 <code>LiveData</code>，您將在後續步驟中修正此錯誤。</p>
</li>
<li><p>使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/plus.html"><code>plus()</code></a> Kotlin 函式增加 <code>_score</code> 值，如此即可使用空值安全性執行加法。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">increaseScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 因 _score 改為 LiveData，使用 plus方法 取代「+」</span></span><br><span class="line">    _score.value = (_score.value)?.plus(SCORE_INCREASE)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>同樣地，您也可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/inc.html"><code>inc()</code></a> Kotlin 函式，使用空值安全性將值增加一。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        _currentScrambledWord.value = String(tempWord)</span><br><span class="line">        <span class="comment">// 因 _currentWordCount 改為 LiveData，使用 .inc()方法 取代「++」</span></span><br><span class="line">        _currentWordCount.value = (_currentWordCount.value)?.inc()</span><br><span class="line">        wordsList.add(currentWord)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在 <code>GameFragment</code> 中，使用 <code>value</code> 屬性存取 <code>score</code> 的值。在 <code>showFinalScoreDialog()</code> 方法中，將 <code>viewModel.score</code> 變更為 <code>viewModel.score.value</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showFinalScoreDialog</span><span class="params">()</span></span> &#123;</span><br><span class="line">   MaterialAlertDialogBuilder(requireContext())</span><br><span class="line">       .setTitle(getString(R.string.congratulations))</span><br><span class="line">       .setMessage(getString(R.string.you_scored, viewModel.score.value))</span><br><span class="line">       ...</span><br><span class="line">       .show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="步驟-2：將-Observer-附加至分數和字詞計數"><a href="#步驟-2：將-Observer-附加至分數和字詞計數" class="headerlink" title="步驟 2：將 Observer 附加至分數和字詞計數"></a>步驟 2：將 Observer 附加至分數和字詞計數</h4><p>應用程式中的分數和字詞計數不會更新。在這項工作中，您將使用 <code>LiveData</code> observer 進行更新。</p>
<ol>
<li>在 <code>GameFragment</code> 的 <code>onViewCreated()</code> 方法中 ，刪除更新分數和字詞計數 text view 的程式碼。</li>
</ol>
<p>移除：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.score.text = getString(R.string.score, <span class="number">0</span>)</span><br><span class="line">binding.wordCount.text = getString(R.string.word_count, <span class="number">0</span>, MAX_NO_OF_WORDS)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>GameFragment</code> 中 <code>onViewCreated()</code> 方法的結尾，為 <code>score</code> 附加 observer。將 <code>viewLifecycleOwner</code> 做為第一個參數傳遞至 observer，並使用 <code>lambda</code> 運算式做為第二個參數。在 <code>lambda</code> 運算式中，將新的分數做為參數傳遞，並在函式主體中，將新分數設為 text view 的文字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.score.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newScore -&gt;</span><br><span class="line">       binding.score.text = getString(R.string.score, newScore)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>onViewCreated()</code> 方法結尾，為 <code>currentWordCount</code> <code>LiveData</code> 附加 observer。將 <code>viewLifecycleOwner</code> 做為第一個參數傳遞至 observer，並使用 <code>lambda</code> 運算式做為第二個參數。在 <code>lambda</code> 運算式中，將新字詞計數做為參數傳遞，並在函式主體中，將新字詞計數與 <code>MAX_NO_OF_WORDS</code> 設為 text view 的文字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.currentWordCount.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newWordCount -&gt;</span><br><span class="line">       binding.wordCount.text =</span><br><span class="line">           getString(R.string.word_count, newWordCount, MAX_NO_OF_WORDS)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>在生命週期擁有者的生命週期期間 (即 <code>GameFragment</code>)，當 <code>ViewModel</code> 內的分數和字詞計數值發生變化時，就會觸發新的 observer。</li>
</ul>
<ol start="4">
<li>執行應用程式即可見證其奧妙之處。使用一些字詞進行遊戲。畫面上的分數和字詞計數也會正確更新。請注意，這些 text view 並不會根據程式碼的部分條件進行更新。<code>score</code> 和 <code>currentWordCount</code> 為 <code>LiveData</code>，且基礎值變更時，系統會自動呼叫對應的 observer。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-livedata/img/80e118245bdde6df_1920.png?hl=zh-tw" width="30%">

<hr>
<h3 id="將-LiveData-搭配-Data-Binding-使用"><a href="#將-LiveData-搭配-Data-Binding-使用" class="headerlink" title="將 LiveData 搭配 Data Binding 使用"></a>將 LiveData 搭配 Data Binding 使用</h3><p>在先前的工作中，您的應用程式會監聽程式碼中的 data 變更。同樣地，應用程式也可以監聽 layout 中的 data 變更。透過 <u><strong>Data Binding</strong></u>，<span class="label primary">當可觀察的 <b>LiveData</b> 值變更時，系統也會通知其<b>綁定(bind)</b>的 <b>layout</b> 中的 <b>UI 元素</b>，且可從 <b>layout</b> 中更新 <b>UI</b></span>。</p>
<h4 id="概念：Data-Binding"><a href="#概念：Data-Binding" class="headerlink" title="概念：Data Binding"></a>概念：Data Binding</h4><p>在先前的程式碼研究室中，您已瞭解單向的 view binding。您可以將 view 綁定(bind)至程式碼，但無法將程式碼綁定(bind)至 view。</p>
<h5 id="複習-View-Binding："><a href="#複習-View-Binding：" class="headerlink" title="複習 View Binding："></a>複習 View Binding：</h5><p>view binding 是一項可讓您更輕鬆地在程式碼中訪問 view 的功能。它會為各 XML layout 檔案產生 binding class。凡是在對應 layout 中具有 ID 的 view，binding class 的例項都會包含指向這些 view 的直接引用。舉例來說，Unscramble 應用程式目前使用 view binding，因此<u>使用產生的 binding class 可在程式碼中引用 view</u>。</p>
<p>範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.textViewUnscrambledWord.text = newWord</span><br><span class="line">binding.score.text = getString(R.string.score, newScore)</span><br><span class="line">binding.wordCount.text =</span><br><span class="line">                  getString(R.string.word_count, newWordCount, MAX_NO_OF_WORDS)</span><br></pre></td></tr></table></figure>
<ul>
<li>如果使用 view binding，就無法引用 view 中的應用程式資料 (layout檔案)。您可以使用 data binding 完成這項操作。</li>
</ul>
<h5 id="Data-Binding"><a href="#Data-Binding" class="headerlink" title="Data Binding"></a>Data Binding</h5><p>Data Binding 程式庫也屬於 Android Jetpack 程式庫的一部分。Data Binding 使用宣告式格式<span class="label primary">將 layout 中的 UI 元件 bind 至應用程式中的資料(data)來源</span>，稍後將在程式碼研究室中說明。</p>
<p>簡單來說，<strong>Data Binding</strong> 會將 <strong>data</strong> (從程式碼) <strong>bind</strong> 至 <span class="label primary"><b>View + View Binding</b></span> (將 view bind 至程式碼)︰</p>
<p>在 UI controller 中使用 view binding 的範例</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.textViewUnscrambledWord.text = viewModel.currentScrambledWord</span><br></pre></td></tr></table></figure>

<p>在 layout 檔案中使用 data binding 的範例</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;gameViewModel.currentScrambledWord&#125;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上範例說明如何使用 data binding 程式庫，直接將應用程式 data 指派至 layout 檔案中的 view&#x2F;widget(小工具)。請注意，指派運算式中使用 <code>@&#123;&#125;</code> 語法。</li>
</ul>
<p>使用 data binding 的主要優點在於，您可以移除 activity 中的許多 UI 架構呼叫，使其更加簡單且易於維護。這還可改善應用程式效能，避免發生記憶體流失及空值(null)指標例外狀況。</p>
<h4 id="步驟-1：變更資料繫結的檢視繫結"><a href="#步驟-1：變更資料繫結的檢視繫結" class="headerlink" title="步驟 1：變更資料繫結的檢視繫結"></a>步驟 1：變更資料繫結的檢視繫結</h4><ol>
<li>在 <code>build.gradle(Module)</code> 檔案中，啟用 <code>buildFeatures</code> 區段下的 <code>dataBinding</code> 屬性。</li>
</ol>
<p>將 </p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding <span class="keyword">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取代為</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">buildFeatures &#123;</span><br><span class="line">    dataBinding <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如要在任何 Kotlin 專案中使用 data binding，請套用 <code>kotlin-kapt</code> 外掛程式。此步驟已在 <code>build.gradle(Module)</code> 檔案中完成。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">   id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">   id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">   id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述步驟會自動為應用程式中的每個 layout XML 檔案產生 <strong>binding class</strong>，如果 layout 檔案名稱為 <code>activity_main.xml</code>，則自動產生的 class 將會稱為 <code>ActivityMainBinding</code>。</li>
</ul>
<h4 id="步驟-2：將-layout-檔案轉換為-Data-Binding-layout"><a href="#步驟-2：將-layout-檔案轉換為-Data-Binding-layout" class="headerlink" title="步驟 2：將 layout 檔案轉換為 Data Binding layout"></a>步驟 2：將 layout 檔案轉換為 Data Binding layout</h4><p>Data Binding layout 檔案略有不同，以 根(root) 標記 <code>&lt;layout&gt;</code> 為開頭，後面接著可選的 <code>&lt;data&gt;</code> 元素和 <code>view</code> 根(root) 元素。此 view 元素就是非綁定(bind) layout 檔案中的根(root)。</p>
<ol>
<li><p>開啟 <code>game_fragment.xml</code>，選取「Code」分頁標籤。</p>
</li>
<li><p>如要將 layout 轉換成 data binding layout，請將根(root)元素納入 <code>&lt;layout&gt;</code> 標記中。您也必須將命名空間定義 (開頭為 <code>xmlns:</code> 的屬性) 移至新的根(root)元素。在根(root)元素上方的 <code>&lt;layout&gt;</code> 標記中加入 <code>&lt;data&gt;&lt;/data&gt;</code> 標記。</p>
</li>
</ol>
<ul>
<li>Android Studio 提供可自動執行此作業的便利方法：在根(root)元素 <code>&lt;ScrollView&gt; </code>上按一下滑鼠右鍵，然後依序選取「Show Context Actions」&gt;「Convert to data binding layout」。</li>
</ul>
<ol start="3">
<li>layout 應如下所示：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">layout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">         <span class="attr">...</span></span></span><br><span class="line"><span class="tag">       &lt;/<span class="attr">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">layout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>GameFragment</code> 中，在 <code>onCreateView()</code> 方法的一開始，變更 <code>binding</code> 變數的 instance，以使用 data binding。</li>
</ol>
<p>將</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding = GameFragmentBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>取代為</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding = DataBindingUtil.inflate(inflater, R.layout.game_fragment, container, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>編譯程式碼；您應能夠順利編譯。您的應用程式現在會使用 data binding，layout 中的 view 也可存取應用程式的 data。</li>
</ol>
<hr>
<h3 id="新增-Data-Binding-變數"><a href="#新增-Data-Binding-變數" class="headerlink" title="新增 Data Binding 變數"></a>新增 Data Binding 變數</h3><p>在這項工作中，您必須在 layout 檔案中加入屬性，以便存取 <code>viewModel</code> 中的應用程式 data。您將初始化程式碼中的 layout 變數。</p>
<ol>
<li>在 <code>game_fragment.xml</code> 的 <code>&lt;data&gt;</code> 標記中，新增名為 <code>&lt;variable&gt;</code> 的子標記，宣告名為 <code>gameViewModel</code> 且類型(type)為 <code>GameViewModel</code> 的屬性。您會使用此方法<span class="label primary">將 <b>ViewModel</b> 中的 <b>data</b> 綁定(bind)至 <b>layout</b></span>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- 將 ViewModel 中的 data 綁定(bind)至 layout --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;gameViewModel&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;com.example.android.unscramble.ui.game.GameViewModel&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，<code>gameViewModel</code> 的類型包含套件名稱(package name)。請確認此套件名稱與應用程式中的套件名稱相符。</li>
</ul>
<ol start="2">
<li>在 <code>gameViewModel</code> 宣告下方，在 <code>&lt;data&gt;</code> 標記中加入另一個變數，並將其命名為 <code>maxNoOfWords</code>，類型(type)為 <code>Integer</code>。您將使用此方法綁定(bind)至 <code>ViewModel</code> 中的變數，以儲存每場遊戲的字詞數。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">data</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">&lt;!-- 每場遊戲的字詞數 --&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">variable</span></span></span><br><span class="line"><span class="tag">       <span class="attr">name</span>=<span class="string">&quot;maxNoOfWords&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">type</span>=<span class="string">&quot;int&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">data</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>onViewCreated()</code> 方法的開頭的 <code>GameFragment</code> 中，初始化 layout 變數 <code>gameViewModel</code> 和 <code>maxNoOfWords</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onViewCreated(view, savedInstanceState)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 初始化 layout 變數 gameViewModel 和 maxNoOfWords</span></span><br><span class="line">   binding.gameViewModel = viewModel</span><br><span class="line">   binding.maxNoOfWords = MAX_NO_OF_WORDS</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><code>LiveData</code> 可觀察生命週期，因此您必須將生命週期擁有者傳遞給 layout。在 <code>onViewCreated()</code> 方法內的 <code>GameFragment</code> 中，在綁定(bind)變數的初始化下方新增下列程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 將 fragment view 指定為 binding 的 lifecycle owner，以觀察 LiveData 更新</span></span><br><span class="line">binding.lifecycleOwner = viewLifecycleOwner</span><br></pre></td></tr></table></figure>
<ul>
<li>提醒您，您在實作 <code>LiveData</code> observer 時，也實作類似功能。您已將 <code>viewLifecycleOwner</code> 做為其中一個參數傳遞給 <code>LiveData</code> observer。</li>
</ul>
<hr>
<h3 id="使用-binding-運算式"><a href="#使用-binding-運算式" class="headerlink" title="使用 binding 運算式"></a>使用 binding 運算式</h3><p>binding 運算式會寫入屬性 (例如 <code>android:text</code>) layout 內，並參照 layout 屬性。layout 屬性會透過 <code>&lt;variable&gt;</code> 標記在 data binding layout 檔案的頂部進行宣告。當任何相依變數有所變更時，「DB Library」將執行 binding 運算式 (進而更新 view)。使用 data binding library時，此變更偵測是無須付費的最佳化功能。</p>
<h5 id="binding-運算式的語法"><a href="#binding-運算式的語法" class="headerlink" title="binding 運算式的語法"></a>binding 運算式的語法</h5><p>binding 運算式以 <code>@</code> 符號開頭，並加上大括號 <code>&#123;&#125;</code>。在以下範例中，將<code>TextView</code> 文字設為 <code>user</code> 變數的 <code>firstName</code> 屬性：</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">android:text</span>=<span class="string">&quot;@&#123;user.firstName&#125;&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="步驟-1：將-binding-運算式新增至目前字詞"><a href="#步驟-1：將-binding-運算式新增至目前字詞" class="headerlink" title="步驟 1：將 binding 運算式新增至目前字詞"></a>步驟 1：將 binding 運算式新增至目前字詞</h4><p>在此步驟中，您可以將目前的<u>字詞 text view</u> 綁定(bind)至 <u><code>ViewModel</code></u> 中的 <u><code>LiveData</code> 物件</u>。</p>
<ol>
<li>在 <code>game_fragment.xml</code> 中，請將 <code>text</code> 屬性新增至 <code>textView_unscrambled_word</code> text view。使用新的 layout 變數 <code>gameViewModel</code>，並將 <code>@&#123;gameViewModel.currentScrambledWord&#125;</code> 指派給 <code>text</code> 屬性。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/textView_unscrambled_word&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;gameViewModel.currentScrambledWord&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>GameFragment</code> 中，移除 <code>currentScrambledWord</code> 的 <code>LiveData</code> observer 程式碼： fragment 中不再需要使用 observer 程式碼。layout 會直接收到 <code>LiveData</code> 的變更更新。</li>
</ol>
<p>移除：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.currentScrambledWord.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newWord -&gt;</span><br><span class="line">       binding.textViewUnscrambledWord.text = newWord</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行您的應用程式，應用程式應可照常運作。不過，打散字詞 text view 目前使用 binding 運算式更新 UI，而非 <code>LiveData</code> observer。</li>
</ol>
<h4 id="步驟-2：將-binding-運算式新增至分數和字詞計數"><a href="#步驟-2：將-binding-運算式新增至分數和字詞計數" class="headerlink" title="步驟 2：將 binding 運算式新增至分數和字詞計數"></a>步驟 2：將 binding 運算式新增至分數和字詞計數</h4><h5 id="data-binding-運算式的資源"><a href="#data-binding-運算式的資源" class="headerlink" title="data binding 運算式的資源"></a>data binding 運算式的資源</h5><p>data binding 運算式可透過下列語法引用應用程式資源。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:padding=&quot;@&#123;@dimen/largePadding&#125;&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li>在上述範例中，系統會為 <code>padding</code> 屬性指派 <code>dimen.xml</code> 資源檔案的 <code>largePadding</code> 值。</li>
</ul>
<p>您也可以傳遞 layout 屬性做為資源參數。</p>
<p>範例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:text=&quot;@&#123;@string/example_resource(user.lastName)&#125;&quot;</span><br></pre></td></tr></table></figure>

<p><code>strings.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;example_resource&quot;</span>&gt;</span>Last Name: %s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在上述範例中，<code>example_resource</code> 是具有<code> %s</code> 預留位置的字串資源。您會將 <code>user.lastName</code> 做為資源參數傳入 binding 運算式，其中 <code>user</code> 是 layout 變數。</li>
</ul>
<p>在此步驟中，您會將 binding 運算式新增至分數和字詞計數 text view，並傳入資源參數。這個步驟與您為上述 <code>textView_unscrambled_word</code> 所做操作類似。</p>
<ol>
<li>在 <code>game_fragment.xml</code> 中，使用以下 binidng 運算式更新 <code>word_count</code> text view 的 <code>text</code> 屬性。使用 <code>word_count</code> 字串資源，並將 <code>gameViewModel.currentWordCount</code> 和 <code>maxNoOfWords</code> 做為資源參數傳入。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/word_count&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/word_count(gameViewModel.currentWordCount, maxNoOfWords)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用以下 binding 運算式更新 <code>score</code> text view 的 <code>text</code> 屬性。使用 <code>score</code> 字串資源，並傳入 <code>gameViewModel.score</code> 做為資源參數。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/score&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;@&#123;@string/score(gameViewModel.score)&#125;&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>從 <code>GameFragment</code> 中移除 <code>LiveData</code> observer。您已無需使用這些 observer，binding 運算式會在對應 <code>LiveData</code> 變更時更新 UI。</li>
</ol>
<p>移除：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">viewModel.score.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newScore -&gt;</span><br><span class="line">       binding.score.text = getString(R.string.score, newScore)</span><br><span class="line">   &#125;)</span><br><span class="line"></span><br><span class="line">viewModel.currentWordCount.observe(viewLifecycleOwner,</span><br><span class="line">   &#123; newWordCount -&gt;</span><br><span class="line">       binding.wordCount.text =</span><br><span class="line">           getString(R.string.word_count, newWordCount, MAX_NO_OF_WORDS)</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式，使用一些字詞進行遊戲。現在，您的程式碼會使用 <code>LiveData</code> 和 binding 運算式更新 UI。</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-livedata/img/7880e60dc0a6f95c_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-livedata/img/9ef2fdf21ffa5c99_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>恭喜！您已瞭解如何將 <code>LiveData</code> observer 搭配 <code>LiveData</code> 使用，以及將 <code>LiveData</code> 搭配 binding 運算式使用。</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><code>LiveData</code> 可保存資料；<code>LiveData</code> 包裝函式可與任何資料搭配使用</li>
<li><code>LiveData</code> 可觀察，這表示當 <code>LiveData</code> 物件保存的資料變更時，observer 會接收通知。</li>
<li><code>LiveData</code> 可感知生命週期。將 observer 附加至 <code>LiveData</code> 時，observer 會與 <code>LifecycleOwner</code> 建立關聯 (通常是 activity 或 fragment)。<code>LiveData</code> 只會更新處於有效生命週期狀態 (例如 <code>STARTED</code> 或 <code>RESUMED</code>) 的 observer。</li>
<li>應用程式可以透過 data binding 和 binding 運算式監聽 layout 中的 <code>LiveData</code> 變更。</li>
<li>binding 運算式會寫入屬性 (例如 <code>android:text</code>) layout 內，並引用 layout 屬性。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>View Binding</tag>
        <tag>UI Controller</tag>
        <tag>ViewModel</tag>
        <tag>LiveData</tag>
        <tag>MutableLiveData</tag>
        <tag>Observer</tag>
        <tag>Data Binding</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(26)-將資料儲存於ViewModel中</title>
    <url>/2023/11/05/Android%E7%AD%86%E8%A8%98-26-%E5%B0%87%E8%B3%87%E6%96%99%E5%84%B2%E5%AD%98%E6%96%BCViewModel%E4%B8%AD/</url>
    <content><![CDATA[<blockquote>
<p>瞭解如何使用 <code>ViewModel</code> 架構元件來儲存應用程式資料。如果在設定變更或其他事件期間，刪除架構並重新建立 activity 和 fragment，儲存的資料不會遺失。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>Android 應用程式架構基本概念簡介。</li>
<li>如何在應用程式中使用 <code>ViewModel</code> 類別。</li>
<li>如何使用 <code>ViewModel</code>，透過裝置設定變更保留 UI 資料。</li>
<li>Kotlin 的幕後屬性。</li>
<li>如何使用質感設計元件庫中的 <code>MaterialAlertDialog</code>。</li>
<li>建立 <code>Unscramble</code> 遊戲應用程式，可讓使用者猜測打散的字詞。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h3><h4 id="遊戲總覽"><a href="#遊戲總覽" class="headerlink" title="遊戲總覽"></a>遊戲總覽</h4><p><code>Unscramble</code> 應用程式為單人字詞重組遊戲。本應用程式一次會顯示一個打散的字詞，且玩家必須使用打散的所有字母猜出這個字詞。只要字詞正確無誤，玩家即可得分，否則玩家可任意進行嘗試。應用程式也具備略過目前字詞的選項。應用程式左上角會顯示字詞計數，也就是目前遊戲中已遊玩過的字詞數。每場遊戲共有 10 字。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/8edd6191a40a57e1_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/992bf57f066caf49_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/b82a9817b5ec4d11_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>如果您使用 GitHub 中的範例程式碼，請注意資料夾名稱是 <code>android-basics-kotlin-unscramble-app-starter</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><a href="https://github.com/google-developer-training/android-basics-kotlin-unscramble-app/tree/starter">https://github.com/google-developer-training/android-basics-kotlin-unscramble-app/tree/starter</a><br><strong>含有範例程式碼的模組名稱：</strong> <b>starter</b></p>
          </div>

<h4 id="範例程式碼總覽"><a href="#範例程式碼總覽" class="headerlink" title="範例程式碼總覽"></a>範例程式碼總覽</h4><ol>
<li>在 Android Studio 中開啟含有範例程式碼的專案。</li>
<li>在 Android 裝置或模擬器上執行應用程式。</li>
<li>透過數個字詞進行遊戲，請輕觸「提交」和「略過」按鈕。 請注意，輕觸按鈕時會顯示下一個字詞，並增加字詞計數。</li>
<li>請留意，分數只會在輕觸「Submit」按鈕時提升。</li>
</ol>
<h4 id="範例程式碼相關問題"><a href="#範例程式碼相關問題" class="headerlink" title="範例程式碼相關問題"></a>範例程式碼相關問題</h4><p>玩遊戲時，您可能已注意到下列錯誤：</p>
<ol>
<li>按一下「Submit」按鈕時，應用程式不會檢查玩家的字詞。玩家總是可以得分。</li>
<li>無法結束遊戲。應用程式可讓您遊玩超過 10 個字詞。</li>
<li>遊戲畫面會顯示打散的字詞、玩家分數和字詞計數。旋轉裝置或模擬器變更螢幕方向。請注意，目前的字詞、分數和字詞計數都會消失，遊戲也會重新開始。</li>
</ol>
<h5 id="應用程式的主要問題"><a href="#應用程式的主要問題" class="headerlink" title="應用程式的主要問題"></a>應用程式的主要問題</h5><p>設定變更時 (例如裝置螢幕方向變更)，範例應用程式不會儲存及還原應用程式狀態和資料。<br>您可以使用 <code>onSaveInstanceState()</code> callback 解決此問題。不過，使用 <code>onSaveInstanceState()</code> 方法時，您必須編寫額外的程式碼將狀態儲存在套件中，並實作邏輯以擷取該狀態。此外，可儲存的資料量極少。<br>您可以使用在本課程所學到的 Android 架構元件來解決這些問題。</p>
<h4 id="範例程式碼逐步操作說明"><a href="#範例程式碼逐步操作說明" class="headerlink" title="範例程式碼逐步操作說明"></a>範例程式碼逐步操作說明</h4><p>您下載的範例程式碼包含已為您預先設計的遊戲畫面版面配置。本課程重點為實作遊戲邏輯。您需要使用架構元件來實作建議的應用程式架構，並解決上述問題。以下是部分檔案的簡要逐步操作說明，可協助您快速上手。</p>
<p><code>game_fragment.xml</code></p>
<ul>
<li>在「設計」檢視畫面中開啟 <code>res/layout/game_fragment.xml</code>。</li>
<li>這包含應用程式中唯一畫面的版面配置，也就是遊戲畫面。</li>
<li>此版面配置包含玩家字詞的文字欄位，以及顯示分數和字詞計數的 <code>TextViews</code>。另外還提供說明、「Submit」按鈕和「Skip」按鈕，方便玩遊戲。</li>
</ul>
<p><code>main_activity.xml</code><br>以單一遊戲片段定義主要 activity 版面配置。</p>
<p><code>res/values</code> 資料夾</p>
<ul>
<li><code>colors.xml</code> 包含應用程式中使用的主題色彩</li>
<li><code>strings.xml</code> 包含應用程式所需的所有字串</li>
<li><code>themes</code> 和 <code>styles</code> 資料夾內含應用程式的 UI 自訂項目</li>
</ul>
<p><code>MainActivity.kt</code><br>包含預設範本產生的程式碼，可將 activity 的內容檢視畫面設為 <code>main_activity.xml</code>。</p>
<p><code>ListOfWords.kt</code><br>此檔案內含遊戲中使用的字詞清單、每場遊戲字詞數量上限，以及玩家針對每個正確字詞所得分數的常數。</p>
<p><code>GameFragment.kt</code><br>這是應用程式中唯一的 fragment，也是大部分遊戲動作發生處：</p>
<ul>
<li>變數是根據目前打散的字詞 (<code>currentScrambledWord</code>)、字詞計數 (<code>currentWordCount</code>) 和分數 (<code>score</code>) 所定義。</li>
<li>已定義可存取名為 <code>binding</code> 之 <code>game_fragment</code> 檢視畫面的 binding 物件 instance。</li>
<li><code>onCreateView()</code> 函式會使用 binding 物件加載 <code>game_fragment</code> 版面配置 XML。</li>
<li><code>onViewCreated()</code> 函式會設定按鈕點選監聽器，並更新 UI。</li>
<li><code>onSubmitWord()</code> 是「提交」按鈕的點擊事件監聽器，此函式會顯示下一個打散的字詞、清除文字欄位，並在未驗證玩家字詞的情況下增加分數和字詞計數。</li>
<li><code>onSkipWord()</code> 是「略過」按鈕的點擊事件監聽器，此函式會更新與 <code>onSubmitWord()</code> 類似的 UI (分數除外)。</li>
<li><code>getNextScrambledWord()</code> 是一項輔助函式，其可從字詞清單中挑選隨機字詞，並隨機排序這些字母。</li>
<li>系統會分別使用 <code>restartGame()</code> 和 <code>exitGame()</code> 函式重新啟動及結束遊戲，您稍後將會使用這些函式。</li>
<li><code>setErrorTextField()</code> 可清除文字欄位內容，並重設錯誤狀態。</li>
<li><code>updateNextWordOnScreen()</code> 函式可顯示新的打散字詞。</li>
</ul>
<hr>
<h3 id="瞭解應用程式架構"><a href="#瞭解應用程式架構" class="headerlink" title="瞭解應用程式架構"></a>瞭解應用程式架構</h3><p>架構可提供相關規範，協助您在應用程式內分配類別間的責任。設計良好的應用程式架構可協助您擴大應用程式，並於日後擴充其他功能。此外，也能讓團隊更輕鬆進行協作。<br>最常見的<a href="https://developer.android.com/jetpack/guide?hl=zh-tw#common-principles">架構原則</a>為：關注點分離，以及透過模型使用 UI。</p>
<p><strong>關注點分離</strong><br>關注點分離的設計原則為，應用程式應區分成不同類別，每個類別具有不同責任。</p>
<p><strong>透過模型使用 UI</strong><br>另一個重要原則是，您應透過模型 (建議為持續性模型) 使用 UI。模型是負責處理應用程式資料的元件。模型與應用程式中的 <code>Views</code> 和應用程式元件無關，因此不受應用程式的生命週期和相關關注點影響。</p>
<p>Android 架構中的主要類別或元件包括 UI controller (activity&#x2F;fragment)、<code>ViewModel</code>、<code>LiveData</code> 和 <code>Room</code>。這些元件負責生命週期的部分複雜度，且可避免發生生命週期相關問題。您將在後續的程式碼研究室中學習 <code>LiveData</code> 和 <code>Room</code>。</p>
<p>下圖為架構的基本部分：<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/597074ed0d08947b_1920.png?hl=zh-tw" width="80%"></p>
<h4 id="UI-Controller-activity-fragment"><a href="#UI-Controller-activity-fragment" class="headerlink" title="UI Controller (activity&#x2F;fragment)"></a>UI Controller (activity&#x2F;fragment)</h4><p>activity 和 fragment 為 UI controller。UI controller 可控制 UI，方法包括<u>在畫面產生 view</u>、<u>擷取使用者事件</u>，以及<u>與使用者互動之 UI 相關的任何其他內容</u>。App 中的資料或與這些資料相關的決策邏輯不應屬於 UI controller 類別。</p>
<p>Android 系統可能會因為特定使用者互動或記憶體不足等系統情況，而隨時刪除 UI controller。由於這些事件不在您的控管之下，您<u>不應在 UI controller 中儲存任何應用程式資料或狀態</u>。反之，<u>應該在 <code>ViewModel</code> 中新增資料相關的決策邏輯</u>。</p>
<p>舉例來說，Unscramble 應用程式中的打散字詞、分數和字詞計數會顯示於 fragment (UI controller) 中。<u>決策程式碼應位於 <code>ViewModel</code> 中</u>，例如判斷下一個打散的字詞，以及分數和字詞計數的計算。</p>
<h4 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h4><p><code>ViewModel</code> 是 view 中顯示的應用程式資料(data)模型。模型是負責處理應用程式資料的元件。其可讓您的應用程式遵循<u>透過模型使用 UI </u>的架構原則。</p>
<p>activity 或 fragment 遭到 Android 架構刪除並重新建立時，未刪除的應用程式相關資料會由 <code>ViewModel</code> 進行儲存。在設定變更期間，系統會自動保留 <code>ViewModel</code> 物件 (不會像 activity 或 fragment instance一般遭到刪除)，讓處於保留狀態的資料立即用於下一個 activity 或 fragment instance。</p>
<p>如要在應用程式中實作 <code>ViewModel</code>，請擴充架構元件庫中的 <code>ViewModel</code> 類別，並將應用程式資料儲存在該類別中。</p>
<p><strong>★總結：</strong> </p>
<table>
<thead>
<tr>
<th align="left">fragment&#x2F;activity (UI controller) 責任</th>
<th align="left">ViewModel 責任</th>
</tr>
</thead>
<tbody><tr>
<td align="left">activity 和 fragment 應負責<strong>在畫面中產生 view 和資料(data)</strong> ，並回應使用者事件。</td>
<td align="left">ViewModel 負責<strong>保留及處理 UI 所需的所有資料</strong>。其不得存取 view 階層 (例如 view binding 物件)，或保留 activity&#x2F;fragment 的引用。</td>
</tr>
</tbody></table>
<hr>
<h3 id="新增-ViewModel"><a href="#新增-ViewModel" class="headerlink" title="新增 ViewModel"></a>新增 ViewModel</h3><p>在這項工作中，您需將 <code>ViewModel</code> 新增至應用程式，以儲存應用程式資料 (打散的字詞、字詞計數和分數)。</p>
<p>您的應用程式架構如下。<code>MainActivity</code> 包含 <code>GameFragment</code>，而 <code>GameFragment</code> 會從 <code>GameViewModel</code> 存取遊戲的相關資訊。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/2b29a13dde3481c3_1920.png?hl=zh-tw" width="40%">

<ol>
<li><p>在 Android Studio 中，「Android」 視窗的「Gradle Scripts」資料夾下，開啟 <code>build.gradle(Module:Unscramble.app)</code> 檔案。</p>
</li>
<li><p>如要在應用程式中使用 <code>ViewModel</code>，請確認 <code>dependencies</code> 區塊中具有 ViewModel 程式庫依附元件。此步驟已經完成。視程式庫的最新版本而定，所產生程式碼中的程式庫版本編號可能有所不同。</p>
</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ViewModel</span></span><br><span class="line">implementation <span class="string">&#x27;androidx.lifecycle:lifecycle-viewmodel-ktx:2.3.1&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立名為 <code>GameViewModel</code> 的新 Kotlin 類別檔案。在「Android」視窗中，於「ui.game」資料夾上按一下滑鼠右鍵。選取「New」&gt;「Kotlin File&#x2F;Class」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/d48361a4f73d4acb_1920.png?hl=zh-tw">

<ol start="4">
<li><p>輸入名稱 <code>GameViewModel</code>，然後從清單中選取「Class」。</p>
</li>
<li><p>將 <code>GameViewModel</code> 變更為 <code>ViewModel</code> 的子類別。<code>ViewModel</code> 為抽象類別，因此您必須將其擴充，才能在應用程式中使用。請參閱下方的 <code>GameViewModel</code> 類別定義。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="將-ViewModel-附加至-fragment"><a href="#將-ViewModel-附加至-fragment" class="headerlink" title="將 ViewModel 附加至 fragment"></a>將 ViewModel 附加至 fragment</h4><p>如要建立 <code>ViewModel</code> 與 UI controller (activity&#x2F;fragment) 的關聯，請在 UI controller 內建立 <code>ViewModel</code> 的引用 (物件)。</p>
<p>在這個步驟中，您會在對應的 UI controller (GameFragment) 中建立 <code>GameViewModel</code> 的 object instance。</p>
<ol>
<li>在 <code>GameFragment</code> 類別頂部新增 <code>GameViewModel</code> 類型的屬性。</li>
<li>使用 <code>by viewModels()</code> Kotlin 屬性委派功能將 <code>GameViewModel</code> 初始化。您將在下一節深入瞭解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel: GameViewModel <span class="keyword">by</span> viewModels()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>如果 Android Studio 顯示提示，請匯入 <code>androidx.fragment.app.viewModels</code>。</li>
</ol>
<h4 id="Kotlin-屬性委派"><a href="#Kotlin-屬性委派" class="headerlink" title="Kotlin 屬性委派"></a>Kotlin 屬性委派</h4><p>在 Kotlin 中，每個<u>可變動 (var) 屬性</u>都會<u>自動產生屬性的 <code>getter</code> 和 <code>setter</code> 函式</u>。當您<u>指派值或讀取屬性值</u>時，系統將會呼叫 <code>setter</code> 和 <code>getter</code> 函式。</p>
<p><u>唯讀屬性 (val)</u> 與可變動屬性稍有不同。根據預設，<u>只會產生 getter 函式</u>。<u>讀取唯讀屬性的值</u>時，系統會呼叫 getter 函式。</p>
<ul>
<li>Kotlin 中的屬性委派功能可協助您將 <code>getter-setter</code> 責任移交給其他類別。</li>
<li>此類別 (稱為「委派類別」) 可提供屬性的 <code>getter</code> 和 <code>setter</code> 函式，並處理其變更。</li>
</ul>
<p>委派屬性是使用 <code>by</code> 子句和委派類別 instance 來定義：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Syntax for property delegation</span></span><br><span class="line"><span class="keyword">var</span> &lt;property-name&gt; : &lt;property-type&gt; <span class="keyword">by</span> &lt;delegate-<span class="keyword">class</span>&gt;()</span><br></pre></td></tr></table></figure>

<p>在應用程式中，如使用預設的 <code>GameViewModel</code> 建構函式初始化 view model，則如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> viewModel = GameViewModel()</span><br></pre></td></tr></table></figure>

<p>裝置經過設定變更後，應用程式將失去 <code>viewModel</code> 引用的狀態。舉例來說，如果您旋轉裝置，系統就會刪除並重新建立 activity，而您將再次擁有具備初始狀態的新 view model。</p>
<p>請改用屬性委派方法，並將 <code>viewModel</code> 物件的責任委派給另一個名為 <code>viewModels</code> 的類別。這代表當您存取 <code>viewModel</code> 物件時，該物件會由委派類別 <code>viewModels</code> 於內部進行處理。委派類別會在第一次存取時為您建立 <code>viewModel</code> 物件，並透過設定變更保留其值，並在要求時傳回該值。</p>
<hr>
<h3 id="將資料移至-ViewModel"><a href="#將資料移至-ViewModel" class="headerlink" title="將資料移至 ViewModel"></a>將資料移至 ViewModel</h3><p>將應用程式的 UI data 與 UI controller (Activity &#x2F; Fragment 類別) 分離，以便您充分遵循上述單一責任原則。您的 activity 和 fragment 負責在畫面中產生 view 和 data，ViewModel 則負責保留及處理 UI 所需的所有資料。</p>
<p>在這項工作中，您必須將資料變數從 <code>GameFragment</code> 移至 <code>GameViewModel</code> 類別。</p>
<ol>
<li>將資料變數 <code>score</code>、<code>currentWordCount</code>、<code>currentScrambledWord</code> 移至 <code>GameViewModel</code> 類別。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> score = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentWordCount = <span class="number">0</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> currentScrambledWord = <span class="string">&quot;test&quot;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>請注意未解決的參照錯誤。這是因為屬性僅供 <code>ViewModel</code> 使用，且無法由 UI 控制器進行存取。您將在下一個步驟修正這些錯誤。</li>
</ol>
<p>如要解決這個問題，屬性的可見度修飾符不得為 <code>public</code>，資料不可由其他類別編輯。此操作具有風險，因為外部類別可能會以非預期的方式，變更未遵循檢視模式中指定遊戲規則的資料。舉例來說，外部類別可以將 <code>score</code> 變更為負值。</p>
<p><code>ViewModel</code> 內的資料應可編輯，因此應為 <code>private</code> 和 <code>var</code>。在 <code>ViewModel</code> 外部，資料應可供讀取，但無法編輯，因此資料應以 <code>public</code> 和 <code>val</code> 的形式呈現。為了達成這個行為，Kotlin 提供名為<a href="https://kotlinlang.org/docs/properties.html#backing-properties">幕後屬性(Backing properties)</a>的功能。</p>
<h4 id="幕後屬性"><a href="#幕後屬性" class="headerlink" title="幕後屬性"></a>幕後屬性</h4><p>幕後屬性可讓您從 <code>getter</code> 傳回確切物件以外的項目。<br>您已瞭解 Kotlin 架構會為每個屬性產生 <code>getter</code> 和 <code>setter</code>。<br><code>getter</code> 和 <code>setter</code> 方法可覆寫此類方法 (一或兩種)，並提供您自訂的行為。如要實作幕後屬性，您將會覆寫 <code>getter</code> 方法，以傳回唯讀資料版本。幕後屬性範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Declare private mutable variable that can only be modified</span></span><br><span class="line"><span class="comment">// within the class it is declared.</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare another public immutable field and override its getter method.</span></span><br><span class="line"><span class="comment">// Return the private property&#x27;s value in the getter method.</span></span><br><span class="line"><span class="comment">// When count is accessed, the get() function is called and</span></span><br><span class="line"><span class="comment">// the value of _count is returned.</span></span><br><span class="line"><span class="keyword">val</span> count: <span class="built_in">Int</span></span><br><span class="line">   <span class="keyword">get</span>() = _count</span><br></pre></td></tr></table></figure>

<p>舉例來說，假設您想在應用程式內，將應用程式資料設為僅供 <code>ViewModel</code> 使用：</p>
<p>在 <code>ViewModel</code> 類別中：</p>
<ul>
<li><code>_count</code> 屬性為 <code>private</code>，且可變動。因此，只能在 <code>ViewModel</code> 類別中進行存取及編輯。慣例是在 <code>private</code> 屬性字首加上底線。</li>
</ul>
<p><code>ViewModel</code> 類別外：</p>
<ul>
<li>Kotlin 中的預設瀏覽權限修飾符為 <code>public</code>，因此 <code>count</code> 是公開狀態，且可從 UI controller 等其他類別存取。由於只有 <code>get()</code> 方法遭到覆寫，因此這個屬性不可變動且為唯讀。外部類別存取這個屬性時，系統會傳回 <code>_count</code> 的值，且該值無法修改。這種做法可確保 <code>ViewModel</code> 中的應用程式資料不會受到外部類別非必要和不安全的變更，但可讓外部呼叫者安全地存取其值。</li>
</ul>
<h4 id="將幕後屬性新增至-currentScrambledWord"><a href="#將幕後屬性新增至-currentScrambledWord" class="headerlink" title="將幕後屬性新增至 currentScrambledWord"></a>將幕後屬性新增至 currentScrambledWord</h4><ol>
<li>在 <code>GameViewModel</code> 中，變更 <code>currentScrambledWord</code> 宣告以新增幕後屬性。目前您只能在 <code>GameViewModel</code> 中存取及編輯 <code>_currentScrambledWord</code>。UI controller <code>GameFragment</code> 可以使用唯讀屬性 <code>currentScrambledWord</code> 讀取其值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _currentScrambledWord = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="keyword">val</span> currentScrambledWord: String</span><br><span class="line">   <span class="keyword">get</span>() = _currentScrambledWord</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>GameFragment</code> 中，更新 <code>updateNextWordOnScreen()</code> 方法，以使用唯讀的 <code>viewModel</code> 屬性 <code>currentScrambledWord</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">updateNextWordOnScreen</span><span class="params">()</span></span> &#123;</span><br><span class="line">   binding.textViewUnscrambledWord.text = viewModel.currentScrambledWord</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>GameFragment</code> 中，刪除 <code>onSubmitWord()</code> 和 <code>onSkipWord()</code> 方法中的程式碼。您將於稍後實作這些方法。您現在應該能夠正確編譯程式碼，而不會產生錯誤。</li>
</ol>
<div class="note no-icon danger">
            <p><strong>警告：</strong> 請勿揭露 <b>ViewModel</b> 中的可變動資料欄位。請確認此資料無法從其他類別進行修改。<b>ViewModel</b> 中的可變動資料一律為 <b>private</b>。</p>
          </div>

<hr>
<h3 id="ViewModel-的生命週期"><a href="#ViewModel-的生命週期" class="headerlink" title="ViewModel 的生命週期"></a>ViewModel 的生命週期</h3><p>只要 activity 或 fragment 的範圍保持運作，該架構就會使 <code>ViewModel</code> 保持運作。如果 <code>ViewModel</code> 的擁有者因設定變更 (例如螢幕旋轉) 而遭到刪除，系統並不會將其刪除。擁有者的新 instance 會重新連線至現有的 <code>ViewModel</code> instance，如下圖所示：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/91227008b74bf4bb_1920.png?hl=zh-tw">

<h4 id="瞭解-ViewModel-生命週期"><a href="#瞭解-ViewModel-生命週期" class="headerlink" title="瞭解 ViewModel 生命週期"></a>瞭解 ViewModel 生命週期</h4><p>在 <code>GameViewModel</code> 和 <code>GameFragment</code> 中新增記錄功能，以進一步瞭解 <code>ViewModel</code> 的生命週期。</p>
<ol>
<li>在 <code>GameViewModel.kt</code> 中，新增含有記錄陳述式的 <code>init</code> 區塊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GameViewModel</span> : <span class="type">ViewModel</span>() &#123;</span><br><span class="line">   <span class="keyword">init</span> &#123;</span><br><span class="line">       Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;GameViewModel created!&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Kotlin 會提供初始化器區塊 (也稱為 <code>init</code> 區塊)，做為物件 instance 初始化期間，所需初始設定程式碼的位置。初始化器區塊的前面會加上 <code>init</code> 關鍵字，後為大括號 {}。這個程式碼區塊會在首次建立並初始化物件 instance 時執行。</li>
</ul>
<ol start="2">
<li><p>在 <code>GameViewModel</code> 類別中，覆寫 <code>onCleared()</code> 方法(Control+o)。在您卸離相關 fragment 或 activity 完成後，系統會將 <code>ViewModel</code> 刪除。在 <code>ViewModel</code> 刪除之前，系統會呼叫 <code>onCleared()</code> callback。</p>
</li>
<li><p>在 <code>onCleared()</code> 中新增記錄(log)陳述式，以追蹤 <code>GameViewModel</code> 生命週期。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCleared</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCleared()</span><br><span class="line">    Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;GameViewModel destroyed!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>GameFragment</code> 的 <code>onCreateView()</code> 中找到 binding 物件引用後，請新增 log 陳述式以記錄 fragment 的建立作業。初次建立及每次重新建立 (例如設定變更等事件) fragment 時，系統會觸發 <code>onCreateView()</code> callback。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">   savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View &#123;</span><br><span class="line">   binding = GameFragmentBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">   Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;GameFragment created/re-created!&quot;</span>)</span><br><span class="line">   <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>GameFragment</code> 中覆寫 <code>onDetach()</code> callback 方法，以在對應的 activity 和 fragment 刪除時呼叫此方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDetach</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDetach()</span><br><span class="line">    Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;GameFragment destroyed!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 Android Studio 中執行應用程式，開啟「Logcat」視窗，然後篩選 <code>GameFragment</code>。請注意，<code>GameFragment</code> 和 <code>GameViewModel</code> 已建立。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameViewModel created!</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>在裝置或模擬器上啟用自動旋轉設定，並變更螢幕方向數次。每次都會刪除並重新建立 <code>GameFragment</code>，但 <code>GameViewModel</code> 只會建立一次，而且不會在每次呼叫時重新建立或刪除。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameViewModel created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>離開遊戲，或使用返回箭頭離開應用程式。<code>GameViewModel</code> 已刪除，並呼叫 <code>onCleared()</code> callback。<code>GameFragment</code> 已刪除。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">com.example.android.unscramble D/GameFragment: GameViewModel destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="填入-ViewModel"><a href="#填入-ViewModel" class="headerlink" title="填入 ViewModel"></a>填入 ViewModel</h3><p>在這項工作中，您將使用輔助方法進一步填入 <code>GameViewModel</code>，以便取得下一個字詞、驗證玩家的字詞能否增加分數，並檢查字詞計數來結束遊戲。</p>
<h4 id="延遲初始化"><a href="#延遲初始化" class="headerlink" title="延遲初始化"></a>延遲初始化</h4><p>通常在宣告變數時，您必須先提供初始值。不過，如果您還沒準備好指派值，可以稍後再進行初始化。為了延遲在 Kotlin 中初始化屬性，您可以使用關鍵字 <code>lateinit</code>，表示延遲初始化。如果您確保在使用前先初始化屬性，可以使用 <code>lateinit</code> 宣告屬性。記憶體必須先初始化，才能分配給變數。如果您在初始化之前就嘗試存取變數，應用程式將會異常終止。</p>
<h4 id="取得下一個字詞"><a href="#取得下一個字詞" class="headerlink" title="取得下一個字詞"></a>取得下一個字詞</h4><p>在 <code>GameViewModel</code> 類別中建立 <code>getNextWord()</code> 方法，且具備下列功能：</p>
<ul>
<li>從 <code>allWordsList</code> 取得隨機字詞，並將其指派給 <code>currentWord</code>.</li>
<li>將 <code>currentWord</code> 中的字母打散，以產生打散的字詞，並將其指派給 <code>currentScrambledWord</code></li>
<li>處理打散與未打散字詞相同的情形。</li>
<li>請確定您在遊戲期間不會重複出現相同的字詞。</li>
</ul>
<p>請在 <code>GameViewModel</code> 類別中執行下列步驟：</p>
<ol>
<li>於 <code>GameViewModel</code>, 中，新增 <code>MutableList&lt;String&gt;</code> 類型的新類別變數 (名為 <code>wordsList</code>)，以保留遊戲中使用的字詞清單，避免重複出現。</li>
<li>新增另一個名為 <code>currentWord</code> 的類別變數，以保留玩家嘗試重組的字詞。由於您稍後會初始化此屬性，請使用 <code>lateinit</code> 關鍵字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> wordsList: MutableList&lt;String&gt; = mutableListOf()</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> currentWord: String</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>init</code> 區塊上新增名為 <code>getNextWord()</code> 的新 <code>private</code> 方法，且無不會傳回任何內容的參數。</li>
<li>從 <code>allWordsList</code> 取得隨機字詞，並將其指派給 <code>currentWord</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">   currentWord = allWordsList.random()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>getNextWord()</code> 中，將 <code>currentWord</code> 字串轉換為字元陣列，並將其指派給名為 <code>tempWord</code> 的新 <code>val</code>。如要打散字詞，請使用 Kotlin 方法 <code>shuffle()</code> 隨機變換此陣列中的字元。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tempWord = currentWord.toCharArray()</span><br><span class="line">tempWord.shuffle()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Array</code> 與 <code>MutableList</code> 相似，但其初始化時有固定的大小。<code>Array</code> 無法展開或縮減大小 (您必須複製陣列才能調整大小)，而 <code>MutableList</code> 具有 <code>add()</code> 和 <code>remove()</code> 函式，因此可以調整大小。</li>
</ul>
<ol start="6">
<li>有時，隨機變換後的字元順序會與原始字詞相同。在要隨機變換的呼叫周圍加上下列 <code>while</code> 迴圈，以在打散字詞不同於原始字詞前持續進行迴圈。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (String(tempWord).equals(currentWord, <span class="literal">false</span>)) &#123;</span><br><span class="line">    tempWord.shuffle()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>新增 <code>if-else</code> 區塊，以確認是否已使用字詞。如果 <code>wordsList</code> 包含 <code>currentWord</code>，請呼叫 <code>getNextWord()</code>。如果沒有，請以剛打散的字詞更新 <code>_currentScrambledWord</code> 值、增加字詞計數，並將新字詞新增至 <code>wordsList</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (wordsList.contains(currentWord)) &#123;</span><br><span class="line">    getNextWord()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    _currentScrambledWord = String(tempWord)</span><br><span class="line">    ++currentWordCount</span><br><span class="line">    wordsList.add(currentWord)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>以下是完整的 <code>getNextWord()</code> 方法，供您參考。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Updates currentWord and currentScrambledWord with the next word.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">getNextWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">   currentWord = allWordsList.random()</span><br><span class="line">   <span class="keyword">val</span> tempWord = currentWord.toCharArray()</span><br><span class="line">   tempWord.shuffle()</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span> (String(tempWord).equals(currentWord, <span class="literal">false</span>)) &#123;</span><br><span class="line">       tempWord.shuffle()</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (wordsList.contains(currentWord)) &#123;</span><br><span class="line">       getNextWord()</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       _currentScrambledWord = String(tempWord)</span><br><span class="line">       ++currentWordCount</span><br><span class="line">       wordsList.add(currentWord)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="延遲初始化-currentScrambledWord"><a href="#延遲初始化-currentScrambledWord" class="headerlink" title="延遲初始化 currentScrambledWord"></a>延遲初始化 currentScrambledWord</h4><p>現在您已建立 <code>getNextWord()</code> 方法，以取得下一個打散的字詞。初次初始化 <code>GameViewModel</code> 時，系統會呼叫此方法。使用 <code>init</code> 區塊初始化類別中的 <code>lateinit</code> 屬性 (例如目前字詞)。如此一來，畫面上顯示的第一個字詞會是打散的字詞，而不是「test」。</p>
<ol>
<li>執行應用程式。請注意，第一個字詞一律為「test」。</li>
<li>如要在應用程式起始處顯示打散的字詞，請呼叫 <code>getNextWord()</code> 方法，藉此讓系統更新 <code>currentScrambledWord</code>。呼叫 <code>GameViewModel</code> <code>init</code> 區塊中的 <code>getNextWord()</code> 方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">init</span> &#123;</span><br><span class="line">    Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;GameViewModel created!&quot;</span>)</span><br><span class="line">    getNextWord()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>_currentScrambledWord</code> 屬性中加入 <code>lateinit</code> 修飾符。由於未提供初始值，請明確提及 <code>String</code> 資料類型。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> _currentScrambledWord: String</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式。請注意，應用程式啟動時會顯示新的打散字詞。太棒了！</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/8edd6191a40a57e1_1920.png?hl=zh-tw" width="30%">

<h4 id="新增-Helper-方法"><a href="#新增-Helper-方法" class="headerlink" title="新增 Helper 方法"></a>新增 Helper 方法</h4><p>接下來，請加入 Helper 方法來處理和修改 <code>ViewModel</code> 中的資料。您將在後續工作中使用此方法。</p>
<p>在 <code>GameViewModel</code> 類別中，新增另一個 <code>nextWord()</code>. 方法。接著從清單中取得下一個字詞，並在字詞計數少於 <code>MAX_NO_OF_WORDS</code> 時傳回 <code>true</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Returns true if the current word count is less than MAX_NO_OF_WORDS.</span></span><br><span class="line"><span class="comment">* Updates the next word.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">nextWord</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">if</span> (currentWordCount &lt; MAX_NO_OF_WORDS) &#123;</span><br><span class="line">        getNextWord()</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="對話方塊"><a href="#對話方塊" class="headerlink" title="對話方塊"></a>對話方塊</h3><p>在範例程式碼中，即使已遊玩 10 個字詞，遊戲也不會結束。請修改應用程式，在使用者遊玩 10 個字詞後結束遊戲，並顯示含有最終分數的對話方塊。使用者還可以選擇重新遊玩或離開遊戲。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/62aa368820ffbe31_1920.png?hl=zh-tw" width="50%">

<p>這是您初次在應用程式中新增對話方塊。對話方塊是一個小視窗 (畫面)，可提示使用者做出決定或輸入額外資訊。一般而言，如果對話方塊未填滿整個畫面，則使用者必須執行操作才能繼續操作。Android 提供不同類型的對話方塊。在本程式碼研究室中，您將瞭解「快訊對話方塊」。</p>
<p><strong>快訊對話方塊剖析</strong><br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/f8650ca15e854fe4_1920.png?hl=zh-tw" width="80%"></p>
<ol>
<li>快訊對話方塊</li>
<li>標題 (選填)</li>
<li>訊息</li>
<li>文字按鈕</li>
</ol>
<h4 id="實作最終分數對話方塊"><a href="#實作最終分數對話方塊" class="headerlink" title="實作最終分數對話方塊"></a>實作最終分數對話方塊</h4><p>使用質感設計元件庫中的 <code>MaterialAlertDialog</code>，在應用程式中加入符合質感設計指南的對話方塊。由於對話方塊與 UI 相關，因此 <code>GameFragment</code> 將負責建立並顯示最終分數對話方塊。</p>
<ol>
<li>首先，在 <code>score</code> 變數中新增幕後屬性。在 <code>GameViewModel</code> 中，將 <code>score</code> 變數宣告變更為以下內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _score = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> score: <span class="built_in">Int</span></span><br><span class="line">   <span class="keyword">get</span>() = _score</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>GameFragment</code> 中，新增名為 <code>showFinalScoreDialog()</code> 的私人函式。如要建立 <code>MaterialAlertDialog</code>，請使用 <code>MaterialAlertDialogBuilder</code> 類別逐步建立對話方塊的內容。使用 fragment 的 <code>requireContext()</code> 方法呼叫傳遞內容的 <code>MaterialAlertDialogBuilder</code> 建構函式。<code>requireContext()</code> 方法會傳回非空值的 <code>Context</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Creates and shows an AlertDialog with the final score.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showFinalScoreDialog</span><span class="params">()</span></span> &#123;</span><br><span class="line">   MaterialAlertDialogBuilder(requireContext())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>顧名思義，<code>Context</code> 是指應用程式、activity 或 fragment 的結構定義或目前狀態。其包含與 activity、fragment 或應用程式相關的資訊。其通常用於存取資源、資料庫和其他系統服務。在這個步驟中，您必須傳遞 fragment 結構定義，以建立快訊對話方塊。</li>
<li>如果 Android Studio 顯示提示，請 <code>import</code> <code>com.google.android.material.dialog.MaterialAlertDialogBuilder</code>。</li>
</ul>
<ol start="3">
<li>加入程式碼以設定快訊對話方塊的標題，請使用 <code>strings.xml</code> 的字串資源。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">MaterialAlertDialogBuilder(requireContext())</span><br><span class="line">   .setTitle(getString(R.string.congratulations))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>設定訊息以顯示最終分數，並使用先前新增的分數變數 (<code>viewModel.score</code>) 唯讀版本。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.setMessage(getString(R.string.you_scored, viewModel.score))</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>使用 <code>setCancelable()</code> 方法並傳遞 <code>false</code>，使快訊對話方塊在按下返回鍵時無法取消。</p>
</li>
<li><p>使用 <code>setNegativeButton()</code> 和 <code>setPositiveButton()</code> 方法新增「離開」和「再玩一次」兩個文字按鈕。從 lambda 分別呼叫 <code>exitGame()</code> 和 <code>restartGame()</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.setNegativeButton(getString(R.string.exit)) &#123; _, _ -&gt;</span><br><span class="line">    exitGame()</span><br><span class="line">&#125;</span><br><span class="line">.setPositiveButton(getString(R.string.play_again)) &#123; _, _ -&gt;</span><br><span class="line">    restartGame()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>這個語法對您來說可能較陌生，但其為 <code>setNegativeButton(getString(R.string.exit), &#123; _, _ -&gt; exitGame()&#125;)</code> 的簡寫，其中 <code>setNegativeButton()</code> 方法會納入兩個參數：<code>String</code> 及可用 lambda 表示的 <code>DialogInterface.OnClickListener()</code> 函式。如果傳入的最後一個引數是函式，您可以將 lambda 運算式放在括號外。這就是所謂的結尾 lambda 語法。系統接受這兩種程式碼編寫方式 (lambda 位於括號內或外)。這同樣適用於 <code>setPositiveButton</code> 函式。</li>
</ul>
<ol start="7">
<li>最後加入 <code>show()</code>，即可建立並顯示快訊對話方塊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.show()</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>以下是完整的 <code>showFinalScoreDialog()</code> 方法，供您參考。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Creates and shows an AlertDialog with the final score.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">showFinalScoreDialog</span><span class="params">()</span></span> &#123;</span><br><span class="line">   MaterialAlertDialogBuilder(requireContext())</span><br><span class="line">       .setTitle(getString(R.string.congratulations))</span><br><span class="line">       .setMessage(getString(R.string.you_scored, viewModel.score))</span><br><span class="line">       .setCancelable(<span class="literal">false</span>)</span><br><span class="line">       .setNegativeButton(getString(R.string.exit)) &#123; _, _ -&gt;</span><br><span class="line">           exitGame()</span><br><span class="line">       &#125;</span><br><span class="line">       .setPositiveButton(getString(R.string.play_again)) &#123; _, _ -&gt;</span><br><span class="line">           restartGame()</span><br><span class="line">       &#125;</span><br><span class="line">       .show()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="實作「Submit」按鈕的-OnClickListener"><a href="#實作「Submit」按鈕的-OnClickListener" class="headerlink" title="實作「Submit」按鈕的 OnClickListener"></a>實作「Submit」按鈕的 OnClickListener</h3><p>在這項工作中，您要使用 <code>ViewModel</code> 和新增的快訊對話方塊，實作「Submit」按鈕點擊事件監聽器的遊戲邏輯。</p>
<h4 id="顯示打散的字詞"><a href="#顯示打散的字詞" class="headerlink" title="顯示打散的字詞"></a>顯示打散的字詞</h4><ol>
<li>如果您尚未在 <code>GameFragment</code> 中刪除 <code>onSubmitWord()</code> 內的程式碼 (輕觸「Submit」按鈕時會呼叫此程式碼)，請先完成這項操作。</li>
<li>請在 <code>viewModel.nextWord()</code> 方法的傳回值新增檢查。如果為 <code>true</code>，則可以使用其他字詞，因此請使用 <code>updateNextWordOnScreen()</code> 更新畫面上打散的字詞。否則遊戲將會結束，並顯示含有最終分數的快訊對話方塊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubmitWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (viewModel.nextWord()) &#123;</span><br><span class="line">        updateNextWordOnScreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        showFinalScoreDialog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>執行應用程式！使用一些字詞進行遊戲。別忘了，您尚未實作「Skip」按鈕，因此無法略過該字詞。</p>
</li>
<li><p>請注意，文字欄位不會更新，因此玩家必須手動刪除上一個字詞。快訊對話方塊中的最終分數永遠為零。您將在後續步驟中修正這些錯誤。</p>
</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/a4c660e212ce2c31_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/12a42987a0edd2c4_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<h4 id="新增-Helper-方法以驗證玩家字詞"><a href="#新增-Helper-方法以驗證玩家字詞" class="headerlink" title="新增 Helper 方法以驗證玩家字詞"></a>新增 Helper 方法以驗證玩家字詞</h4><ol>
<li>在 <code>GameViewModel</code> 中，新增名為 <code>increaseScore()</code> 的新私人方法，且不含參數和傳回值。透過 <code>SCORE_INCREASE</code> 將 <code>score</code> 變數提高。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">increaseScore</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _score += SCORE_INCREASE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 <code>GameViewModel</code> 中，新增名為 <code>isUserWordCorrect()</code> 的 Helper 方法，其會傳回 <code>Boolean</code> 並將玩家字詞 <code>String</code> 做為參數。</p>
</li>
<li><p>在 <code>isUserWordCorrect()</code> 中驗證玩家的字詞，如果答案正確無誤，則增加分數。這會更新快訊對話方塊中的最終分數。</p>
</li>
</ol>
<h4 id="更新文字欄位"><a href="#更新文字欄位" class="headerlink" title="更新文字欄位"></a>更新文字欄位</h4><p><strong>顯示文字欄位中的錯誤</strong><br>針對 Material 文字欄位，<code>TextInputLayout</code> 內建能顯示錯誤訊息的功能。舉例來說，在下列文字欄位中，標籤顏色有所變更、顯示錯誤圖示、顯示錯誤訊息等。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/520cc685ae1317ac_1920.png?hl=zh-tw" width="50%">

<p>如要在文字欄位中顯示錯誤，您可以在程式碼中以動態方式設定錯誤訊息，或在版面配置檔案中以靜態方式設定錯誤訊息。設定及重設程式碼中錯誤的範例如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Set error text</span></span><br><span class="line">passwordLayout.error = getString(R.string.error)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Clear error text</span></span><br><span class="line">passwordLayout.error = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>在範例程式碼中，您會發現已定義 <code>setErrorTextField(error: Boolean)</code> Helper 方法，以協助您設定及重設文字欄位中的錯誤。根據是否要在文字欄位中顯示錯誤，使用 <code>true</code> 或 <code>false</code> 做為輸入參數，呼叫此方法。</p>
<p>範例程式碼中的程式碼片段</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setErrorTextField</span><span class="params">(error: <span class="type">Boolean</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (error) &#123;</span><br><span class="line">       binding.textField.isErrorEnabled = <span class="literal">true</span></span><br><span class="line">       binding.textField.error = getString(R.string.try_again)</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       binding.textField.isErrorEnabled = <span class="literal">false</span></span><br><span class="line">       binding.textInputEditText.text = <span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這項工作中，您會實作 <code>onSubmitWord()</code> 方法。使用者提交字詞時，您可透過檢查原始字詞，驗證使用者的答案。如果字詞正確無誤，請前往下一個字詞 (如果遊戲已結束，則顯示對話方塊)。如果字詞有誤，請在文字欄位中顯示錯誤，並繼續使用目前的字詞。</p>
<ol>
<li>在 <code>GameFragment</code> 中（<code>onSubmitWord()</code> 開始的部分），建立名為 <code>playerWord</code> 的 <code>val</code>。從 <code>binding</code> 變數的文字欄位中擷取文字，將玩家的字詞儲存在其中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubmitWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> playerWord = binding.textInputEditText.text.toString()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>在 <code>onSubmitWord()</code> 中的 <code>playerWord</code> 宣告下方，驗證玩家的字詞。新增 if 陳述式，以使用 <code>isUserWordCorrect()</code> 方法檢查玩家的字詞，並傳入 <code>playerWord</code>。</p>
</li>
<li><p>在 if 區塊中，重設文字欄位，呼叫 <code>setErrorTextField</code> 傳入 <code>false</code>。</p>
</li>
<li><p>將現有程式碼移至 if 區塊中。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubmitWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> playerWord = binding.textInputEditText.text.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModel.isUserWordCorrect(playerWord)) &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (viewModel.nextWord()) &#123;</span><br><span class="line">            updateNextWordOnScreen()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showFinalScoreDialog()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果使用者字詞不正確，請在文字欄位中顯示錯誤訊息。將 else 區塊新增至上述 if 區塊，並呼叫 <code>setErrorTextField()</code> 傳入 <code>true</code>。已完成的 <code>onSubmitWord()</code> 方法應如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSubmitWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> playerWord = binding.textInputEditText.text.toString()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (viewModel.isUserWordCorrect(playerWord)) &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">false</span>)</span><br><span class="line">        <span class="keyword">if</span> (viewModel.nextWord()) &#123;</span><br><span class="line">            updateNextWordOnScreen()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            showFinalScoreDialog()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行應用程式，並透過一些字詞進行遊戲。如果玩家的字詞正確無誤，按一下「Submit」按鈕即可清除字詞，否則系統會顯示「Try again!」的訊息。請注意，「略過」按鈕目前仍未運作。您將在下一個工作中加入此實作。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/a10c7d77aa26b9db_1920.png?hl=zh-tw" width="30%">

<hr>
<h3 id="實作略過按鈕"><a href="#實作略過按鈕" class="headerlink" title="實作略過按鈕"></a>實作略過按鈕</h3><p>在這項工作中，您要新增 <code>onSkipWord()</code> 實作，用於處理使用者輕觸「Skip」按鈕時的情況。</p>
<ol>
<li>與 <code>onSubmitWord()</code> 類似，請在 <code>onSkipWord()</code> 方法中新增條件。如為 <code>true</code>，請在畫面上顯示文字並重設文字欄位。如為 <code>false</code>，且這回合沒有其他字詞，則顯示含有最終分數的快訊對話方塊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Skips the current word without changing the score.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSkipWord</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (viewModel.nextWord()) &#123;</span><br><span class="line">        setErrorTextField(<span class="literal">false</span>)</span><br><span class="line">        updateNextWordOnScreen()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        showFinalScoreDialog()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行您的應用程式。遊玩遊戲。請注意，「略過」和「提交」按鈕可正常運作。非常好！</li>
</ol>
<hr>
<h3 id="確認-ViewModel-將會保留資料"><a href="#確認-ViewModel-將會保留資料" class="headerlink" title="確認 ViewModel 將會保留資料"></a>確認 ViewModel 將會保留資料</h3><p>在這項工作中，於 <code>GameFragment</code> 中新增 log，以觀察在設定變更期間，您的應用程式資料是否會保留在 <code>ViewModel</code> 中。如要存取 <code>GameFragment</code> 中的 <code>currentWordCount</code>，您必須使用幕後屬性公開唯讀版本。</p>
<ol>
<li><p>在 <code>GameViewModel</code> 中，在 <code>currentWordCount</code> 變數上按一下滑鼠右鍵，然後選取「Refactor」&gt;「Rename…」。在新名稱前加上底線 <code>_currentWordCount</code>。</p>
</li>
<li><p>新增支援欄位。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _currentWordCount = <span class="number">0</span></span><br><span class="line"><span class="keyword">val</span> currentWordCount: <span class="built_in">Int</span></span><br><span class="line">   <span class="keyword">get</span>() = _currentWordCount</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>GameFragment</code> 內的 <code>onCreateView()</code> 中，在回傳敘述上方新增另一個 log，以列印應用程式資料、字詞、分數和字詞計數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Log.d(<span class="string">&quot;GameFragment&quot;</span>, <span class="string">&quot;Word: <span class="subst">$&#123;viewModel.currentScrambledWord&#125;</span> &quot;</span> +</span><br><span class="line">       <span class="string">&quot;Score: <span class="subst">$&#123;viewModel.score&#125;</span> WordCount: <span class="subst">$&#123;viewModel.currentWordCount&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 Android Studio 中，開啟「Logcat」，並篩選 <code>GameFragment</code>。執行應用程式，使用一些字詞進行遊戲。變更裝置的螢幕方向。fragment (UI controller) 會刪除並重新建立。觀察記錄。您現在可以看到分數和字詞計數增加！</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameViewModel created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: Word: oimfnru Score: 0 WordCount: 1</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: Word: ofx Score: 80 WordCount: 5</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: Word: ofx Score: 80 WordCount: 5</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: Word: nvoiil Score: 160 WordCount: 9</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment destroyed!</span><br><span class="line">com.example.android.unscramble D/GameFragment: GameFragment created/re-created!</span><br><span class="line">com.example.android.unscramble D/GameFragment: Word: nvoiil Score: 160 WordCount: 9</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，螢幕方向變更時，應用程式資料會保存在 <code>ViewModel</code> 中。您將在後續的程式碼研究室中使用 <code>LiveData</code> 和 data biniding，更新 UI 上的分數值和字詞計數。</li>
</ul>
<hr>
<h3 id="更新遊戲重新啟動邏輯"><a href="#更新遊戲重新啟動邏輯" class="headerlink" title="更新遊戲重新啟動邏輯"></a>更新遊戲重新啟動邏輯</h3><ol>
<li><p>再次執行應用程式，使用所有字詞進行遊戲。在「Congratulations!」快訊對話方塊中，按一下「PLAY AGAIN」。由於字詞計數現已達到 <code>MAX_NO_OF_WORDS</code> 值，因此應用程式無法讓您再玩一次。您必須將字詞計數重設為 0，才能再次從頭開始遊戲。</p>
</li>
<li><p>如要重設應用程式資料，請在 <code>GameViewModel</code> 中新增名為 <code>reinitializeData()</code> 的方法。將分數和字詞計數設為 <code>0</code>。清除字詞清單並呼叫 <code>getNextWord()</code> 方法。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Re-initializes the game data to restart the game.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">reinitializeData</span><span class="params">()</span></span> &#123;</span><br><span class="line">   _score = <span class="number">0</span></span><br><span class="line">   _currentWordCount = <span class="number">0</span></span><br><span class="line">   wordsList.clear()</span><br><span class="line">   getNextWord()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>GameFragment</code> 頂端的方法 <code>restartGame()</code> 中，呼叫新建立的方法 <code>reinitializeData()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">restartGame</span><span class="params">()</span></span> &#123;</span><br><span class="line">   viewModel.reinitializeData()</span><br><span class="line">   setErrorTextField(<span class="literal">false</span>)</span><br><span class="line">   updateNextWordOnScreen()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>再次執行應用程式。開始遊戲。看到祝賀對話方塊時，請按一下「Play Again」。現在，您應該可以成功再次遊玩遊戲！</li>
</ol>
<p>應用程式最終畫面應如下所示。這個遊戲會顯示十個隨機打散的字詞，讓玩家進行重組。您可選擇「略過」字詞，或猜測字詞，然後輕觸「提交」。如果答案正確，分數將會增加。答案不正確會在文字欄位中顯示錯誤狀態。隨著每個新字詞的進行，字詞計數也會增加。</p>
<p>請注意，畫面上顯示的分數和字詞計數尚未更新。但這些資訊仍會儲存在檢視模型中，並在設定變更 (例如裝置旋轉) 期間保留。您將在後續的程式碼研究室中，更新畫面上的分數和字詞計數。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/f332979d6f63d0e5_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/2803d4855f5d401f_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>遊戲將在 10 個字詞後結束，畫面上會出現快訊對話方塊，顯示最終分數和結束遊戲或再玩一次的選項。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-viewmodel/img/d8e0111f5f160ead_1920.png?hl=zh-tw" width="30%">

<p>恭喜！您已建立第一個 <code>ViewModel</code>，並成功儲存資料！</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>Android 應用程式架構指南建議將具有不同責任的類別分離，並透過模型使用 UI。</li>
<li>UI Controller 是一種 UI 類別，例如 <code>Activity</code> 或 <code>Fragment</code>。UI 控制器只能包含處理 UI 和作業系統互動的邏輯；其不應做為在 UI 中顯示的資料來源。將該資料和任何相關的邏輯存放在 <code>ViewModel</code> 中。</li>
<li><code>ViewModel</code> 類別會儲存和管理 UI 相關資料。<code>ViewModel</code> 類別可在螢幕旋轉等變更時保留資料。</li>
<li><code>ViewModel</code> 是建議使用的 Android 架構元件之一。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>UI Controller</tag>
        <tag>ViewModel</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(25)-測試Navigation Component</title>
    <url>/2023/10/28/Android%E7%AD%86%E8%A8%98-25-%E6%B8%AC%E8%A9%A6Navigation-Component/</url>
    <content><![CDATA[<blockquote>
<p>學習如何測試 Navigation 元件。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何利用 <code>instrumentation test(設備測試)</code> 來測試 Navigation 元件。</li>
<li>如何不使用重複的程式碼設定測試。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="下載本程式碼研究室的範例程式碼"><a href="#下載本程式碼研究室的範例程式碼" class="headerlink" title="下載本程式碼研究室的範例程式碼"></a>下載本程式碼研究室的範例程式碼</h4><p>在本程式碼研究室中，您將新增設備測試到 Words 應用程式的程式碼。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong> <a href="https://github.com/google-developer-training/android-basics-kotlin-words-app">https://github.com/google-developer-training/android-basics-kotlin-words-app</a><br>含有範例程式碼的模組名稱：<b>main</b></p>
          </div>

<hr>
<h4 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h4><p>Words 應用程式的主畫面會顯示一份清單，每個清單項目都是字母表中的一個字母。按一下其中一個字母，螢幕上會顯示該字母開頭的字詞清單。</p>
<hr>
<h4 id="建立測試目錄"><a href="#建立測試目錄" class="headerlink" title="建立測試目錄"></a>建立測試目錄</h4><p>如有需要，請按照之前的程式碼研究室步驟，建立 Words 應用程式的設備測試(instrumentation test )目錄。如果您已完成這個步驟，請直接跳到「新增必要的依附元件(dependencies)」。</p>
<ul>
<li>可以參考<a href="https://linglingdr00.github.io/2023/09/19/Android%E7%AD%86%E8%A8%98-15-%E7%B7%A8%E5%AF%AB%E6%AA%A2%E6%B8%AC%E8%A8%AD%E5%82%99%E6%B8%AC%E8%A9%A6">Android筆記(15)-編寫檢測設備測試</a>這篇文章。</li>
</ul>
<hr>
<h4 id="建立設備測試類別"><a href="#建立設備測試類別" class="headerlink" title="建立設備測試類別"></a>建立設備測試類別</h4><p>在「androidTest」資料夾中，建立名為 <code>NavigationTests.kt</code> 的新類別。</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-test-navigation-components/img/b023023a2ccc3813_1920.png?hl=zh-tw" width="80%">

<hr>
<h4 id="新增必要的-Dependencies"><a href="#新增必要的-Dependencies" class="headerlink" title="新增必要的 Dependencies"></a>新增必要的 Dependencies</h4><p>測試 Navigation Component 時，會需要某些特定的 Gradle dependencies。另外，我們會提供 dependencies，以特定方式測試 fragments。前往應用程式模組的「build.gradle」檔案，並新增下列 dependencies：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">androidTestImplementation <span class="string">&#x27;androidx.test.ext:junit:1.1.3&#x27;</span></span><br><span class="line">androidTestImplementation <span class="string">&#x27;androidx.test.espresso:espresso-core:3.4.0&#x27;</span></span><br><span class="line">androidTestImplementation <span class="string">&#x27;com.android.support.test.espresso:espresso-contrib:3.4.0&#x27;</span></span><br><span class="line">androidTestImplementation <span class="string">&#x27;androidx.navigation:navigation-testing:2.5.2&#x27;</span></span><br><span class="line"></span><br><span class="line">debugImplementation <span class="string">&#x27;androidx.fragment:fragment-testing:1.5.3&#x27;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="撰寫-Navigation-Component-測試"><a href="#撰寫-Navigation-Component-測試" class="headerlink" title="撰寫 Navigation Component 測試"></a>撰寫 Navigation Component 測試</h4><p>測試 Navigation Component 不同於測試一般 navigation。測試一般 navigation 時，我們會在裝置或模擬器上觸發 navigation 操作來執行。但測試 Navigation Component 時，我們實際上並未讓裝置&#x2F;模擬器執行明顯的 navigation 操作，而是會以不實際變更裝置或模擬器上顯示的內容為前提，強制 Navigation Controller 來瀏覽，然後才確認其是否抵達正確的目的地。</p>
<ol>
<li><p>建立名為 <code>navigate_to_words_nav_component()</code> 的測試函式。</p>
</li>
<li><p>在測試中使用 Navigation Component 需要進行一些設定。請在 <code>navigate_to_words_nav_component()</code> 方法中，建立 Navigation Controller 的測試執行個體(instance)。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> navController = TestNavHostController(</span><br><span class="line">   ApplicationProvider.getApplicationContext()</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>Navigation Component 會使用 Fragment 驅動 UI。其中一個相當於 <code>ActivityScenarioRule</code> 的 fragment，可用來隔離要測試的 fragment，所以需要 fragment 專屬的 dependencies。</li>
</ol>
<ul>
<li>測試需要大量導覽的fragment時，這個做法很實用，因為啟動不必額外的程式碼處理 navigation 目的地。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> letterListScenario = launchFragmentInContainer&lt;LetterListFragment&gt;(themeResId =</span><br><span class="line">R.style.Theme_Words)</span><br></pre></td></tr></table></figure>

<p>這裡會指出我們想要啟動 <code>LetterListFragment</code>。我們必須傳遞應用程式的主題(theme)，讓 UI 元件知道要使用哪個主題(theme)，否則測試可能異常終止。</p>
<ol start="4">
<li>最後，我們需要明確宣告 fragment 啟動後，Navigation Controller 要使用哪個 Navigation Graph。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">letterListScenario.onFragment &#123; fragment -&gt;</span><br><span class="line"></span><br><span class="line">   navController.setGraph(R.navigation.nav_graph)</span><br><span class="line"></span><br><span class="line">   Navigation.setViewNavController(fragment.requireView(), navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>接著觸發提示 navigaton 的事件。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.recycler_view))</span><br><span class="line">   .perform(RecyclerViewActions</span><br><span class="line">       .actionOnItemAtPosition&lt;RecyclerView.ViewHolder&gt;(<span class="number">2</span>, click()))</span><br></pre></td></tr></table></figure>

<p>使用 <code>launchFragmentInContainer()</code> 方法時，實際 navigation 是不可能的，因為容器不知道我們可能前往的其他 fragment 或 activity。容器只知道我們指定啟動的 fragment。因此，在裝置或模擬器上執行測試時，您不會看到實際的 navigation。或許這不符合直覺，但我們可以根據目前的目的地，做出更直接的判斷。與其尋找已知會顯示在特定畫面的 UI 元件，我們可以直接檢查目前 navigation controller 的目的地，確認是否包含預期的 fragment ID。此方法比上述做法可靠許多。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertEquals(navController.currentDestination?.id, R.id.wordListFragment)</span><br></pre></td></tr></table></figure>

<p>您的測試看起來應像這樣：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-test-navigation-components/img/78b4a72f75134ded_1920.png?hl=zh-tw">

<hr>
<h4 id="避免包含備註的重複程式碼"><a href="#避免包含備註的重複程式碼" class="headerlink" title="避免包含備註的重複程式碼"></a>避免包含備註的重複程式碼</h4><p>在 Android 中，設備測試和單元測試都有功能可以不必重複程式碼，即可設定類別中每個測試相同的設定。<br>假設我們使用包含 10 個按鈕的 fragment。按一下按鈕後，按鈕會導向特定的 fragment。<br>如果我們按照上述測試的模式，可能必須分別為這 10 次測試重複使用下列程式碼 (請注意，此程式碼只是範例，不會在本程式碼研究室使用的應用程式中編譯)：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> navController = TestNavHostController(</span><br><span class="line">    ApplicationProvider.getApplicationContext()</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> exampleFragmentScenario = launchFragmentInContainer&lt;ExampleFragment&gt;(themeResId =</span><br><span class="line">R.style.Theme_Example)</span><br><span class="line"></span><br><span class="line">exampleFragmentScenario.onFragment &#123; fragment -&gt;</span><br><span class="line"></span><br><span class="line">   navController.setGraph(R.navigation.example_nav_graph)</span><br><span class="line"></span><br><span class="line">   Navigation.setViewNavController(fragment.requireView(), navController)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重複 10 次的程式碼非常冗長。在這個案例中，我們可以使用 <strong>JUnit</strong> 提供的 <code>@Before</code> 註解來節省寶貴的時間。即在一個方法上加上註解，並於其中提供測試設定所需的程式碼。我們可以隨意命名這個方法，但名稱必須有關連性。我們不必重複設定相同的 fragment 10 次，而是按照以下範例撰寫設定程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> navController: TestNavHostController</span><br><span class="line"></span><br><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> exampleFragmentScenario: FragmentScenario&lt;ExampleFragment&gt;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    navController = TestNavHostController(</span><br><span class="line">        ApplicationProvider.getApplicationContext()</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    exampleFragmentScenario =  launchFragmentInContainer(themeResId=R.style.Theme_Example)</span><br><span class="line"></span><br><span class="line">    exampleFragmentScenario.onFragment &#123; fragment -&gt;</span><br><span class="line"></span><br><span class="line">       navController.setGraph(R.navigation.example_nav_graph)</span><br><span class="line"></span><br><span class="line">       Navigation.setViewNavController(fragment.requireView(),  navController)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在，此方法會對我們在這個類別中編寫的每項測試執行，且我們可從任何一項測試存取必要的變數。</p>
<p>以此類推，若要每次測試後執行程式碼，也可使用 <code>@After</code> 註解。例如，<code>@After</code> 可用來清理用於測試的資源，對設備測試來說，也可用來將裝置回復至特定狀態。</p>
<p><strong>JUnit</strong> 也提供 <code>@BeforeClass</code> 和 <code>@AfterClass</code> 註解。不同之處在於此註解的方法<u>僅執行一次</u>，但已執行的程式碼仍會套用至每個方法。如果您的設定或中止方法涉及消耗大量資源的作業，建議您改用這些註解。使用 <code>@BeforeClass</code> 和 <code>@AfterClass</code> 註解的方法必須搭配 <code>@JvmStatic</code> 註解，放在 companion object 中。若要示範這些註解的執行順序，請參考下列程式碼：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-test-navigation-components/img/5157ab00a9b7fb84_1920.png?hl=zh-tw">

<p>請記得，<code>@BeforeClass</code> 會針對類別執行，<code>@Before</code> 會在函式執行前執行，<code>@After</code> 會在函式執行後執行，<code>@AfterClass</code> 也會針對類別執行。您能預測以下內容的輸出結果嗎？</p>
<p>函式的執行順序為 <code>setupClass()</code>、<code>setupFunction()</code>、<code>test_a()</code>、<code>tearDownFunction()</code>、<code>setupFunction()</code>、<code>test_b()</code>、<code>tearDownFunction()</code>、<code>setupFunction()</code>、<code>test_c()</code>、<code>tearDownFunction()</code>、<code>tearDownClass()</code>。這個執行順序很合理，因為 <code>@Before</code> 和 <code>@After</code> 會分別在每個方法前後執行。<code>@BeforeClass</code> 會在類別中的任何項目執行前執行一次，<code>@AfterClass</code> 則在類別的所有其他項目執行後執行一次。</p>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><ul>
<li>學習測試 Navigation Component 的方法。</li>
<li>瞭解如何使用 <code>@Before</code>、<code>@BeforeClass</code>、<code>@After</code> 和 <code>@AfterClass</code> 註解，避免重複的程式碼。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Instrumentation Test</tag>
        <tag>companion object</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(24)-Fragments和Navigation Component</title>
    <url>/2023/10/17/Android%E7%AD%86%E8%A8%98-24-Fragments%E5%92%8CNavigationComponent/</url>
    <content><![CDATA[<blockquote>
<p>許多 Android 應用程式不需個別為每個畫面設定活動。事實上，許多常見的使用者介面模式 (如分頁標籤(tabs)) 均存在單一 activity 內，並使用名為「fragment」的組成部分。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/64100b59bb487856_1920.png?hl=zh-tw" width="30%">

<span id="more"></span>

<p><a href="https://developer.android.com/guide/fragments?hl=zh-tw">fragment</a>是可重複使用的使用者介面，並可嵌入一或多個 activity 中。在上方的螢幕截圖中，輕觸 tabs 並不會觸發顯示下一個畫面的 intent。而是，切換 tabs 僅僅是在先前 fragment 與原先 fragment 之間調換。這些事項都不需要啟動其他 activity。</p>
<p>您甚至可以在單一畫面上一次顯示多個 fragment，例如平板電腦裝置的主控制項詳細資料 layout。在以下範例中，左邊的導覽使用者介面和右側的內容都可以包含在不同的 fragment 中。兩個 fragment 在同一個 activity 中並存。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/b5711344c5795d55_1920.png">

<p>如您所見，fragment 是建構高品質應用程式的關鍵要素。在本程式碼研究室中，您將瞭解 fragment 的基本概念，並轉換 Word 應用程式來使用 fragment。也會瞭解如何使用 Jetpack Navigation component，以及使用名為 <strong>Navigation Graph</strong> 的新資源檔案，以在同一主機活動中導覽不同 fragment。完成本程式碼研究室後，您將獲得在下一個應用程式中導入 fragment 的基本技能。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>fragment 生命週期 activity 生命週期的差異。</li>
<li>如何將現有 activity 轉換成 fragment。</li>
<li>如何在 <code>Navigation Graph</code> 中新增目的地，以及在使用 <code>Safe Args</code> 外掛程式時在 fragment 之間傳遞資料。</li>
</ul>
<hr>
<h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><p>在本程式碼研究室中，在 activity 和 intent 程式碼研究室的結束時，您就能使用 Word 應用程式接續先前的進度。如果您已完成 activity 與 intent 程式碼研究室，請隨時使用您的程式碼作為起點。或者，直到此刻，您也可以從 GitHub 下載程式碼。</p>
<h4 id="下載本程式碼研究室的範例程式碼"><a href="#下載本程式碼研究室的範例程式碼" class="headerlink" title="下載本程式碼研究室的範例程式碼"></a>下載本程式碼研究室的範例程式碼</h4><p>本程式碼研究室提供範例程式碼，可延伸至本程式碼研究室所教授的功能。範例程式碼可能包含先前介紹過的程式碼。也可能含有您不熟悉的程式碼，您可以在後續的程式碼研究室中學習。</p>
<p>如果您使用 GitHub 中的範例程式碼，請注意資料夾名稱是 <code>android-basics-kotlin-words-app-activities</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong> <a href="https://github.com/google-developer-training/android-basics-kotlin-words-app">https://github.com/google-developer-training/android-basics-kotlin-words-app</a><br><strong>含有範例程式碼的模組名稱：</strong> <b>activities</b></p>
          </div>

<hr>
<h3 id="Fragment-與-Fragment-生命週期"><a href="#Fragment-與-Fragment-生命週期" class="headerlink" title="Fragment 與 Fragment 生命週期"></a>Fragment 與 Fragment 生命週期</h3><p>片段(fragment)僅僅是一段可重複使用的應用程式使用者介面 如同 activity，fragment 具有生命週期且可回應使用者輸入。在畫面上顯示 activity 的 view 區塊階層內始終包含 fragment。由於 fragment 強調可重用性和模組化，甚至可以由單一 activity 同時代管多個 fragment，所以每個 fragment 都有各自的生命週期。</p>
<h4 id="Fragment-生命週期"><a href="#Fragment-生命週期" class="headerlink" title="Fragment 生命週期"></a>Fragment 生命週期</h4><p>如同 activity，您也可以從記憶體初始化及移除 fragment，並且在 fragment 存在期間，會在螢幕上顯示、消失和重新顯示。此外，如同 activity，fragment 的生命週期有數個狀態，並提供多種覆寫方法，以回應 fragment 之間的轉換。fragment 生命週期為五個狀態，以 <a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/Lifecycle.State">Lifecycle.State</a> 列舉表示。</p>
<ul>
<li><strong>INITIALIZED (已初始化)：</strong> fragment 的新 instance <u>已實例化(instantiated)</u>。</li>
<li><strong>CREATED (已建立)：</strong> 呼叫第一個 fragment 生命週期方法。在此狀態下，系統也會<u>建立與 fragment 相關聯的 view</u>。</li>
<li><strong>STARTED (已啟動)：</strong> fragment 在畫面上可見，但<u>沒有焦點(focus)</u>，因此無法回應使用者輸入。</li>
<li><strong>RESUMED (已重新啟用)：</strong> fragment 在畫面上可見，且<u>有焦點(focus)</u>。</li>
<li><strong>DESTROYED (已刪除)：</strong> fragment 物件<u>已解除實例化(de-instantiated)</u>。</li>
</ul>
<p>也類似於活動，<a href="https://developer.android.com/reference/android/app/Fragment">Fragment</a> 類別提供多種方法，讓您可回應於生命週期事件進行覆寫。</p>
<ul>
<li><code>onCreate()</code>：fragment 已實例化(instantiated)，並處於 <code>CREATED</code> 狀態。不過，尚未建立對應的 view。</li>
<li><code>onCreateView()</code>：這個方法是加載 layout 之處。fragment 已進入 <code>CREATED</code> 狀態。</li>
<li><code>onViewCreated()</code>：會在建立 view 後呼叫。在此方法中，您通常會呼叫 <code>findViewById()</code> 來綁定(bind)特定 view 與屬性。</li>
<li><code>onStart()</code>：fragment 已進入 <code>STARTED</code> 狀態。</li>
<li><code>onResume()</code>：fragment 已進入 <code>RESUMED</code> 狀態且現在已聚焦(focus) (可回應使用者輸入)。</li>
<li><code>onPause()</code>：fragment 已重新進入 <code>STARTED</code> 狀態。使用者可看得到使用者介面</li>
<li><code>onStop()</code>：fragment 已重新進入 <code>CREATED</code> 狀態。物件已實例化(instantiated)，但不再顯示在畫面上。</li>
<li><code>onDestroyView()</code>：在 fragment 正好進入 <code>DESTROYED</code> 狀態時呼叫。view 已從記憶體中移除，但fragment 物件仍然存在。</li>
<li><code>onDestroy()</code>：fragment 進入 <code>DESTROYED</code> 狀態。</li>
</ul>
<p>下圖概述各種片段生命週期，以及各狀態之間的轉換。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/8dc30a4c12ab71b_1920.png?hl=zh-tw" width="50%">

<p>生命週期狀態和 callback 方法非常類似於 activity 中使用的方法。不過，請記住與 <code>onCreate()</code> 方法的差異。配合 activity，使用此方法加載 layout 並 bind views。不過，在 fragment 生命週期內，系統會在建立 view 之前呼叫 <code>onCreate()</code>，因此您無法在這裡加載 layout。請改為在 <code>onCreateView()</code> 中執行這項操作。建立 view 之後，系統會呼叫 <code>onViewCreated()</code> 方法，然後將屬性綁定(bind)至特定 view。</p>
<p>儘管似乎很理論，但您現在已經瞭解 fragment 的基本運作方式，以及與各 activity 的相似及相異之處。在本程式碼研究室的其餘部分，您將充分學以致用。首先，您必須遷移先前使用 Words 應用程式至使用 fragment 為基礎的版面配置。接下來，導入在單一 activity 中不同 fragment 之間的導覽(navigation)功能。</p>
<hr>
<h3 id="建立-Fragment-和-layout-檔案"><a href="#建立-Fragment-和-layout-檔案" class="headerlink" title="建立 Fragment 和 layout 檔案"></a>建立 Fragment 和 layout 檔案</h3><p>如同 activity，您新增的每個 fragment 都包含兩個檔案：一個檔案是 <span class="label primary">layout 的 XML 檔案</span>，另一個檔案則是<span class="label primary">顯示資料和處理使用者互動的 Kotlin 類別</span>。您必須新增字母列表和字詞列表的 fragment。</p>
<ol>
<li>在「Project Navigator」(專案導覽器) 中選取「app」(應用程式)，並加入下列片段 (「File」(檔案) &gt;「New」(新增) &gt;「Fragment」(片段) &gt;「Fragment (Blank)」(片段 (空白)))，應該會產生各 fragment 的<u>類別</u>和 <u>layout 檔案</u>。</li>
</ol>
<ul>
<li>將第一個 fragment 的「Fragment Name」(fragment名稱) 設定為<code> LetterListFragment</code>。「Fragment Layout Name」(fragment layout 名稱) 應填入 <code>fragment_letter_list</code>。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/4a1729f01d62e65e_1920.png?hl=zh-tw" width="70%">

<ul>
<li>將第二個 fragment 的「Fragment Name」(片段名稱) 設定為 <code>WordListFragment</code>。「Fragment Layout Name」(fragment layout 名稱) 應填入 <code>fragment_word_list.xml</code>。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/5b86ff3a94833b5a_1920.png?hl=zh-tw" width="70%">

<ol start="2">
<li>為這兩個 fragment 產生的 Kotlin 類別都包含許多範例程式碼，通常用於實作 fragment。不過，由於您是第一次使用 fragment，請從這兩個檔案中刪除所有內容，惟 <code>LetterListFragment</code> 和 <code>WordListFragment</code> 的類別宣告除外。我們會引導您您從頭開始逐步實作片段，使您瞭解所有程式碼的運作方式。刪除範例程式碼後，Kotlin 檔案應像如下所示。</li>
</ol>
<p><code>LetterListFragment.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wordsapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LetterListFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WordListFragment.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.wordsapp</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.fragment.app.Fragment</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WordListFragment</span> : <span class="type">Fragment</span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將 <code>activity_main.xml</code> 的內容複製到 <code>fragment_letter_list.xml</code>，並將 <code>activity_detail.xml</code> 的內容複製到 <code>fragment_word_list.xml</code>。將 <code>fragment_letter_list.xml</code> 中的 <code>tools:context</code> 更新為 <code>.LetterListFragment</code>，並將 <code>fragment_word_list.xml</code> 中的 <code>tools:context</code> 更新為 <code>.WordListFragment</code>。</li>
</ol>
<p>變更後，片段版面配置檔案應像如下所示。</p>
<p><code>fragment_letter_list.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:context</span>=<span class="string">&quot;.LetterListFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:clipToPadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>fragment_word_list.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:context</span>=<span class="string">&quot;.WordListFragment&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:clipToPadding</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">tools:listitem</span>=<span class="string">&quot;@layout/item_view&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="導入-LetterListFragment"><a href="#導入-LetterListFragment" class="headerlink" title="導入 LetterListFragment"></a>導入 LetterListFragment</h3><p>如同 activity，您需要加載 layout 置並綁定(bind)個別 view。使用 fragment 生命週期時，還是有些許差異。我們會引導您逐步完成 <code>LetterListFragment</code> 的設定程序，讓您有機會為 <code>WordListFragment</code> 進行相同設定。</p>
<p>若要在 <code>LetterListFragment</code> 中<u>導入 view binding</u>，您必須先<u>取得 <code>FragmentLetterListBinding</code> 可為空值(nullable)的 reference(引用)</u>。在 <strong>build.gradle</strong> 檔案的 <code>buildFeatures</code> 區段下<u>啟用 <code>viewBinding</code> 屬性</u>時，Android Studio 會為<u>每個 layout 檔案</u>產生與此類似的 <u><strong>Binding classes</strong></u>。您只需要為 <code>FragmentLetterListBinding</code> 中的每個 <u>view</u> 指派 <u>fragment class 中的屬性</u>。</p>
<p>type 應為 <code>FragmentLetterListBinding?</code>，且初始值應為 <code>null</code>。為什麼要使其可為空值？因為除非呼叫 <code>onCreateView()</code>，否則您無法加載 layout。建立 <code>LetterListFragment</code> 的 instance (生命週期開始於  <code>onCreate()</code> ) 與到此屬性實際可用之間會有一段期間(period)。也請注意，您可以在 fragment 的生命週期內建立和刪除 fragment 的 view 數次。因此，您還必須重設在另一個生命週期方法 ( <code>onDestroyView()</code> ) 中的值。</p>
<ol>
<li>在 <code>LetterListFragment.kt</code> 中，首先獲取對 <code>FragmentLetterListBinding</code> 的引用(reference)，並將引用(reference)命名為 <code>_binding</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentLetterListBinding? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>它可為空值，因此每次存取 <code>_binding</code> 的屬性 (例如 <code>_binding?.someView</code>) 時，您都必須納入 <code>?</code> 來提供空值安全(null safety)。然而，這並不意謂您會因為一個空值，而捨棄有問號的程式碼。如果您確定某值在存取時不會為空值，則可以在類型名稱中附加 <code>!!</code>。於是您就不需使用 <code>?</code> 運算子，也能和任何其他屬性一樣進行存取。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 使用 <b>!!</b> 使變數可為空值時，限制只能在<u>已知值不會是空值</u>的一處或幾處使用該變數，就像您知道在 <b>onCreateView()</b> 中指派 <b>_binding</b> 之後將具有的值。以這種方式存取可為空值的值會有危險，並可能導致當機，因此請謹慎使用。</p>
          </div>

<ol start="2">
<li>建立名為 <code>binding</code> 的新屬性 (不含底線)，並將其設為等於 <code>_binding!!</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br></pre></td></tr></table></figure>

<p>此處，<code>get()</code> 意指屬性是「get-only」。這意指您可以「get」(取得) 這個值，但一旦指派 (如此處)，就無法指派後給其他。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 在 Kotlin 中或一般而言在程式設計時，您通常會看到<u>屬性名稱後面接著底線</u>。這通常意指<u>屬性不適合直接存取</u>。就您的情況而言，您會用 binding 屬性來存取 <b>LetterListFragment</b> 中的 view binding。不過，您不一定要在 <b>LetterListFragment</b> 外存取 <b>_binding</b> 屬性。</p>
          </div>

<ol start="3">
<li>如要顯示 options menu，請覆寫 <code>onCreate()</code>。在 <code>onCreate()</code> 內呼叫 <code>setHasOptionsMenu()</code> 並傳入 <code>true</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">   setHasOptionsMenu(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>請記住，使用 fragment 時，系統會在 <code>onCreateView()</code> 中加載 layout。加載 view、設定 <code>_binding</code> 的值，並傳回 root view，就可導入 <code>onCreateView()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   inflater: <span class="type">LayoutInflater</span>, container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">   savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">   _binding = FragmentLetterListBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">   <span class="keyword">val</span> view = binding.root</span><br><span class="line">   <span class="keyword">return</span> view</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>binding</code> 屬性下方，建立 recycler view 的屬性(property)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> recyclerView: RecyclerView</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>然後在 <code>onViewCreated()</code> 中設定 <code>recyclerView</code> 屬性的值，並呼叫 <code>chooseLayout()</code>，就像您在 <code>MainActivity</code> 中的做法一樣。您很快就會將 <code>chooseLayout()</code> 方法移到 <code>LetterListFragment</code>，所以不需擔心有錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   recyclerView = binding.recyclerView</span><br><span class="line">   chooseLayout()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>請注意，binding class 已經建立 <code>recyclerView</code> 的屬性，因此您不需要針對每個 view 呼叫 <code>findViewById()</code>。</p>
<ol start="7">
<li>最後在 <code>onDestroyView()</code> 中，將 <code>_binding</code> 屬性重設為 <code>null</code>，因為 view 已不存在。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroyView</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onDestroyView()</span><br><span class="line">   _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>另外要注意的是，使用 fragment 時，<code>onCreateOptionsMenu()</code> 方法有些微的差異。雖然 <code>Activity</code> class 具有名為 <code>menuInflater</code> 的全域屬性(global property)，但 <code>Fragment</code> 並未提供這項屬性(property)，而是將 menu inflater 傳遞至 <code>onCreateOptionsMenu()</code> 中。另請注意，搭配 fragment 使用的 <code>onCreateOptionsMenu()</code> 方法不需要回傳 statement。實作方法如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>, inflater: <span class="type">MenuInflater</span>)</span></span> &#123;</span><br><span class="line">   inflater.inflate(R.menu.layout_menu, menu)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> layoutButton = menu.findItem(R.id.action_switch_layout)</span><br><span class="line">   setIcon(layoutButton)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>從 <code>MainActivity</code> 中按原樣移動 <code>chooseLayout()</code>、<code>setIcon()</code> 和 <code>onOptionsItemSelected()</code> 的其餘程式碼。應注意的唯一差別在於，與 activity 不同，fragment 不是 <code>Context</code>。您無法傳入 <code>this</code> (指 fragment object) 做為 layout manager 的 context。但是，fragment 會提供 <code>context</code> 屬性，您可以改用該屬性。程式碼的其餘部分與 <code>MainActivity</code> 相同。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">chooseLayout</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">when</span> (isLinearLayoutManager) &#123;</span><br><span class="line">       <span class="literal">true</span> -&gt; &#123;</span><br><span class="line">           recyclerView.layoutManager = LinearLayoutManager(context)</span><br><span class="line">           recyclerView.adapter = LetterAdapter()</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="literal">false</span> -&gt; &#123;</span><br><span class="line">           recyclerView.layoutManager = GridLayoutManager(context, <span class="number">4</span>)</span><br><span class="line">           recyclerView.adapter = LetterAdapter()</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setIcon</span><span class="params">(menuItem: <span class="type">MenuItem</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (menuItem == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   menuItem.icon =</span><br><span class="line">       <span class="keyword">if</span> (isLinearLayoutManager)</span><br><span class="line">           ContextCompat.getDrawable(<span class="keyword">this</span>.requireContext(), R.drawable.ic_grid_layout)</span><br><span class="line">       <span class="keyword">else</span> ContextCompat.getDrawable(<span class="keyword">this</span>.requireContext(), R.drawable.ic_linear_layout)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">       R.id.action_switch_layout -&gt; &#123;</span><br><span class="line">           isLinearLayoutManager = !isLinearLayoutManager</span><br><span class="line">           chooseLayout()</span><br><span class="line">           setIcon(item)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">else</span> -&gt; <span class="keyword">super</span>.onOptionsItemSelected(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> <a href="https://developer.android.com/reference/androidx/fragment/app/Fragment#requireContext()">requireContext()</a> 會傳回目前與此 fragment 相關聯的 <b>Context</b>。</p>
          </div>

<ol start="10">
<li>最後，複製 <code>MainActivity</code> 的 <code>isLinearLayoutManager</code> 屬性。將此屬性放在 <code>recyclerView</code> 屬性的宣告正下方。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> isLinearLayoutManager = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="11">
<li>現在所有功能都已經移至 <code>LetterListFragment</code>，<code>MainActivity</code> class 所需要做的只是<u>加載 layout</u>，使得 <u>fragment 顯示在 view</u> 中。繼續從 <code>MainActivity</code> 刪除所有內容，惟 <code>onCreate()</code> 除外。變更後，<code>MainActivity</code> 只能包含下列項目。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">   setContentView(binding.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="將-DetailActivity-轉換為-WordListFragment"><a href="#將-DetailActivity-轉換為-WordListFragment" class="headerlink" title="將 DetailActivity 轉換為 WordListFragment"></a>將 DetailActivity 轉換為 WordListFragment</h4><p>就是將 <code>DetailActivity</code> 轉換為 <code>WordListFragment</code> 和將 <code>MainActivity</code> 遷移至 <code>LettersListFragment</code> 的遷移作業幾乎相同。請執行下列步驟，將程式碼遷移至 <code>WordListFragment</code>。</p>
<ol>
<li>首先，請將 companion object 複製到 <code>WordListFragment</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">   <span class="keyword">val</span> LETTER = <span class="string">&quot;letter&quot;</span></span><br><span class="line">   <span class="keyword">val</span> SEARCH_PREFIX = <span class="string">&quot;https://www.google.com/search?q=&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然後在 <code>LetterAdapter</code> 中，在執行 intent 的 <code>onClickListener()</code> 中，您必須將呼叫更新為 <code>putExtra()</code>，將 <code>DetailActivity.LETTER</code> 替換為 <code>WordListFragment.LETTER</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">intent.putExtra(WordListFragment.LETTER, holder.button.text.toString())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>同樣地，在 <code>WordAdapter</code> 中，在您前往字詞的搜尋結果時必須更新出現 <code>onClickListener()</code>，並將 <code>DetailActivity.SEARCH_PREFIX</code> 替換為 <code>WordListFragment.SEARCH_PREFIX</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> queryUrl: Uri = Uri.parse(<span class="string">&quot;<span class="subst">$&#123;WordListFragment.SEARCH_PREFIX&#125;</span><span class="subst">$&#123;item&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>返回 <code>WordListFragment</code>，新增 type 為 <code>FragmentWordListBinding?</code> 的 <code>_binding</code> 變數。變數應可為空值，並將 <code>null</code> 作為初始值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> _binding: FragmentWordListBinding? = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>然後新增名為 <code>binding</code> 的 <strong>get-only</strong> 變數，這樣無需使用 <code>?</code> 就能引用 view。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> binding <span class="keyword">get</span>() = _binding!!</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>接著，請調整 layout，指派 <code>_binding</code> 變數並傳回 root view。請記得，對於 fragment，您在 <code>onCreateView()</code> 中執行此作業，而不是 <code>onCreate()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateView</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">   inflater: <span class="type">LayoutInflater</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">   container: <span class="type">ViewGroup</span>?,</span></span></span><br><span class="line"><span class="params"><span class="function">   savedInstanceState: <span class="type">Bundle</span>?</span></span></span><br><span class="line"><span class="params"><span class="function">)</span></span>: View? &#123;</span><br><span class="line">    <span class="comment">// 設定 _binding 的值</span></span><br><span class="line">   _binding = FragmentWordListBinding.inflate(inflater, container, <span class="literal">false</span>)</span><br><span class="line">    <span class="comment">// 傳回 root view</span></span><br><span class="line">   <span class="keyword">return</span> binding.root</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>接下來，您要導入 <code>onViewCreated()</code>。這幾乎和在 <code>DetailActivity</code> 中的 <code>onCreate()</code> 中設定 <code>recyclerView</code> 相同。不過，由於 fragment 無法直接存取 intent，因此您必須使用 <code>activity.intent</code> 進行引用。但是，您必須在 <code>onViewCreated()</code> 中執行此作業，因為無法保證在生命週期早期已存在 activity。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onViewCreated</span><span class="params">(view: <span class="type">View</span>, savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> recyclerView = binding.recyclerView</span><br><span class="line">   recyclerView.layoutManager = LinearLayoutManager(requireContext())</span><br><span class="line">   recyclerView.adapter = WordAdapter(activity?.intent?.extras?.getString(LETTER).toString(), requireContext())</span><br><span class="line"></span><br><span class="line">   recyclerView.addItemDecoration(</span><br><span class="line">       DividerItemDecoration(context, DividerItemDecoration.VERTICAL)</span><br><span class="line">   )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最後，您可以在 <code>onDestroyView()</code> 中將 <code>_binding</code> 重設為空值(null)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy()</span><br><span class="line">    <span class="comment">// 將 _binding 屬性重設為 null，因為 view 已不存在</span></span><br><span class="line">    _binding = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>刪除 <code>DetailActivity</code> 中的其餘程式碼，只保留 <code>onCreate()</code> 方法。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> binding = ActivityDetailBinding.inflate(layoutInflater)</span><br><span class="line">   setContentView(binding.root)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="移除-DetailActivity"><a href="#移除-DetailActivity" class="headerlink" title="移除 DetailActivity"></a>移除 DetailActivity</h4><p>現在，您已順利將 <code>DetailActivity</code> 的功能遷移至 <code>WordListFragment</code>，所以不再需要 <code>DetailActivity</code>。您可以繼續刪除 <code>DetailActivity.kt</code> 和 <code>activity_detail.xml</code>，也可以對資訊清單進行小幅變更。</p>
<ol>
<li>首先，請刪除 <code>DetailActivity.kt</code></li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/2b13b08ac9442ae5_1920.png?hl=zh-tw" width="60%">

<ol start="2">
<li>確認已取消勾選「Safe Delete」，然後按一下「OK」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/239f048d945ab1f9_1920.png?hl=zh-tw" width="80%">

<ol start="3">
<li>接著刪除 <code>activity_detail.xml</code>。再次確認已取消勾選「Safe Delete」(安全刪除)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/774c8b152c5bff6b_1920.png?hl=zh-tw" width="50%">

<ol start="4">
<li>最後，由於 <code>DetailActivity</code> 已不存在，請將下列項目從 <code>AndroidManifest.xml</code> 中移除。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">activity</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:name</span>=<span class="string">&quot;.DetailActivity&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:parentActivityName</span>=<span class="string">&quot;.MainActivity&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>刪除 <code>DetailActivity</code> 後，剩下兩個 fragment ( <code>LetterListFragment</code> 和 <code>WordListFragment</code> ) 和單一 activity ( <code>MainActivity</code> )。下一節將介紹 <strong>Jetpack 導覽元件(navigation component)</strong> 並編輯 <code>activity_main.xml</code>，使得能夠顯示 fragment 及在 fragment 之間導覽，而不是代管靜態 layout。</p>
<hr>
<h3 id="Jetpack-導覽元件"><a href="#Jetpack-導覽元件" class="headerlink" title="Jetpack 導覽元件"></a>Jetpack 導覽元件</h3><p>Android Jetpack 提供<u>導覽元件(Navigation component)</u>，可協助您在應用程式中處理任何簡易或複雜的導覽(navigation)實作。Navigation component 包含三個主要部分，可供您在 Words 應用程式中導入 navigation 功能。</p>
<ul>
<li><code>Navigation Graph</code>：<code>Navigation Graph</code> 是可以在您的應用程式中<u>提供 navigation 功能視覺表示</u>的 <u>XML 檔案</u>。檔案包含<u>對應於個別 activity 和 fragment 的「目的地」</u>，以及在程式碼中可用於<u>在目的地之間導覽(navigation)的動作</u>。就如同 layout 檔案，Android Studio 提供視覺編輯器，可用於在 <code>Navigation Graph</code> 中加入目的地和動作。</li>
<li><code>NavHost</code>：<code>NavHost</code> 是用來<u>顯示在 activity 內來自 <code>Navigation Graph</code> 的目的地</u>。當您在 fragment 之間導覽時，<code>NavHost</code> 中顯示的目的地也會隨之更新。您需要在 <code>MainActivity</code> 中使用內建的實作，名為 <code>NavHostFragment</code>。</li>
<li><code>NavController</code>：<u><code>NavController</code> 物件(object)</u>可讓您<u>控制 <code>NavHost</code> 中顯示的目的地之間的導覽(navigation)動作</u>。使用 intent 時，您必須呼叫 <code>startActivity</code> 才能前往新的畫面。您可以<u>使用 navigation component 呼叫 <code>NavController</code> 的 <code>navigate()</code> 方法，調換所顯示的 fragment</u>。<code>NavController</code> 也有助於您處理一般工作，例如回應系統「up」按鈕，即可返回先前顯示的 fragment。</li>
</ul>
<h4 id="Navigation-Dependency"><a href="#Navigation-Dependency" class="headerlink" title="Navigation Dependency"></a>Navigation Dependency</h4><ol>
<li>在 project-level 的 <code>build.gradle</code> 檔案中，於 <strong>buildscript &gt; ext</strong> 的 <code>material_version</code> 下方，將 <code>nav_version</code> 設為等於 <code>2.5.2</code>。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    ext &#123;</span><br><span class="line">        appcompat_version = <span class="string">&quot;1.5.1&quot;</span></span><br><span class="line">        constraintlayout_version = <span class="string">&quot;2.1.4&quot;</span></span><br><span class="line">        core_ktx_version = <span class="string">&quot;1.9.0&quot;</span></span><br><span class="line">        kotlin_version = <span class="string">&quot;1.7.10&quot;</span></span><br><span class="line">        material_version = <span class="string">&quot;1.7.0-alpha2&quot;</span></span><br><span class="line">        nav_version = <span class="string">&quot;2.5.2&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 app-level 的 <code>build.gradle</code> 檔案中，將以下內容加入 dependencies 群組：</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">implementation <span class="string">&quot;androidx.navigation:navigation-fragment-ktx:$nav_version&quot;</span></span><br><span class="line">implementation <span class="string">&quot;androidx.navigation:navigation-ui-ktx:$nav_version&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="Safe-Args-Plugin-外掛程式"><a href="#Safe-Args-Plugin-外掛程式" class="headerlink" title="Safe Args Plugin(外掛程式)"></a>Safe Args Plugin(外掛程式)</h3><p>初次在 Words 應用程式中導入 navigation 時，您使用這兩種 activity 之間的 explicit intent(明確意圖)。若要在兩個 activity 之間傳遞資料，您必須呼叫 <code>putExtra()</code> 方法，並傳入所選字母。</p>
<p>將 navigation component 導入至 Words 應用程式之前，建議您也新增名為 <strong>Safe Args</strong> 的 Gradle plugin(外掛程式)，協助您在 fragment 之間傳遞資料時確保 type 安全。</p>
<p>請執行下列步驟，將 SafeArgs 整合至您的專案</p>
<ol>
<li>在 project-level 的 <code>build.gradle</code> 檔案中，於 buildscript &gt; dependencies 新增下列類別路徑。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">classpath</span> <span class="string">&quot;androidx.navigation:navigation-safe-args-gradle-plugin:$nav_version&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 app-level 的 <code>build.gradle</code> 檔案中，在 <code>plugins</code> 內的頂端新增 <code>androidx.navigation.safeargs.kotlin</code>。</li>
</ol>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">plugins &#123;</span><br><span class="line">    id <span class="string">&#x27;com.android.application&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-android&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;kotlin-kapt&#x27;</span></span><br><span class="line">    id <span class="string">&#x27;androidx.navigation.safeargs.kotlin&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>編輯 Gradle 檔案後，頁面頂端會顯示黃色橫幅，要求您同步處理專案。按一下「Sync Now」，等待一兩分鐘讓 Gradle 更新專案的 dependencies，反映所做變更。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/854d44a6f7c4c080_1920.png?hl=zh-tw">

<p>同步完成後，您就可以進行下一步來新增 navigation graph。</p>
<hr>
<h3 id="使用-Navigation-Graph"><a href="#使用-Navigation-Graph" class="headerlink" title="使用 Navigation Graph"></a>使用 Navigation Graph</h3><p>現在您對 fragments 和生命週期都有基本瞭解，接著就要開始更有趣的事情。下一步是納入 Navigation component。<u>Navigation component 只是一系列導入尤其在 fragments 之間 navigation 的工具集合</u>。您將使用新的 <strong>visual editor</strong> 協助<u>導入 fragments 之間的 navigation</u>；<code>Navigation Graph</code> (簡稱 <code>NavGraph</code>)。</p>
<h4 id="什麼是-Navigation-Graph？"><a href="#什麼是-Navigation-Graph？" class="headerlink" title="什麼是 Navigation Graph？"></a>什麼是 Navigation Graph？</h4><p><code>Navigation Graph</code> (簡稱 <code>NavGraph</code>) 是應用程式 navigation 的虛擬對應。在這種情況下，<u>每個 screen 或 fragment 都變成一個可以前往的可能「目的地」</u>。<u><code>NavGraph</code> 能以 XML 檔案表示，表明每個目的地彼此之間有何關聯</u>。</p>
<p>這項功能會在幕後建立 <code>NavGraph</code> class 的新 instance。不過，<code>FragmentContainerView</code> 會向使用者顯示 navigation graph 中的目的地。您只需建立 XML 檔案並定義可能的目的地即可。然後使用產生的程式碼以在 fragment 之間導覽。</p>
<h4 id="在-MainActivity-中使用-FragmentContainerView"><a href="#在-MainActivity-中使用-FragmentContainerView" class="headerlink" title="在 MainActivity 中使用 FragmentContainerView"></a>在 MainActivity 中使用 FragmentContainerView</h4><p>由於 layouts 已包含在 <code>fragment_letter_list.xml</code> 和 <code>fragment_word_list.xml</code> 中，因此 <code>activity_main.xml</code> 檔案不再需要包含應用程式中第一個畫面(screen)的 layout。而是重複利用 <code>MainActivity</code> 以包含 <code>FragmentContainerView</code> 來作為 fragment 的 <code>NavHost</code>。從現在開始，應用程式中的所有 navigation 動作都會發生在 <code>FragmentContainerView</code> 中。</p>
<ol>
<li>將 <code>activity_main.xml</code> (即 <code>androidx.recyclerview.widget.RecyclerView</code>) 中的 <code>FrameLayout</code> 內容替換為 <code>FragmentContainerView</code>。將此 ID 設定為 <code>nav_host_fragment</code>，並將高度和寬度設定為 <code>match_parent</code>，即可填滿整個 frame layout。</li>
</ol>
<p>將下面的 code：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>替換為此：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.fragment.app.FragmentContainerView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/nav_host_fragment&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 ID 屬性下方新增 <code>name</code> 屬性，並設定為 <code>androidx.navigation.fragment.NavHostFragment</code>。雖然您可以針對此屬性指定特定 fragment，但設定為 <code>NavHostFragment</code> 即可讓 <code>FragmentContainerView</code> 在 fragment 之間導覽。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:name=&quot;androidx.navigation.fragment.NavHostFragment&quot;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>layout_height</code> 和 <code>layout_width</code> 屬性下方新增 <code>app:defaultNavHost</code> 屬性，並設定為等於 “true”。如此一來，fragment container 就可以與 navigation 階層互動。舉例來說，按下系統返回(back)按鈕後，container 就會回到先前顯示的 fragment，就像顯示新 activity 時的情況一樣。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:defaultNavHost=&quot;true&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增名為 <code>app:navGraph</code> 的屬性，並將該屬性設定為等於 “@navigation&#x2F;nav_graph”。這會指向一個 XML 檔案，用於定義應用程式 fragment 之間的導覽方式。Android Studio 暫時會顯示尚未解決的符號錯誤。您會在接下來的工作中解決這個問題。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:navGraph=&quot;@navigation/nav_graph&quot;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>最後，由於您使用應用程式 namespace 新增了兩項屬性，因此務必在 <code>FrameLayout</code> 中加入 <code>xmlns:app</code> 屬性。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>這些就是 <code>activity_main.xml</code> 中的所有變更。接下來，您將建立 <code>nav_graph</code> 檔案。</p>
<h3 id="設定-Navigation-Graph"><a href="#設定-Navigation-Graph" class="headerlink" title="設定 Navigation Graph"></a>設定 Navigation Graph</h3><p>新增 navigation graph 檔案 (「File」(檔案)&gt;「New」(新增) &gt;「Android Resource File」(Android 資源檔案))，並按照以下方式填寫各欄位。</p>
<ul>
<li>檔案名稱：<code>nav_graph.xml</code> 這個名稱與您為 <code>app:navGraph</code> 屬性設定的名稱相同。</li>
<li>資源類型：「Navigation」。系統隨即會將「Directory Name」自動變更為 navigation，然後建立名為「navigation」的新資源資料夾。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/6812c83aa1e9cea6_1920.png">

<p>建立 XML 檔案時，系統會顯示新的視覺編輯器。由於您已引用 <code>FragmentContainerView</code> 的 <code>navGraph</code> 屬性中的 <code>nav_graph</code>，如要新增目的地，請按一下畫面左上方的新增按鈕，然後為每個 fragment 建立目的地 (一個用於 <code>fragment_letter_list</code>，另一個用於 <code>fragment_word_list</code>)。</p>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/dc2b53782de5e143.gif">

<p>新增完成後，這些片段應該就會顯示在畫面中央的 navigation gragh 上。您也可以使用左側顯示的元件樹狀結構來選取特定目的地。</p>
<h4 id="建立-Navigation-action-動作"><a href="#建立-Navigation-action-動作" class="headerlink" title="建立 Navigation action(動作)"></a>建立 Navigation action(動作)</h4><p>如要建立 <code>letterListFragment</code> 到 <code>wordListFragment</code> 目的地之間的導覽動作，請將滑鼠游標懸停在 <code>letterListFragment</code> 目的地上，然後從右側顯示的圓圈拖曳至 <code>wordListFragment</code> 目的地。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/980cb34d800c7155.gif?hl=zh-tw">

<p>現在您應該會看到已建立的箭頭，用來表示兩個目的地之間的動作。按一下箭頭，您就會在屬性窗格中看到可在程式碼中引用名稱為 <code>action_letterListFragment_to_wordListFragment</code> 的動作。</p>
<h3 id="指定-WordListFragment-的-Arguments-參數"><a href="#指定-WordListFragment-的-Arguments-參數" class="headerlink" title="指定 WordListFragment 的 Arguments(參數)"></a>指定 WordListFragment 的 Arguments(參數)</h3><p>使用 intent 在 activity 之間導覽(navigation)時，您指定了「extra」(額外項目)，使得所選字母可傳遞到 <code>wordListFragment</code>。Navigation 也支援在目的地之間傳遞<u>參數</u>，並以 type 安全的方式完成這項操作。</p>
<p>選取 <code>wordListFragment</code> 目的地，然後在屬性窗格的 <strong>Arguments</strong>下方，按一下「＋」按鈕建立新的參數(argument)。</p>
<p>參數(argument)應名為 <code>letter</code>，型別應為 <code>String</code>。您先前新增的 Safe Args 外掛程式就能派上用場。將這個引數(argument)指定為字串(String)，可確保在程式碼中執行 navigation 動作時，String 會如預期運作。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/f1541e01d3462f3e_1920.png?hl=zh-tw" width="60%">

<h3 id="設定起始目的地"><a href="#設定起始目的地" class="headerlink" title="設定起始目的地"></a>設定起始目的地</h3><p>當您的 <code>NavGraph</code> 知道所有需要的目的地時，<code>FragmentContainerView</code> 如何知道首先要顯示哪個 fragment？ 在 <code>NavGraph</code> 中，您需要將字母列表設定為起始目的地。</p>
<p>如要設定起始目的地，請選取 <code>letterListFragment</code>，然後按一下「Assign start destination」按鈕。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/3fdb226894152fb0_1920.png?hl=zh-tw" width="60%">

<p>這就是您目前需要在 <code>NavGraph</code> 編輯器執行的所有操作。此時，您就可以繼續並建立專案。在 Android Studio 中，從選單列依序選取「Build」&gt;「Rebuild Project」。系統會根據您的 navigation graph 產生一些程式碼，方便您使用剛建立的 navigation 動作。</p>
<h3 id="執行-Navigation-Action"><a href="#執行-Navigation-Action" class="headerlink" title="執行 Navigation Action"></a>執行 Navigation Action</h3><p>開啟 <code>LetterAdapter.kt</code> 以執行 navigation action(動作)。只需要兩個步驟即可完成。</p>
<ol>
<li>刪除按鈕 <code>setOnClickListener()</code> 的內容。您必須改為擷取剛建立的 navigation action。將以下內容新增至 <code>setOnClickListener()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> action = LetterListFragmentDirections.actionLetterListFragmentToWordListFragment(letter = holder.button.text.toString())</span><br></pre></td></tr></table></figure>

<p>系統可能無法辨識部分的類別和函式名稱，原因是在建構專案後已自動產生這些名稱。如此一來，您在第一個步驟新增的 <strong>Safe Args</strong> 外掛程式就能派上用場，而在 <code>NavGraph</code> 中建立的動作(action)會轉為您可以使用的程式碼。然而，這些名稱應該要相當直覺易懂。<code>LetterListFragmentDirections</code> 表示從 <code>letterListFragment</code> 為起點開始的所有可能 navigation 路徑。</p>
<p><code>actionLetterListFragmentToWordListFragment()</code> 函式是前往 <code>wordListFragment</code> 的特定動作。</p>
<p>對 navigation action 進行引用後，只需要取得「NavController」(可用來執行 navigation action 的物件) 的引用並呼叫 <code>navigate()</code> 傳入該動作(action)即可。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">holder.view.findNavController().navigate(action)</span><br></pre></td></tr></table></figure>

<h4 id="設定-MainActivity"><a href="#設定-MainActivity" class="headerlink" title="設定 MainActivity"></a>設定 MainActivity</h4><p>最後一段設定位於 <code>MainActivity</code> 中。僅需要少許變更 <code>MainActivity</code> 就可確保一切運作正常。</p>
<ol>
<li>建立 <code>navController</code> 屬性。此標記為 <code>lateinit</code>，因為它會在 <code>onCreate</code> 中進行設定。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> navController: NavController</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然後，在 <code>onCreate()</code> 中呼叫 <code>setContentView()</code> 後，引用 <code>nav_host_fragment</code> (這是 <code>FragmentContainerView</code> 的 ID)，並指派給 <code>navController</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> navHostFragment = supportFragmentManager</span><br><span class="line">    .findFragmentById(R.id.nav_host_fragment) <span class="keyword">as</span> NavHostFragment</span><br><span class="line">navController = navHostFragment.navController</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然後，在 <code>onCreate()</code> 中呼叫 <code>setupActionBarWithNavController()</code>，並傳入 <code>navController</code>。這可確保畫面上會顯示動作列(action bar&#x2F;app bar) 按鈕（例如 <code>LetterListFragment</code> 中的 menu 選項）可見。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setupActionBarWithNavController(navController)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>最後，導入 <code>onSupportNavigateUp()</code>。除了在 XML 中將 <code>defaultNavHost</code> 設定為 <code>true</code> 之外，此方法也可用來處理 up 按鈕。不過，您的 activity 必須提供實作。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSupportNavigateUp</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> navController.navigateUp() || <span class="keyword">super</span>.onSupportNavigateUp()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到目前為止，所有元件就緒，可以使用 fragment 進行導覽(navigation)。不過，現在 navigation 功能是使用 fragment 而非 intent 執行，因此您在 <code>WordListFragment</code> 中使用的字母的 intent extras 將不再有效。在下一個步驟中，您必須更新 <code>WordListFragment</code> 以取得 <code>letter</code> 參數。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 由於 ，<b>navigateUp()</b> 函式可能會失敗，因此會傳回 <b>Boolean</b> 以指示是否成功。不過，只有在 <b>navigateUp()</b> 傳回 <b>false</b> 時，您才需要呼叫 <b>super.onSupportNavigateUp()</b>。由於 <code>||</code> 運算子只需要符合其中一個條件就為 <b>true</b>，所以仍然適用，因此如果 <b>navigateUp()</b> 傳回 <b>true</b>，則不會執行 <code>||</code> 運算式的右側。不過，如果 <b>navigateUp()</b> 為 <b>false</b>，則會呼叫父項類別的實作。這稱為<a href="https://en.wikipedia.org/wiki/Short-circuit_evaluation">短路求值 (Short-circuit evaluation)</a>，是程式設計的必備小技巧。</p>
          </div>

<hr>
<h3 id="獲取-WordListFragment-中的參數"><a href="#獲取-WordListFragment-中的參數" class="headerlink" title="獲取 WordListFragment 中的參數"></a>獲取 WordListFragment 中的參數</h3><p>您先前曾在 <code>WordListFragment</code> 中引用 <code>activity?.intent</code> 以存取 <code>letter</code> extra。這雖然有效，但不是最佳做法，因為 fragment 可以嵌入在其他 layout 中及大型應用程式中，這會很難假設 fragment 屬於哪個 activity。此外，使用 <code>nav_graph</code> 執行導覽且使用安全參數時是沒有 intent 的，因此嘗試存取 intent extra 並不可行。</p>
<p>幸好，存取安全參數非常簡單，無須等到 <code>onViewCreated()</code> 呼叫完畢。</p>
<ol>
<li>在 <code>WordListFragment</code> 中建立 <code>letterId</code> 屬性。您可以將此屬性標記為 <code>lateinit</code>，這樣就不必將它設為可為 null 了。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> letterId: String</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著覆寫 <code>onCreate()</code> (不是 <code>onCreateView()</code> 或 <code>onViewCreated()！</code>)，並加入以下內容：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">    arguments?.let &#123;</span><br><span class="line">        letterId = it.getString(LETTER).toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於 <code>arguments</code> 有可能是可選的，因此請務必呼叫 <code>let()</code> 並傳入 <code>lambda</code>。這段程式碼會假設 <code>arguments</code> 不是空值(null)，並傳入 <code>it</code> 參數的非空值(null)參數。不過，如果 <code>arguments</code> 是 <code>null</code>，則 lambda 將不會執行。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/96a6a3253cea35b0_1920.png?hl=zh-tw" width="70%">

<p>雖然 Android Studio 不是實際程式碼之部分，但還提供實用的提示，讓您瞭解 <code>it</code> 參數。</p>
<p><code>Bundle</code> 到底是什麼？可將其視為用在類別 (例如 activity 和 fragment) 之間傳遞資料的 key&#x2F;value 組合。實際上，當您在這個應用程式的第一個版本中執行 intent 時，呼叫 <code>intent?.extras?.getString()</code> 時使用的就是 bundle。和使用 fragment 時，從參數中取得字串的方式完全相同。</p>
<ol start="3">
<li>最後，您可以在設定 recycler view 的 adapter 時存取 <code>letterId</code>。將 <code>onViewCreated()</code> 中的 <code>activity?.intent?.extras?.getString(LETTER).toString()</code> 替換成 <code>letterId</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView.adapter = WordAdapter(letterId, requireContext())</span><br></pre></td></tr></table></figure>

<p>您成功了！請花點時間執行應用程式。現在，您可以在一個 activity 中，在兩個畫面之間進行導覽(navigation)，而不需要使用任何 intent。</p>
<hr>
<h3 id="更新-Fragment-Label"><a href="#更新-Fragment-Label" class="headerlink" title="更新 Fragment Label"></a>更新 Fragment Label</h3><p>您已成功將這兩個畫面轉換成使用 fragment。在進行變更之前，每個 fragment 的 app bar 都會針對 app bar 中的每個 activity 提供描述性標題(descriptive title)。然而，一旦轉換成使用 fragment，這個標題就不會出現在 detail activity 中。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/c385595994ba91b5_1920.png?hl=zh-tw" width="30%">

<p>fragment 有一個名為 <code>label</code> 的屬性，您可以在其中設定父項 activity 要在 app bar 中使用的標題。</p>
<ol>
<li>在 <code>strings.xml</code> 中，在 app 名稱之後，新增下列常數。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;word_list_fragment_label&quot;</span>&gt;</span>Words That Start With &#123;letter&#125;<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>您可以在 navigation graph 中設定每個 fragment 的 label。返回 <code>nav_graph.xml</code> 中，在 component 樹狀結構中選取 <code>letterListFragment</code>，然後前往屬性窗格將 label 設定為 <code>app_name</code> 字串：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/a5ffe7a27aa03750_1920.png?hl=zh-tw" width="70%">

<ol start="3">
<li>選取 <code>wordListFragment</code>，並將 label 設定為 <code>word_list_fragment_label</code>：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-fragments-navigation-component/img/29c206f03a97557b_1920.png?hl=zh-tw" width="70%"> 

<p>恭喜您完成目前為止的工作！請再執行一次應用程式，您應該會看到程式碼研究室開始時呈現的原貌，不過現在所有 navigation 動作都已透過單一 activity 代管，且每個畫面都設有獨立的 fragment。</p>
<img src="https://i.imgur.com/eEIGXji.png" width="30%">

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>fragment 是可嵌入 activity 中可重複使用的使用者介面。</li>
<li>fragment 的生命週期與 activity 生命週期不同，而 view 設定發生在 <code>onViewCreated()</code>中，而不是 <code>onCreateView()</code>。</li>
<li><code>FragmentContainerView</code> 可用來將 fragment 嵌入至其他 activity 中，以及管理 fragment 之間的  navigation。</li>
</ul>
<p><strong>使用 navigation component</strong>  </p>
<ul>
<li>設定 <code>FragmentContainerView</code> 的 <code>navGraph</code> 屬性可讓您在 activity 內的不同 fragment 之間進行 navigation。</li>
<li><code>NavGraph</code> 編輯器可讓您新增 navigation 動作，以及指定不同目的地的之間的參數(argument)。</li>
<li>使用 intent 進行 navigation 時，您必須傳入 extra，navigation component 會使用 SafeArgs 自動為 navigation 動作產生類別和方法，以確保參數(argument)的 type 安全性。</li>
</ul>
<p><strong>fragment 的用途</strong>  </p>
<ul>
<li>使用 navigation component 時，許多應用程式可在單一 activity 中管理整個 layout，且所有navigation 動作都在 fragment 之間進行。</li>
<li>fragment 可讓您使用常見的 layout 模式，例如平板電腦上的 master-detail layout，或是相同 activity 中的多個 fragment label。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>companion object</tag>
        <tag>Navigation</tag>
        <tag>Activity</tag>
        <tag>Fragment</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(23)-Activity生命週期的各個階段</title>
    <url>/2023/10/16/Android%E7%AD%86%E8%A8%98-23-Activity%E7%94%9F%E5%91%BD%E9%80%B1%E6%9C%9F%E7%9A%84%E5%90%84%E5%80%8B%E9%9A%8E%E6%AE%B5/</url>
    <content><![CDATA[<blockquote>
<p>身為 Android 開發人員，您必須瞭解 <strong>activity 生命週期(lifecycle)</strong> 。如果您的 activity 未正確回應生命週期狀態變更，應用程式可能會產生<u>異常錯誤</u>、<u>造成使用者混淆行為</u>，或<u>耗用過多 Android 系統資源</u>。瞭解 Android 生命週期，並正確回應生命週期狀態變更，是成為 Android 優良使用者的重要條件。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何將記錄資訊列印至 <code>Logcat</code>。</li>
<li><code>Activity</code> 生命週期的基本概念，以及 activity 於狀態之間變動時叫用的 callback。</li>
<li>如何覆寫生命週期 callback 方法，以在 activity 生命週期的不同時間點執行運算</li>
</ul>
<span id="more"></span>

<p><strong>Activity 生命週期</strong> 是 <span class="label primary">activity 在其生命週期內可呈現的狀態組合</span>。<strong>生命週期(lifecycle)</strong> 是指 <span class="label primary">activity 從最初建立到刪除的這段期間</span>，且<u>系統會回收該 activity 的資源</u>。當使用者在應用程式 (包括應用程式內外) 的 activity 間進行瀏覽時，這些 activity 會在 activity 生命週期中的不同狀態之間進行轉換。</p>
<hr>
<h3 id="應用程式總覽"><a href="#應用程式總覽" class="headerlink" title="應用程式總覽"></a>應用程式總覽</h3><p>在本程式碼研究室中，您將使用名為 DessertClicker 的範例應用程式。在此應用程式中，每當使用者輕觸畫面上的甜點，應用程式就會為使用者「購買」甜點。這款應用程式會更新 layout 中的值，包括<u>已購買的甜點數量</u>，以及<u>使用者花費的總金額</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/8216c20f5571fc04_1920.png?hl=zh-tw" width="30%">

<p>此應用程式含有數個與 <strong>Android 生命週期相關的錯誤</strong> ：舉例來說，應用程式會在特定情況下將甜點值重設為 0。瞭解 Android 生命週期有助於瞭解問題發生的原因與修正方法。</p>
<h4 id="取得範例應用程式"><a href="#取得範例應用程式" class="headerlink" title="取得範例應用程式"></a>取得範例應用程式</h4><p>下載 <a href="https://github.com/google-developer-training/android-basics-kotlin-dessert-clicker-app/tree/starter">DessertClicker範例程式碼</a>，並在 Android Studio 中開啟。</p>
<p>如果您使用 GitHub 中的範例程式碼，請注意資料夾名稱是 <code>android-basics-kotlin-dessert-clicker-app-starter</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<hr>
<h3 id="探索生命週期方法並新增基本記錄"><a href="#探索生命週期方法並新增基本記錄" class="headerlink" title="探索生命週期方法並新增基本記錄"></a>探索生命週期方法並新增基本記錄</h3><p>每個 activity 都具有生命週期。這是植物和動物生命週期的影射，如同這隻蝴蝶的生命週期。蝴蝶的不同狀態，顯示其從出生到完全成熟的成蟲，再到死亡的成長過程。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/c685f48ff799f0c9_1920.png?hl=zh-tw" width="60%">

<p>同樣地，<strong>activity 生命週期</strong> 由 activity 可能經歷的<u>不同狀態</u>組成，從 <span class="label primary">activity 首次初始化到最終刪除，且系統回收其記憶體的這段時間</span>。當使用者啟動您的應用程式、在 activity 間瀏覽、在應用程式內部或外部瀏覽時，activity 皆會改變狀態。下圖顯示所有 activity 生命週期狀態。顧名思義，這些狀態代表 activity 的狀態。</p>
<img src="https://i.imgur.com/JTwpN3o.png" width="70%">

<p>通常，當 activity 生命週期狀態變更時，您會想變更部分行為或執行某些程式碼。因此，Activity 類別本身和 Activity 的任何子類別 (例如 <code>AppCompatActivity</code>) 會實作一系列生命週期 <span class="label primary">回調(callback)</span> 方法。</p>
<p>當 activity <u>狀態改變</u>時，Android 會叫用這些 <u>callback</u>，而您可以在自己的 activity 中覆寫此類方法，並執行任務來回應生命週期狀態變更。下圖顯示生命週期狀態，以及可用的可覆寫 callback。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/f6b25a71cec4e401_1920.png?hl=zh-tw" width="70%">

<p>請務必瞭解這些 callback 的叫用時機，以及每個 callback 方法的處理方式。但兩個圖表都很複雜，可能會令人感到困惑。在本程式碼研究室中，您不僅將瞭解每個狀態和 callback 的意義，還會進行一些偵測工作並瞭解實際情況。</p>
<h4 id="步驟-1：檢查-onCreate-方法並新增記錄"><a href="#步驟-1：檢查-onCreate-方法並新增記錄" class="headerlink" title="步驟 1：檢查 onCreate() 方法並新增記錄"></a>步驟 1：檢查 onCreate() 方法並新增記錄</h4><p>如要瞭解 Android 生命週期發生的情況，瞭解呼叫各種生命週期方法的時機相當實用。這有助於您找出 DessertClicker 中的問題。</p>
<p>最簡單的方法就是使用 Android <strong>紀錄(logging)功能</strong>。<strong>紀錄(logging)功能</strong>可讓您<span class="label primary">在應用程式執行期間，將簡短訊息寫入主控台，以便顯示不同 callback 觸發的時間</span>。</p>
<ol>
<li><p>執行 <code>Dessert Clicker</code> 應用程式，然後在甜點相片上輕觸數次。請注意<u>已售出甜點值</u>和<u>總金額</u>的變化情況。</p>
</li>
<li><p>開啟 <code>MainActivity.kt</code> 並檢查此活動的 <code>onCreate()</code> 方法：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在活動生命週期圖表中，您可能已認出 <code>onCreate()</code> 方法，因為您先前使用過此 callback。這是每項 activity 都必須實作的方法。<code>onCreate()</code> 是您為 activity 執行任何一次性<u>初始化</u>作業的方法。舉例來說，在 <code>onCreate()</code> 中，您會<u>加載 layout</u>、<u>定義 click listeners</u>，或是<u>設定 view binding</u>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/9be2255ff49e0af8_1920.png?hl=zh-tw" width="70%">

<p>當 activity 初始化後 (在記憶體中建立新的 Activity 物件時)，系統會呼叫 <code>onCreate()</code> 生命週期方法一次。執行 <code>onCreate()</code> 後，系統會<u>將 activity 視為已建立</u>。</p>
<div class="note no-icon success">
            <p><strong>注意事項：</strong> 覆寫 <b>onCreate()</b> 方法時，您必須<u>呼叫父類別實作</u>來完成 activity 建立，因此您必須立即在其內部呼叫 <b>super.onCreate()</b>。其他生命週期 callback 方法也是如此。</p>
          </div>

<ol start="3">
<li>在 <code>onCreate()</code> 方法中，於呼叫 <code>super.onCreate()</code> 後新增下列程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Log.d(<span class="string">&quot;MainActivity&quot;</span>, <span class="string">&quot;onCreate Called&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>視需要匯入 <code>Log</code> 類別 (Mac 上請按 Alt+Enter 或 Option+Enter，然後選取「Import」)。如果您已啟用自動匯入功能，系統會自動執行這項操作。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> android.util.Log</span><br></pre></td></tr></table></figure>

<p><code>Log</code> 類別會將訊息寫入「Logcat」。「Logcat」是記錄訊息的主控台。此處會顯示來自 Android 的應用程式相關訊息，包括您透過 <code>Log.d()</code> 方法或其他 <code>Log</code> 類別方法明確傳送至記錄的訊息。</p>
<p>這個指令包含三個部分：</p>
<ul>
<li>log message 的「優先順序(priority)」，也就是訊息的重要性。在這種情況下，<code>Log.d()</code> 方法會寫入偵錯(debug)訊息。<code>Log</code> 類別中的其他方法包括資訊(informational)訊息的 <code>Log.i()</code>、錯誤(errors)的 <code>Log.e()</code>、警示(warnings)的 <code>Log.w()</code>，或詳細(verbose)訊息的 <code>Log.v()</code>。</li>
<li><strong>log tag (第一個參數)</strong> ，在本範例中為 “MainActivity”。這個標記是 <span class="label primary">字串</span>，供您在 <code>Logcat</code> 中輕鬆找到記錄訊息。標記通常是<u>類別的名稱</u>。</li>
<li><strong>log message (第二個參數)</strong> 是 <span class="label primary">簡短字串</span>，在本範例中為 “onCreate called”。</li>
</ul>
<div class="note no-icon success">
            <p>注意：在類別中宣告 <b>TAG 常數</b>是良好慣例：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure><p>並在記錄(logging)方法的後續呼叫中使用，如下所示：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Log.d(TAG, <span class="string">&quot;onCreate Called&quot;</span>)</span><br></pre></td></tr></table></figure>
          </div>

<p><a href="https://kotlinlang.org/docs/properties.html#backing-properties">編譯時間常數(compile-time constant)</a>是不會改變的值。在變數宣告之前使用 <code>const</code>，以將其標示為編譯時間常數(compile-time constant)。</p>
<ol start="5">
<li>編譯並執行 DessertClicker 應用程式。輕觸甜點時，就不會在應用程式中看到任何行為差異。在 Android Studio 中，按一下畫面底部的「Logcat」分頁標籤。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/6463f587ac6997fe_1920.png?hl=zh-tw">

<ol start="6">
<li>在「Logcat」視窗的搜尋欄位中輸入 <code>D/MainActivity</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/bb0b78600cd47789_1920.png?hl=zh-tw">

<p>Logcat 可包含許多訊息，其中大部分無法派上用場。篩選 Logcat 項目的方法相當多樣，但搜尋是最簡單的方法。由於您在程式碼中使用 <code>MainActivity</code> 做為log tag，因此您可以使用該 tag 篩選記錄(log)。<del>在開頭加上 <code>D/</code>，表示這是由 <code>Log.d()</code> 建立的偵錯(debug)訊息</del>。</p>
<div class="note no-icon danger">
            <p><code>D/</code>已無法使用 –&gt; 改成使用 <code>level:debug</code> 來篩選偵錯(debug)訊息、使用 <code>tag: MainActivity</code> 來篩選 <code>MainActivity</code>。</p>
          </div>

<img src="https://i.imgur.com/64lFOcy.png">

<p>您的 log message 包括日期和時間、套件名稱 (<code>com.example.android.dessertclicker</code>)、log tag，以及實際訊息。由於這則訊息會出現在記錄(log)中，但您知道系統已執行該 <code>onCreate()</code>。</p>
<h4 id="步驟-2：實作-onStart-方法"><a href="#步驟-2：實作-onStart-方法" class="headerlink" title="步驟 2：實作 onStart() 方法"></a>步驟 2：實作 onStart() 方法</h4><p>系統將在 <code>onCreate()</code> 之後呼叫 <code>onStart()</code> 生命週期方法。<code>onStart()</code> 開始執行後，螢幕上會顯示您的 activity。<code>onCreate()</code> 僅可呼叫一次以初始化 activity，與之不同的是，<code>onStart()</code> 在 activity 生命週期中<span class="label primary">可呼叫多次</span>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/385df4ce82ae2de9_1920.png?hl=zh-tw" width="70%">

<p>請注意，<code>onStart()</code> 已和對應的 <code>onStop()</code> 生命週期方法配對。<span class="label primary">如果使用者啟動應用程式，然後返回裝置的主畫面，activity 就會停止，且不再顯示於螢幕上</span>。</p>
<ol>
<li>在 Android Studio，於 <code>MainActivity.kt</code> 開啟且游標位於 MainActivity 類別內時選取「Code」(程式碼) &gt;「Override Methods」(覆寫方法)，或按下 <strong>Control+o</strong> 。顯示的對話方塊會列出您可在此類別中覆寫的所有方法。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/e1f2460242b2ae_1920.png?hl=zh-tw" width="60%">

<ol start="2">
<li>輸入 <code>onStart</code> 以搜尋正確方法。如要捲動至下一個相符的項目，請使用向下鍵。從清單中選擇 <code>onStart()</code>，然後按一下「OK」，插入樣板覆寫程式碼。程式碼如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onStart()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>MainActivity.kt</code> (位於類別宣告 <code>class</code> <code>MainActivity.</code> 上方) 頂層新增下列常數</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>onStart()</code> 方法中加入記錄(log)訊息：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStart</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onStart()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onStart Called&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>編譯並執行 DessertClicker 應用程式，然後開啟「Logcat」窗格。在搜尋欄位中輸入 <code>tag: MainActivity level:debug</code> ，以篩選記錄。請注意，將逐一呼叫 <code>onCreate()</code> 和 <code>onStart()</code> 方法，且您的 activity 會顯示在螢幕上。</li>
</ol>
<img src="https://i.imgur.com/O0gMjxZ.png">

<ol start="6">
<li>按下裝置的主畫面按鈕，然後使用「最近使用」畫面返回 activity。請注意，activity 會從上次中斷的地方接續進行，所有值皆相同，且系統會將 <code>onStart()</code> 再次記錄到 Logcat。另請注意，通常不會再次呼叫 <code>onCreate()</code> 方法。</li>
</ol>
<img src="https://i.imgur.com/avSaQzf.png">

<div class="note no-icon success">
            <p><strong>注意：</strong> 在測試裝置並觀察生命週期 callback 時，可能會在裝置旋轉時發現異常行為。稍後您將在本程式碼研究室中學習相關行為。</p>
          </div>

<h4 id="步驟-3：新增更多記錄陳述式"><a href="#步驟-3：新增更多記錄陳述式" class="headerlink" title="步驟 3：新增更多記錄陳述式"></a>步驟 3：新增更多記錄陳述式</h4><p>在這個步驟中，您會實作所有其他生命週期方法的記錄(logging)功能。</p>
<ol>
<li>覆寫 MainActivity 中的其餘生命週期方法，並為每個方法新增陳述式。程式碼如下：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onResume</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onResume()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onResume Called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onPause</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onPause()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onPause Called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onStop</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onStop()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onStop Called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onDestroy</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onDestroy()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onDestroy Called&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onRestart</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onRestart()</span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onRestart Called&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>再次編譯並執行 DessertClicker，並檢查 Logcat。這次請注意，除了 <code>onCreate()</code> 和 <code>onStart()</code> 以外，系統也會提供 <code>onResume()</code> 生命週期 callback 的記錄(log)訊息。</li>
</ol>
<img src="https://i.imgur.com/Z49Q817.png">

<p>activity 從頭開始時，系統會依序呼叫下列三個生命週期 callback：</p>
<ul>
<li><code>onCreate()</code> 可建立應用程式。</li>
<li><code>onStart()</code> 可啟動 activity 並在螢幕上顯示。</li>
<li><code>onResume()</code> 可<u>聚焦(focus)</u>在 activity，並使其<u>準備與使用者進行互動</u>。</li>
</ul>
<p>儘管有名稱，即使沒有可繼續進行的操作，啟動時仍會呼叫 <code>onResume()</code> 方法。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/160054d59f67519_1920.png?hl=zh-tw" width="70%">

<hr>
<h3 id="探索生命週期用途"><a href="#探索生命週期用途" class="headerlink" title="探索生命週期用途"></a>探索生命週期用途</h3><p>現在，DessertClicker 應用程式已進行記錄設定，您可以透過各種方式開始使用該應用程式，並探索如何觸發生命週期回呼來回應用途。</p>
<h4 id="用途-1：開啟及關閉-activity"><a href="#用途-1：開啟及關閉-activity" class="headerlink" title="用途 1：開啟及關閉 activity"></a>用途 1：開啟及關閉 activity</h4><p>您將從最基本的用途開始，也就是初次啟動應用程式，然後完全關閉應用程式。</p>
<ol>
<li>編譯並執行 DessertClicker 應用程式 (如果尚未執行)。如您所見，活動初次開始時，就會呼叫 <code>onCreate()</code>、<code>onStart()</code>，以及 <code>onResume()</code> 回呼。</li>
</ol>
<img src="https://i.imgur.com/LBdn6B0.png">

<ol start="2">
<li><p>輕觸杯子蛋糕數次。</p>
</li>
<li><p>關閉應用程式。請注意，Logcat 中會依序呼叫 <code>onPause()</code>、<code>onStop()</code> 和 <code>onDestroy()</code>。</p>
</li>
</ol>
<img src="https://i.imgur.com/0QqTifY.png">

<ol start="4">
<li>重新開啟 DessertClicker 應用程式。Logcat 如下：</li>
</ol>
<img src="https://i.imgur.com/TJacVYl.png">

<div class="note no-icon success">
            <p><strong>注意：</strong> 此處重點為 <b>onCreate()</b> 和 <b>onDestroy()</b> 在單一活動執行個體的生命週期中只呼叫一次：<b>onCreate()</b> 會首次初始化應用程式，<b>onDestroy()</b> 會清除應用程式使用的資源。</p>
          </div>

<h4 id="用途-2：離開後再返回-activity"><a href="#用途-2：離開後再返回-activity" class="headerlink" title="用途 2：離開後再返回 activity"></a>用途 2：離開後再返回 activity</h4><p>現在，您已啟動並完全關閉應用程式，您可看到 activity 首次建立時的大部分生命週期狀態。此外，您也會看到 activity 完全關閉且刪除後經歷的所有生命週期狀態。然而，當使用者與 Android 裝置互動時，會在應用程式間切換、返回主畫面、啟動新的應用程式，並處理因其他 activity (例如來電) 而中斷的 activity。</p>
<p>每次使用者離開該 activity 時，activity 都<u>不會完全關閉</u>：</p>
<ul>
<li>當系統不再於畫面中顯示 activity 時，即稱為使 <u>activity 進入背景</u>。(反之，則 activity 位於前景或螢幕上。)</li>
<li>使用者返回您的應用程式時，系統會重新啟動相同的 activity，並再次顯示該 activity。生命週期中的此部分稱為應用程式的可見生命週期。</li>
</ul>
<p>應用程式在背景運作時，通常不應主動運作，以維持系統資源和電池壽命。您會使用 Activity 生命週期及其 callback 來瞭解應用程式移至背景的時間，以便暫停任何進行中的作業。接著您會在應用程式進入前景時重新開始作業。</p>
<p>在這個步驟中，您可以查看<u>應用程式進入背景後再次回到前景的 activity 生命週期</u>。</p>
<ol>
<li>開啟 DessertClicker 應用程式，並點選杯子蛋糕數次。</li>
</ol>
<img src="https://i.imgur.com/SJvsRRm.png">

<ol start="2">
<li>按下裝置上的「主畫面」按鈕，然後觀察 Android Studio 中的 Logcat。返回主畫面會讓應用程式進入背景，而非完全關閉應用程式。請注意，系統會呼叫 <code>onPause()</code> 方法和 <code>onStop()</code> 方法，但不會呼叫 <code>onDestroy()</code> 方法。</li>
</ol>
<img src="https://i.imgur.com/3r6awdd.png">

<p>呼叫 <code>onPause()</code> 後，應用程式就<u>不再有焦點</u>。<code>onStop()</code> 後，應用程式就<u>不會再顯示於螢幕上</u>。儘管 activity 已經停止，但 Activity 物件仍位於背景的記憶體中。系統並未刪除該 activity。使用者可能會返回應用程式，因此 Android 會保留您的 activity 資源。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/b488b32801220b79_1920.png?hl=zh-tw" width="70%">

<ol start="3">
<li>使用最近使用畫面返回應用程式。請注意，activity 會在 Logcat 中使用 <code>onRestart()</code> 和 <code>onStart()</code> 重新啟動，然後使用 <code>onResume()</code> 重新啟用。</li>
</ol>
<p>當 activity 返回前景時，就不會再次呼叫 <code>onCreate()</code> 方法。activity 物件並未刪除，因此不需要重新建立。系統會呼叫 <code>onRestart()</code> 方法，而不是 <code>onCreate()</code>。請注意，當 activity 返回前景時，系統會保留「Desserts Sold」數量。</p>
<img src="https://i.imgur.com/NETWqlA.png">

<ol start="4">
<li><p>至少啟動一個 DessertClicker 以外的應用程式，使裝置的最近使用畫面中含有多個應用程式。</p>
</li>
<li><p>開啟最近使用畫面，並開啟其他最近 activity。接著返回最近使用的應用程式，並將 DessertClicker 移回前景。</p>
</li>
</ol>
<img src="https://i.imgur.com/NeVrydM.png">

<ol start="6">
<li>來回切換應用程式<img src="https://i.imgur.com/M6k6pzu.png"></li>
</ol>
<p>請注意，此處 Logcat 中顯示的回呼與按下主畫面按鈕時相同。應用程式進入背景時，系統會呼叫 <code>onPause()</code> 和 <code>onStop()</code>，並在應用程式返回時呼叫 <code>onRestart()</code>、<code>onStart()</code> 和 <code>onResume()</code>。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 此處重點是，當使用者往返瀏覽 activity 時，系統會多次呼叫 <b>onStart()</b> 和 <b>onStop()</b>。</p>
          </div>

<p>當應用程式停止並移至背景，或應用程式返回前景並再次啟動時，系統就會呼叫這些方法。如果遇到這類情況，而您必須在應用程式中執行工作，請覆寫相關的生命週期 callback 方法。</p>
<p>那麼，<code>onRestart()</code> 呢？<code>onRestart()</code> 方法與 <code>onCreate()</code> 類似。在 activity 顯示之前，系統會呼叫 <code>onCreate()</code> 或 <code>onRestart()</code>。第一次僅會呼叫 <code>onCreate()</code> 方法，<code>onRestart()</code> 則在後續呼叫。<code>onRestart()</code> 方法是放置程式碼的地方，<span class="label primary">只有在活動為「非」初次啟動時才會呼叫該程式碼</span>。</p>
<h4 id="用途-3：部分隱藏-activity"><a href="#用途-3：部分隱藏-activity" class="headerlink" title="用途 3：部分隱藏 activity"></a>用途 3：部分隱藏 activity</h4><p>您已經瞭解應用程式啟動且呼叫 <code>onStart()</code> 時，螢幕上會顯示該應用程式。重新啟用應用程式並呼叫 <code>onResume()</code> 時，應用程式會取得使用者焦點，即使用者可與應用程式互動。應用程式完全顯示在畫面上，且有使用者焦點時，這個生命週期部分便是「互動」生命週期。</p>
<p>應用程式進入背景時，焦點會於 <code>onPause()</code> 後消失，且應用程式在 <code>onStop()</code> 後也不再顯示。</p>
<p>焦點和可見度之間的差異非常重要，因為 activity 在畫面上可以部分顯示，但沒有使用者焦點。在此步驟中，可查看部分顯示，但沒有使用者焦點的 activity。</p>
<ol>
<li>在 DessertClicker 應用程式執行時，按一下畫面右上方的「Share」按鈕。<br>分享 activity 會顯示在畫面的下半部，但 activity 仍會在上半部顯示</li>
</ol>
<p><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/9ddc8b1dc79b1bff_1920.png?hl=zh-tw"
width="30%"></p>
<ol start="2">
<li>檢查 Logcat，且注意僅呼叫 <code>onPause()</code>。</li>
</ol>
<img src="https://i.imgur.com/A1BHLmX.png">

<p>在此用途中，系統不會呼叫 <code>onStop()</code>，因為 activity 仍部分顯示。不過，這類 activity 沒有使用者焦點，且使用者無法與其互動，因為位於前景的「分享」activity 具有使用者焦點。</p>
<p>為什麼這個差異很重要？僅使用 <code>onPause()</code> 的干擾通常只會持續一小段時間，然後使用者便會返回 activity 或前往其他 activity 或應用程式。一般而言，您需要持續更新 UI，應用程式的其餘部分便不會停止運作。</p>
<p>在 <code>onPause()</code> 中執行的程式碼會使其他內容無法顯示，因此請將程式碼保存在輕量 <code>onPause()</code> 中。例如，如果有來電，<code>onPause()</code> 中的程式碼可能會延遲來電通知。</p>
<ol start="3">
<li>按一下分享對話方塊以外的地方，返回應用程式，並留意系統已呼叫 <code>onResume()</code>。</li>
</ol>
<img src="https://i.imgur.com/o77e1Is.png">

<p><code>onResume()</code> 和 <code>onPause()</code> 都必須與焦點有關。活動有焦點時，系統會呼叫 <code>onResume()</code> 方法，而活動失去聚焦時，就會呼叫 <code>onPause()</code>。</p>
<hr>
<h3 id="探索設定變更"><a href="#探索設定變更" class="headerlink" title="探索設定變更"></a>探索設定變更</h3><p>管理 activity 生命週期的另一個用例也十分重要：設定變更對 activity 生命週期的影響。</p>
<p>設定變更於裝置狀態改變時發生，因此基本上，使系統解決變更的最簡單方法就是完全關閉，然後重新建立 activity。舉例來說，若使用者變更裝置語言，您必須調整整個版面配置，以配合不同的文字方向和字串長度。如果使用者將裝置插入座架或新增實體鍵盤，應用程式版面配置可能必須採用不同的顯示大小或版面配置。如果裝置螢幕方向改變 (例如將裝置從直向轉為橫向或向後旋轉)，您可能需要根據新的螢幕方向變更版面配置。讓我們看看應用程式在這個情境中的行為。</p>
<h4 id="裝置旋轉時資料遺失"><a href="#裝置旋轉時資料遺失" class="headerlink" title="裝置旋轉時資料遺失"></a>裝置旋轉時資料遺失</h4><ol>
<li><p>編譯並執行應用程式，然後開啟 Logcat。</p>
</li>
<li><p>將裝置或模擬器旋轉至橫向模式。您可以使用旋轉按鈕或 Control 方向鍵，將模擬器向左或向右旋轉。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/623fce7c623d42bd_1920.png?hl=zh-tw" width="30%">

<ol start="3">
<li>檢查 Logcat 中的輸出內容。在 MainActivity 上篩選輸出內容。</li>
</ol>
<img src="https://i.imgur.com/SBJSsym.png">

<p>請注意，當裝置或模擬器旋轉螢幕時，系統會呼叫所有生命週期 callback 來<u>關閉 activity</u>。接著，當您重新建立 activity 時，系統會呼叫所有生命週期 callback 來<u>啟動 activity</u>。</p>
<p>裝置旋轉且關閉並重新建立 activity 後，activity 就會以預設值啟動，也就是將甜點售出數量和收益重設為零。</p>
<h4 id="使用-onSaveInstanceState-儲存套件資料"><a href="#使用-onSaveInstanceState-儲存套件資料" class="headerlink" title="使用 onSaveInstanceState() 儲存套件資料"></a>使用 onSaveInstanceState() 儲存套件資料</h4><p><code>onSaveInstanceState()</code> 方法為 callback，可用於在 Activity 刪除時儲存您需要的任何資料。在生命週期 callback 圖中，系統會在 activity 停止後呼叫 <code>onSaveInstanceState()</code>。每當應用程式進入背景時就會呼叫此方法。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activity-lifecycle/img/c259ab6beca0ca88_1920.png?hl=zh-tw" width="70%">

<p>您可以將 <code>onSaveInstanceState()</code> 呼叫視為安全防護措施；此呼叫會在 activity 離開前景時，將少量資訊儲存至套件。系統會在此時儲存資料，因為若等待直到應用程式關閉，系統可能會有資源壓力。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> Android 有時會關閉整個應用程式處理程序，包括與該應用程式相關的所有活動。Android 會在系統處於壓力且發生視覺延遲問題時執行此類關閉程序，因此目前不會執行其他 callback 或程式碼。應用程式處理程序只是在背景中自動關閉。但對使用者而言，應用程式似乎沒有關閉。當使用者返回 Android 系統已關閉的應用程式時，Android 就會重新啟動該應用程式。您必須<u>確保使用者不會在此情況下發生任何資料遺失情形</u>。</p>
          </div>

<p>每次儲存資料可確保套件中的已更新資料能夠視需要還原。</p>
<ol>
<li>在 MainActivity 中覆寫 <code>onSaveInstanceState()</code> callback，並新增 log 陳述式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onSaveInstanceState</span><span class="params">(outState: <span class="type">Bundle</span>)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onSaveInstanceState(outState)</span><br><span class="line"></span><br><span class="line">   Log.d(TAG, <span class="string">&quot;onSaveInstanceState Called&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> <b>onSaveInstanceState()</b> 有兩種覆寫設定，一種只有 <b>outState</b> 參數，另一種則包含 <b>outState</b> 和 <b>outPersistentState</b> 參數。請使用上述程式碼中顯示的單一 <b>outState</b> 參數。</p>
          </div>

<ol start="2">
<li>編譯並執行應用程式，然後按一下「Home」按鈕，讓應用程式進入背景。請注意，<code>onSaveInstanceState()</code> callback 緊接在 <code>onPause()</code> 和 <code>onStop()</code> 之後：</li>
</ol>
<img src="https://i.imgur.com/MzqhfVQ.png">

<ol start="3">
<li>在檔案頂端的類別定義前方，加入以下常數：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> KEY_REVENUE = <span class="string">&quot;revenue_key&quot;</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> KEY_DESSERT_SOLD = <span class="string">&quot;dessert_sold_key&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>您將使用這些鍵儲存與擷取執行個體狀態套件(instance state bundle)中的資料。</li>
</ul>
<ol start="4">
<li><p>向下捲動至 <code>onSaveInstanceState()</code>，並注意 <code>outState</code> 參數為 <code>Bundle</code> 類型。<code>Bundle</code> 是一系列 <strong>key-value</strong> 組合，其中 <strong>key</strong> 一律為字串(<code>String</code>)。您可以將簡易的資料 (例如 <code>Int</code> 和 <code>Boolean</code> 值) 加入套件中。由於系統會將此套件儲存在記憶體中，因此最佳做法是讓套件中的資料保持精簡。此套件的大小有限，但尺寸會因裝置而異。如果儲存過多資料，應用程式可能會因為 <code>TransactionTooLargeException</code> error 而異常終止。</p>
</li>
<li><p>在 <code>onSaveInstanceState()</code> 中，使用 <code>putInt()</code> 方法將 <code>revenue</code> 值 (Int) 加入套件中：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">outState.putInt(KEY_REVENUE, revenue)</span><br></pre></td></tr></table></figure>

<p><code>putInt()</code> 方法 (以及 <code>Bundle</code> 類別中的類似方法，例如 <code>putFloat()</code> 和 <code>putString()</code>) 使用兩個引數：<u>key 字串</u> (<code>KEY_REVENUE</code> 常數)，以及<u>要儲存的實際值(value)</u>。</p>
<ol start="6">
<li>按照相同的甜點售出數量重複上述步驟：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">outState.putInt(KEY_DESSERT_SOLD, dessertsSold)</span><br></pre></td></tr></table></figure>

<h4 id="使用-onCreate-還原套件資料"><a href="#使用-onCreate-還原套件資料" class="headerlink" title="使用 onCreate() 還原套件資料"></a>使用 onCreate() 還原套件資料</h4><p>您可以在 <code>onCreate(Bundle)</code> 或 <code>onRestoreInstanceState(Bundle)</code> 中還原 activity 狀態 (由 <code>onSaveInstanceState()</code> 方法填入的 <code>Bundle</code> 會傳遞至這兩個生命週期 callback 方法)。</p>
<ol>
<li>向上捲動至 <code>onCreate()</code>，並檢查方法簽章(signature)：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br></pre></td></tr></table></figure>

<p>請注意，每次呼叫時，<code>onCreate()</code> 都會獲得一個 <code>Bundle</code>。當您的 activity 因程序關閉而重新啟動時，您儲存的套件會傳遞至 <code>onCreate()</code>。如果您的 activity 重新啟動，<code>onCreate()</code> 中的此 <code>Bundle</code> 為 <code>null</code>。因此，如果套件並非 <code>null</code>，表示您是從先前的已知點「重新建立」activity。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 如果正在重新建立 activity，系統會在 <b>onStart()</b> 後呼叫含有套件的 <b>onRestoreInstanceState()</b> callback。在大多數情況下，您可以還原 <b>onCreate()</b> 的 activity 狀態。不過，由於在 <b>onStart()</b> 之後呼叫 <b>onRestoreInstanceState()</b>，如果您需要在呼叫 <b>onCreate()</b> 後還原部分狀態，可以使用 <b>onRestoreInstanceState()</b>。</p>
          </div>

<ol start="2">
<li>在設定 <code>binding</code> 變數後，將此程式碼新增至 <code>onCreate()</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">   revenue = savedInstanceState.getInt(KEY_REVENUE, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>null</code> 的測試可判斷套件中是否含有資料，或套件是否為 <code>null</code>，以讓您瞭解應用程式是否已重新啟動，或在關閉後重新建立。這項測試是從套件還原資料的常見模式。</p>
<p>請注意，您在此處使用的 <code>key (KEY_REVENUE)</code> 與您在 <code>putInt()</code> 中使用的 key 相同。為確保每次都使用相同的鍵，最佳做法是將這些 key 定義為常數。請使用 <code>getInt()</code> 將資料移出套件，如同使用 <code>putInt()</code> 將資料放入套件一樣。<code>getInt()</code> 方法使用兩個引數：</p>
<ul>
<li>可做為 key 的字串，例如收益值的 “key_revenue”。</li>
<li>預設值，假如套件中沒有該 key 的任何值。</li>
</ul>
<p>系統會將從套件中取得的整數指派給 <code>revenue</code> 變數，且 UI 會使用該值。</p>
<ol start="3">
<li>新增 <code>getInt()</code> 方法，還原收益和甜點售出數量。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">   revenue = savedInstanceState.getInt(KEY_REVENUE, <span class="number">0</span>)</span><br><span class="line">   dessertsSold = savedInstanceState.getInt(KEY_DESSERT_SOLD, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>編譯並執行應用程式。按下杯子蛋糕至少五次，直到切換成甜甜圈為止。</li>
</ol>
<img src="https://i.imgur.com/qZallCm.png" width="30%">

<ol start="5">
<li>旋轉裝置。請注意，應用程式現在可以顯示正確的收益，以及套件中的甜點售出值。另請注意，甜點已恢復為杯子蛋糕。</li>
</ol>
<img src="https://i.imgur.com/wREAUdC.png" width="70%">

<ol start="6">
<li>在 MainActivity 中檢查 <code>showCurrentDessert()</code> 方法。請注意，此方法會根據目前的甜點售出數量和 <code>allDesserts</code> 變數中的甜點清單，判斷要在 activity 中顯示的甜點圖片。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (dessert <span class="keyword">in</span> allDesserts) &#123;</span><br><span class="line">   <span class="keyword">if</span> (dessertsSold &gt;= dessert.startProductionAmount) &#123;</span><br><span class="line">       newDessert = dessert</span><br><span class="line">   &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">break</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此方法仰賴甜點的售出數量來選擇正確的圖片。因此，您無須採取任何行動，以儲存 <code>onSaveInstanceState()</code> 中套件的圖片參照。您已在該套件中儲存甜點售出數量。</p>
<ol start="7">
<li>在 <code>onCreate()</code> 中，從套件還原狀態的區塊呼叫 <code>showCurrentDessert()</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (savedInstanceState != <span class="literal">null</span>) &#123;</span><br><span class="line">   revenue = savedInstanceState.getInt(KEY_REVENUE, <span class="number">0</span>)</span><br><span class="line">   dessertsSold = savedInstanceState.getInt(KEY_DESSERT_SOLD, <span class="number">0</span>)</span><br><span class="line">   showCurrentDessert()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>編譯並執行應用程式，然後旋轉畫面。請注意，甜點售出值、總收益和甜點圖片已順利還原。</li>
</ol>
<img src="https://i.imgur.com/naBOnos.gif" width="30%">

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><h4 id="activity-生命週期"><a href="#activity-生命週期" class="headerlink" title="activity 生命週期"></a>activity 生命週期</h4><ul>
<li>activity 生命週期是一組 activity 轉移的狀態。activity 生命週期是從首次建立時開始，並在 activity 刪除時結束。</li>
<li>使用者在不同 activity 之間及應用程式內外瀏覽時，每個 activity 會在 activity 生命週期中的狀態間切換。</li>
<li>activity 生命週期中的每個狀態都有相應的 <u>callback 方法</u>，可在 Activity 類別中<u>覆寫</u>，如下：<a href="https://developer.android.com/reference/android/app/Activity#onCreate(android.os.Bundle)"><code>onCreate()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onStart()"><code>onStart()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onPause()"><code>onPause()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onRestart()"><code>onRestart()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onResume()"><code>onResume()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onStop()"><code>onStop()</code></a> <a href="https://developer.android.com/reference/android/app/Activity#onDestroy()"><code>onDestroy()</code></a></li>
<li>如要新增在 activity 轉換為生命週期狀態時發生的行為，請<u>覆寫狀態的 callback 方法</u>。</li>
<li>如要在 Android Studio 中為類別新增架構覆寫方法，請依序選取「Code」&gt;「Override Methods」，或按下 <code>Control+o</code>。</li>
</ul>
<h4 id="使用-Log-進行記錄"><a href="#使用-Log-進行記錄" class="headerlink" title="使用 Log 進行記錄"></a>使用 Log 進行記錄</h4><ul>
<li>Android Logging API (尤其是 <a href="https://developer.android.com/reference/android/util/Log"><code>Log</code></a> 類別)，可讓您編寫在 Android Studio 的 Logcat 中顯示的簡短訊息。</li>
<li>請使用 <code>Log.d()</code> 編寫偵錯訊息。這個方法使用兩個引數：<u>log tag</u>，通常是類別名稱，以及 <u>log message</u>，此為簡短字串。</li>
<li>使用 Android Studio 中的「Logcat」視窗檢視系統記錄，包括您編寫的訊息。</li>
</ul>
<h4 id="保留-activity-狀態"><a href="#保留-activity-狀態" class="headerlink" title="保留 activity 狀態"></a>保留 activity 狀態</h4><ul>
<li>應用程式進入背景時，只要呼叫 <code>onStop()</code> 後，即可將應用程式資料儲存至套件中。系統會自動儲存部分應用程式資料 (例如 <code>EditText</code> 的內容)。</li>
<li>套件是 <a href="https://developer.android.com/reference/kotlin/android/os/Bundle"><code>Bundle</code></a> 執行個體，也是 <u>key</u> 和 <u>value</u> 的集合。key 一律是字串。</li>
<li>使用 <code>onSaveInstanceState()</code> callback <u>將其他資料儲存至您要保留的套件</u> (即使應用程式會自動關閉)。如要<u>將資料放入套件</u>，請使用開頭為 <code>put</code> 的套件方法，例如 <code>putInt()</code>。</li>
<li>您可以從 <code>onRestoreInstanceState()</code> 方法中的套件，或更常見的 <code>onCreate()</code> <u>取回資料</u>。<code>onCreate()</code> 方法的 <code>savedInstanceState</code> 參數可用來保存套件。</li>
<li>如果 <code>savedInstanceState</code> 變數為 <code>null</code>，表示 activity 是在沒有狀態套件的情況下開啟動，且沒有可擷取的狀態資料。</li>
<li>如要<u>透過 key 從套件擷取資料</u>，請使用以 <code>get</code> 開頭的 <code>Bundle</code> 方法，例如 <code>getInt()</code>。</li>
</ul>
<h4 id="設定變更"><a href="#設定變更" class="headerlink" title="設定變更"></a>設定變更</h4><ul>
<li>設定變更於裝置狀態改變時發生，因此基本上，使系統解決變更的最簡單方法就是<u>刪除</u>，然後<u>重新建立 activity</u>。</li>
<li>最常見的設定變更範例為，使用者將裝置從直向轉為橫向模式，或從橫向轉為直向模式時。裝置語言變更或外接硬體鍵盤時，也可能會發生設定變更。</li>
<li>發生設定變更時，Android 會叫用所有 activity 生命週期的<u>關閉 callback</u>。接著，Android 會從頭<u>重新啟動 activity</u>，並執行所有生命週期啟動 callback。</li>
<li>Android 因設定變更而關閉應用程式時，Android 會以<code> onCreate()</code> 可用的狀態套件來重新啟動 activity。</li>
<li>如同程序中斷，請將應用程式的狀態儲存到 <code>onSaveInstanceState()</code> 的套件中。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Activity</tag>
        <tag>Lifecycle</tag>
        <tag>Log</tag>
        <tag>Logcat</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(22)-Activities和Intents</title>
    <url>/2023/09/29/Android%E7%AD%86%E8%A8%98-22-Activities%E5%92%8CIntents/</url>
    <content><![CDATA[<blockquote>
<p>目前為止，您使用的應用程式只執行一項<code>活動(activity)</code>。但實際上很多 Android 應用程式需要執行多項活動(activity)，並透過<code>導覽(navigation)</code>來切換應用程式。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>使用<code>明確意圖(intent)</code>導覽(navigation)至特定活動(activity)。</li>
<li>使用<code>隱含意圖(intent)</code>導覽(navigation)至其他應用程式的內容。</li>
<li>新增<code>選單(menu)</code>選項，並新增按鈕至<code>應用程式列(app bar)</code>。</li>
</ul>
<p>在本程式碼研究室中，您要建構一個字典應用程式，讓應用程式使用多項活動，並使用<code>意圖(intent)</code>切換應用程式，同時<strong>傳遞資料</strong>至其他應用程式。</p>
<span id="more"></span>

<hr>
<h3 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h3><p>在後續步驟中，您要使用 Words 應用程式。Words 應用程式是簡單的字典應用程式，包含字母清單、每個字母的字詞，以及在瀏覽器中查詢個別字詞定義的功能。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/c465ef280fe3792a_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/8ad271362c0a113b_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<h4 id="下載範例程式碼"><a href="#下載範例程式碼" class="headerlink" title="下載範例程式碼"></a>下載範例程式碼</h4><p>請注意，GitHub 下載範例程式碼的資料夾名稱是 <code>android-basics-kotlin-words-app-starter</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong> <a href="https://github.com/google-developer-training/android-basics-kotlin-words-app">https://github.com/google-developer-training/android-basics-kotlin-words-app</a><br><strong>分支版本名稱：</strong> <b>starter</b></p>
          </div>

<h4 id="在-Android-Studio-中開啟專案"><a href="#在-Android-Studio-中開啟專案" class="headerlink" title="在 Android Studio 中開啟專案"></a>在 Android Studio 中開啟專案</h4><ol>
<li>啟動 Android Studio。</li>
<li>開啟 <code>android-basics-kotlin-words-app-starter</code> 專案</li>
<li>按一下「Run」按鈕，確認應用程式的建構符合預期。</li>
</ol>
<hr>
<h3 id="Word-應用程式總覽"><a href="#Word-應用程式總覽" class="headerlink" title="Word 應用程式總覽"></a>Word 應用程式總覽</h3><p>繼續操作前，請花點時間熟悉專案內容。您必須熟悉上一個單元的所有概念。應用程式目前有兩項<code>活動(activities)</code>，包含 <code>recycler view</code> 和 <code>adapter</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/61af34429128695e_1920.png" width="50%" height="50%">

<p>具體而言，您會使用下列檔案：</p>
<ol>
<li><code>MainActivity</code> 的 <code>RecyclerView</code> 會使用 <code>LetterAdapter</code>。每個字母都是包含 <code>onClickListener</code> 的按鈕，這些按鈕目前沒有任何內容。您可以在這裡管理按鈕點按操作以導覽至 <code>DetailActivity</code>。</li>
<li><code>DetailActivity</code> 的 <code>RecyclerView</code> 使用 <code>WordAdapter</code>，以顯示字詞清單(list)。雖然您暫時無法前往此畫面，但請記得每個字詞都有對應的按鈕和 <code>onClickListener</code>。在這個步驟中，為了導覽至瀏覽器並顯示字詞的定義，您要加入程式碼。</li>
<li><code>MainActivity</code> 也需要進行一些變更。在這個步驟中，為了顯示按鈕，讓使用者切換清單(list)和格線版面配置，您要實作選項選單(option menu)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/ce3474dba2a9c1c8_1920.png?hl=zh-tw" width="30%" height="30%">

<hr>
<h3 id="Intent簡介"><a href="#Intent簡介" class="headerlink" title="Intent簡介"></a>Intent簡介</h3><p>您已完成初始專案設定，接著我們要探討意圖(intent)，以及如何在應用程式中使用意圖(intent)。</p>
<p><code>意圖(intent)</code>是物件，代表要執行的一些動作。我們最常看到意圖用來啟動<code>活動(activity)</code> (當然意圖不只這個用途)。<code>意圖(intent)</code>分為兩種類型：<code>隱含(implicit)</code>和<code>明確(explicit)</code>。</p>
<ul>
<li><strong>明確意圖(explicit intent)</strong> ：極為精確，您確切知道要啟動的活動(activity) (通常是應用程式的畫面)。</li>
<li><strong>隱含意圖(implicit intent)</strong> ：較抽象，系統收到動作的類型 (例如開啟連結、撰寫電子郵件或撥打電話)，然後負責判斷如何完成要求。</li>
</ul>
<p>您可能已看過這兩種意圖(intent)，只是未察覺到。一般而言，在您的應用程式中 <strong>顯示活動(activity)</strong> 時，即是使用 <strong>明確意圖(explicit intent)</strong> 。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/c465ef280fe3792a_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>但如果動作不涉及目前的應用程式 (例如您找到有趣的 Android 文件資訊頁面，並想分享給朋友)，即使用 <strong>隱含意圖(implicit intent)</strong> 。您可能會看到類似選單，詢問您要使用什麼應用程式分享資訊頁面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/e9c77033d9224170_1920.png?hl=zh-tw" width="30%" height="30%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/702236c6e2276f91_1920.png?hl=zh-tw" width="70%" height="70%">

<hr>
<h3 id="設定-Explicit-Intent"><a href="#設定-Explicit-Intent" class="headerlink" title="設定 Explicit Intent"></a>設定 Explicit Intent</h3><p>現在可以實作第一個意圖(Intent)了。在第一個畫面上，當使用者輕觸字母後，就會前往列有字詞清單的第二個畫面。因為已實作 <code>DetailActivity</code>，所以只需使用Intent啟動此動作。因為應用程式已經知道要啟動特定的活動(Activity)，您可以使用明確意圖(Explicit Intent)。</p>
<p>建立並使用Intent只需幾個步驟：</p>
<ol>
<li>開啟 <code>LetterAdapter.kt</code> 並向下捲動至 <code>onBindViewHolder()</code>。在這一行程式碼下，設定按鈕文字，並設定 <code>holder.button</code> 的 <code>onClickListener</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">holder.button.setOnClickListener &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>然後取得 <code>context</code> 的參考。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> context = holder.itemView.context</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>建立 <code>Intent</code>，並傳入目的地活動的結構定義和 class name。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(context, DetailActivity::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>
<ul>
<li>您要顯示的活動名稱指定為 <code>DetailActivity::class.java</code>。實際的 <code>DetailActivity</code> 物件會在幕後建立。</li>
</ul>
<ol start="4">
<li>呼叫 <code>putExtra</code> 方法，然後傳入「letter」做為第一個引數，按鈕文字則做為第二個引數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">intent.putExtra(<span class="string">&quot;letter&quot;</span>, holder.button.text.toString())</span><br></pre></td></tr></table></figure>

<p>extra 是什麼？請記得，intent 只是一組操作說明，但目的地動作目前沒有 intent。而 extra 是一段資料，例如數字或字串，即之後擷取的指定名稱。這類似於呼叫函式時傳遞引數。因為 <code>DetailActivity</code> 可顯示任何字母，您必須指定顯示哪個字母。</p>
<p>此外，您認為為什麼需要呼叫 <code>toString()</code>？按鈕的文字是字串，對吧？</p>
<p>可以這麼說。它其實是 <code>CharSequence</code> 類型，即所謂的介面。您目前不需瞭解 Kotlin 介面的任何資訊，只需知道介面是用於確定字串等類型，以及實作特定函式和屬性的方式。您可以將 － 聯想為類似字串 class 的一般表示法。按鈕的 <code>text</code> 屬性可以是字串，或同時是 <code>CharSequence</code> 的任何物件。但 <code>putExtra()</code> 方法接受 <code>String</code>，不是 <code>CharSequence</code>，所以必須呼叫 <code>toString()</code>。</p>
<ol start="5">
<li>呼叫結構定義的 <code>startActivity()</code> 方法，並傳入 <code>intent</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>接著執行應用程式，並嘗試輕觸字母。隨即顯示詳細資料畫面！但無論使用者輕觸哪個字母，詳細資料畫面會一律顯示字母 A 的字詞。在詳細資料動作中，一些工作仍有待完成，才會顯示傳遞字母的字詞，作為 <code>intent</code> 額外資料。</p>
<hr>
<h3 id="設定-DetailActivity"><a href="#設定-DetailActivity" class="headerlink" title="設定 DetailActivity"></a>設定 DetailActivity</h3><p>您已建立第一個明確意圖！現在進入詳細資料畫面。</p>
<p>在 <code>DetailActivity</code> 的 <code>onCreate</code> 方法中，呼叫 <code>setContentView</code> 後，以程式碼取代硬式編碼字母，從 <code>intent</code> 取得傳入的 <code>letterId</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> letterId = intent?.extras?.getString(<span class="string">&quot;letter&quot;</span>).toString()</span><br></pre></td></tr></table></figure>

<p>這裡有很多要注意的事項，所以接著我們要查看每個項目：</p>
<p>首先，<code>intent</code> 屬性的來源為何？這不是 <code>DetailActivity</code> 的屬性，而是任何活動的屬性。此屬性會持續參考啟動活動使用的意圖。</p>
<p>額外屬性是 <code>Bundle</code> 類型，或許您已猜到，該屬性提供方法來存取傳入意圖的所有額外屬性。</p>
<p>這兩個屬性會以問號標示。原因是什麼呢？原因是 <code>intent</code> 和 <code>extras</code> 屬性可為空值，換句話說，您可以使用值，也可以不使用值。有時，您可能想要變數為 <code>null</code>。<code>intent</code> 屬性可能不是 <code>Intent</code> (如果活動不是從意圖啟動)，此外，額外的屬性可能不是 <code>Bundle</code>，而是名為 <code>null</code> 的值。在 Kotlin 中，<code>null</code> 代表沒有值。物件可能存在，或可能是 <code>null</code>。如果您的應用程式嘗試在 <code>null</code> 物件上存取屬性或呼叫函式，該應用程式就會異常終止。若要安全存取這個值，您必須在名稱後方加上 <code>?</code>。如果 <code>intent</code> 是 <code>null</code>，應用程式不會嘗試存取額外的屬性，此外，如果 <code>extras</code> 為空值，程式碼也不會嘗試呼叫 <code>getString()</code>。</p>
<p>如何知道哪些屬性需要問號才能確保空值的安全性？您可以透過類型名稱後方是否有問號或驚嘆號來判斷。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/b43155b06a5556e_1920.png?hl=zh-tw" width="70%">

<p>最後請注意，使用 <code>getString</code> 擷取實際字母會傳回 <code>String?</code>，所以呼叫 <code>toString()</code> 可確保它是 <code>String</code>，而不是 <code>null</code>。</p>
<p>您現在執行應用程式，並導覽至詳細資料畫面時，應該會看到每個字母的字詞清單。</p>
<h4 id="清除-Cleaning-Up"><a href="#清除-Cleaning-Up" class="headerlink" title="清除(Cleaning Up)"></a>清除(Cleaning Up)</h4><p>兩個程式碼會執行意圖，並擷取選取 <code>extra</code> 名稱「letter」(字母) 的字母硬式編碼。雖然小型樣本可以使用這方法，但對於大型應用程式 (其中包含需持續追蹤的大量意圖額外資料) 就不是最佳做法。</p>
<p>雖然您可以只建立名為「letter」的常數，但應用程式加入較多意圖額外資訊後，就不適合使用常數；更何況常數要放置在哪個 class 也是個問題。請記得，字串會同時用於 <code>DetailActivity</code> 和 <code>MainActivity</code>。您必須定義常數，才可以跨多個 class 使用，並維持程式碼井然有序。</p>
<p>值得慶幸的是，我們可透過一項實用的 Kotlin 功能來區隔常數，而且不必使用名為「<a href="https://kotlinlang.org/docs/object-declarations.html">companion object</a>」 class 的特定 instance，一樣可以使用常數。Companion object 類似於 class instance 這種其他物件。但在程式執行期間，<u><strong>companion object</strong> 只會存在一個 <strong>instance</strong></u>，所以有時稱為「<a href="https://en.wikipedia.org/wiki/Singleton_pattern">單例模式(singleton)</a>」。除了本程式碼研究室的適用範圍外，單例模式(singleton)仍有許多用途，但目前您要使用 companion object 規劃常數，並使其可從 <code>DetailActivity</code> 外部存取。您可以開始使用 companion object，重構「letter」(字母) 額外資料的程式碼。</p>
<ol>
<li>在 <code>onCreate</code> 上方的 <code>DetailActivity</code> 中，新增以下內容：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>請注意，這做法類似於定義 class，只是使用了 <code>object</code> 關鍵字。另外還有關鍵字 <code>companion</code>，表示該關鍵字與 <code>DetailActivity</code> class 相關聯，所以我們不必為其指定額外的類型名稱。</li>
</ul>
<ol start="2">
<li>在大括號中加入字母常數的屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">val</span> LETTER = <span class="string">&quot;letter&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>若要使用新的常數，請更新 <code>onCreate()</code> 中呼叫的硬式編碼字母，如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> letterId = intent?.extras?.getString(LETTER).toString()</span><br></pre></td></tr></table></figure>

<p>再次提醒您，常數通常會參考點標記法，但仍屬於 <code>DetailActivity</code>。</p>
<ol start="4">
<li>切換至 <code>LetterAdapter</code>，並修改呼叫 <code>putExtra</code>，以使用新的常數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">intent.putExtra(DetailActivity.LETTER, holder.button.text.toString())</span><br></pre></td></tr></table></figure>

<p>大功告成！重構後，您的程式碼會更容易閱讀和維護。如果您要變更程式碼，或新增的其他常數，只需在一個位置進行變更。</p>
<p>若要深入瞭解 companion object，請參閱<a href="https://kotlinlang.org/docs/object-declarations.html">物件運算式和宣告</a>的 Kotlin 說明文件。</p>
<hr>
<h3 id="設定-Implicit-Intent"><a href="#設定-Implicit-Intent" class="headerlink" title="設定 Implicit Intent"></a>設定 Implicit Intent</h3><p>在多數情況下，您的應用程式會顯示特定的活動(Activity)。但在部分情況下，您不會知道要啟動什麼活動(Activity)或應用程式(Application)。在我們的詳細資料畫面上，每個字詞按鈕會顯示使用者的字詞定義。</p>
<p>例如，使用 <code>Google</code> 搜尋提供的字典功能。您不是在應用程式中加入新活動，而是啟動裝置瀏覽器，顯示搜尋網頁。<br>所以您可能需要意圖(Intent)以在 <code>Chrome</code> (Android 預設的瀏覽器) 中載入資訊頁面嗎？</p>
<p>答錯了。<br>部分使用者可能慣用第三方瀏覽器，或手機隨附製造商預先安裝的瀏覽器。他們也許已安裝 Google 搜尋應用程式，或是第三方字典應用程式。</p>
<p>您無法得知使用者安裝哪些應用程式，也無法假定他們要查詢的字詞。這範例正適合使用隱含意圖(Implicit Intent)。您的應用程式會提供系統採用動作的資訊，然後系統會判斷處置動作的方式，並在必要時提示使用者其他資訊。</p>
<p>請按照下列步驟建立隱含意圖：</p>
<ol>
<li>在這個應用程式中，您要執行 Google 搜尋字詞。第一個搜尋結果是字詞的字典定義。由於每次搜尋都會使用相同的基準網址，因此建議您將網址定義為常數。在 <code>DetailActivity</code> 中修改隨附物件(companion object)，增加新的常數 <code>SEARCH_PREFIX</code>。這是 Google 搜尋的基準網址。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">val</span> LETTER = <span class="string">&quot;letter&quot;</span></span><br><span class="line">   <span class="keyword">const</span> <span class="keyword">val</span> SEARCH_PREFIX = <span class="string">&quot;https://www.google.com/search?q=&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著，開啟 <code>WordAdapter</code>，然後在 <code>onBindViewHolder()</code> 方法中呼叫按鈕的 <code>setOnClickListener()</code>。開始建立搜尋查詢的 <code>Uri</code>。呼叫 <code>parse()</code> 以從 <code>String</code> 建立 <code>Uri</code> 時，您必須使用字串格式，才能將字詞附加至 <code>SEARCH_PREFIX</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">holder.button.setOnClickListener &#123;</span><br><span class="line">    <span class="keyword">val</span> queryUrl: Uri = Uri.parse(<span class="string">&quot;<span class="subst">$&#123;DetailActivity.SEARCH_PREFIX&#125;</span><span class="subst">$&#123;item&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您想知道「URI」是什麼，URI 不是錯字，而是「統一資源識別項」。您可能已經知道網址，或「統一資源定位器」是指向網頁的字串。URI 是格式的一般用語。所有網址 (URL) 都是 URI，但不是所有 URI 都是網址。其他 URI (例如電話號碼位址) 會以 <code>tel:</code> 開頭，但系統會視為 URN 或統一資源名稱，而不是網址。用來代表兩者的資料類型稱為 <code>URI</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/828cef3fdcfdaed_1920.png?hl=zh-tw">

<p>請注意，以下沒有任何與應用程式相關的活動。您只需提供 URI，但不知道最終用法。</p>
<ol start="3">
<li>定義 <code>queryUrl</code> 後，請將新的 <code>intent</code> 物件初始化：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> intent = Intent(Intent.ACTION_VIEW, queryUrl)</span><br></pre></td></tr></table></figure>

<p>但不必傳入結構定義和活動，而是傳入 <code>Intent.ACTION_VIEW</code> 和 <code>URI</code>。</p>
<p><code>ACTION_VIEW</code> 是通用意圖，可採用 URI，在本案例即是網址。接著，系統會在使用者的網路瀏覽器中，開啟 URI 處理意圖。其他意圖類型：</p>
<ul>
<li>CATEGORY_APP_MAPS：啟動地圖應用程式</li>
<li>CATEGORY_APP_EMAIL：啟動電子郵件應用程式</li>
<li>CATEGORY_APP_GALLERY：啟動圖片庫 (相簿) 應用程式</li>
<li>ACTION_SET_ALARM：在背景設定鬧鐘</li>
<li>ACTION_DIAL：撥打電話</li>
</ul>
<p>若要瞭解詳情，請參閱部分<a href="https://developer.android.com/guide/components/intents-common">常用意圖</a>的說明文件。</p>
<ol start="4">
<li>最後，即使您不在應用程式中啟動任何特定活動，但您仍會呼叫 <code>startActivity()</code> 並傳入 <code>intent</code>，指示系統啟動其他應用程式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">context.startActivity(intent)</span><br></pre></td></tr></table></figure>

<p>現在當您啟動應用程式、前往字詞清單，並輕觸其中一個字詞時，您的裝置應會導覽至該網址 (或根據安裝的應用程式，顯示選項清單)。</p>
<hr>
<h3 id="設定-Menu-和-Icons"><a href="#設定-Menu-和-Icons" class="headerlink" title="設定 Menu 和 Icons"></a>設定 Menu 和 Icons</h3><p>新增明確和隱含意圖，更方便瀏覽應用程式後，您可以新增選單選項，讓使用者可以在字母和清單與格線版面配置間切換。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/7edb0777b033c159_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/ce3474dba2a9c1c8_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>您目前可能看到很多應用程式畫面的頂端，使用此選項列。這是應用程式列，除了顯示應用程式名稱外，應用程式列也可以自訂並代管許多實用的功能，例如實用動作的快速鍵或溢位選單。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/dfc4095251c1466e_1920.png?hl=zh-tw" width="50%">

<p>在本應用程式中，我們不會新增完備的選單，您會瞭解如何在應用程式列中新增自訂按鈕，方便使用者變更版面配置。</p>
<ol>
<li>首先，您必須匯入兩個圖示，代表格狀和清單檢視。新增名為「view module」(將其命名為 <code>ic_grid_layout</code>) 和「view list」(將其命名為 <code>ic_linear_layout</code>) 的 vector assets。如需複習新增 material icons 的操作方式，請參閱<a href="https://developer.android.com/codelabs/basic-android-kotlin-training-polished-user-experience?continue=https://developer.android.com/courses/pathways/android-basics-kotlin-unit-2-pathway-1%23codelab-https://developer.android.com/codelabs/basic-android-kotlin-training-polished-user-experience&hl=zh-tw#3">此資訊頁面</a>的操作說明。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/5a01fc03113ac399_1920.png?hl=zh-tw" width="70%">

<ol start="2">
<li>您必須設法告知系統應用程式列要顯示的選項，以及使用的圖示。方法是在「res」資料夾上按一下滑鼠右鍵，然後依序選取「New」&gt;「Android Resource File」，藉此新增資源檔案。將「Resource Type」設為 <code>Menu</code>，並將「File Name」設為 <code>layout_menu</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-activities-intents/img/c4f83806a1aa121b_1920.png?hl=zh-tw" width="70%">

<ol start="3">
<li><p>按一下「OK」。</p>
</li>
<li><p>開啟「res&#x2F;Menu&#x2F;layout_menu」。以下列內容取代 <code>layout_menu.xml</code> 的內容：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">menu</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:id</span>=<span class="string">&quot;@+id/action_switch_layout&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:title</span>=<span class="string">&quot;@string/action_switch_layout&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:icon</span>=<span class="string">&quot;@drawable/ic_linear_layout&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">app:showAsAction</span>=<span class="string">&quot;always&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>此選單檔案的結構很簡單。就像版面配置會在開頭透過版面配置管理工具來保留個人檢視畫面，選單 XML 檔案會在開頭使用包含個別選項的選單標記。</p>
<p>您的選單只有一個按鈕，並包含一些屬性：</p>
<ul>
<li><code>id</code>：就像檢視畫面，選單選項在程式碼中也有可以參考的識別碼。</li>
<li><code>title</code>：在本範例中其實不會顯示文字，但螢幕閱讀器可能使用文字識別選單</li>
<li><code>icon</code>：預設為 <code>ic_linear_layout</code>。但選取按鈕後，系統會開啟或關閉按鈕，顯示網格圖示。</li>
<li><code>showAsAction</code>：告訴系統如何顯示按鈕。由於它設定為 always，這個按鈕會始終在應用程式列中可見，並且不會成為溢出選單(overflow menu)的一部分。</li>
</ul>
<p>您仍須在 <code>MainActivity.kt</code> 中新增一些程式碼，才能讓選單順利運作。</p>
<hr>
<h3 id="實作-Menu-button"><a href="#實作-Menu-button" class="headerlink" title="實作 Menu button"></a>實作 Menu button</h3><p>若要查看 menu button 實際的運作情形，您必須在 <code>MainActivity.kt</code> 中執行以下步驟。</p>
<ol>
<li>首先，建議您建立屬性(property)，追蹤應用程式所在的版面配置狀態，這樣做可讓您更輕鬆切換 layout 按鈕。將預設值設為 <code>true</code>，因為預設會使用 linear layout manager。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> isLinearLayoutManager = <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>當使用者切換按鈕時，您會希望 item 清單(item list)轉換成 item 的格狀清單(grid list)。不曉得您是否記得，我們在 recycler views 的課程中提到很多不同的版面配置管理工具，其中的 <code>GridLayoutManager</code> 可以在單一資料列顯示多個 item。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">chooseLayout</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isLinearLayoutManager) &#123;</span><br><span class="line">        recyclerView.layoutManager = LinearLayoutManager(<span class="keyword">this</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        recyclerView.layoutManager = GridLayoutManager(<span class="keyword">this</span>, <span class="number">4</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    recyclerView.adapter = LetterAdapter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在這個步驟中，您可以使用 <code>if</code> 陳述式指派 layout manager。除了設定 <code>layoutManager</code> 外，此程式碼也會指派 adapter。<code>LetterAdapter</code> 會用於 list 和 grid layout。</li>
</ul>
<ol start="3">
<li>一開始在 xml 中設定 menu 時，您會指定靜態圖示。但切換 layout 後，為了反映新功能，建議您更新圖示，並切換回 list layout。在這個步驟中，您只要設定 liner 和 grid layout 圖示，而在下次輕觸按鈕後，按鈕會根據 layout 切換回圖示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">setIcon</span><span class="params">(menuItem: <span class="type">MenuItem</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (menuItem == <span class="literal">null</span>)</span><br><span class="line">       <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Set the drawable for the menu icon based on which LayoutManager is currently in use</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// An if-clause can be used on the right side of an assignment if all paths return a value.</span></span><br><span class="line">   <span class="comment">// The following code is equivalent to</span></span><br><span class="line">   <span class="comment">// if (isLinearLayoutManager)</span></span><br><span class="line">   <span class="comment">//     menu.icon = ContextCompat.getDrawable(this, R.drawable.ic_grid_layout)</span></span><br><span class="line">   <span class="comment">// else menu.icon = ContextCompat.getDrawable(this, R.drawable.ic_linear_layout)</span></span><br><span class="line">   menuItem.icon =</span><br><span class="line">       <span class="keyword">if</span> (isLinearLayoutManager)</span><br><span class="line">           ContextCompat.getDrawable(<span class="keyword">this</span>, R.drawable.ic_grid_layout)</span><br><span class="line">       <span class="keyword">else</span> ContextCompat.getDrawable(<span class="keyword">this</span>, R.drawable.ic_linear_layout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根據 <code>isLinearLayoutManager</code> 屬性，系統會有條件地設定圖示。</p>
<p>若要應用程式順利使用 menu，您必須覆寫另外兩種方法。</p>
<ul>
<li><code>onCreateOptionsMenu</code>：這會加載 option menu，並執行其他設定</li>
<li><code>onOptionsItemSelected</code>：選取按鈕後，這會實際呼叫 <code>chooseLayout()</code>。</li>
</ul>
<ol>
<li>依照下列方式覆寫 <code>onCreateOptionsMenu</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateOptionsMenu</span><span class="params">(menu: <span class="type">Menu</span>?)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   menuInflater.inflate(R.menu.layout_menu, menu)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> layoutButton = menu?.findItem(R.id.action_switch_layout)</span><br><span class="line">   <span class="comment">// Calls code to set the icon based on the LinearLayoutManager of the RecyclerView</span></span><br><span class="line">   setIcon(layoutButton)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下方式並不難。加載 layout 後，請呼叫 <code>setIcon()</code>，確保圖示符合 layout。這個方法會傳回 <code>Boolean</code>，因為您要建立 option menu，所以會傳回 <code>true</code>。</p>
<ol start="2">
<li>只要在 <code>onOptionsItemSelected</code> 加入幾行程式碼實作，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onOptionsItemSelected</span><span class="params">(item: <span class="type">MenuItem</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">when</span> (item.itemId) &#123;</span><br><span class="line">       R.id.action_switch_layout -&gt; &#123;</span><br><span class="line">           <span class="comment">// Sets isLinearLayoutManager (a Boolean) to the opposite value</span></span><br><span class="line">           isLinearLayoutManager = !isLinearLayoutManager</span><br><span class="line">           <span class="comment">// Sets layout and icon</span></span><br><span class="line">           chooseLayout()</span><br><span class="line">           setIcon(item)</span><br><span class="line"></span><br><span class="line">           <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//  Otherwise, do nothing and use the core event handling</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// when clauses require that all possible paths be accounted for explicitly,</span></span><br><span class="line">       <span class="comment">//  for instance both the true and false cases if the value is a Boolean,</span></span><br><span class="line">       <span class="comment">//  or an else to catch all unhandled cases.</span></span><br><span class="line">       <span class="keyword">else</span> -&gt; <span class="keyword">super</span>.onOptionsItemSelected(item)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每次輕觸 menu item 都會呼叫這個程式碼，所以請務必檢查輕觸的 memu item。您會使用上述的 <code>when</code> 陳述式。如果 <code>id</code> 與 <code>action_switch_layout</code> memu item 相符，系統會取消 <code>isLinearLayoutManager</code> 的值。接著，請呼叫 <code>chooseLayout()</code> 和 <code>setIcon()</code>，更新使用者介面。</p>
<p>此外，執行應用程式前，因為 <code>chooseLayout()</code> 中已設定 layout manager 和 adapter，您必須在 <code>onCreate()</code> 中更換程式碼，才能呼叫新方法。變更完成後，<code>onCreate()</code> 應該會如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> binding = ActivityMainBinding.inflate(layoutInflater)</span><br><span class="line">   setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">   recyclerView = binding.recyclerView</span><br><span class="line">   <span class="comment">// Sets the LinearLayoutManager of the recyclerview</span></span><br><span class="line">   chooseLayout()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接著請執行應用程式，您可以使用 menu button，切換 list 和格狀檢視。</p>
<div class="video-container"><iframe src="https://player.vimeo.com/video/874763484" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<hr>
<h3 id="解決模擬器WIFI無網路"><a href="#解決模擬器WIFI無網路" class="headerlink" title="解決模擬器WIFI無網路"></a>解決模擬器WIFI無網路</h3><p>以MAC示範：</p>
<ol>
<li>打開系統設定 &gt; 網路 &gt; 點選 WIFI 的詳細資料</li>
</ol>
<img src="https://i.imgur.com/XrhmXOY.png" width="70%">

<ol start="2">
<li>切換到 DNS &gt; 新增 8.8.8.8 和 8.8.4.4 並套用</li>
</ol>
<img src="https://i.imgur.com/NszWjnG.png" width="70%">

<ol start="3">
<li>最後重啟模擬器，即可看到 AndroidWifi 顯示已連線(Connected)</li>
</ol>
<img src="https://i.imgur.com/bzJG3Oj.png" width="30%">

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li>明確意圖(explicit intent)會用來前往應用程式特定的活動。</li>
<li>隱含意圖(implicit intent)會對應特定動作 (例如開啟連結或共用圖片)，並讓系統決定如何執行意圖。</li>
<li>選單選項(Menu options)讓您可在應用程式列加入按鈕和選單。</li>
<li>透過隨附物件(Companion objects)，您可以將能重複使用的常數和類型建立關聯，而非與該類型的 instance 建立關聯。</li>
</ul>
<p>若要執行意圖(intent)：</p>
<ul>
<li>取得結構定義(context)的參考(reference)。</li>
<li>建立 <code>Intent</code> 物件提供活動(activity)或 intent type (視 intent 為 explicit 或 implicit 而定)。</li>
<li>呼叫 <code>putExtra()</code> 傳遞任何必要資料。</li>
<li>呼叫 <code>startActivity()</code> 傳入 <code>intent</code> 物件。</li>
</ul>
<hr>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://medium.com/@daydreamer_/how-to-fix-android-emulator-wi-fi-connected-with-no-internet-c62fd4ed652d">如何修復 Android 模擬器 Wi-Fi 連線無網際網路的問題</a><br><a href="https://support.apple.com/zh-tw/guide/mac-help/mh141272/mac">在 Mac 上輸入 DNS 和搜尋網域設定</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Intent</tag>
        <tag>Menu</tag>
        <tag>companion object</tag>
        <tag>singleton</tag>
        <tag>Navigation</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(21)-Kotlin中的Collections</title>
    <url>/2023/09/28/Android%E7%AD%86%E8%A8%98-21-Kotlin%E4%B8%AD%E7%9A%84Collections/</url>
    <content><![CDATA[<blockquote>
<p>在這個程式碼研究室中，您將進一步了解集合(collection)，以及 Kotlin 中的 lambdas 和高階函式。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何使用 sets 和 maps 等集合(collection)</li>
<li>瞭解 lambdas 的基本概念</li>
<li>高階函式的基本概念</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="了解Collection"><a href="#了解Collection" class="headerlink" title="了解Collection"></a>了解Collection</h3><p><a href="https://kotlinlang.org/docs/collections-overview.html">集合(collection)</a>是指一組相關項目，例如字詞清單或一組員工記錄。集合可以包含排序或未排序的項目，這些項目可以是獨一無二的或重複的。您已經瞭解一種類型的集合，那就是list。list 中 item 是有序的，但 item 可以重複。</p>
<p>如同 list，Kotlin 可區分可變(mutable)集合和不可變(immutable)集合。Kotlin 提供多項功能，可用於新增或刪除項目、檢視及操控集合。</p>
<h4 id="建立List"><a href="#建立List" class="headerlink" title="建立List"></a>建立List</h4><p>在這項工作中，您會建立數字列表(list)，然後加以排序。</p>
<ol>
<li>開啟 <a href="https://developer.android.com/training/kotlinplayground?hl=zh-tw">Kotlin Playground</a>。</li>
<li>使用下列程式碼取代所有程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">    println(<span class="string">&quot;list:   <span class="subst">$&#123;numbers&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如要執行程式，請輕觸綠色箭頭，然後查看畫面上顯示的結果：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list:   [<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>這個 list 包含 0 到 9 這 10 個數字。某些數字會重複出現數次，而有些則一次也沒有出現。</p>
</li>
<li><p>在這個 list 中，item 的順序很重要：第一個 item 是 0，第二個 item 是 3，依此類推。除非您變更順序，否則這些 item 都會按照這個順序顯示。</p>
</li>
<li><p>回想一下，先前的程式碼研究室中提到過，list 有許多內建函式 (例如 <code>sorted()</code> 函式，會傳回遞增排序后的 list )。在 <code>println()</code> 之後，為程式新增一行以列印排序後的 list：</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;sorted: <span class="subst">$&#123;numbers.sorted()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>再次執行程式並查看結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">list:   [0, 3, 8, 4, 0, 5, 5, 8, 9, 2]</span><br><span class="line">sorted: [0, 0, 2, 3, 4, 5, 5, 8, 8, 9]</span><br></pre></td></tr></table></figure>

<p>將數字排序，方便您查看個別數字在 list 中出現的次數。</p>
<h4 id="了解Set"><a href="#了解Set" class="headerlink" title="了解Set"></a>了解Set</h4><p>Kotlin 中的另一種集合類型為<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-set/">集(Set)</a>。這是由相關 item 組成的一個群組，但和 list 不同，set中不允許出現重複的 item，但是 item 之間是無序的。一個 item 可以包含於一個 set 或不包含與一個 set，只要位於組合中，則該 item 僅能在該 set 中出現一次。這與數學中的集合概念類似。舉例來說，有一組您已讀的書籍。閲讀某本書多次並不影響您閱讀過的書籍這一集合。</p>
<ol>
<li>將以下幾行指令新增至程式，即可將 list 轉換成 set：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> setOfNumbers = numbers.toSet()</span><br><span class="line">println(<span class="string">&quot;set:    <span class="subst">$&#123;setOfNumbers&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行程式並查看結果：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">list:   [<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br><span class="line">sorted: [<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="keyword">set</span>:    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">2</span>]</span><br></pre></td></tr></table></figure>

<p>結果包含原始 list 中的所有數字，但每個數字只會出現一次。請注意，這些數字的順序與原始 list 中的順序相同，但這個順序對 set 來說無關緊要。</p>
<ol start="3">
<li>定義可變(mutable)集合和不可變(immutable)集合，並以相同的數字組初始化這些 set，方法是新增下列幾行程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> set1 = setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">val</span> set2 = mutableSetOf(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增一行以列印二者是否相等：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;<span class="variable">$set1</span> == <span class="variable">$set2</span>: <span class="subst">$&#123;set1 == set2&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行您的程式並查看新的結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[1, 2, 3] == [3, 2, 1]: true</span><br></pre></td></tr></table></figure>

<p>即使只有一個 set 是可變的，而當中的 item 順序也不同，系統仍然會將其視為相同的 set，因為這二者包含完全相同的 item 組合。</p>
<p>您對 set 執行的主要作業之一是，透過 <code>contains()</code> 函式檢查特定 item 是否包含於某個 set 中。</p>
<ol start="6">
<li>如果 set 中包含 7，新增如下一行以列印：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;contains 7: <span class="subst">$&#123;setOfNumbers.contains(<span class="number">7</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行您的程式並查看額外的結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">contains 7: false</span><br></pre></td></tr></table></figure>

<p>上述所有程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">0</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">0</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">2</span>)</span><br><span class="line">    println(<span class="string">&quot;list:   <span class="subst">$&#123;numbers&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;sorted: <span class="subst">$&#123;numbers.sorted()&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> setOfNumbers = numbers.toSet()</span><br><span class="line">    println(<span class="string">&quot;set:    <span class="subst">$&#123;setOfNumbers&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> set1 = setOf(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> set2 = mutableSetOf(<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$set1</span> == <span class="variable">$set2</span>: <span class="subst">$&#123;set1 == set2&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;contains 7: <span class="subst">$&#123;setOfNumbers.contains(<span class="number">7</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和數學中的集合一樣，在 Kotlin 中，您也可以運用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/intersect.html">intersect()</a> 或 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/union.html">union()</a> 對兩個集合執行 <strong>交集(Intersection) (∩)</strong> 或 <strong>聯集(Union) (∪)</strong> 運算。</p>
<h4 id="了解Map"><a href="#了解Map" class="headerlink" title="了解Map"></a>了解Map</h4><p>在本程式碼研究室中，您要了解的最後一個集合類型是 Map 或 Dictionary(字典)。Map 是一組 <strong>鍵&#x2F;值(key-value)</strong> 組合，可讓您以特定 key 輕鬆查詢 value。key 不得重複，每個 key 只能對應至一個 value，但 value 可以重複。Map 中的 value 可以是字串(strings)、數字(numbers)或物件(objects)，甚至是列表( list)或一組 set 等其他集合。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/b55b9042a75c56c0_1920.png" width="70%" height="70%">

<p>如果您有成對的 data，map 就相當實用，您可以基於它的 value 辨別出每一對 data。該 key 會對應到相對應的 value。</p>
<ol>
<li>在 Kotlin playground 中，請將所有程式碼替換成這段程式碼，以建立可修改的 map 來儲存使用者名稱和年齡：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleAges = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;(</span><br><span class="line">        <span class="string">&quot;Fred&quot;</span> to <span class="number">30</span>,</span><br><span class="line">        <span class="string">&quot;Ann&quot;</span> to <span class="number">23</span></span><br><span class="line">    )</span><br><span class="line">    println(peopleAges)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這項操作會將 <code>String (key)</code> 的 mutable map 對應到 <code>Int (value)</code>、將兩個 item 初始化，然後列印 item。</p>
<ol start="2">
<li>執行程式並查看結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Fred=30, Ann=23&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如要在 map 中加入更多 item，您可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-map/put.html">put()</a> 函式傳入 key和 value：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">peopleAges.put(<span class="string">&quot;Barbara&quot;</span>, <span class="number">42</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>您也可以使用簡寫標記來新增 item：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">peopleAges[<span class="string">&quot;Joe&quot;</span>] = <span class="number">51</span></span><br></pre></td></tr></table></figure>

<p>以下是上述所有程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleAges = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;(</span><br><span class="line">        <span class="string">&quot;Fred&quot;</span> to <span class="number">30</span>,</span><br><span class="line">        <span class="string">&quot;Ann&quot;</span> to <span class="number">23</span></span><br><span class="line">    )</span><br><span class="line">    peopleAges.put(<span class="string">&quot;Barbara&quot;</span>, <span class="number">42</span>)</span><br><span class="line">    peopleAges[<span class="string">&quot;Joe&quot;</span>] = <span class="number">51</span></span><br><span class="line">    println(peopleAges)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行程式並查看結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Fred=30, Ann=23, Barbara=42, Joe=51&#125;</span><br></pre></td></tr></table></figure>

<p>如上所述，key (姓名) 不得重複，但value (年齡) 可以重複。當您嘗試使用同一個鍵新增 item 時，會發生什麼情況？</p>
<ol start="6">
<li>在 <code>println()</code> 之前加入這行程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">peopleAges[<span class="string">&quot;Fred&quot;</span>] = <span class="number">31</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行程式並查看結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Fred=31, Ann=23, Barbara=42, Joe=51&#125;</span><br></pre></td></tr></table></figure>

<p>系統不會再次新增 key <code>&quot;Fred&quot;</code>，但其所對應的 value 會更新為 <code>31</code>。</p>
<hr>
<h3 id="使用Collection"><a href="#使用Collection" class="headerlink" title="使用Collection"></a>使用Collection</h3><p>雖然性質各不相同，但各種類型的集合(collection)有很多共同點。如果是可變集合，您可以新增或移除item。您可以列舉集合中的所有item、尋找特定item，有時也可以將某種集合轉換成另一種集合。你先前曾執行過，透過 <code>toSet()</code> 將 <code>List</code> 轉換成 <code>Set</code>。以下是使用集合的幾個實用函式。</p>
<h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p>假設您想列印「<code>peopleAges</code>」中的項目，並在其中納入使用者姓名和年齡。例如 <code>&quot;Fred is 31, Ann is 23,...&quot;</code>、等。您曾在先前的程式碼研究室中學到 <code>for</code> 這個迴圈，因此可以使用 <code>for (people in peopleAges) &#123; ... &#125;</code> 撰寫迴圈。</p>
<p>不過，列舉集合中的所有項目都是常見的作業，因此 Kotlin 提供的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/for-each.html">forEach()</a> 會分析所有項目，並在各個項目中執行。</p>
<ol>
<li>在 playground 中，將下列程式碼加到 <code>println()</code> 後方：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">peopleAges.forEach &#123; print(<span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>, &quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>這與 <code>for</code> 迴圈類似，但有點複雜。<code>forEach</code> 會使用特殊 ID <code>it</code> 為目前的項目指定變數，<br>請注意，在呼叫 <code>forEach()</code> 方法時無需加上括號，只要以大括號 <code>&#123;&#125;</code> 傳送程式碼即可。</p>
<ol start="2">
<li>執行您的程式並查看額外的結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fred is 31, Ann is 23, Barbara is 42, Joe is 51,</span><br></pre></td></tr></table></figure>

<p>這與您需要的非常接近，但結尾有一個額外的逗號。<br>將集合(collection)轉換為字串(string)是一種常見的作業，而結尾的分隔符也是一個常見問題。我們將在下列步驟中說明相關處理方式。</p>
<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p><a href="https://kotlinlang.org/docs/collection-transformations.html#mapping">map()</a> 函式 (不應與上方 map 或 dictionary collection 混淆) 會將 collection 中的每個 item 套用到轉換中的每個 item。</p>
<ol>
<li>將程式中的 <code>forEach</code> 陳述式替換成這一行：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(peopleAges.map &#123; <span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>&quot;</span> &#125;.joinToString(<span class="string">&quot;, &quot;</span>) )</span><br></pre></td></tr></table></figure>

<p>執行您的程式並查看額外的結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Fred is 31, Ann is 23, Barbara is 42, Joe is 51</span><br></pre></td></tr></table></figure>

<p>可產生正確的輸出內容，而且沒有多餘的逗號！有一行有太多工作，請密切關注。</p>
<ul>
<li><code>peopleAges.map</code> 會為 <code>peopleAges</code> 中的每個 item 套用一項轉換，並建立新的轉換 item 集合</li>
<li>大括號 <code>&#123;&#125;</code> 中的部分會定義每個 item 的轉換作業。轉換作業會使用 key&#x2F;value 組合，並將其轉換為 string，例如<code> &lt;Fred, 31&gt;</code> 會轉換為 <code>Fred is 31</code>。</li>
<li><code>joinToString(&quot;, &quot;)</code> 會將轉換集合中的每個 item 新增至 string 中，並以 <code>,</code> 分隔，但不知道是否要將該 item 新增到最後一個 item</li>
<li>以上所有 item 會以 <code>.</code> (點號運算子) 鏈結在一起，就像您在先前的程式碼研究室中對函式呼叫和屬性存取作業所做的一樣</li>
</ul>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>集合(collection) 的另一個常見操作是尋找與特定條件相符的 item。<a href="https://kotlinlang.org/docs/reference/collection-filtering.html">filter()</a> 函式會根據運算式傳回相符 collection 中的 item。</p>
<ol>
<li>在 <code>println()</code> 之後，新增以下這行：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> filteredNames = peopleAges.filter &#123; it.key.length &lt; <span class="number">4</span> &#125;</span><br><span class="line">println(filteredNames)</span><br></pre></td></tr></table></figure>
<p>另請注意，<code>filter</code> 的呼叫不需要括號，而 <code>it</code> 是指 list 中目前的 item。</p>
<p>執行您的程式並查看額外的結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;Ann=23, Joe=51&#125;</span><br></pre></td></tr></table></figure>

<p>在此情況下，運算式會取得 <code>key</code> 的長度 (String)，並檢查其是否小於 4。任何符合條件的項目 (也就是名稱少於 4 個半形字元) 都會新增至新的 collection。</p>
<p>將 <code>filter</code> 套用至對應時，系統會傳回新的類型 (<code>LinkedHashMap</code>)。您可以在對應上進行額外的處理，或將其轉換成其他類型的 collection，例如 list。</p>
<hr>
<h3 id="了解Lambda和高階函式"><a href="#了解Lambda和高階函式" class="headerlink" title="了解Lambda和高階函式"></a>了解Lambda和高階函式</h3><h4 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h4><p>讓我們再回到先前的範例：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">peopleAges.forEach &#123; print(<span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>&quot;</span>) &#125;</span><br></pre></td></tr></table></figure>

<p>有一變數 (<code>peopleAges</code>) 呼叫了函式 (<code>forEach</code>)。在函式名稱前方加上括號時，你會在大括號後方看到大括號 <code>&#123;&#125;</code> 的部分程式碼。程式碼中也會使用上一個步驟中的 <code>map</code> 和 <code>filter</code> 函式。<code>forEach</code> 函式會透過 <code>peopleAges </code>變數呼叫，並使用大括號中的程式碼。</p>
<p>就好像您用大括號表示小函式，卻並沒有函式名稱。這個沒有名稱而可立即用作運算式的函式是很實用的概念，也就是所謂的「<code>lambda 運算式</code>」，簡稱 <code>lambda</code>。</p>
<p>這是一個重要主題，可讓您瞭解如何利用 Kotlin 功能強大的函式與函式互動。您可將函式儲存在變數和類別中、將引數傳遞為引數，甚至傳回函式。就像其他變數 (例如 <code>Int</code> 或 <code>String</code>) 的變數一樣。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 由於 <b>lambda</b> 通常只有單一參數，因此 Kotlin 提供了簡要參數。Kotlin 以隱含識別碼 <a href="https://kotlinlang.org/docs/lambdas.html#it-implicit-name-of-a-single-parameter"><strong>it</strong></a> 做為一個 <b>lambda</b> 參數 (使用單一參數)。</p>
          </div>

<h4 id="函式類型"><a href="#函式類型" class="headerlink" title="函式類型"></a>函式類型</h4><p>為了啟用這種類型的行為，Kotlin 提供了一個「<code>函式類型(function types)</code>」，可讓您根據其輸入參數和傳回值定義特定類型的函式。格式如下：</p>
<p>函式類型範例：<code>(Int) -&gt; Int</code></p>
<p>具有上述函式類型的函式必須採用 <code>Int</code> 類型的參數，並傳回 <code>Int</code> 類型的值。在函式類型標記中，這些參數會以括號列出 (如有多個參數，請以半形逗號分隔)。旁邊有箭頭 <code>-&gt;</code>，後面接著傳回類型。</p>
<p>哪些函式符合這項條件？如下所示，您可以使用 <code>lambda</code> 運算式將整數輸入的值改成三倍，如下所示。針對 <code>lambda</code> 運算式的語法，參數會先顯示 (以紅色方塊醒目顯示)，後面接著函式箭頭，然後是函式內文 (以紫色方塊醒目顯示)。<code>lambda</code> 中的最後一個運算式是傳回值。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/252712172e539fe2_1920.png?hl=zh-tw">

<p>您甚至可以將 <code>lambda</code> 儲存在變數中，如下圖所示。這個語法類似於宣告基本資料類型 (例如 <code>Int</code>) 的變數時所用的方式。觀察變數名稱 (黃色方塊)、變數類型 (藍色方塊) 和變數值 (綠色方塊)。<code>triple</code> 變數會儲存函式。其類型為 <code>(Int) -&gt; Int</code> 的函式類型，且值為 <code>lambda</code> 運算式 <code>&#123; a: Int -&gt; a * 3&#125;</code>。</p>
<ol>
<li>在遊樂場裡試用這個程式碼。你可以傳送 <code>triple</code> 函式 (如 5) 來呼叫並呼叫它。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/4d3f2be4f253af50_1920.png?hl=zh-tw">

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> triple: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a: <span class="built_in">Int</span> -&gt; a * <span class="number">3</span> &#125;</span><br><span class="line">    println(triple(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>產生的輸出內容應為：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在大括號中，可明確宣告參數 (<code>a: Int</code>)、省略函式箭頭 (<code>-&gt;</code>)，而是只包含函式主體。更新 <code>main</code> 函式中宣告的 <code>triple</code> 函式，然後執行程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> triple: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; it * <span class="number">3</span> &#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>輸出結果應該相同，但僅以更精簡的方式呈現 <code>lambda</code>！如需更多 <code>lambda</code> 的範例，請參考這個<a href="https://play.kotlinlang.org/byExample/04_functional/02_Lambdas">資源</a>。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15</span><br></pre></td></tr></table></figure>

<p>⭐️ 嘗試修改一下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">/* function type: 輸入Int 回傳Int */</span></span><br><span class="line">    <span class="keyword">val</span> triple: (<span class="built_in">Int</span>) -&gt; <span class="built_in">Int</span> = &#123; a: <span class="built_in">Int</span> -&gt; a * <span class="number">3</span> &#125;</span><br><span class="line">    println(triple(<span class="number">6</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* function type: 輸入String 回傳String */</span></span><br><span class="line">    <span class="keyword">val</span> name: (String) -&gt; String = &#123; a: String -&gt; <span class="string">&quot;My name is &quot;</span> + a &#125;</span><br><span class="line">    println(name(<span class="string">&quot;Tina&quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* function type: 輸入String 回傳Int */</span></span><br><span class="line">    <span class="keyword">val</span> nameLen: (String) -&gt; <span class="built_in">Int</span> = &#123; a: String -&gt; a.length &#125;</span><br><span class="line">    println(nameLen(<span class="string">&quot;Tina&quot;</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">18</span><br><span class="line">My name is Tina</span><br><span class="line">4</span><br></pre></td></tr></table></figure>

<h4 id="高階函式"><a href="#高階函式" class="headerlink" title="高階函式"></a>高階函式</h4><p>您現在已學會在 Kotlin 中操縱函式的彈性了，接著我們要談談另一個功能強大的概念，也就是高階函式(Higher-order functions)。這只是<strong>將函式 (在本例中為 <code>lambda</code>) 傳遞給其他函式，或從另一個函式傳回函式</strong>。</p>
<p>結果指出，<code>map</code>、<code>filter</code> 和 <code>forEach</code> 函式都是高階函式的範例，因為它們都會將函式視為參數。(在傳送至這個 <code>filter</code> 較高順序函式的 <code>lambda</code> 中，您可以省略單一參數和箭頭符號，也可以使用 <code>it</code> 參數)。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleAges = mutableMapOf&lt;String, <span class="built_in">Int</span>&gt;(</span><br><span class="line">        <span class="string">&quot;Fred&quot;</span> to <span class="number">30</span>,</span><br><span class="line">        <span class="string">&quot;Ann&quot;</span> to <span class="number">23</span></span><br><span class="line">    )</span><br><span class="line">    peopleAges.put(<span class="string">&quot;Barbara&quot;</span>, <span class="number">42</span>)</span><br><span class="line">    peopleAges[<span class="string">&quot;Joe&quot;</span>] = <span class="number">51</span></span><br><span class="line">    peopleAges[<span class="string">&quot;Fred&quot;</span>] = <span class="number">31</span></span><br><span class="line">    println(peopleAges)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* it 代表 peopleAges 中的 item */</span></span><br><span class="line">    <span class="comment">/* forEach */</span></span><br><span class="line">    peopleAges.forEach &#123; print(<span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>, &quot;</span>) &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* map */</span></span><br><span class="line">    peopleAges.map &#123; print(<span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>, &quot;</span>) &#125;</span><br><span class="line">    println(peopleAges.map &#123; <span class="string">&quot;<span class="subst">$&#123;it.key&#125;</span> is <span class="subst">$&#123;it.value&#125;</span>&quot;</span> &#125;.joinToString(<span class="string">&quot;, &quot;</span>))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* filter */</span></span><br><span class="line">    println(peopleAges.filter &#123; it.key.length &lt; <span class="number">4</span> &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是高優先順序函式的範例：<code>sortedWith()</code>。</p>
<p>如果想排序字串 list，可以使用內建的 <code>sorted()</code> 方法集合。不過，如果您想用字串長度為 list 排序，就必須撰寫一些程式碼來比較兩個字串的長度。Kotlin 可讓您將 <code>lambda</code> 傳遞至 <code>sortedWith()</code> 方法，藉此達成此目標。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 如要比較兩個要排序的 objects，慣例是在第一個 objects 小於第二個時傳回小於 0 的值，如果二者大小相同，則會傳回 0；如果第一個 objects 大於第二個 objects，則會傳回大於 0 的值。  </p><ul><li><code>objects1 &lt; objects2</code> 回傳 <code>小於 0 的值</code></li><li><code>objects1 == objects2</code> 回傳 <code>0</code></li><li><code>objects1 &gt; objects2</code> 回傳 <code>大於 0 的值</code></li></ul>
          </div>

<ol>
<li>在 Playground 中，使用這個程式碼建立 name list，並按 name 排序輸出該 list：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> peopleNames = listOf(<span class="string">&quot;Fred&quot;</span>, <span class="string">&quot;Ann&quot;</span>, <span class="string">&quot;Barbara&quot;</span>, <span class="string">&quot;Joe&quot;</span>)</span><br><span class="line">    println(peopleNames.sorted())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Ann, Barbara, Fred, Joe]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>現在請將 <code>lambda</code> 傳送至 <code>sortedWith()</code> 函式，按名稱長度排序 list。<code>lambda</code> 應採用相同類型的兩個參數並傳回 <code>Int</code>。在 <code>main()</code> 函式的 <code>println()</code> 陳述式後方加上這行程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(peopleNames.sortedWith &#123; str1: String, str2: String -&gt; str1.length - str2.length &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行程式並查看結果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Ann, Barbara, Fred, Joe]</span><br><span class="line">[Ann, Joe, Fred, Barbara]</span><br></pre></td></tr></table></figure>

<p>傳送至 <code>sortedWith()</code> 的 <code>lambda</code> 有兩個參數，<code>str1</code> 為 <code>String</code>，<code>str2</code> 則為 <code>String</code>。然後，您就會依次看到函式箭頭和函式主體。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/7005f5b6bc466894_1920.png?hl=zh-tw">

<p>請記住，<code>lambda</code> 中的最後一個運算式是傳回 value。在這種情況下，系統會<strong>傳回第一個字串和第二個字串長度之間的差異</strong>，也就是 <code>Int</code>。符合排序所需的項目：</p>
<ul>
<li>如果 <code>str1.length &lt; str2.length</code>，則會傳回<code>小於 0 的值</code>。</li>
<li>如果 <code>str1.length == str2.length</code>，系統會傳回 <code>0</code>。</li>
<li>如果 <code>str1.length &gt; str2.length</code>，就會傳回<code>大於 0 的值</code>。</li>
</ul>
<p>透過一次比較兩個 <code>Strings</code> 的方式，<code>sortedWith()</code> 函式會輸出 list，list 將按照長度遞增排序。</p>
<h4 id="Android-中的-OnClickListener-和-OnKeyListener"><a href="#Android-中的-OnClickListener-和-OnKeyListener" class="headerlink" title="Android 中的 OnClickListener 和 OnKeyListener"></a>Android 中的 OnClickListener 和 OnKeyListener</h4><p>統整一下上述內容與您目前學到的 Android 知識，您會發現其實在之前的程式碼研究室就用過 lambda，例如在小費計算機應用程式中為按鈕設定點按事件監聽器時：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">calculateButton.setOnClickListener&#123; calculateTip() &#125;</span><br></pre></td></tr></table></figure>

<p>只要使用 <code>lambda</code> 來設定點擊事件監聽器，就能快速完成。編寫上述程式碼的長版方法如下所示，並與精簡版相比。您不一定要知道長版版本的所有詳細資料，但需要注意這兩種版本的模式。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/29760e0a3cac26a2_1920.png?hl=zh-tw">

<p>觀察 <code>lambda</code> 與 <code>OnClickListener</code> 中的 <code>onClick()</code> 方法具有相同函式類型的方式 (使用一個 <code>View</code> 引數並傳回 <code>Unit</code>，表示<strong>沒有傳回值</strong>)。</p>
<p>由於 Kotlin 中名為 <code>SAM (Single-Abstract-Method)</code> 轉換，您可以縮短程式碼的版本。Kotlin 會將 <code>lambda</code> 轉換為一個實作單一抽象方法 <code>onClick()</code> 的 <code>OnClickListener</code> 物件(object)。只要確認 <code>lambda</code> 函式類型與抽象函式的函式類型相符即可。</p>
<p>由於 <code>lambda</code> 中一律不使用 <code>view</code> 參數，因此可略過該參數。接著我們只具備 <code>lambda</code> 中的功能主體。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">calculateButton.setOnClickListener &#123; calculateTip() &#125;</span><br></pre></td></tr></table></figure>

<p>這些概念非常具有挑戰性，因此請耐心累積經驗，您需要一些時間才能沉澱所學。再舉另一個例子回想一下您在小費計算機的「Cost of service」文字欄位中設定的按鍵事件監聽器，以便在使用者按下 Enter 鍵後把螢幕小鍵盤隱藏起來。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">costOfServiceEditText.setOnKeyListener &#123; view, keyCode, event -&gt; handleKeyEvent(view, keyCode) &#125;</span><br></pre></td></tr></table></figure>

<p>查詢 <a href="https://developer.android.com/reference/android/view/View.OnKeyListener">OnKeyListener</a> 時，抽象方法擁有下列參數 <code>onKey(View v, int keyCode, KeyEvent event)</code>，並傳回 <code>Boolean</code>。由於 Kotlin 中的 <strong>SAM</strong> 轉換功能，您可以將 <code>lambda</code> 傳送至 <code>setOnKeyListener()</code>。請確認 <code>lambda</code> 的函式類型為 <code>(View, Int, KeyEvent) -&gt; Boolean</code>。</p>
<p>以下是使用的 運算式。參數的值為 <strong>View</strong>、<strong>keyCode</strong> 和 <strong>event</strong>。函式主體包含使用 <code>handleKeyEvent(view, keyCode)</code> 並傳入 <code>Boolean</code> 的參數。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/f73fe767b8950123_1920.png?hl=zh-tw">

<div class="note no-icon success">
            <p><strong>注意：</strong> 如果您並未在函式內文中使用 <b>lambda</b> 參數，則可為 <b>_</b> 命名，以便更清晰易懂。這段程式碼的行為相同。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">costOfServiceEditText.setOnKeyListener &#123; view, keyCode, _ -&gt; handleKeyEvent(view, keyCode) &#125;</span><br></pre></td></tr></table></figure>
          </div>

<hr>
<h3 id="製作字詞List"><a href="#製作字詞List" class="headerlink" title="製作字詞List"></a>製作字詞List</h3><p>現在，請將您學到的 <code>collections</code>、<code>lambdas</code> 和 <code>higher order functions(高階函式)</code> 全部納入考量，然後應用在實際用途中。</p>
<p>假設您想要建立 Android 應用程式來玩文字遊戲或學習字彙。這個應用程式看起來會像這樣，每個字母中的每個字母都會顯示按鈕：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-collections/img/7539df92789fad47_1920.png?hl=zh-tw">

<p>按一下字母 <strong>A</strong>，畫面上隨即會顯示一份以字母 A 開頭的幾個字詞 list 等等。</p>
<p>你需要收集一組字詞，但要使用哪一種集合(collections)？如果應用程式要包含一些字母開頭的字母，您就必須找到或整理所有以特定字母開頭的字詞。如要增加挑戰，建議您在每次使用者執行應用程式時，從產品素材資源集合中選擇不同的字詞。</p>
<p>首先是字詞 list。在真正的應用程式中，建議您建立更長的字詞 list，並且包括以字母表中所有字母做為開頭的字詞，不過現在我們只要一個簡短的 list 就足夠了。</p>
<ol>
<li>使用下列程式碼取代 Kotlin Playground 中的程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> words = listOf(<span class="string">&quot;about&quot;</span>, <span class="string">&quot;acute&quot;</span>, <span class="string">&quot;awesome&quot;</span>, <span class="string">&quot;balloon&quot;</span>, <span class="string">&quot;best&quot;</span>, <span class="string">&quot;brief&quot;</span>, <span class="string">&quot;class&quot;</span>, <span class="string">&quot;coffee&quot;</span>, <span class="string">&quot;creative&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>如要取得開頭為字母 <strong>B</strong> 的字詞集合，您可以使用 <code>filter</code> 搭配 <code>lambda</code> 運算式。新增以下幾行內容：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> filteredWords = words.filter &#123; it.startsWith(<span class="string">&quot;b&quot;</span>, ignoreCase = <span class="literal">true</span>) &#125;</span><br><span class="line">println(filteredWords)</span><br></pre></td></tr></table></figure>

<p>如果字串開頭為指定字串，<a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/starts-with.html">startsWith()</a> 函式則會傳回 <code>true</code>。您也可以指定系統忽略大小寫，因此「b」的比對結果會包括「b」或「B」。</p>
<ol start="3">
<li>執行程式並查看結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[balloon, best, brief]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>別忘了，您希望應用程式隨機挑選字詞。使用 Kotlin 集合時，您可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/shuffled.html">shuffled()</a> 函式，為隨機隨機分組的項目建立副本。同時變更篩選過的字詞。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> filteredWords = words.filter &#123; it.startsWith(<span class="string">&quot;b&quot;</span>, ignoreCase = <span class="literal">true</span>) &#125;</span><br><span class="line">    .shuffled()</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><b>shuffled()</b>：回傳一個新 list，該 list 的元素隨機排列。</p>
          </div>

<ol start="5">
<li>執行您的程式並查看新的結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一次：[brief, best, balloon]</span><br><span class="line">第二次：[best, brief, balloon]</span><br><span class="line">第三次：[brief, best, balloon]</span><br></pre></td></tr></table></figure>
<ul>
<li>由於這類字詞會隨機隨機播放，所以您看到的字詞可能會有不同的排列順序。</li>
</ul>
<ol start="6">
<li>您不想使用所有字，您可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/take.html">take()</a> 函式取得產品素材資源集合中的第一個項目。讓篩選後的字詞只包含前兩個重組字詞：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> filteredWords = words.filter &#123; it.startsWith(<span class="string">&quot;b&quot;</span>, ignoreCase = <span class="literal">true</span>) &#125;</span><br><span class="line">    .shuffled()</span><br><span class="line">    </span><br><span class="line">println(filteredWords)   </span><br><span class="line">println(filteredWords.take(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><b>take(n: Int)</b>：回傳包含前 <b>n</b> 個元素的 list。</p>
          </div>

<ol start="7">
<li>執行您的程式並查看新的結果：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[best, balloon, brief]</span><br><span class="line">[best, balloon]</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>最後，請針對該應用程式的隨機字詞 list 隨機排序。一如往常，您可以使用 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html">sorted()</a> 函式，傳回含有下列項目的集合副本：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> filteredWords = words.filter &#123; it.startsWith(<span class="string">&quot;b&quot;</span>, ignoreCase = <span class="literal">true</span>) &#125;</span><br><span class="line">    .shuffled()</span><br><span class="line">    .take(<span class="number">2</span>)</span><br><span class="line">    .sorted()</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>執行您的程式並查看新的結果：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[balloon, best]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>上述所有程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> words = listOf(<span class="string">&quot;about&quot;</span>, <span class="string">&quot;acute&quot;</span>, <span class="string">&quot;awesome&quot;</span>, <span class="string">&quot;balloon&quot;</span>, <span class="string">&quot;best&quot;</span>, <span class="string">&quot;brief&quot;</span>, <span class="string">&quot;class&quot;</span>, <span class="string">&quot;coffee&quot;</span>, <span class="string">&quot;creative&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> filteredWords = words.filter &#123; it.startsWith(<span class="string">&quot;b&quot;</span>, ignoreCase = <span class="literal">true</span>) &#125;</span><br><span class="line">        .shuffled()</span><br><span class="line">        .take(<span class="number">2</span>)</span><br><span class="line">        .sorted()</span><br><span class="line">    println(filteredWords)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><strong>集合(collection)</strong> 是指一組相關項目</li>
<li><strong>集合(collection)</strong> 可以是 <strong>可變更(mutable)</strong> 或 <strong>不可變更(immutable)</strong> 的</li>
<li><strong>集合(collection)</strong> 可以是有序或無序的</li>
<li><strong>集合(collection)</strong> 可以有唯一項目或允許重複項目</li>
<li>Kotlin 支援不同類型的 <strong>集合(collection)<strong>，包括 <strong>list</strong>、</strong>set</strong> 和 <strong>map</strong></li>
<li>Kotlin 提供了許多處理及轉換集合的功能，包括 <code>forEach</code>、<code>map</code>、<code>filter</code>、<code>sorted</code> 等。</li>
<li><strong>lambda</strong> 是一種不含名稱的函式，不可用來立即傳遞運算式。例如：<code>&#123; a: Int -&gt; a * 3 &#125;</code>。</li>
<li><strong>高階函式(higher-order function)</strong> 指的是將函式傳送至其他函式，或傳回來自其他函式的函式。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Navigation</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>List</tag>
        <tag>Collection</tag>
        <tag>Set</tag>
        <tag>Map</tag>
        <tag>Lambda</tag>
        <tag>Function Type</tag>
        <tag>Higher-order Function</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(20)-專案：Dogglers應用程式</title>
    <url>/2023/09/26/Android%E7%AD%86%E8%A8%98-20-%E5%B0%88%E6%A1%88-Dogglers%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>運用版面配置(Layout)知識，在 Android Studio 中構建可滾動的 Dogglers 應用程式，並針對程式碼執行測試，以確保一切正常。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>運用在單元 2 中學到的技巧，建構一個名為 Doggler 的應用程式，以便在 <code>RecyclerView</code> 中顯示資訊。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="應用程式總覽"><a href="#應用程式總覽" class="headerlink" title="應用程式總覽"></a>應用程式總覽</h4><p>在 Google，我們會親切地稱呼同事為「Googler」(Google 員工)。由於許多 Google 員工都有養狗，所以我們覺得為狗狗朋友建構一款名為 Dogglers 的應用程式，應該會很有趣。你的任務是實作 Dogglers，此應用程式會顯示捲動清單來列出 Google 員工的寵物狗，還會提供每隻寵物狗的一些資訊，包括名字、年齡、嗜好和相片。在此專案中，您會在 Dogglers 應用程式中為 RecyclerView 項目建構 Layout，並實作 Adapter，以便透過以下三種方式來呈現寵物狗清單：水平捲動、垂直捲動和垂直捲動格狀版面配置。</p>
<p>啟動應用程式時，您會看到 <strong>水平(horizontal)</strong> 、 <strong>垂直(vertical)</strong> 和 <strong>格狀版面配置(grid layouts)</strong> 三個選項。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/9e1186e8d2cff595_1920.png?hl=zh-tw" width="30%" height="30%">

<p>第一個選項是垂直捲動的 recycler view，items 會占據畫面的全寬度。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/dc2852940d6994e7_1920.png?hl=zh-tw" width="30%" height="30%">

<p>第二個選項是在水平捲動的 recycler view中，顯示狗狗 list。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/b959082c9491381d_1920.png?hl=zh-tw" width="30%" height="30%">

<p>第三個選項是在垂直捲動的格狀版面配置(grid layouts)中顯示狗狗，每一列顯示兩隻狗。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/438b19a77ecfaaba_1920.png?hl=zh-tw" width="30%" height="30%">

<p>這些版面配置全都由相同的 adapter 類別提供支援。您的工作是為 recycler view card 建構版面配置，然後實作adapter，以便為每個 item 填入每隻寵物狗的相關資訊。</p>
<hr>
<h4 id="下載專案程式碼"><a href="#下載專案程式碼" class="headerlink" title="下載專案程式碼"></a>下載專案程式碼</h4><p>請注意，資料夾名稱是 <code>android-basics-kotlin-dogglers-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note no-icon success">
            <p>範例程式碼網址：<br><a href="https://github.com/google-developer-training/android-basics-kotlin-dogglers-app/tree/main">https://github.com/google-developer-training/android-basics-kotlin-dogglers-app/tree/main</a><br>具有範例程式碼的分支版本名稱：<b>main</b></p>
          </div>

<ol>
<li><p>前往專案所在的 GitHub 儲存庫，下載 main 分支程式碼。</p>
</li>
<li><p>在Android Studio 中開啟專案</p>
</li>
<li><p>按一下「Run」按鈕即可建構並執行應用程式。請確認應用程式的建構符合預期。</p>
</li>
</ol>
<p>專案會整理成個別的套件。雖然已實作大部分功能，但您需要實作 <code>DogCardAdapter</code>。此外，您還需要修改兩個版面配置(Layout)檔案。我們會視需要在以下操作說明中討論其他檔案。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/c181caccdddc5c2e_1920.png?hl=zh-tw" width="50%" height="50%">

<hr>
<h4 id="實作Layout"><a href="#實作Layout" class="headerlink" title="實作Layout"></a>實作Layout</h4><p>垂直和水平版面配置都相同，因此您只需為這兩種版面配置實作一個 Layout 檔案。格狀版面配置會顯示所有相同的資訊，但寵物狗的名字、年齡和嗜好都以垂直方式堆疊，因此在這種情況下，您需要單獨的 Layout。這兩種版面配置都需要四種不同 View，才能顯示每隻狗狗的相關資訊。</p>
<ol>
<li>含有狗狗相片的 <code>ImageView</code></li>
<li>含有狗狗名字的 <code>TextView</code></li>
<li>含有狗狗年齡的 <code>TextView</code></li>
<li>含有狗狗嗜好的 <code>TextView</code></li>
</ol>
<p>您也會發現每張卡片上都有一些樣式，顯示了邊框和陰影。這項操作由 <code>MaterialCardView</code> 處理，已新增到範例專案的版面配置檔案中。每個 <code>MaterialCardView</code> 中都有 <code>ConstraintLayout</code>，您需要在其中新增其餘的View。</p>
<div class="note no-icon success">
            <p><strong>提示：</strong> 您可以為每個View使用任何您所選的 ID，但請注意，這兩種 Layout 都使用相同的 <b>ViewHolder</b> 類別，因此請務必確認在各 Layout 中，為相應的 View 使用相同的 ID。舉例來說，格狀 Layout 和水平&#x2F;垂直 Layout 都有 ID 為 <b>dog_name</b> 的 <b>TextView</b>。</p>
          </div>

<p>您需要兩個 XML 檔案來實作版面配置：使用 <code>vertical_horizontal_list_item.xml</code> 實作水平和垂直 Layout，使用 <code>grid_list_item.xml</code> 實作格狀 Layout。</p>
<ol>
<li>建構垂直和水平清單的 Layout。<br>開啟 <code>vertical_horizontal_list_item.xml</code>，然後在內部 <code>ConstraintLayout</code> 中建構與圖片相符的版面配置。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/6464da5b34a739ed_1920.png?hl=zh-tw" width="70%" height="70%">

<p>⭐️ <code>vertical_horizontal_list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Copyright (C) 2021 The Android Open Source Project.</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  ~ you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  ~ You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  ~ distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  ~ See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  ~ limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardElevation</span>=<span class="string">&quot;4dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardCornerRadius</span>=<span class="string">&quot;4dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 請注意，與grid view list不同，垂直和水平list中的一張卡</span></span><br><span class="line"><span class="comment">            有效地佔據了螢幕的寬度。 這意味著您擁有更多顯示跨越卡片寬度的資訊的</span></span><br><span class="line"><span class="comment">            空間。 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 為狗的圖像建立一個 ImageView 資源。</span></span><br><span class="line"><span class="comment">                高度應為 194dp</span></span><br><span class="line"><span class="comment">                寬度應與卡片的寬度相符</span></span><br><span class="line"><span class="comment">                scaleType 應設定為 centerCrop --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_image&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;194dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:srcCompat</span>=<span class="string">&quot;@drawable/tzeitel&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 為下列各項建立一個 TextView：</span></span><br><span class="line"><span class="comment">                The dog&#x27;s name</span></span><br><span class="line"><span class="comment">                The dog&#x27;s age</span></span><br><span class="line"><span class="comment">                The dog&#x27;s hobbies --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;Tzeitel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceHeadline6&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_image&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingStart</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_age&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;@string/dog_age&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceBody1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingStart</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">&quot;8dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_hobbies&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;@string/dog_hobbies&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceBody1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingEnd</span>=<span class="string">&quot;8dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>vertical_horizontal_list_item.xml</code> 預覽畫面：</p>
<img src="https://i.imgur.com/ckADPaO.png" width="30%" height="30%">

<ol start="2">
<li>建構格狀版面配置。<br>開啟 <code>grid_list_item.xml</code>，然後在內部 <code>ConstraintLayout</code> 中建構與圖片相符的版面配置。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/dfa4b5f0acda0ec6_1920.png?hl=zh-tw" width="40%" height="40%">

<p>⭐️ <code>grid_list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">  ~ Copyright (C) 2021 The Android Open Source Project.</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">  ~ you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">  ~ You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">  ~</span></span><br><span class="line"><span class="comment">  ~ Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">  ~ distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">  ~ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">  ~ See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">  ~ limitations under the License.</span></span><br><span class="line"><span class="comment">  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardCornerRadius</span>=<span class="string">&quot;4dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:cardElevation</span>=<span class="string">&quot;4dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 請注意，此list item將在需要不同佈局的grid view中使用，</span></span><br><span class="line"><span class="comment">            因為該list將有兩列卡片。 這表示卡片內的資訊必須垂直堆疊，因為寬度</span></span><br><span class="line"><span class="comment">            方面的空間較小。 --&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 為狗的圖像建立一個 ImageView 資源。</span></span><br><span class="line"><span class="comment">                高度應為 194dp</span></span><br><span class="line"><span class="comment">                寬度應與卡片的寬度相符</span></span><br><span class="line"><span class="comment">                scaleType 應設定為 centerCrop --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_image&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;194dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:srcCompat</span>=<span class="string">&quot;@drawable/leroy&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- <span class="doctag">TODO:</span> 為下列各項建立一個 TextView：</span></span><br><span class="line"><span class="comment">                The dog&#x27;s name</span></span><br><span class="line"><span class="comment">                The dog&#x27;s age</span></span><br><span class="line"><span class="comment">                The dog&#x27;s hobbies --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;Tzeitel&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceHeadline6&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_image&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingStart</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_age&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;@string/dog_age&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceBody1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_name&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingStart</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">&quot;8dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/dog_hobbies&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">tools:text</span>=<span class="string">&quot;@string/dog_hobbies&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceBody1&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@+id/dog_age&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingTop</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingBottom</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:paddingStart</span>=<span class="string">&quot;8dp&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>grid_list_item.xml</code> 預覽畫面：</p>
<img src="https://i.imgur.com/0Uaz6cp.png" width="30%" height="30%">

<hr>
<h4 id="實作Adapter"><a href="#實作Adapter" class="headerlink" title="實作Adapter"></a>實作Adapter</h4><p>定義版面配置後，下一步就是實作 <code>RecyclerView</code> 轉接程式(Adapter)。在Adapter套件中開啟 <code>DogCardAdapter.kt</code>。您會看到許多 <code>TODO</code> 註解，說明您要導入的項目。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-dogglers-app/img/1bd9c8014cd1070e_1920.png?hl=zh-tw">

<p>實作Adapter需要 5 個步驟。</p>
<ol>
<li>定義狗狗資料list的變數或常數。此list位於名為 <code>DataSource</code> 物件的 <code>data</code> 套件中，如下所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> DataSource &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">val</span> dogs: List&lt;Dog&gt; = listOf( ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dogs</code> 屬性的類型是 <code>List&lt;Dog&gt;</code>。<code>Dog</code> 類別位於 <code>model</code> 套件中，並定義了 4 個屬性：1 張圖片 (由資源 ID 表示) 和 3 個 <code>String</code> 屬性。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Dog</span>(</span><br><span class="line">   <span class="meta">@DrawableRes</span> <span class="keyword">val</span> imageResourceId: <span class="built_in">Int</span>,</span><br><span class="line">   <span class="keyword">val</span> name: String,</span><br><span class="line">   <span class="keyword">val</span> age: String,</span><br><span class="line">   <span class="keyword">val</span> hobbies: String</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>將您在 <code>DogCardAdapter</code> 定義的變數設為 <code>DataSource</code> 物件中的 <code>dogs</code> list。<br>⭐️ <code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DogCardAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layout: <span class="built_in">Int</span></span><br><span class="line">): RecyclerView.Adapter&lt;DogCardAdapter.DogCardViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用data/DataSource中的list初始化數據</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dogList = DataSource.dogs</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>實作 <code>DogCardViewHolder</code>。View Holder 應綁定要為每個 Recycler 檢視卡片設定的 4 個View。<code>grid_list_item</code> 和 <code>vertical_horizontal_list_item</code> Layout 都會共用相同的 View Holder，原因是所有 View 都會在這兩個 Layout 之間共用。<code>DogCardViewHolder</code> 應包含下列 View ID 的屬性：<code>dog_image</code>、<code>dog_name</code>、<code>dog_age</code> 和 <code>dog_hobbies</code>。</li>
</ol>
<p>⭐️ <code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化view elements</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogCardViewHolder</span>(view: View?): RecyclerView.ViewHolder(view!!) &#123;</span><br><span class="line">    <span class="comment">// 宣告並初始化所有list item UI 元件</span></span><br><span class="line">    <span class="comment">/* 小筆記：?和!!的意思</span></span><br><span class="line"><span class="comment">        ?：做 null check 後，不為空的話再執行</span></span><br><span class="line"><span class="comment">        !!：堅持不會是空值，執行就是了 */</span></span><br><span class="line">    <span class="keyword">val</span> dogImageView: ImageView? = view!!.findViewById(R.id.dog_image)</span><br><span class="line">    <span class="keyword">val</span> dogNameTextView: TextView? = view!!.findViewById(R.id.dog_name)</span><br><span class="line">    <span class="keyword">val</span> dogAgeTextView: TextView? = view!!.findViewById(R.id.dog_age)</span><br><span class="line">    <span class="keyword">val</span> dogHobbiesTextView: TextView? = view!!.findViewById(R.id.dog_hobbies)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>onCreateViewHolder()</code> 中，建議您加載 <code>grid_list_item</code> 或 <code>vertical_horizontal_list_item</code> Layout。如何得知要使用哪個 Layout 呢？在轉接程式的定義中，您會看到在建構轉接程式執行個體時，系統會傳遞一個名為 <code>layout</code> 且類型為 <code>Int</code> 的值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DogCardAdapter</span>(</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> context: Context?,</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> layout: <span class="built_in">Int</span></span><br><span class="line">): RecyclerView.Adapter&lt;DogCardAdapter.DogCardViewHolder&gt;() &#123;</span><br></pre></td></tr></table></figure>

<p>該值與 <strong>const</strong> 套件中 <code>Layout</code> 物件定義的值相對應。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">object</span> Layout &#123;</span><br><span class="line">   <span class="keyword">val</span> VERTICAL = <span class="number">1</span></span><br><span class="line">   <span class="keyword">val</span> HORIZONTAL = <span class="number">2</span></span><br><span class="line">   <span class="keyword">val</span> GRID = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>layout 的值會是 1、2 或 3，但您可以根據 <code>Layout</code> 物件中的 ID <code>VERTICAL</code>、<code>HORIZONTAL</code> 和 <code>GRID</code> 來做交互檢查。</p>
<p>如果是 <code>GRID</code> Layout，請加載 <code>grid_list_item</code>；如果是 <code>HORIZONTAL</code> 和 <code>VERTICAL</code> Layout，請加載 <code>vertical_horizontal_list_item</code>。此方法應傳回 <code>DogCardViewHolder</code> 執行個體，代表加載後的 Layout。</p>
<div class="note no-icon success">
            <p><strong>提示：</strong> 您可以使用條件陳述式 (例如 if 或 when)，根據 Layout 類型設定變數，如果是 <b>GRID</b>，應設定 <b>grid_list_item</b>；如果是 <b>VERTICAL</b> 或 <b>HORIZONTAL</b>，則應設定 <b>vertical_horizontal_list_item</b>。取得正確的 Layout ID 後，只要將 ID 傳入方法來加載 Layout 即可。</p>
          </div>

<p>⭐️ <code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: DogCardViewHolder &#123;</span><br><span class="line">    <span class="comment">// 使用conditional決定layout type並進行對應設定。</span></span><br><span class="line">    <span class="comment">// 如果layout variable是 Layout.GRID，則應使用grid list item。</span></span><br><span class="line">    <span class="comment">// 非Layout.GRID則應使用vertical/horizontal list item。</span></span><br><span class="line">    <span class="keyword">val</span> adapterLayout: View</span><br><span class="line">    <span class="keyword">if</span> (layout == GRID) &#123;</span><br><span class="line">        adapterLayout = LayoutInflater.from(parent.context).inflate(R.layout.grid_list_item, parent, <span class="literal">false</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        adapterLayout = LayoutInflater.from(parent.context).inflate(R.layout.vertical_horizontal_list_item, parent, <span class="literal">false</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 小筆記：LayoutInflater的意思</span></span><br><span class="line"><span class="comment">       Inflater是指打氣機的意思，比如把氣球充滿氣，所以LayoutInflater就是把layout充氣充滿的機制，</span></span><br><span class="line"><span class="comment">       可以想像成製作出一個layout的意思。 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//另一個方法(用when)</span></span><br><span class="line">    <span class="comment">/* val adapterLayout = when (layout) &#123;</span></span><br><span class="line"><span class="comment">        // Inflate the layout</span></span><br><span class="line"><span class="comment">        GRID -&gt; LayoutInflater.from(parent.context).inflate(R.layout.grid_list_item, parent, false)</span></span><br><span class="line"><span class="comment">        else -&gt; LayoutInflater.from(parent.context).inflate(R.layout.vertical_horizontal_list_item, parent, false)</span></span><br><span class="line"><span class="comment">    &#125; */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不應將Null傳遞到view holder。 應該更新它以反映inflated layout。</span></span><br><span class="line">    <span class="keyword">return</span> DogCardViewHolder(adapterLayout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>實作 <code>getItemCount()</code> 即可傳回狗狗清單的長度。</li>
</ol>
<p>⭐️ <code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// 回傳data set的大小</span></span><br><span class="line">    <span class="keyword">return</span> dogList.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>最後，您需要實作 <code>onBindViewHolder()</code>，才能在每個 Recycler View Card 中設定資料。使用 position 存取清單正確的狗狗資料，並設定圖片和狗狗名字。使用字串資源 <code>dog_age</code> 和 <code>dog_hobbies</code> 正確設定年齡和嗜好的格式。</li>
</ol>
<div class="note no-icon success">
            <p>提示：在 <b>onBindViewHolder()</b> 方法中，我們已經定義一個 <b>resources</b> 變數，您可以借此參照字串資源，不必每次都使用 <b>context?.resources</b>。</p>
          </div>

<p>⭐️ <code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">DogCardViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 取得current position的data</span></span><br><span class="line">        <span class="keyword">val</span> dogData = dogList[position]</span><br><span class="line">        <span class="comment">// 設定current dog的image resource</span></span><br><span class="line">        holder.dogImageView?.setImageResource(dogData.imageResourceId)</span><br><span class="line">        <span class="comment">// 設定current dog&#x27;s name的text</span></span><br><span class="line">        holder.dogNameTextView?.text = dogData.name</span><br><span class="line">        <span class="comment">// 設定current dog&#x27;s age的text</span></span><br><span class="line">        <span class="keyword">val</span> resources = context?.resources</span><br><span class="line">        holder.dogAgeTextView?.text = resources?.getString(R.string.dog_age, dogData.age)</span><br><span class="line">        <span class="comment">// 透過將hobbies傳遞給R.string.dog_hobbies字串來設定current dog&#x27;s hobbies的text。</span></span><br><span class="line">        <span class="comment">// 將參數傳遞給字串資源如下所示：</span></span><br><span class="line">        <span class="comment">// resources?.getString(R.string.dog_hobbies, dog.hobbies)</span></span><br><span class="line">        holder.dogHobbiesTextView?.text = resources?.getString(R.string.dog_hobbies, dogData.hobbies)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>實作 adapter 後，請在模擬器上執行應用程式，驗證是否已正確實作所有程式碼。</p>
<div class="video-container"><iframe src="https://player.vimeo.com/video/868744902" frameborder="0" loading="lazy" allowfullscreen></iframe></div>

<hr>
<h4 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h4><p><code>DogCardAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* Copyright (C) 2021 The Android Open Source Project.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span></span><br><span class="line"><span class="comment">* you may not use this file except in compliance with the License.</span></span><br><span class="line"><span class="comment">* You may obtain a copy of the License at</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*     http://www.apache.org/licenses/LICENSE-2.0</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* Unless required by applicable law or agreed to in writing, software</span></span><br><span class="line"><span class="comment">* distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span></span><br><span class="line"><span class="comment">* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span></span><br><span class="line"><span class="comment">* See the License for the specific language governing permissions and</span></span><br><span class="line"><span class="comment">* limitations under the License.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">package</span> com.example.dogglers.adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.ImageView</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.example.dogglers.R</span><br><span class="line"><span class="keyword">import</span> com.example.dogglers.<span class="keyword">const</span>.Layout.GRID</span><br><span class="line"><span class="keyword">import</span> com.example.dogglers.<span class="keyword">data</span>.DataSource</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adapter to inflate the appropriate list item layout and populate the view with information</span></span><br><span class="line"><span class="comment"> * from the appropriate data source</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DogCardAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context?,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> layout: <span class="built_in">Int</span></span><br><span class="line">): RecyclerView.Adapter&lt;DogCardAdapter.DogCardViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用data/DataSource中的list初始化數據</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dogList = DataSource.dogs</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化view elements</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">DogCardViewHolder</span>(view: View?): RecyclerView.ViewHolder(view!!) &#123;</span><br><span class="line">        <span class="comment">// 宣告並初始化所有list item UI 元件</span></span><br><span class="line">        <span class="comment">/* 小筆記：?和!!的意思</span></span><br><span class="line"><span class="comment">            ?：做 null check 後，不為空的話再執行</span></span><br><span class="line"><span class="comment">            !!：堅持不會是空值，執行就是了 */</span></span><br><span class="line">        <span class="keyword">val</span> dogImageView: ImageView? = view!!.findViewById(R.id.dog_image)</span><br><span class="line">        <span class="keyword">val</span> dogNameTextView: TextView? = view!!.findViewById(R.id.dog_name)</span><br><span class="line">        <span class="keyword">val</span> dogAgeTextView: TextView? = view!!.findViewById(R.id.dog_age)</span><br><span class="line">        <span class="keyword">val</span> dogHobbiesTextView: TextView? = view!!.findViewById(R.id.dog_hobbies)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: DogCardViewHolder &#123;</span><br><span class="line">        <span class="comment">// 使用conditional決定layout type並進行對應設定。</span></span><br><span class="line">        <span class="comment">// 如果layout variable是 Layout.GRID，則應使用grid list item。</span></span><br><span class="line">        <span class="comment">// 非Layout.GRID則應使用vertical/horizontal list item。</span></span><br><span class="line">        <span class="keyword">val</span> adapterLayout: View</span><br><span class="line">        <span class="keyword">if</span> (layout == GRID) &#123;</span><br><span class="line">            adapterLayout = LayoutInflater.from(parent.context).inflate(R.layout.grid_list_item, parent, <span class="literal">false</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            adapterLayout = LayoutInflater.from(parent.context).inflate(R.layout.vertical_horizontal_list_item, parent, <span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 小筆記：LayoutInflater的意思</span></span><br><span class="line"><span class="comment">           Inflater是指打氣機的意思，比如把氣球充滿氣，所以LayoutInflater就是把layout充氣充滿的機制，</span></span><br><span class="line"><span class="comment">           可以想像成製作出一個layout的意思。 */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//另一個方法(用when)</span></span><br><span class="line">        <span class="comment">/* val adapterLayout = when (layout) &#123;</span></span><br><span class="line"><span class="comment">            // Inflate the layout</span></span><br><span class="line"><span class="comment">            GRID -&gt; LayoutInflater.from(parent.context).inflate(R.layout.grid_list_item, parent, false)</span></span><br><span class="line"><span class="comment">            else -&gt; LayoutInflater.from(parent.context).inflate(R.layout.vertical_horizontal_list_item, parent, false)</span></span><br><span class="line"><span class="comment">        &#125; */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 不應將Null傳遞到view holder。 應該更新它以反映inflated layout。</span></span><br><span class="line">        <span class="keyword">return</span> DogCardViewHolder(adapterLayout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="comment">// 回傳data set的大小</span></span><br><span class="line">        <span class="keyword">return</span> dogList.size</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">DogCardViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">// 取得current position的data</span></span><br><span class="line">        <span class="keyword">val</span> dogData = dogList[position]</span><br><span class="line">        <span class="comment">// 設定current dog的image resource</span></span><br><span class="line">        holder.dogImageView?.setImageResource(dogData.imageResourceId)</span><br><span class="line">        <span class="comment">// 設定current dog&#x27;s name的text</span></span><br><span class="line">        holder.dogNameTextView?.text = dogData.name</span><br><span class="line">        <span class="comment">// 設定current dog&#x27;s age的text</span></span><br><span class="line">        <span class="keyword">val</span> resources = context?.resources</span><br><span class="line">        holder.dogAgeTextView?.text = resources?.getString(R.string.dog_age, dogData.age)</span><br><span class="line">        <span class="comment">// 透過將hobbies傳遞給R.string.dog_hobbies字串來設定current dog&#x27;s hobbies的text。</span></span><br><span class="line">        <span class="comment">// 將參數傳遞給字串資源如下所示：</span></span><br><span class="line">        <span class="comment">// resources?.getString(R.string.dog_hobbies, dog.hobbies)</span></span><br><span class="line">        holder.dogHobbiesTextView?.text = resources?.getString(R.string.dog_hobbies, dogData.hobbies)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="https://github.com/HemantSachdeva/Dogglers">HemantSachdeva&#x2F;Dogglers</a><br><a href="https://louis383.medium.com/kotlin-%E9%80%99%E4%BA%9B%E7%AC%A6%E8%99%9F%E5%88%B0%E5%BA%95%E4%BB%80%E9%BA%BC%E6%84%8F%E6%80%9D-4274d3ae32ab">Kotlin ?!! 這些符號到底什麼意思</a><br><a href="https://shoujhengduan.medium.com/layoutinflater%E7%9A%84%E4%BD%BF%E7%94%A8%E6%A6%82%E5%BF%B5-192024cb6631">[Android] LayoutInflater的使用概念</a><br><a href="https://hackmd.io/s/quick-start-tw#%F0%9F%95%B9-3-6%EF%BC%8E%E5%B5%8C%E5%85%A5%E5%BD%B1%E7%89%87">HackMD 快速入門教學 - 嵌入影片</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Layout</tag>
        <tag>Card</tag>
        <tag>MaterialCardView</tag>
        <tag>List</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(19)-測試Lists和Adapters</title>
    <url>/2023/09/22/Android%E7%AD%86%E8%A8%98-19-%E6%B8%AC%E8%A9%A6Lists%E5%92%8CAdapters/</url>
    <content><![CDATA[<blockquote>
<p>詳細了解測試以及如何新增測試<code>依賴項(dependencies)</code>。進一步練習編寫<code>單元測試(unit test)</code>和<code>設備測試(instrumentation test)</code>。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>撰寫測試的基本概念。</li>
<li>如何新增測試專用的 <code>Gradle</code> 依附元件。</li>
<li>如何透過<code>檢測設備測試(instrumentation tests)</code>，來測試List。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="最佳做法"><a href="#最佳做法" class="headerlink" title="最佳做法"></a>最佳做法</h4><p>測試程式碼在設計上會與應用程式的商業邏輯有所不同。原因是<span class="label primary">測試不應包含任何邏輯內容</span>；只單純進行測試而已。因此，<span class="label primary">測試不應有條件陳述式 (例如 if 或 when)，或者控制流程陳述式 (例如 for 或 while)</span>。也不得操控值或執行任何實際的運算。</p>
<p>有時候，您的測試可能需要其中一些項目，不過一般而言，請避免使用這些項目。由於我們想要在應用程式中測試這個邏輯類型，因此如果測試中有這類程式碼，可能就會失敗，就像應用程式的程式碼可能會失敗一樣。</p>
<p>我們的<span class="label primary">單元測試</span>只應<span class="label primary">從應用程式呼叫部分測試所需的程式碼</span>，並測試呼叫這些程式碼時所產生的<span class="label primary">程式碼值</span>或<span class="label primary">狀態</span>。<span class="label primary">UI 測試</span>則只應測試<span class="label primary">使用者介面的預期狀態</span>。</p>
<hr>
<h4 id="建立測試目錄"><a href="#建立測試目錄" class="headerlink" title="建立測試目錄"></a>建立測試目錄</h4><p>在<a href="https://linglingdr00.github.io/2023/09/19/Android%E7%AD%86%E8%A8%98-15-%E7%B7%A8%E5%AF%AB%E6%AA%A2%E6%B8%AC%E8%A8%AD%E5%82%99%E6%B8%AC%E8%A9%A6/">先前的筆記</a>中，我們已說明如何建立 <code>androidTest</code> 目錄來進行檢測設備測試。針對 <code>androidTest</code> 目錄和 <code>test</code> 目錄，重複這個專案的流程。這兩者的流程相同，唯一的差別是對於 <code>test</code> 目錄，您必須從「New Directory」下拉式選單中選取「<strong>test&#x2F;java</strong>」，而不是「androidTest&#x2F;java」。接著請為每個名稱為 <code>com.example.affirmations</code> 的新目錄建立新套件。</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-affirmations-test-lists-and-adapters/img/d762ecd8950e97b2_1920.png?hl=zh-tw" width="60%" height="60%">

<div class="note no-icon success">
            <p><strong>注意：</strong> <b>test&#x2F;java</b> 在新版本的 Android Studio 可能已經自動建好了</p>
          </div>

<hr>
<h4 id="建立檢測設備測試類別"><a href="#建立檢測設備測試類別" class="headerlink" title="建立檢測設備測試類別"></a>建立檢測設備測試類別</h4><p>在「androidTest」-&gt;「com.example.affirmations」路徑中，建立名為 <code>AffirmationsListTests.kt</code> 的新類別。</p>
<p>與 <strong>Dice Roller</strong> 應用程式一樣，<strong>Affirmations</strong> 只有一個活動。為了測試活動的使用者介面，我們必須指明要啟動活動。試試看能不能自己回想出做法！</p>
<ol>
<li>在新建的類別中加入測試執行器。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>為主要活動建立活動情境規則。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@get:Rule</span></span><br><span class="line"><span class="keyword">val</span> activity = ActivityScenarioRule(MainActivity::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Affirmations</strong> 應用程式會顯示圖片及各自的正向肯定語錄清單。使用者介面不允許與項目進行任何互動，例如點擊或滑動。因此，這個應用程式的檢測設備測試只會測試靜態資料。建立名為 <code>scroll_to_item()</code> 的測試方法。請記得加上 <code>@Test</code> 的註解。</li>
</ol>
<p>這項測試應捲動至清單中的特定項目。我們尚未介紹這個方式，因為這需要用到專案尚未參照的方法。在繼續測試之前，需要新增一些測試依附元件。</p>
<hr>
<h4 id="新增檢測設備測試dependencies"><a href="#新增檢測設備測試dependencies" class="headerlink" title="新增檢測設備測試dependencies"></a>新增檢測設備測試dependencies</h4><p>您應該已大致瞭解如何在應用程式的程式碼中，新增要使用的 Gradle 依附元件。透過 Gradle，我們也能新增單元測試和檢測設備測試專用的dependencies。方法是依序前往「app」-&gt;「build.gradle」，開啟應用程式層級的 <code>build.gradle</code> 檔案。「依附元件(dependencies)」部分會列出三種實作依附元件的方式：<code>implementation</code>、<code>testImplementation</code> 和 <code>androidTestImplementation</code>。</p>
<p><code>implementation</code> 適用於應用程式本身會使用的依附元件，<code>testImplementation</code> 適用於單元測試中使用的依附元件，<code>androidTestImplementation</code> 則適用於檢測設備測試中使用的依附元件。</p>
<ol>
<li>新增依附元件，允許在檢測設備測試中與 <code>RecyclerView</code> 互動。將下列程式庫新增為 <code>androidTestImplementation</code>：</li>
</ol>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line">androidx.test.espresso:espresso-contrib:<span class="number">3.5</span><span class="number">.1</span></span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> 您可以在<a href="https://developer.android.com/jetpack/androidx/releases/test?hl=zh-tw">這裡</a>找到最新版本的 <code>espresso-contrib</code>。</p>
          </div>

<p>dependencies看起來會像這樣：</p>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    androidTestImplementation <span class="string">&quot;androidx.test.espresso:espresso-contrib:3.5.1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著點選 Sync Now(同步)。</li>
</ol>
<hr>
<h4 id="測試-RecyclerView"><a href="#測試-RecyclerView" class="headerlink" title="測試 RecyclerView"></a>測試 RecyclerView</h4><ol>
<li>專案同步處理後，請返回 <code>AffirmationsListTests.kt</code> 檔案。提供 <code>ViewInteraction</code>，以使用 <code>onView()</code> 執行動作。<code>onView()</code> 方法需要傳入 <code>ViewMatcher</code>。使用 <code>withId()</code>，確認傳入的是用於確認的 <code>RecyclerView</code> ID。立即在 <code>ViewInteraction</code> 上呼叫 <code>perform()</code>。也就是新加入的依附元件！現在可以傳入 <code>RecyclerViewActions.scrollToPosition&lt;RecyclerView.Viewholder&gt;(9) ViewAction</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.recycler_view)).perform(</span><br><span class="line">   RecyclerViewActions</span><br><span class="line">       .scrollToPosition&lt;RecyclerView.ViewHolder&gt;(<span class="number">9</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>瞭解這一行的語法不太重要，但還是值得看一看。<code>RecyclerViewActions</code> 這個名稱與跟名稱所暗示的一樣：讓您在 <code>RecyclerView</code> 執行測試的類別。<code>scrollToPosition()</code> 是 <code>RecyclerViewActions</code> 類別中的靜態方法，可捲動至指定位置。這個方法會傳回「一般」內容。「一般」內容不在這個程式碼研究室的涵蓋範圍內，但在此案例中，您可以把它想成是 <code>scrollToPosition()</code> 方法，可傳回 <code>RecyclerView</code> 中的所有項目 (可能是任何內容)。</p>
<p>在我們的應用程式中，<code>RecyclerView</code> 中的項目是 <code>ViewHolder</code>，因此我們會在方法呼叫完成後置入一對角括號，並在其中指定 <code>RecyclerView.ViewHolder</code>。最後，請傳遞清單中的最後一個位置 <code>(9)</code>。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 系統已針對該位置傳遞 9 的硬式編碼值，因為此應用程式中的清單大小為靜態，所以才會這樣。如果應用程式的清單大小為動態，則不建議使用硬式編碼值，因為除了大小不明外，也無法存取 <b>MainActivity</b> 的 <b>RecyclerView</b> 轉接器 (這是 <b>onCreate()</b> 方法中有內含 <b>RecyclerView</b> 的變數所致)。如果在 <b>MainActivity</b> 類別層級宣告了變數，我們可以存取該變數以取得轉接器的大小。此外，UI 測試不應一定要存取測試中活動的變數；這類方法更適合用於單元測試。</p><p>下方步驟 2 中會說明如何避免在這類測試中採用硬式編碼值。</p>
          </div>

<ol start="2">
<li>現在已經可以捲動至 <code>RecyclerView</code> 的所需位置，因此請做出斷言，確保 UI 顯示的是預期資訊。確保當您捲動至最後一個項目後，系統會顯示與最終肯定相關聯的文字。請從 <code>ViewInteraction</code> 開始，但這次在新的 <code>ViewMatcher</code> 中傳遞 (在本案例中為 <code>withText()</code>)。對於此方法，請傳送包含最後一個肯定語錄文字的字串資源。<code>withText()</code> 方法會根據顯示的文字來識別使用者介面元件。</li>
</ol>
<p>對於這項元件，只需檢查元件中是否顯示所需的文字即可。方法是透過在 <code>ViewInteraction</code> 上呼叫 <code>check()</code>。<code>check()</code> 需要 <code>ViewAssertion</code>，因此您可以使用 <code>matches()</code> 方法。最後，傳遞 <code>isDisplayed()</code> 方法，宣告要顯示使用者介面元件。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withText(R.string.affirmation10))</span><br><span class="line">    .check(matches(isDisplayed()))</span><br></pre></td></tr></table></figure>

<p>回到用硬式編碼的方式設定捲動目標位置的附註，有一種方式可透過 <code>RecyclerViewActions</code> 解決此問題。當您不確定清單長度時，可以使用 <code>scrollTo</code> 動作。如要使用 <code>scrollTo</code> 函式，您需要使用 <code>Matcher&lt;View!&gt;!</code> 來尋找特定項目。這可以包含許多項目，但若要達到這項測試的目的，請使用 <code>withText</code>。將其套用到您剛才編寫的測試後，程式碼看起來會像這樣：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 捲動到字串10的位置 */</span></span><br><span class="line">onView(withId(R.id.recycler_view)).perform(</span><br><span class="line">   RecyclerViewActions</span><br><span class="line">       .scrollTo&lt;RecyclerView.ViewHolder&gt;(</span><br><span class="line">           hasDescendant(withText(R.string.affirmation10))</span><br><span class="line">       )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 檢查顯示字串10文字 */</span></span><br><span class="line">onView(withText(R.string.affirmation10))</span><br><span class="line">    .check(matches(isDisplayed())</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h5 id="解決-bug"><a href="#解決-bug" class="headerlink" title="解決 bug"></a>解決 bug</h5><p>原 google 課程的 code 有 bug，會執行失敗：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.recycler_view)).perform(</span><br><span class="line">   RecyclerViewActions</span><br><span class="line">       .scrollTo&lt;RecyclerView.ViewHolder&gt;(</span><br><span class="line">           hasDescendant(withText(R.string.affirmation10))</span><br><span class="line">       )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>參考<a href="https://github.com/google-developer-training/android-basics-kotlin-affirmations-app-solution/issues/128">這篇文章</a>，在 <code>withText()</code> 外用 <code>hasDescendant()</code> 包起來，即可執行成功。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.recycler_view)).perform(</span><br><span class="line">   RecyclerViewActions</span><br><span class="line">       .scrollTo&lt;RecyclerView.ViewHolder&gt;(</span><br><span class="line">           withText(R.string.affirmation10)</span><br><span class="line">       )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p>注意：您可以參閱<a href="https://developer.android.com/reference/androidx/test/espresso/contrib/RecyclerViewActions">這篇文章</a>，瞭解與 <b>RecyclerViewActions</b> 類別相關聯的多個實用函式。</p>
          </div>

<p>現在一切已準備就緒，隨時可以執行測試。裝置或模擬器應捲動到清單底部，然後才通過測試。如要確保測試結果正確無誤，請將字串 ID 替換成 <code>R.string.affirmation1</code>。捲動完成後，這個字串資源就不會顯示，且測試應會失敗。</p>
<p><code>RecyclerViewActions</code> 類別提供的方法有很多種，建議您查看<a href="https://developer.android.com/reference/androidx/test/espresso/contrib/RecyclerViewActions">可用的方法</a>。</p>
<hr>
<h4 id="建立本機測試類別"><a href="#建立本機測試類別" class="headerlink" title="建立本機測試類別"></a>建立本機測試類別</h4><p>在「test」-&gt;「com.example.affirmations」路徑中，建立名為 <code>AffirmationsAdapterTests.kt</code> 的新類別。</p>
<img src="https://i.imgur.com/KX9NcPy.png">

<hr>
<h4 id="新增本機測試dependencies"><a href="#新增本機測試dependencies" class="headerlink" title="新增本機測試dependencies"></a>新增本機測試dependencies</h4><p>在本程式碼研究室的前半部，我們討論了三種依附元件(dependencies)實作方式，且您新增了檢測設備測試的依附元件。現在請新增本機測試的依附元件。方法是依序前往「app」-&gt;「build.gradle」，並將以下內容新增為單位測試依附元件：</p>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line">org.mockito:mockito-core:<span class="number">3.12</span><span class="number">.4</span></span><br></pre></td></tr></table></figure>

<p>dependencies應如下所示：</p>
<figure class="highlight kts"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    ...</span><br><span class="line">    testImplementation <span class="string">&quot;org.mockito:mockito-core:3.12.4&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著點選 Sync Now(同步)。</li>
</ol>
<hr>
<h4 id="測試-Adapter"><a href="#測試-Adapter" class="headerlink" title="測試 Adapter"></a>測試 Adapter</h4><p>這個應用程式本身不需要進行單元測試，因為沒有足夠的邏輯可以測試。然而，我們可以取得測試各項元件的更多經驗，為日後的測試做準備。</p>
<ol>
<li>在單元測試類別中加入以下這行：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> context = mock(Context::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p><code>mock()</code> 方法來自我們剛才在專案中實作的程式庫。模擬是單元測試的必要部分，但不在這個程式碼研究室的範圍內。我們會在另一個程式碼研究室中詳細說明模擬功能。在 Android 中，<code>Context</code> 是應用程式目前狀態的結構定義，但別忘了，單元測試是在 <strong>JVM</strong> 執行，而不是在實際裝置上執行，因此沒有 <code>Context</code>。這個模擬方法能讓我們建立 <code>Context</code> 的「模擬」執行個體。這個執行個體沒有任何實際的功能，但可用來測試需要結構定義的方法。</p>
<ol start="2">
<li>建立名為 <code>adapter_size()</code> 的函式並加上註解作為測試。這項測試旨在確認 adapter 與傳遞至 adapter 的 list 兩者大小相同。執行方法是建立 <code>ItemAdapter</code> 的執行個體，並傳入 <code>Datasource</code> 類別中 <code>loadAffirmations()</code> 方法所傳回的 list。您也可以建立新的 list 並進行測試。如果是單元測試，最佳做法是建立測試專屬的資料，以便我們為這項測試建立自訂名單。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> <span class="keyword">data</span> = listOf(</span><br><span class="line">   Affirmation(R.string.affirmation1, R.drawable.image1),</span><br><span class="line">   Affirmation(R.string.affirmation2, R.drawable.image2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>立即建立 <code>ItemAdapter</code> 的執行個體，並傳入在上述步驟中建立的 <code>context</code> 和 <code>data</code> 變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapter = ItemAdapter(context, <span class="keyword">data</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Recycler view adapters</strong> 有一方法，會傳回名為 <code>getItemCount()</code> 的 adapter 大小。對於這個應用程式而言，方法如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Return the size of your dataset (invoked by the layout manager)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = dataset.size</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>這是應該測試的方法。這個方法的傳回值必須與您在步驟 2 中建立的 list 大小相符。使用 <code>assertEquals()</code> 方法，並比較 list 大小和 adapter 大小的值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">assertEquals(<span class="string">&quot;ItemAdapter is not the correct size&quot;</span>, <span class="keyword">data</span>.size, adapter.itemCount)</span><br></pre></td></tr></table></figure>

<p>您已經熟悉 <code>assertEquals()</code> 方法，但建議您仔細檢查這一行。第一個參數是測試失敗時，會在測試結果中顯示的字串。第二個參數是預期的值。第三個參數是實際值。您的測試類別應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.adapter.ItemAdapter</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.model.Affirmation</span><br><span class="line"><span class="keyword">import</span> org.junit.Assert.assertEquals</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.mockito.Mockito.mock</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AffirmationsAdapterTests</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context = mock(Context::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">adapter_size</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = listOf(</span><br><span class="line">            Affirmation(R.string.affirmation1, R.drawable.image1),</span><br><span class="line">            Affirmation(R.string.affirmation2, R.drawable.image2)</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">val</span> adapter = ItemAdapter(context, <span class="keyword">data</span>)</span><br><span class="line">        <span class="comment">/* 比對adapter大小和list大小 */</span></span><br><span class="line">        assertEquals(<span class="string">&quot;ItemAdapter is not the correct size&quot;</span>, <span class="keyword">data</span>.size, adapter.itemCount)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最後，執行測試應該可以看到 Tests passed。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>List</tag>
        <tag>Adapter</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(18)-使用Cards顯示圖像List</title>
    <url>/2023/09/22/Android%E7%AD%86%E8%A8%98-18-%E4%BD%BF%E7%94%A8Cards%E9%A1%AF%E7%A4%BA%E5%9C%96%E5%83%8FList/</url>
    <content><![CDATA[<blockquote>
<p>使用 Android 版 Material 元件程式庫中的 <code>MaterialCardView</code> 小工具，在資訊卡(cards)中顯示各個肯定字詞的文字和圖片。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-display-list-cards/img/8d7a20a5d7a079ce_1920.png?hl=zh-tw" width="30%" height="30%">

<p><strong>學習目標</strong></p>
<ul>
<li>如何將圖像新增至 <code>RecyclerView</code> 顯示的肯定字詞清單中。</li>
<li>如何在 <code>RecyclerView</code> 項目的版面配置中使用 <code>MaterialCardView</code>。</li>
<li>在使用者介面中進行視覺調整，讓應用程式看起來更精美。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="將圖像新增至List項目"><a href="#將圖像新增至List項目" class="headerlink" title="將圖像新增至List項目"></a>將圖像新增至List項目</h3><p>您目前建立了一個適配器 <code>ItemAdapter</code>，可顯示 <code>RecyclerView</code> 中的肯定字詞字串。功能運作良好，但視覺上沒有吸引力。在這項工作中，您將修改List項目的版面配置和適配器的程式碼，顯示包含肯定字詞的圖片。</p>
<h4 id="下載圖像"><a href="#下載圖像" class="headerlink" title="下載圖像"></a>下載圖像</h4><ol>
<li>在 Android Studio 中開啟 <code>Affirmations</code> 應用程式專案。</li>
<li>接著，請將<a href="https://github.com/google-developer-training/android-basics-kotlin-affirmations-app-solution/raw/main/images.zip">圖像檔</a>下載到電腦上。應用程式中應有十張圖片，每張各代表一個肯定字詞。檔案名稱應介於 <code>image1.jpg</code> 至 <code>image10.jpg</code> 之間。</li>
<li>將電腦中的圖像複製到 Android Studio 中專案的「Res」(解析度) &gt;「drawable」(可繪項目) 資料夾 (<code>app/src/main/res/drawable</code>)。將這些資源新增至應用程式後，您就能使用資源資源 ID (例如 <code>R.drawable.image1</code>)，從程式碼存取這些圖片 (您可能需要重新建立程式碼，才能讓 Android Studio 找到這個圖像)。</li>
</ol>
<h4 id="新增對-Affirmation-肯定字詞-類別中圖像的支援"><a href="#新增對-Affirmation-肯定字詞-類別中圖像的支援" class="headerlink" title="新增對 Affirmation (肯定字詞) 類別中圖像的支援"></a>新增對 Affirmation (肯定字詞) 類別中圖像的支援</h4><p>在這個步驟中，您將在 <code>Affirmation</code> 資料類別中新增屬性，用來保存圖片資源 ID 的值。這樣一來，單一 <code>Affirmation</code> 物件例項就會包含肯定字詞的<strong>文字資源 ID</strong> 和<strong>圖片資源 ID</strong>。</p>
<ol>
<li>開啟 <code>model</code> 套件中的 <code>Affirmation.kt</code> 檔案。</li>
<li>新增命名為 <code>imageResourceId</code> 的參數 <code>Int</code>，即可修改 <code>Affirmation</code> 類別的建構函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Affirmation</span>(<span class="keyword">val</span> stringResourceId: <span class="built_in">Int</span>, <span class="keyword">val</span> imageResourceId: <span class="built_in">Int</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用資源註解"><a href="#使用資源註解" class="headerlink" title="使用資源註解"></a>使用資源註解</h5><p><code>stringResourceId</code> 和 <code>imageResourceId</code> 都是 <strong>Int(整數)</strong> 值。雖然看起來沒問題，但呼叫端可能會不小心以錯誤的順序傳入引數，即先傳入 <code>imageResourceId</code>，而不是 <code>stringResourceId</code>。</p>
<p>若要避免這種情況發生，您可以使用<strong>資源註解</strong>。註解相當實用，因為會新增至其他資訊至類別、方法或參數中。系統一律會使用 <code>@</code> 符號宣告註解。在此情況下，請將 <code>@StringRes</code> 註解新增至<strong>字串資源 ID</strong> 屬性，並將 <code>@DrawableRes</code> 註解新增至<strong>可繪製資源 ID</strong> 屬性。如果提供的資源 ID 類型有誤，您會收到警告。</p>
<ol>
<li>將 <code>@StringRes</code> 註解新增至 <code>stringResourceId</code>。</li>
<li>將 <code>@DrawableRes</code> 註解新增至 <code>imageResourceId</code>。</li>
<li>套件宣告完成後，確認匯入的 <code>androidx.annotation.DrawableRes</code> 和 <code>androidx.annotation.StringRes</code>　新增至檔案頂端。</li>
</ol>
<p><code>Affirmation.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Affirmation</span>(</span><br><span class="line">   <span class="meta">@StringRes</span> <span class="keyword">val</span> stringResourceId: <span class="built_in">Int</span>, <span class="meta">@DrawableRes</span> <span class="keyword">val</span> imageResourceId: <span class="built_in">Int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="初始化內含圖像的肯定字詞清單"><a href="#初始化內含圖像的肯定字詞清單" class="headerlink" title="初始化內含圖像的肯定字詞清單"></a>初始化內含圖像的肯定字詞清單</h4><p>您已變更 <code>Affirmation</code> 類別的建構函式，因此必須更新 <code>Datasource</code> 類別。將圖像資源 ID 傳遞至每個初始化的 <code>Affirmation</code> 物件。</p>
<ol>
<li>開啟 <code>Datasource.kt</code>。您應該會看到 <code>Affirmation</code> 的每個執行個體化錯誤。</li>
<li>請為每個 <code>Affirmation</code> 新增圖像的資源 ID 做為引數，例如 <code>R.drawable.image1</code>。</li>
</ol>
<p><code>Datasource.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Datasource</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAffirmations</span><span class="params">()</span></span>: List&lt;Affirmation&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf&lt;Affirmation&gt;(</span><br><span class="line">            Affirmation(R.string.affirmation1, R.drawable.image1),</span><br><span class="line">            Affirmation(R.string.affirmation2, R.drawable.image2),</span><br><span class="line">            Affirmation(R.string.affirmation3, R.drawable.image3),</span><br><span class="line">            Affirmation(R.string.affirmation4, R.drawable.image4),</span><br><span class="line">            Affirmation(R.string.affirmation5, R.drawable.image5),</span><br><span class="line">            Affirmation(R.string.affirmation6, R.drawable.image6),</span><br><span class="line">            Affirmation(R.string.affirmation7, R.drawable.image7),</span><br><span class="line">            Affirmation(R.string.affirmation8, R.drawable.image8),</span><br><span class="line">            Affirmation(R.string.affirmation9, R.drawable.image9),</span><br><span class="line">            Affirmation(R.string.affirmation10, R.drawable.image10)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="新增-ImageView-至List項目版面配置"><a href="#新增-ImageView-至List項目版面配置" class="headerlink" title="新增 ImageView 至List項目版面配置"></a>新增 ImageView 至List項目版面配置</h4><p>若要顯示這份List中各項肯定字詞的圖像，您必須新增 <code>ImageView</code> 至項目版面配置。由於您現在有 <code>TextView</code> 和 <code>ImageView</code> 兩個檢視畫面，因此需要將這兩個檢視畫面放置為 <code>ViewGroup</code> 內的子項檢視畫面。若要排列垂直欄的檢視畫面，請使用 <code>LinearLayout</code>。<code>LinearLayout</code> 會在單一方向 (垂直或水平) 對齊所有子項檢視畫面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-display-list-cards/img/a5cb4349a970c992_1920.png?hl=zh-tw" width="35%" height="35%">

<ol>
<li>依序開啟「Res」&gt;「Layout」&gt;「list_item.xml」。在現有 <code>TextView</code> 周圍新增 <code>LinearLayout</code>，並將 <code>orientation</code> 屬性設定為 <code>vertical</code>。</li>
<li>將 <code>xmlns schema</code> 宣告行從 <code>TextView</code> 元素移至 <code>LinearLayout</code> 元素，以避免錯誤。</li>
</ol>
<p><code>list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>TextView</code>, 之前的 <code>LinearLayout</code>, 內，新增資源 ID 為 <code>item_image</code> 的 <code>ImageView</code>。</li>
<li>將 <code>ImageView</code> 的寬度設定為 <code>match_parent</code>，高度設定為 <code>194dp</code>。視螢幕大小而定，這個值應會隨時在螢幕上顯示幾張資訊卡(card)。</li>
<li>將 <code>scaleType</code> 設定為 <code>centerCrop</code>.</li>
<li>將 <code>importantForAccessibility</code> 屬性設定為 <code>no</code>，因為該圖像用於裝飾用途。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;194dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_image&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="更新-ItemAdapter-以設定圖像"><a href="#更新-ItemAdapter-以設定圖像" class="headerlink" title="更新 ItemAdapter 以設定圖像"></a>更新 ItemAdapter 以設定圖像</h4><ol>
<li>開啟 <code>adapter/ItemAdapter.kt</code> (「App」(應用程式) &gt;「Java」 &gt; 「adapter 」(適配器) &gt;「ItemAdapter」)</li>
<li>前往 <code>ItemViewHolder</code> 類別。</li>
<li>在清單項目版面配置中，<code>ItemViewHolder</code> 執行個體應保留對 <code>TextView</code> 的參照及對 <code>ImageView</code> 的參照。進行以下變更。</li>
</ol>
<p>在 <code>textView</code> 屬性的初始化下方，新增名為 <code>imageView</code> 的 <code>val</code>。使用 <code>findViewById()</code> 找出對 ID 為 <code>item_image</code> 的 <code>ImageView</code> 的參照，並指派給 <code>imageView</code> 屬性。</p>
<p><code>ItemAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View): RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">    <span class="keyword">val</span> textView: TextView = view.findViewById(R.id.item_title)</span><br><span class="line">    <span class="keyword">val</span> imageView: ImageView = view.findViewById(R.id.item_image)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>ItemAdapter</code> 中找出 <code>onBindViewHolder()</code> 函式。</li>
<li>您先前在 <code>ItemViewHolder</code> 中的 <code>textView</code> 上設定肯定字詞的 <code>stringResourceId</code>。現在，請在List項目檢視畫面的 <code>ImageView</code> 上設定肯定字詞項目的 <code>imageResourceId</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ItemViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = dataset[position]</span><br><span class="line">        holder.textView.text = context.resources.getString(item.stringResourceId)</span><br><span class="line">        holder.imageView.setImageResource(item.imageResourceId)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行應用程式，然後捲動肯定字詞清單。</li>
</ol>
<img src="https://i.imgur.com/lAPUKyN.png" width="30%" height="30%">

<hr>
<h3 id="製作精美的使用者介面"><a href="#製作精美的使用者介面" class="headerlink" title="製作精美的使用者介面"></a>製作精美的使用者介面</h3><p>到目前為止，您已經建構出功能完備的應用程式，內含肯定字詞字串和圖像List 本節將說明如何微調程式碼與 XML，讓應用程式看起來更精美。</p>
<h4 id="新增邊框間距"><a href="#新增邊框間距" class="headerlink" title="新增邊框間距"></a>新增邊框間距</h4><p>一開始，請先在List中的項目(Item)之間新增空白字元。</p>
<div class="note no-icon success">
            <p><strong>提示：</strong> 您可以依照本節所述，在 XML 中調整版面配置，也可以按個人偏好，前往「Design」檢視畫面中的「Attributes」面板進行變更。</p>
          </div>

<ol>
<li>開啟 <code>item_list.xml</code> (「App」&gt;「Res」&gt;「Layout」&gt;「activity_main.xml」)，並將 <code>16dp</code> 邊框間距新增至現有的 <code>LinearLayout</code>。</li>
</ol>
<p><code>list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>16dp</code> 邊框間距新增至 <code>item_title</code> <code>TextView</code>。</li>
<li>在 <code>TextView</code> 中，將 <code>textAppearance</code> 屬性設定為 <code>?attr/textAppearanceHeadline6</code>。<a href="https://developer.android.com/guide/topics/ui/look-and-feel/themes?hl=zh-tw#textappearance"><code>textAppearance</code></a> 是可讓您定義<strong>文字專屬樣式</strong>的屬性。若要瞭解其他預先定義的文字外觀值，請參閱此<a href="https://medium.com/androiddevelopers/android-styling-common-theme-attributes-8f7c50c9eaba">常見主題屬性網誌</a>文章中的「TextAppearances」章節。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_title&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceHeadline6&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式。</li>
</ol>
<img src="https://i.imgur.com/W3EoBO9.png" width="30%" height="30%">

<h4 id="使用資訊卡-Card"><a href="#使用資訊卡-Card" class="headerlink" title="使用資訊卡(Card)"></a>使用資訊卡(Card)</h4><p>但很難判斷圖像是否屬於圖像上方或下方的肯定字詞文字。若要解決這個問題，您可以使用<code>「Card」(資訊卡)</code> 檢視畫面。<code>「Card」(資訊卡)</code> 檢視畫面可讓您輕鬆納入一組檢視畫面，並為容器提供一致的樣式。若要進一步瞭解使用資訊卡的 <code>Material Design (質感設計)</code> 指南，請參閱這篇<a href="https://m2.material.io/develop/android/components/cards/">資訊卡指南</a>。</p>
<ol>
<li>在現有的<code> LinearLayout</code> 四周新增 <code>MaterialCardView</code>。</li>
<li>再次將結構定義宣告從 <code>LinearLayout</code> 移到 <code>MaterialCardView</code>。</li>
<li>將 <code>MaterialCardView</code> 的 <code>layout_width</code> 設定為 <code>match_parent</code>，並將 <code>layout_height</code> 設定為 <code>wrap_content</code>。</li>
<li>新增 <code>8dp</code> 的 <code>layout_margin</code>。</li>
<li>移除 <code>LinearLayout</code> 中的邊框間距，以免有太多空白字元。</li>
<li>現在再次執行應用程式。您可以運用<code> MaterialCardView</code> 明確分辨每個肯定字詞嗎？</li>
</ol>
<p><code>list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.card.MaterialCardView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;8dp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">LinearLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_image&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;194dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:scaleType</span>=<span class="string">&quot;centerCrop&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_title&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:textAppearance</span>=<span class="string">&quot;?attr/textAppearanceHeadline6&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.card.MaterialCardView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://i.imgur.com/QgqaqGC.png" width="30%" height="30%">

<h4 id="變更應用程式佈景主題色彩"><a href="#變更應用程式佈景主題色彩" class="headerlink" title="變更應用程式佈景主題色彩"></a>變更應用程式佈景主題色彩</h4><p>預設的應用程式佈景主題色彩可能不如您自己做的其他選擇。在這項工作中，您必須將應用程式佈景主題色彩變更為藍色。如此一來，您就可以使用自己的想法再次變更！</p>
<p>您可以從這個<a href="https://m3.material.io/styles/color/overview#!/?view.left=0&view.right=0">連結</a>找到 Material Design 調色盤提供的預先定義不同層次的藍色。</p>
<p>在本程式碼研究室中，您將使用 Material Design 調色盤中的下列色彩：</p>
<ul>
<li>blue_200: <code>#FF90CAF9</code></li>
<li>blue_500: <code>#FF2196F3</code></li>
<li>blue_700: <code>#FF1976D2</code></li>
</ul>
<h5 id="新增色彩資源"><a href="#新增色彩資源" class="headerlink" title="新增色彩資源"></a>新增色彩資源</h5><p>集中定義應用程式內使用的色彩：<code>colors.xml</code> 檔案。</p>
<ol>
<li>開啟 <code>colors.xml</code> (「Res」&gt;「values」&gt;「colors.xml」)。</li>
<li>針對以下定義的藍色，將新的色彩資源新增至檔案：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;blue_200&quot;</span>&gt;</span>#FF90CAF9<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;blue_500&quot;</span>&gt;</span>#FF2196F3<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;blue_700&quot;</span>&gt;</span>#FF1976D2<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="變更佈景主題色彩"><a href="#變更佈景主題色彩" class="headerlink" title="變更佈景主題色彩"></a>變更佈景主題色彩</h5><p>現在，您已擁有可用於主題的新色彩資源。</p>
<ol>
<li>開啟 <code>themes.xml</code> (「Res」(解析度) &gt;「Values」(設定值) &gt;「themes」(佈景主題) &gt;「themes.xml」)。</li>
<li>找到　<code>&lt;!-- Primary brand color. --&gt;</code>　部分。</li>
<li>若要使用 <code>@color/blue_500</code>，請新增或變更 <code>colorPrimary</code>。</li>
<li>若要使用 <code>@color/blue_700</code>，請新增或變更 <code>colorPrimaryVariant</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/blue_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/blue_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行應用程式。應用程式列的色彩應該會變成藍色。</li>
</ol>
<img src="https://i.imgur.com/3wY3jMu.png" width="30%" height="30%">

<h5 id="更新深色佈景主題色彩"><a href="#更新深色佈景主題色彩" class="headerlink" title="更新深色佈景主題色彩"></a>更新深色佈景主題色彩</h5><p>建議您為應用程式的深色佈景主題選擇更飽和的色彩。</p>
<ol>
<li>開啟深色佈景主題 <code>themes.xml (night)</code> 檔案 (「themes」(佈景主題) &gt;「themes.xml (night)」 (themes.xml (night))。</li>
<li>新增或變更 <code>colorPrimary</code> 和 <code>colorPrimaryVariant</code> 佈景主題屬性如下：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/blue_200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/blue_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行應用程式</li>
<li>在裝置的「設定」中，開啟「深色主題」。</li>
<li>您的應用程式會切換為「深色主題」。</li>
</ol>
<img src="https://i.imgur.com/jd0rdwp.png" width="30%" height="30%">

<div class="note no-icon success">
            <p><strong>注意：</strong> 應用程式列色彩。您可能不知道為什麼應用程式列無法指定的顯示深色佈景主題的主要色彩。深色應用程式列是依據設計。在深色主題中，應用程式列和其他大型區域會以<b>深色背景 (colorSurface)</b> 顯示，而非主要色彩。這是因為 Material 深色主題會建議在大型表面使用明亮色彩。按鈕或其他小型強調色會顯示定義的主要色彩。</p>
          </div>

<h4 id="變更應用程式圖示"><a href="#變更應用程式圖示" class="headerlink" title="變更應用程式圖示"></a>變更應用程式圖示</h4><p>最後一個步驟是更新應用程式圖示。</p>
<ol>
<li>下載應用程式圖示檔案 <a href="https://raw.githubusercontent.com/google-developer-training/android-basics-kotlin-affirmations-app-solution/main/app/src/main/res/drawable/ic_launcher_foreground.xml"><code>ic_launcher_foreground.xml</code></a> 和 <a href="https://raw.githubusercontent.com/google-developer-training/android-basics-kotlin-affirmations-app-solution/main/app/src/main/res/drawable-v24/ic_launcher_background.xml"><code>ic_launcher_background.xml</code></a>。如果瀏覽器只是顯示檔案，而並未下載，請選取「File」&gt;「Save Page As…」，將檔案儲存到您的電腦。</li>
<li>在 Android Studio 中，刪除用於先前應用程式圖示的　<code>drawable/ic_launcher_background.xml</code> 和 <code>drawable-v24/ic_launcher_foreground.xml</code> 這兩個檔案。您可以取消勾選「Safe delete (with usage search)」(安全刪除 (使用搜尋功能)。</li>
<li>接著，用滑鼠右鍵依序點選「Res」&gt;「drawable」資料夾，然後依序選取「New」&gt;「Image Asset」。</li>
<li>在「Configure Image Asset」視窗中，確認已選取「Foreground Layer」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-display-list-cards/img/8c437aa925887439_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="5">
<li>在下方找出「Path」標籤。</li>
<li>按一下「Path」文字方塊內的資料夾圖示。</li>
<li>在電腦上尋找並開啟所下載的 <code>ic_launcher_foreground.xml</code> 檔案。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-display-list-cards/img/ddac89ef587fba99_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="8">
<li>切換至「Background Layer」分頁。</li>
<li>按一下「Path」文字方塊中的「Browse」圖示。</li>
<li>在電腦上找出並開啟 <code>ic_launcher_background.xml</code> 檔案。不需要其他變更。<br>按一下「Next」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-display-list-cards/img/c0c1986d1887afdb_1920.png?hl=zh-tw" width="70%" height="70%">

<ol start="11">
<li>在「Confirm Icon Path」對話方塊中，按一下「Finish」。</li>
<li>根據最佳做法，您可以將新的向量可繪項目 <code>ic_launcher_foreground.xml</code> 和 <code>ic_launcher_background.xml</code>，移至名為 <code>drawable-anydpi-v26</code> 的新資源目錄。<a href="https://developer.android.com/develop/ui/views/launch/icon_design_adaptive">自動調整圖示</a>已在 <strong>API 26</strong> 中推出，因此這些資源只能在搭載 API 26 以上版本的裝置 (任何 dpi) 使用。</li>
<li>如果 <code>drawable-v24</code> 目錄沒有內容，則刪除。</li>
<li>執行應用程式，然後在應用程式導覽匣中看到精美的新應用程式圖示！</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/jYLTnPm.png">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://i.imgur.com/VXkomNz.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>完成如下！</p>
<img src="https://i.imgur.com/1aEU8Mg.gif" width="30%" height="30%">]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Card</tag>
        <tag>MaterialCardView</tag>
        <tag>Material Component</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(17)-使用RecyclerView顯示可捲動的List</title>
    <url>/2023/09/21/Android%E7%AD%86%E8%A8%98-17-%E4%BD%BF%E7%94%A8RecyclerView%E9%A1%AF%E7%A4%BA%E5%8F%AF%E6%8D%B2%E5%8B%95%E7%9A%84List/</url>
    <content><![CDATA[<blockquote>
<p>建構 <code>Affirmations</code> 應用程式，並使用 <code>RecyclerView</code> 在可捲動的 <code>List</code> 中顯示 10 個正面肯定的文字。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/cf10a913f9db0ee4_1920.png?hl=zh-tw" width="30%" height="30%">

<p><strong>學習目標</strong></p>
<ul>
<li>如何使用 <code>RecyclerView</code> 顯示資料 List。</li>
<li>如何將程式碼編排到對應的套件中</li>
<li>如何與 <code>RecyclerView</code> 搭配使用<code>適配器(adapter)</code>來自訂個別 List 項目的外觀。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="建立專案"><a href="#建立專案" class="headerlink" title="建立專案"></a>建立專案</h3><h4 id="建立空白活動專案"><a href="#建立空白活動專案" class="headerlink" title="建立空白活動專案"></a>建立空白活動專案</h4><ol>
<li>使用「<strong>Empty Views Acitivity</strong>」(空白活動) 範本在 Android Studio 中建立新的 Kotlin 專案。</li>
<li>輸入「<code>Affirmations</code>」做為應用程式的名稱，「<code>com.example.affirmations</code>」做為套件名稱，然後選擇「<strong>API Level 19</strong>」做為 最低 SDK 版本。</li>
<li>按一下「Finish」建立專案。</li>
</ol>
<hr>
<h3 id="設定資料-List"><a href="#設定資料-List" class="headerlink" title="設定資料 List"></a>設定資料 List</h3><p>建立 <code>Affirmations</code> 應用程式的下一步是新增資源。您必須在專案中新增以下內容。</p>
<ul>
<li>在應用程式中顯示<strong>肯定字詞</strong>的字串資源。</li>
<li>為您的應用程式提供<strong>肯定字詞 List</strong> 的資料來源。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong> 在大部分的正式 Android 專案中，您會從資料庫或伺服器擷取肯定資料。網路和資料庫不在本程式碼研究室的涵蓋範圍內，因此請使用應用程式內定義的肯定字串 List。</p>
          </div>

<h4 id="新增肯定字串"><a href="#新增肯定字串" class="headerlink" title="新增肯定字串"></a>新增肯定字串</h4><ol>
<li><p>在「Project」(專案) 視窗中，開啟 「App」(應用程式) &gt;「Res」(解析度) &gt;「Values」(設定值) &gt;「string.xml」。這個檔案目前只有一項資源，也就是應用程式的名稱。</p>
</li>
<li><p>在 <code>strings.xml</code> 中，新增以下肯定做為個別字串資源。將其命名為 <code>affirmation1</code>、<code>affirmation2</code> 等。</p>
</li>
</ol>
<p><strong>肯定文字</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">I am strong.</span><br><span class="line">I believe in myself.</span><br><span class="line">Each day is a new opportunity to grow and be a better version of myself.</span><br><span class="line">Every challenge in my life is an opportunity to learn from.</span><br><span class="line">I have so much to be grateful for.</span><br><span class="line">Good things are always coming into my life.</span><br><span class="line">New opportunities await me at every turn.</span><br><span class="line">I have the courage to follow my heart.</span><br><span class="line">Things will unfold at precisely the right time.</span><br><span class="line">I will be present in all the moments that this day brings.</span><br></pre></td></tr></table></figure>

<p>完成後，<code>strings.xml</code> 檔案應該會如下所示。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>Affirmations<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation1&quot;</span>&gt;</span>I am strong.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation2&quot;</span>&gt;</span>I believe in myself.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation3&quot;</span>&gt;</span>Each day is a new opportunity to grow and be a better version of myself.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation4&quot;</span>&gt;</span>Every challenge in my life is an opportunity to learn from.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation5&quot;</span>&gt;</span>I have so much to be grateful for.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation6&quot;</span>&gt;</span>Good things are always coming into my life.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation7&quot;</span>&gt;</span>New opportunities await me at every turn.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation8&quot;</span>&gt;</span>I have the courage to follow my heart.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation9&quot;</span>&gt;</span>Things will unfold at precisely the right time.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;affirmation10&quot;</span>&gt;</span>I will be present in all the moments that this day brings.<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>現在，您已新增了字串資源，可以在程式碼中將其參照為 <code>R.string.affirmation1</code> 或 <code>R.string.affirmation2</code>。</p>
<h4 id="建立新的套件"><a href="#建立新的套件" class="headerlink" title="建立新的套件"></a>建立新的套件</h4><p>以合理方式管理程式碼能幫助您和其他開發人員瞭解、維護及擴充程式碼。就像將文書工作整理到檔案和資料夾一樣，您可以將程式碼整理到檔案和套件中。</p>
<h5 id="什麼是套件？"><a href="#什麼是套件？" class="headerlink" title="什麼是套件？"></a>什麼是套件？</h5><ol>
<li>在 Android Studio 中的「Project」(專案)視窗 (Android) 中，在「App」(應用程式) &gt;「Java」下查看 Affirmations 應用程式的新專案檔案。其外觀應與下方的螢幕截圖類似，其中有三個套件，其中一個是您的程式碼 (<code>com.example.affirmations</code>)，另二個則是測試檔案 (<code>com.example.affirmations (androidTest)</code>) 和 (<code>com.example.affirmations (test)</code>)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/809a0d77a0759dc5_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="2">
<li>請注意，套件名稱包含數個字詞，並以半形句號分隔。</li>
</ol>
<p>使用套件的方法有兩種。</p>
<ul>
<li>為程式碼的不同部分建立不同的套件。例如，開發人員通常會將處理資料的類別，以及在不同套件中建立 UI 的類別分開。</li>
<li>在程式碼中使用其他套件的程式碼。如要使用其他套件的類別，您必須在建構系統的依附元件中定義這些類別。在程式碼中 <code>import</code> 套件也是一種標準的實作方法，因此您可使用短名稱 (例如 <code>TextView</code>)，而非使用完整名稱 (例如 <code>android.widget.TextView</code>)。例如，您已經為 <code>sqrt</code> (<code>import kotlin.math.sqrt</code>) 和 <code>View</code> (<code>import android.view.View</code>) 等類別使用 <code>import</code> 陳述式。</li>
</ul>
<p>在 Affirmations 應用程式中，除了匯入 Android 和 Kotlin 類別之外，您也需要將應用程式整理為幾個套件。即使您的應用程式類別數量不多，使用套件將類別依功能分組也是一種不錯的實作方法。</p>
<h5 id="為套件命名"><a href="#為套件命名" class="headerlink" title="為套件命名"></a>為套件命名</h5><p>可用任何名稱為套件命名，但不可重複使用。其他任何已發布的套件名稱都不能相同。由於套件的數量相當龐大，因此要隨機想出不重複名稱並不容易，所以程式設計師會利用慣例來更輕鬆建立和理解套件名稱。</p>
<ul>
<li>套件名稱通常從常見名稱排列到特定名稱，名稱中每個部分都會是<strong>小寫英文字母</strong>，並以<strong>半形句號</strong>分隔。重要事項：半型句號只是名稱的一部分。而這並不代表程式碼為階層結構，或對資料夾結構的強制要求！</li>
<li>因為網際網路網域在全球皆不重複，因此慣例會使用<strong>網域</strong> (通常是您或貴公司的網域) 做為<strong>名稱的第一個部分</strong>。</li>
<li>您可以選擇套件名稱，指明<strong>套件內含的Item</strong>，以及<strong>檔案之間彼此的關聯性</strong>。</li>
<li>對於像這樣的程式碼範例，經常會在 <code>com.example</code> 後方接上<strong>應用程式的名稱</strong>。</li>
</ul>
<p>以下列舉幾種預先定義的套件名稱及其內容範例：</p>
<ul>
<li><code>kotlin.math</code> - 數學函式與常數。</li>
<li><code>android.widget</code> - 檢視畫面，例如 <code>TextView</code>。</li>
</ul>
<div class="note no-icon success">
            <p><strong>注意：</strong> 雖然套件的名稱 (及其在 Android Studio 中的「Project」(專案) 視窗內其依階層排列的檔案夾) 會依階層顯示，但在可執行的程式碼中並<strong>沒有實際的階層</strong>。就像圖晝館編號系統雖然會對圖書進行分類和編制，但圖書仍在同一個書架上，您可以從中取出任何一本來。</p>
          </div>

<h5 id="建立套件"><a href="#建立套件" class="headerlink" title="建立套件"></a>建立套件</h5><ol>
<li>在 Android Studio 的「Project」窗格中，以滑鼠右鍵按一下「App」&gt;「Java」&gt;「com.example.affirmations」，然後依序選取「New」&gt;「Package」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/39f35a81a574b7ee_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="2">
<li><p>在「New Package」彈出式視窗中，查看建議的套件名稱前置字元。建議套件名稱的第一個部分為您按一下滑鼠右鍵時出現的套件名稱。套件名稱並不會建立套件階層，但名稱中重複使用的部分可用來表示內容之間的關係和編制！</p>
</li>
<li><p>在彈出式視窗中，將 <code>model</code> 附加到建議的套件名稱結尾處。開發人員通常會使用 <code>model</code> 做為建模 (或代表) data class 的套件名稱。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/3d392f8da53adc6f_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="4">
<li>按下「Enter」(輸入) 鍵，系統隨即會在「<code>com.example.affirmations</code>」(根層級) 套件下建立新的套件。這個新的套件將包含應用程式中定義的任何資料相關類別</li>
</ol>
<h4 id="建立-Affirmation-data-class"><a href="#建立-Affirmation-data-class" class="headerlink" title="建立 Affirmation data class"></a>建立 Affirmation data class</h4><p>在這項工作中，您會建立名為 <code>Affirmation</code> 的類別。<code>Affirmation</code> 的<strong>物件執行個體(object instance)<strong>代表一個</strong>肯定字詞</strong>，且包含使用該肯定字詞的<strong>字串資源 ID</strong>。</p>
<ol>
<li>在「com.example.affirmations.model」套件上按一下滑鼠右鍵，然後依序選取「New」&gt;「Kotlin File&#x2F;Class」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/a6bc9eb5c382cf9_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="2">
<li><p>在彈出式視窗中選取「Class」，然後輸入 <code>Affirmation</code> 做為類別名稱。這麼做會在 <code>model</code> 套件中建立名為 <code>Affirmation.kt</code> 的新檔案。</p>
</li>
<li><p>在類別定義前新增 <code>data</code> 關鍵字，即可將 <code>Affirmation</code> 設為 data class。這樣會發生錯誤，因為 data class 必須定義至少一個屬性。</p>
</li>
</ol>
<p><code>Affirmation.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Affirmation</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在建立 <code>Affirmation</code> 的<code>執行個體(instance)</code>時，您必須傳遞<strong>肯定字串的資源 ID</strong>。資源 ID 是 <code>Int(整數)</code>。</p>
<ol start="4">
<li>將 <code>val</code> <code>Int</code> 參數 <code>stringResourceId</code> 新增至 <code>Affirmation</code> 類別的建構函式。這麼做可以排除錯誤。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations.model</span><br><span class="line"></span><br><span class="line"><span class="keyword">data</span> <span class="keyword">class</span> <span class="title class_">Affirmation</span>(<span class="keyword">val</span> stringResourceId: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<h4 id="建立一個資料來源的類別"><a href="#建立一個資料來源的類別" class="headerlink" title="建立一個資料來源的類別"></a>建立一個資料來源的類別</h4><p>應用程式中顯示的資料可能來自不同來源 (例如您的應用程式專案中或來自需要連上網際網路才能下載資料的外部資源)。因此，資料不一定與您所需格式完全相同。應用程式的其餘部分不應與資料來自何處或是資料原本是以何種格式提供有所關聯。您可以並應該將此資料準備隱藏在為此應用程式預備資料的單獨 <code>Datasource</code> 類別中。</p>
<p>準備資料是另一個問題，因此請將 Datasource 類別放在獨立的「data」套件中。</p>
<ol>
<li>在 Android Studio 的「Project」視窗中，以滑鼠右鍵按一下「App」&gt;「Java」&gt;「com.example.affirmations」，然後依序選擇「New」&gt;「Package」。</li>
<li>輸入 <code>data</code> 做為套件名稱的最後一個部分。</li>
<li>在 <code>data</code> 套件上按一下滑鼠右鍵，然後選取「New Kotlin File&#x2F;Class」。</li>
<li>輸入 <code>Datasource</code> 做為類別名稱。</li>
<li>在 <code>Datasource</code> 類別中，建立名為 <code>loadAffirmations()</code> 的函式。</li>
</ol>
<p><code>loadAffirmations()</code> 函式必須傳回 <code>Affirmations</code> 的 List。方法是建立 List，並在每個資源字串中填入 <code>Affirmation</code> instance(執行個體)。</p>
<ol start="6">
<li>將 <code>List&lt;Affirmation&gt;</code> 宣告為 <code>loadAffirmations()</code> 方法的傳回類型。</li>
<li>在 <code>loadAffirmations()</code> 內文中，新增 <code>return</code> 陳述式。</li>
<li>在 <code>return</code> 關鍵字之後，呼叫 <code>listOf&lt;&gt;()</code> 以建立 List。</li>
<li>在角括號 <code>&lt;&gt;</code> 中，將 list Item的類型指定為 <code>Affirmation</code>。視需要匯入 <code>com.example.affirmations.model.Affirmation</code>。</li>
<li>在括號中建立一個 <code>Affirmation</code>，並傳入 <code>R.string.affirmation1</code> 做為資源 ID，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Affirmation(R.string.affirmation1)</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>請將剩餘的 <code>Affirmation</code> 物件新增至所有肯定字詞的 List 中 (以半形逗號分隔)。完成的程式碼應如下所示。</li>
</ol>
<p><code>Datasource.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations.<span class="keyword">data</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.R</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.model.Affirmation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Datasource</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">loadAffirmations</span><span class="params">()</span></span>: List&lt;Affirmation&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> listOf&lt;Affirmation&gt;(</span><br><span class="line">            Affirmation(R.string.affirmation1),</span><br><span class="line">            Affirmation(R.string.affirmation2),</span><br><span class="line">            Affirmation(R.string.affirmation3),</span><br><span class="line">            Affirmation(R.string.affirmation4),</span><br><span class="line">            Affirmation(R.string.affirmation5),</span><br><span class="line">            Affirmation(R.string.affirmation6),</span><br><span class="line">            Affirmation(R.string.affirmation7),</span><br><span class="line">            Affirmation(R.string.affirmation8),</span><br><span class="line">            Affirmation(R.string.affirmation9),</span><br><span class="line">            Affirmation(R.string.affirmation10)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="選用-在-TextView-中顯示肯定字詞-List-的大小"><a href="#選用-在-TextView-中顯示肯定字詞-List-的大小" class="headerlink" title="[選用] 在 TextView 中顯示肯定字詞 List 的大小"></a>[選用] 在 TextView 中顯示肯定字詞 List 的大小</h4><p>如要確認您可以建立肯定字詞 List，您可以呼叫 <code>loadAffirmations()</code>，來顯示「Empty Acitivity」應用程式範本隨附的 <code>TextView</code> 中肯定字詞回傳 List 大小。</p>
<ol>
<li>在 <code>layouts/activity_main.xml</code> 中，將範本隨附的 <code>TextView</code> 賦予 <code>textview</code> 的 <code>id</code>。</li>
<li>在現有程式碼後、<code>onCreate()</code> 方法的 <code>MainActivity</code> 中，取得 <code>textview</code> 的參照。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> textView: TextView = findViewById(R.id.textview)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然後新增程式碼來建立和顯示肯定字詞 List 的大小。建立 <code>Datasource</code>、呼叫 <code>loadAffirmations()</code>、取得回傳 List 的大小、將其轉換為字串並指派其做為 <code>textView</code> 的 <code>text</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">textView.text = Datasource().loadAffirmations().size.toString()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式。畫面應如下所示。</li>
</ol>
<img src="https://i.imgur.com/XrAIG0P.png" width="30%" height="30%">

<ol start="5">
<li>刪除您剛才在 <code>MainActivity</code> 中新增的程式碼。</li>
</ol>
<hr>
<h3 id="⭐️⭐️⭐️-在應用程式中新增-RecyclerView"><a href="#⭐️⭐️⭐️-在應用程式中新增-RecyclerView" class="headerlink" title="⭐️⭐️⭐️ 在應用程式中新增 RecyclerView"></a>⭐️⭐️⭐️ 在應用程式中新增 RecyclerView</h3><p>在這項工作中，您將設定 <code>RecyclerView</code> 以顯示 <code>Affirmations</code> List。</p>
<p>建立及使用 <code>RecyclerView</code> 涉及幾個部分。您可以把這幾個部分想成是勞力的分配。下圖提供總覽說明，方便您瞭解導入作業的每個部分。</p>
<ul>
<li><strong>item</strong> - 要顯示的 List 資料項目。代表應用程式中的一個 <code>Affirmation</code> 物件。</li>
<li><strong>Adapter</strong> - 擷取資料並準備顯示 <code>RecyclerView</code>。</li>
<li><strong>ViewHolders</strong> - 可供 <code>RecyclerView</code> 使用且重複使用以顯示肯定字詞的檢視區塊池。</li>
<li><strong>RecyclerView</strong> - 螢幕上的檢視區塊</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/4e9c18b463f00bf7_1920.png?hl=zh-tw" width="60%" height="60%">

<h4 id="在版面配置中新增-RecyclerView"><a href="#在版面配置中新增-RecyclerView" class="headerlink" title="在版面配置中新增 RecyclerView"></a>在版面配置中新增 RecyclerView</h4><p><code>Affirmations</code> 應用程式是由名為 <code>MainActivity</code> 的單一活動與名為 <code>activity_main.xml</code> 版面配置檔案所組成。首先，您需要將 <code>RecyclerView</code> 新增至 <code>MainActivity</code> 的版面配置中。</p>
<ol>
<li>開啟 <code>activity_main.xml</code> (「App」(應用程式) &gt;「Res」(解析度) &gt;「Layout」(版面配置) &gt;「activity_main.xml」)</li>
<li>如果您尚未使用這個程式，請切換為「Split」檢視畫面。</li>
<li>刪除 <code>TextView</code>。</li>
</ol>
<p>目前的版面配置使用 <code>ConstraintLayout</code>。<code>ConstraintLayout</code> 適用於在版面配置中放置多個子畫面且十分靈活。由於您的版面配置只有單一子畫面 <code>RecyclerView</code>，因此可以切換成名為 <code>FrameLayout</code> 的簡易 <code>ViewGroup</code>，以用來存放單一子畫面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/9e6f235be5fa31a8_1920.png?hl=zh-tw" width="60%" height="60%">

<ol start="4">
<li>在 XML 中，將 <code>ConstraintLayout</code> 替換成 <code>FrameLayout</code>。已完成的版面配置應如下所示。</li>
</ol>
<p>activity_main.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>切換至「Design」(設計) 檢視畫面。</li>
<li>在「Palette」中選取「Containers」，然後找出「RecyclerView」。</li>
<li>將「RecyclerView」拖曳至版面配置中。</li>
<li>如果畫面顯示「Add Project Dependency」彈出式視窗，請查看視窗內容，並按一下「OK」(如果沒有看到彈出式視窗，則不必採取任何行動)。</li>
<li>請等待 Android Studio 完成以將 <code>RecyclerView</code> 顯示在版面配置中。</li>
<li>如有需要，請將 <code>RecyclerView</code> 的 <code>layout_width</code> 和 <code>layout_height</code> 屬性變更為 <code>match_parent</code>，以讓 <code>RecyclerView</code> 填滿整個螢幕。</li>
<li>將 <code>RecyclerView</code> 的資源 ID 設為 <code>recycler_view</code>。</li>
</ol>
<p><code>RecyclerView</code> 支援以不同方式 (如線性List或格狀排列) 顯示項目(Item)。排列項目(Item)是由 <code>LayoutManager</code> 處理。Android 架構提供基本項目(Item)版面配置的版面配置管理工具。<code>Affirmations</code> 應用程式會將項目(Item)顯示為直向List，讓您可以使用 <code>LinearLayoutManager</code>。</p>
<ol start="12">
<li>切換回「Code」檢視畫面。在 XML 程式碼中，將 <code>RecyclerView</code> 元素內的 <code>LinearLayoutManager</code> 新增為 <code>RecyclerView</code> 的版面配置管理工具屬性，如下所示。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:layoutManager=&quot;LinearLayoutManager&quot;</span><br></pre></td></tr></table></figure>

<p>如直向 List要捲動超過螢幕範圍的項目(Item)，您必須新增直向捲軸。</p>
<ol start="13">
<li>在 <code>RecyclerView</code> 中，新增設為 <code>vertical</code> 的 <code>android:scrollbars</code> 屬性。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:scrollbars=&quot;vertical&quot;</span><br></pre></td></tr></table></figure>

<p>最終的 XML 版面配置應如下所示：</p>
<p><code>activity_main.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">androidx.recyclerview.widget.RecyclerView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/recycler_view&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:scrollbars</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layoutManager</span>=<span class="string">&quot;LinearLayoutManager&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="14">
<li>執行應用程式</li>
</ol>
<p>專案應可正常編譯並順利執行。不過，因為缺少程式碼的關鍵部分，因此只會在應用程式中顯示白色背景畫面。目前，您已將資料來源和 <code>RecyclerView</code> 加入版面配置，但 <code>RecyclerView</code> 沒有關於如何顯示 <code>Affirmation</code> 物件的資訊。</p>
<h4 id="實作-RecyclerView-的-Adapter"><a href="#實作-RecyclerView-的-Adapter" class="headerlink" title="實作 RecyclerView 的 Adapter"></a>實作 RecyclerView 的 Adapter</h4><p>您的應用程式需要一種能從 <code>Datasource</code> 取出資料並設定其格式的方法，讓每個 <code>Affirmation</code> 都可以在 <code>RecyclerView</code> 中顯示為一個<code>項目(Item)</code>。</p>
<p><code>Adapter</code> 是一種設計模式，能將資料調整為 <code>RecyclerView</code> 可以使用的內容。在這個情況下，您必須要有從 <code>loadAffirmations()</code> 回傳 List 中取得 <code>Affirmation</code> 例項的 <code>Adapter(適配器)</code>，並將其轉換成 List 項目(Item)檢視畫面，以便在 <code>RecyclerView</code> 中顯示。</p>
<p>執行應用程式時，<code>RecyclerView</code> 會使用 <code>Adapter(適配器)</code> 來判斷如何在螢幕上顯示資料。<code>RecyclerView</code> 要求適配器為 List 中的第一個資料項目(Item)建立新的 List 項目(Item)檢視畫面。</p>
<p>在顯示檢視畫面後，系統會要求 <code>Adapter(適配器)</code> 提供資料以繪製項目(Item)。這個流程會重複直到 <code>RecyclerView</code> 不需要再透過任何其他檢視畫面填滿螢幕為止。如果一次只有 3 個 List 項目(Item)顯示在螢幕上，則 <code>RecyclerView</code> 只會要求適配器(adapter)準備這 3 個 List 項目(Item)的檢視畫面 (而非所有 10 個 List 項目(Item)的檢視畫面)。</p>
<p>在這個步驟中，您必須建構<code>Adapter(適配器)</code> 來調整 <code>Affirmation</code> 物件例項，使其可在 <code>RecyclerView</code> 中顯示。</p>
<h4 id="建立適配器-Adapter"><a href="#建立適配器-Adapter" class="headerlink" title="建立適配器(Adapter)"></a>建立適配器(Adapter)</h4><p>適配器(adapter)包含許多部分，因此您將撰寫許多與到目前為止課程中所完成過的程式碼相比更複雜的程式碼。如果您一開始無法完全瞭解其中的詳細內容也沒關係。在您透過 <code>RecyclerView</code> 完成這整個應用程式後，您就能進一步瞭解所有部分如何搭配一同運作。您還可以重複使用本程式碼做為未來透過 <code>RecyclerView</code> 建立應用程式的基礎。</p>
<h5 id="建立項目-Item-版面配置"><a href="#建立項目-Item-版面配置" class="headerlink" title="建立項目(Item)版面配置"></a>建立項目(Item)版面配置</h5><p><code>RecyclerView</code> 中的每個 Item 都有各自的版面配置，您可以在獨立的版面配置檔案中定義這些版面配置。由於系統只會顯示字串，因此您可以使用 <code>TextView</code> 來設定 Item 版面配置。</p>
<ol>
<li>在「Res」(解析度) &gt;「Layout」(版面配置) 中，建立一個名為 <code>list_item.xml</code> 的全新空白檔案。</li>
<li>在「Code」(程式碼) 檢視畫面中開啟 <code>list_item.xml</code>。</li>
<li>新增包含 <code>id</code> <code>item_title</code> 的 <code>TextView</code>。</li>
<li>為 <code>layout_width</code> 和 <code>layout_height</code> 新增 <code>wrap_content</code>，如以下程式碼所示。</li>
</ol>
<p>請注意，您不需要在版面配置周圍使用 <code>ViewGroup</code>，因為這個 List 項目(Item)版面配置稍後會加載並新增以做為 <code>RecyclerView</code> 父項的子項。</p>
<p><code>list_item.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/item_title&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>您也可以依序點選「File」&gt;「New」&gt;「Layout Resource File」，然後將「File name」設為 <code>list_item.xml</code>，並將「Root element」設為 <code>TextView</code>。接著更新產生的程式碼，使其與上方的程式碼相符。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/dbb34ca516c804c6_1920.png?hl=zh-tw" width="60%" height="60%">

<h5 id="建立-ItemAdapter-類別"><a href="#建立-ItemAdapter-類別" class="headerlink" title="建立 ItemAdapter 類別"></a>建立 ItemAdapter 類別</h5><ol>
<li>在 Android Studio 的「Project」窗格中，以滑鼠右鍵依序點選「App」&gt;「Java」&gt;「com.example.affirmations」，然後依序選取「New」&gt;「Package」。</li>
<li>輸入 <code>adapter</code> 做為套件名稱的最後一個部分，</li>
<li>在 <code>adapter</code> 套件上按一下滑鼠右鍵，然後依序選取「New」&gt;「Kotlin File&#x2F;Class」。</li>
<li>輸入 <code>ItemAdapter</code> 做為類別名稱，完成後 <code>ItemAdapter.kt</code> 檔案隨即開啟。</li>
</ol>
<p>您必須將參數新增至 <code>ItemAdapter</code> 的建構函式，以便將肯定字詞 List 傳遞給<code>Adapter(適配器)</code>。</p>
<ol start="5">
<li>將參數新增至 <code>ItemAdapter</code> 建構函式，一個屬於 <code>List&lt;Affirmation&gt;</code> 類型，名為 <code>dataset</code> 的 <code>val</code>。視需要匯入 <code>Affirmation</code>。</li>
<li>由於 <code>dataset</code> 只會用於本類別，因此請將其設為 <code>private</code>。</li>
</ol>
<p><code>ItemAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.affirmations.model.Affirmation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ItemAdapter</code> 需要有關如何解決<strong>字串資源</strong>的資訊。系統會將上述資訊以及其他與應用程式的相關資訊儲存在 <code>Context</code> 物件執行個體中，而您可以將這些執行個體傳遞至 <code>ItemAdapter</code> 執行個體中。</p>
<ol start="7">
<li>將參數新增至 <code>ItemAdapter</code> 建構函式，一個屬於 <code>Context</code> 類型，名為 <code>context</code> 的 <code>val</code>。將這個值做為建構函式中的<strong>第一個參數</strong>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context, <span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="建立-ViewHolder"><a href="#建立-ViewHolder" class="headerlink" title="建立 ViewHolder"></a>建立 ViewHolder</h5><p><code>RecyclerView</code> 不會直接與項目(Item)檢視畫面互動，而是與 <code>ViewHolders</code> 互動。<code>ViewHolder</code> 代表 <code>RecyclerView</code> 中的單一 List項目(Item)檢視畫面，而且在可能時可以重複使用。<code>ViewHolder</code> 執行個體會保留 List 項目(Item)版面配置中個別檢視畫面的參照 (因此稱其為<code>「View Holder」(檢視畫面保留項)</code>)。如此一來，在使用新資料更新 List項目(Item)檢視中畫面時就能更加輕鬆。檢視畫面保留項也會新增 <code>RecyclerView</code> 用來有效在螢幕上移動檢視畫面的資訊。</p>
<ol>
<li>在 <code>ItemAdapter</code> 類別中，在關閉 <code>ItemAdapter</code> 的大括號前，先建立 <code>ItemViewHolder</code> 類別。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context, <span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在另一個類別中定義類別的動作稱為建立<strong>巢狀類別</strong>。</li>
<li>由於 <code>ItemViewHolder</code> 僅由 <code>ItemAdapter</code> 使用，因此在 <code>ItemAdapter</code> 中建立元素會顯示這種關係。這並非強制要求，但可協助其他開發人員瞭解您程式的結構。</li>
</ul>
<ol start="2">
<li>將 <code>View</code> 類型的 <code>private val view</code> 做為參數新增至 <code>ItemViewHolder</code> 類別建構函式。</li>
<li>將 <code>ItemViewHolder</code> 設為 <code>RecyclerView.ViewHolder</code> 的子類別，並將 <code>view</code> 參數傳遞給父類別建構函式。</li>
<li>在 <code>ItemViewHolder</code> 內部定義 <code>TextView</code> 類型的 <code>val</code> 屬性 <code>textView</code>。請使用您在 <code>list_item xml</code> 中定義的 ID <code>item_title</code> 來指派其檢視畫面。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(<span class="keyword">private</span> <span class="keyword">val</span> context: Context, <span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> textView: TextView = view.findViewById(R.id.item_title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="覆寫適配器-adapter-方法"><a href="#覆寫適配器-adapter-方法" class="headerlink" title="覆寫適配器(adapter)方法"></a>覆寫適配器(adapter)方法</h5><ol>
<li>新增程式碼以從抽象類別 <code>RecyclerView.Adapter</code> 擴充 <code>ItemAdapter</code>。使用角括號指定 <code>ItemAdapter.ItemViewHolder</code> 做為檢視畫面保留項類型。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;</span><br><span class="line">) : RecyclerView.Adapter&lt;ItemAdapter.ItemViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> textView: TextView = view.findViewById(R.id.item_title)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您將會看到錯誤訊息，因為您必須從 <code>RecyclerView.Adapter</code> 實作一些摘要方法。</p>
<ol start="2">
<li>將游標移至 <code>ItemAdapter</code>，然後按下 <code>Control + I</code>。然後會顯示需要導入的方法 List：<code>getItemCount()</code>、<code>onCreateViewHolder()</code> 和 <code>onBindViewHolder()</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-recyclerview-scrollable-list/img/7a8a383a8633094b_1920.png?hl=zh-tw" width="60%" height="60%">

<ol start="3">
<li>按住 <code>Shift</code> 並點選，即可全選三個函式，然後按一下「OK」。</li>
</ol>
<p>這會為三個方法建立附正確參數的虛設常式，如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ItemViewHolder &#123;</span><br><span class="line">    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ItemViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>您應該不會再次看到錯誤。接下來，您必須導入這些方法，確保其能在您的應用程式上發揮正常的功能。</p>
<h5 id="導入-getItemCount"><a href="#導入-getItemCount" class="headerlink" title="導入 getItemCount()"></a>導入 getItemCount()</h5><p><code>getItemCount()</code> 方法必須傳回您的<strong>資料集大小</strong>。應用程式資料位於您傳遞至 <code>ItemAdapter</code> 建構函式的 <code>dataset</code> 屬性中，您可以透過 <code>size</code> 取得其大小。</p>
<ol>
<li>將 <code>getItemCount()</code> 替換成以下內容：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = dataset.size</span><br></pre></td></tr></table></figure>

<p>以下是更簡介的寫法：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> dataset.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="導入-onCreateViewHolder"><a href="#導入-onCreateViewHolder" class="headerlink" title="導入 onCreateViewHolder()"></a>導入 onCreateViewHolder()</h5><p>版面配置管理員會呼叫 <code>onCreateViewHolder()</code> 方法，為 <code>RecyclerView</code> 建立新的檢視畫面保留項 (在沒有可以重複使用的現有檢視畫面保留項的情況下)。請注意，檢視畫面保留項代表單一 List 項目(Item)檢視畫面。</p>
<p><code>onCreateViewHolder()</code> 方法會採用<strong>兩個參數</strong>並傳回新的 <code>ViewHolder</code>。</p>
<ul>
<li><code>parent</code> 參數是將 List 中的新項目(Item)的 <code>View</code> 做為子項目(Item)附加的 <code>ViewGroup</code>。父項為 <code>RecyclerView</code>。</li>
<li><code>viewType</code> 參數在同一個 <code>RecyclerView</code> 包含多個項目(Item)檢視區塊類型時會變得十分重要。如果在 <code>RecyclerView</code> 內顯示不同的 List 項目(Item)版面配置，則會有不同的項目(Item)檢視畫面類型。您只能使用相同的項目(Item)檢視畫面類型回收檢視畫面。在這個範例中，只有一個 List 項目(Item)版面配置和一個項目(Item)檢視畫面類型，因此不需要擔心這個參數。</li>
</ul>
<ol>
<li>在 <code>onCreateViewHolder()</code> 方法中，從提供的結構定義 (<code>parent</code> 的 <code>context</code>) 中取得 <code>LayoutInflater(動態載入頁面)</code> 的例項。版面配置加載程式知道如何將 XML 版面配置加載到檢視畫面物件階層中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 對於一個沒有被載入或者想要動態載入的頁面，要使用inflate的方法來載入Layout</span></span><br><span class="line"><span class="keyword">val</span> adapterLayout = LayoutInflater.from(parent.context)</span><br></pre></td></tr></table></figure>

<div class="note no-icon primary">
            <p><strong>注意：</strong> 對於一個沒有被載入或者想要動態載入的<code>頁面(Layout)</code>，要使用<code>LayoutInflater.inflate()</code>來載入。</p><p>使用<code>inflate</code>的方法來載入<code>Layout</code>(以下3種code都是同樣的功能)：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">LayoutInflater inflater = getLayoutInflater()</span><br><span class="line">LayoutInflater localinflater = (LayoutInflater)context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</span><br><span class="line">LayoutInflater inflater = LayoutInflater.from(context)</span><br></pre></td></tr></table></figure>
          </div>

<ol start="2">
<li>建立 <code>LayoutInflater</code> 物件執行個體後，請加上一個半型句號 <code>.</code>，然後呼叫另一個方法，以加載實際的 List 項目(Item)檢視畫面。傳入 XML 版面配置資源 ID <code>R.layout.list_item</code> 和 <code>parent</code> 檢視區塊群組。第三個布林值引數是 <code>attachToRoot</code>。這個引數必須是 <code>false</code>，因為 <code>RecyclerView</code> 在適當時會為您新增此項目(Item)到檢視區塊階層。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> adapterLayout = LayoutInflater.from(parent.context)</span><br><span class="line">       .inflate(R.layout.list_item, parent, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<div class="note no-icon primary">
            <p><strong>LayoutInflater 的 method：</strong>  </p><ul><li><code>inflate(int resource, ViewGroup root)</code><ul><li>resource：Layout 的 ID，例如：<code>R.layout.example</code></li><li>root：該Layout的外部再嵌套一層parent Layout，如果不需要就直接填<code>null</code></li></ul></li><li><code>inflate(int resource, ViewGroup root, boolean attachToRoot)</code><ul><li>若root為<code>null</code>，attachToRoot設置任何值都沒有意義</li><li>若root不為<code>null</code>，attachToRoot設為<code>true</code>，則會給加載的佈局文件的指定一個parent Layout</li><li>若root不為<code>null</code>，attachToRoot設為<code>false</code>，則會將佈局文件最外層的所有Layout屬性進行設置，當該view被添加到parent view當中時，這些Layout屬性會自動生效</li></ul></li></ul>
          </div>

<p>現在 <code>adapterLayout</code> 持有 List 項目(Item)檢視畫面的參照 (稍後可以從中找到子項檢視畫面，例如 <code>TextView</code>)。</p>
<ol start="3">
<li>在 <code>onCreateViewHolder()</code> 中，傳回根檢視畫面為 <code>adapterLayout</code> 的新 <code>ItemViewHolder</code> 執行個體。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> ItemViewHolder(adapterLayout)</span><br></pre></td></tr></table></figure>

<p>以下是到目前為止的 <code>onCreateViewHolder()</code> 程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ItemViewHolder &#123;</span><br><span class="line">    <span class="comment">// 建立一個新view</span></span><br><span class="line">    <span class="keyword">val</span> adapterLayout = LayoutInflater.from(parent.context)</span><br><span class="line">        .inflate(R.layout.list_item, parent, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ItemViewHolder(adapterLayout)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="導入-onBindViewHolder"><a href="#導入-onBindViewHolder" class="headerlink" title="導入 onBindViewHolder()"></a>導入 onBindViewHolder()</h5><p>最後需要覆寫的方法為 <code>onBindViewHolder()</code>。<code>版面配置管理員(layout manager)</code>會呼叫此方法，以取代 List 項目(Item)檢視畫面的內容。</p>
<p><code>onBindViewHolder()</code> 方法有<strong>兩個參數</strong>，一個是先前透過 <code>onCreateViewHolder()</code> 方法建立的 <code>ItemViewHolder</code>，另一個則是代表 List 中目前項目(Item) <code>position</code> 的 <code>int</code>。使用這個方法時，您可以依據位置找到資料集中的 <code>Affirmation</code> 物件。</p>
<ol>
<li>在 <code>onBindViewHolder()</code> 中，建立 <code>val item</code> 並在 <code>dataset</code> 中的指定 <code>position</code> 取得項目(Item)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> item = dataset[position]</span><br></pre></td></tr></table></figure>

<p>最後，您必須更新檢視畫面保留項參照的所有資料檢視，以反映這個項目(Item)的正確資料。在這個範例中，只有一個檢視畫面：<code>ItemViewHolder</code> 中的 <code>TextView</code>。設定 <code>TextView</code> 的文字以顯示這個項目(Item)的 <code>Affirmation</code> 字串。</p>
<ol start="2">
<li>使用 <code>Affirmation</code> 物件執行個體時，您可以呼叫 <code>item.stringResourceId</code> 來尋找對應的字串資源 ID。然而此數值為整數，因此您必須找出實際字串值的對應值。</li>
</ol>
<p>在 Android 架構中，您可以使用字串資源 ID 呼叫 <code>getString()</code>，以傳回其相關聯的字串值。<code>getString()</code> 是 <code>Resources</code> 類別中的方法，您可以透過 <code>context</code> 取得 <code>Resources</code> 類別執行個體。</p>
<p>也就是說，您可以呼叫 <code>context.resources.getString()</code> 並傳入字串資源 ID。產生的字串可以設為 <code>holder ItemViewHolder</code> 中 <code>textView</code> 的 <code>text</code>。簡而言之，這一行程式碼會更新檢視畫面保留項，以顯示肯定字串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">holder.textView.text = context.resources.getString(item.stringResourceId)</span><br></pre></td></tr></table></figure>

<p>已完成的 <code>onBindViewHolder()</code> 方法應如下所示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ItemViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> item = dataset[position]</span><br><span class="line">    holder.textView.text =  context.resources.getString(item.stringResourceId)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是已完成的適配器(adapter)程式碼。</p>
<p><code>ItemAdapter.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations.adapter</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.content.Context</span><br><span class="line"><span class="keyword">import</span> android.view.LayoutInflater</span><br><span class="line"><span class="keyword">import</span> android.view.View</span><br><span class="line"><span class="keyword">import</span> android.view.ViewGroup</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.R</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.model.Affirmation</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Adapter for the [RecyclerView] in [MainActivity]. Displays [Affirmation] data object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ItemAdapter</span>(</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> context: Context,</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> dataset: List&lt;Affirmation&gt;</span><br><span class="line">) : RecyclerView.Adapter&lt;ItemAdapter.ItemViewHolder&gt;() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Provide a reference to the views for each data item</span></span><br><span class="line">    <span class="comment">// Complex data items may need more than one view per item, and</span></span><br><span class="line">    <span class="comment">// you provide access to all the views for a data item in a view holder.</span></span><br><span class="line">    <span class="comment">// Each data item is just an Affirmation object.</span></span><br><span class="line">    <span class="comment">// ViewHolder為每個Item的檢視畫面</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">ItemViewHolder</span>(<span class="keyword">private</span> <span class="keyword">val</span> view: View) : RecyclerView.ViewHolder(view) &#123;</span><br><span class="line">        <span class="keyword">val</span> textView: TextView = view.findViewById(R.id.item_title)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立新views（由layout manager呼叫)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreateViewHolder</span><span class="params">(parent: <span class="type">ViewGroup</span>, viewType: <span class="type">Int</span>)</span></span>: ItemViewHolder &#123;</span><br><span class="line">        <span class="comment">// 建立一個新view</span></span><br><span class="line">        <span class="comment">// 對於一個沒有被載入或者想要動態載入的頁面，要使用inflate的方法來載入Layout</span></span><br><span class="line">        <span class="keyword">val</span> adapterLayout = LayoutInflater.from(parent.context)</span><br><span class="line">            .inflate(R.layout.list_item, parent, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ItemViewHolder(adapterLayout)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 替換view的內容（由layout manager呼叫）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 更新檢視畫面(ItemViewHolder)的所有資料</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onBindViewHolder</span><span class="params">(holder: <span class="type">ItemViewHolder</span>, position: <span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> item = dataset[position]</span><br><span class="line">        holder.textView.text = context.resources.getString(item.stringResourceId)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 傳回dataset的大小（由layout manager呼叫）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">getItemCount</span><span class="params">()</span></span> = dataset.size</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在您已經導入 <code>ItemAdapter</code>，所以需要告知 <code>RecyclerView</code> 使用這個適配器。</p>
<h4 id="修改-MainActivity-以使用-RecyclerView"><a href="#修改-MainActivity-以使用-RecyclerView" class="headerlink" title="修改 MainActivity 以使用 RecyclerView"></a>修改 MainActivity 以使用 RecyclerView</h4><p>如要完成上述步驟，您必須使用 <code>Datasource</code> 和 <code>ItemAdapter</code> 類別建立和顯示 <code>RecyclerView</code> 中的項目(Item)。請在 <code>MainActivity</code> 中進行這項操作。</p>
<ol>
<li>開啟 <code>MainActivity.kt</code>。</li>
<li>呼叫 <code>setContentView(R.layout.activity_main)</code> 後插入下列步驟中說明的新程式碼。</li>
<li>建立 <code>Datasource</code> 的執行個體，並呼叫該執行個體上的 <code>loadAffirmations()</code> 方法。將傳回的肯定字詞 List 儲存在名為 <code>myDataset</code> 的 <code>val</code> 中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> myDataset = Datasource().loadAffirmations() </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>建立名為 <code>recyclerView</code> 的變數，並使用 <code>findViewById()</code> 在版面配置中尋找對 <code>RecyclerView</code> 的參照。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recycler_view)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如果要告知 <code>recyclerView</code> 使用您建立的 <code>ItemAdapter</code> 類別，則請建立新的 <code>ItemAdapter</code> 執行個體。<code>ItemAdapter</code> 要求使用兩個參數：<strong>此活動的結構定義 (this)</strong> 以及 <strong>myDataset 中的肯定字詞</strong>。</li>
<li>將 <code>ItemAdapter</code> 物件指派給 <code>recyclerView</code> 的 <code>adapter</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView.adapter = ItemAdapter(<span class="keyword">this</span>, myDataset)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>由於活動版面配置中的 <code>RecyclerView</code> 版面配置大小是固定的，因此您可以將 <code>RecyclerView</code> 的 <code>setHasFixedSize</code> 參數設為 <code>true</code>。這項設定僅用於改善效能。如果您知道內容變更不會改變 <code>RecyclerView</code> 的版面配置大小，則請使用這項設定。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">recyclerView.setHasFixedSize(<span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>完成後，<code>MainActivity</code> 的程式碼應該會與下列程式碼類似。</li>
</ol>
<p><code>MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.affirmations</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> androidx.appcompat.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> androidx.recyclerview.widget.RecyclerView</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.adapter.ItemAdapter</span><br><span class="line"><span class="keyword">import</span> com.example.affirmations.<span class="keyword">data</span>.Datasource</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化data</span></span><br><span class="line">        <span class="keyword">val</span> myDataset = Datasource().loadAffirmations()</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 建立名為 recyclerView 的變數，並使用 findViewById() 在layout中尋找對 RecyclerView 的參照</span></span><br><span class="line">        <span class="keyword">val</span> recyclerView = findViewById&lt;RecyclerView&gt;(R.id.recycler_view)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 將 ItemAdapter 指派給 recyclerView 的 adapter</span></span><br><span class="line">        <span class="comment">// ItemAdapter 要求使用兩個參數：此活動的結構定義 (this) 以及 myDataset 中的肯定字詞</span></span><br><span class="line">        recyclerView.adapter = ItemAdapter(<span class="keyword">this</span>, myDataset)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果您知道會發生變化，請使用此設定來提高效能</span></span><br><span class="line">        <span class="comment">// 在內容中不要更改 RecyclerView 的layout大小</span></span><br><span class="line">        recyclerView.setHasFixedSize(<span class="literal">true</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>執行您的應用程式。您應該會看到在螢幕上顯示的肯定字串 List。</li>
</ol>
<img src="https://i.imgur.com/uaeNGzD.png" width="30%" height="30%">

<p>這個應用程式包含所有顯示您肯定字詞的必要部分，但還不可用於正式發布階段。UI 還有些可加強的地方。在接下來的程式碼研究室中，您將改善程式碼、瞭解如何在應用程式中新增圖片以及簡化 UI。</p>
<hr>
<h3 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h3><ul>
<li><code>RecyclerView</code> 小工具有助於顯示資料 List。</li>
<li><code>RecyclerView</code> 會使用<code>適配器模式(adapter pattern)</code>來調整及顯示資料。</li>
<li><code>ViewHolder</code> 會建立並保留 <code>RecyclerView</code> 的檢視畫面。</li>
<li><code>RecyclerView</code> 內建 <code>LayoutManagers</code>。<code>RecyclerView</code> 會委派項目(Item)版面配置 <code>LayoutManagers</code>。</li>
</ul>
<p>如何導入<code>適配器(adapter)</code>：</p>
<ul>
<li>為適配器建立新類別，例如 <code>ItemAdapter</code>。</li>
<li>建立代表單一 List 項目(Item)檢視畫面的自訂 <code>ViewHolder</code> 類別。自 <code>RecyclerView.ViewHolder</code> 類別擴充而來。</li>
<li>修改 <code>ItemAdapter</code> 類別，使其從 <code>RecyclerView</code> 擴充。<code>Adapter</code> 類別搭配自訂 <code>ViewHolder</code> 類別。</li>
<li>在<code>適配器(adapter)</code>中導入下列方法：  <ul>
<li><code>getItemsCount()</code></li>
<li><code>onCreateViewHolder()</code></li>
<li><code>onBindViewHolder()</code></li>
</ul>
</li>
</ul>
<hr>
<h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><p><a href="https://spicyboyd.blogspot.com/2018/03/app-layoutinflater.html">如何使用 LayoutInflater 動態載入頁面</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>List</tag>
        <tag>Adapter</tag>
        <tag>RecyclerView</tag>
        <tag>Data Class</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(16)-在Kotlin中使用List</title>
    <url>/2023/09/20/Android%E7%AD%86%E8%A8%98-16-%E5%9C%A8Kotlin%E4%B8%AD%E4%BD%BF%E7%94%A8List/</url>
    <content><![CDATA[<blockquote>
<p>了解如何在在 Kotlin 中創建 List 並循環使用該 List。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何在 Kotlin 中建立及使用 <code>List</code></li>
<li><code>List</code> 和 <code>MutableList</code> 的差異，以及兩者的使用時機</li>
<li>如何迭代 <code>List</code> 中的所有項目，並對每個項目執行動作。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="List-簡介"><a href="#List-簡介" class="headerlink" title="List 簡介"></a>List 簡介</h4><p>在先前的程式碼研究室中，您已瞭解 Kotlin 的基本資料類型，例如 <code>Int</code>、<code>Double</code>、<code>Boolean</code> 和 <code>String</code>。這些資料類型可讓您在變數中儲存特定類型的值。但如要儲存多個值，該怎麼辦？這時我們就需要 List 資料類型。</p>
<p>清單是具有特定順序的項目的集合。Kotlin 中有兩種類型的清單：</p>
<ul>
<li>唯讀列表：<code>List</code> 建立後即無法修改。</li>
<li>可變動列表：<code>MutableList</code> 在建立後可以修改，也就是說，您可以新增、移除或更新其元素。</li>
</ul>
<p>使用 <code>List</code> 或 <code>MutableList</code> 時，您必須指定它能夠包含的元素類型。例如，<code>List&lt;Int&gt;</code> 包含整數清單，<code>List&lt;String&gt;</code> 則包含字串清單。如果您在程式中定義 <code>Car</code> 類別，則可擁有 <code>List&lt;Car&gt;</code>，其中包含 <code>Car</code> 物件例項的清單。</p>
<h5 id="建立-List"><a href="#建立-List" class="headerlink" title="建立 List"></a>建立 List</h5><ol>
<li><p>開啟 <a href="https://developer.android.com/training/kotlinplayground">Kotlin Playground</a>，並刪除其中提供的現有程式碼。</p>
</li>
<li><p>新增空白的 <code>main()</code> 函式。下列所有程式碼步驟都會位於這個 <code>main()</code> 函式中。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>main()</code> 中，建立類型為 <code>List&lt;Int&gt;</code> 的 <code>numbers</code> 變數，因為其中包含整數的唯讀清單。使用 Kotlin 標準程式庫函式 <code>listOf()</code> 建立新的 <code>List</code>，然後將清單元素做為以半形逗號隔開的引數傳入。<code>listOf(1, 2, 3, 4, 5, 6)</code> 會傳回介於 1 到 6 之間的整數唯讀清單。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers: List&lt;<span class="built_in">Int</span>&gt; = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如果根據指派運算子 (<code>=</code>) 右側的值可推斷 (或推論) 變數類型，則可忽略變數的資料類型。因此，您可以將這行程式碼縮短為以下內容：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 <code>println()</code> 列印 <code>numbers</code> 列表。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;List: <span class="variable">$numbers</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>請記住，在字串中加入 <code>$</code> 表示後面的內容是一個<span class="label primary">運算式</span>，系統會評估該運算式並將其加入該字串 (請參閱字串範本)。這行程式碼也可寫成 <code>println(&quot;List: &quot; + numbers)</code>.</li>
</ul>
<ol start="6">
<li>使用 <code>numbers.size</code> 屬性擷取 List 大小，並將其列印出來。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Size: <span class="subst">$&#123;numbers.size&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行程式。輸出結果會列出清單的所有元素和清單的大小。請注意，括號 <code>[]</code> 代表這是 <code>List</code>。括號內為 <code>numbers</code> 的元素，以半形逗號分隔。另請注意，這些元素的順序與其建立順序相同。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List: [1, 2, 3, 4, 5, 6]</span><br><span class="line">Size: 6</span><br></pre></td></tr></table></figure>

<h5 id="存取-List-元素"><a href="#存取-List-元素" class="headerlink" title="存取 List 元素"></a>存取 List 元素</h5><p><code>List</code> 的特定功能是，能夠依 <code>元素(Element)</code> 的 <code>索引(Index)</code> 存取 <code>List</code> 的每個 <code>元素(Element)</code>，<code>索引(Index)</code> 是代表位置的整數。下圖是我們建立的 numbers List圖表，其中顯示了每個元素及其對應的索引。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-lists/img/cb6924554804458d_1920.png?hl=zh-tw" width="70%" height="70%">

<p>索引實際上是與第一個元素的偏移值。例如，當您表示 <code>list[2]</code> 時，您並非要求清單的第二個元素，而是要求與第一個元素偏移 2 個位置的元素。因此，<code>list[0]</code> 是第一個元素 (零偏移)，<code>list[1]</code> 是第二個元素 (偏移值 1)，<code>list[2]</code> 是第三個元素 (偏移值 2)，依此類推。</p>
<ol>
<li>列印 <code>List</code> 中索引為 <code>0</code> 的第一個元素。您可以呼叫 <code>get()</code> 函式，使得所需索引為 <code>numbers.get(0)</code>，也可以使用簡式語法搭配索引前後的方括號做為 <code>numbers[0]</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;First element: <span class="subst">$&#123;numbers.get(<span class="number">0</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;First element: <span class="subst">$&#123;numbers[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接下來，列印 <code>List</code> 中索引為 <code>1</code> 的第二個元素。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Second element: <span class="subst">$&#123;numbers.get(<span class="number">1</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Second element: <span class="subst">$&#123;numbers[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>List</code> 的有效索引值 (「索引」) 介於 0 到最後一個索引之間，也就是 <code>List</code> 大小減 1。也就是說，您的 <code>numbers</code> <code>List</code> 中的索引介於 0 至 5 之間。</p>
<ol start="3">
<li>列印 <code>List</code> 的最後一個元素，使用 <code>numbers.size - 1</code> 計算其索引，應為 5。存取第 5 個索引處的元素時，系統會傳回 6 做為輸出內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Last index: <span class="subst">$&#123;numbers.size - <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Last element: <span class="subst">$&#123;numbers[numbers.size - <span class="number">1</span>]&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>Kotlin 也支援在 <code>List</code> 上執行 <code>first()</code> 和 <code>last()</code> 作業。請嘗試呼叫 <code>numbers.first()</code> 和 <code>numbers.last()</code>，並查看輸出內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;First: <span class="subst">$&#123;numbers.first()&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Last: <span class="subst">$&#123;numbers.last()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>numbers.first()</code> 會傳回 List 的第一個元素，而 <code>numbers.last()</code> 會傳回 List 的最後一個元素。</li>
</ul>
<ol start="5">
<li>另一個實用的 <code>List</code> 作業就是 <code>contains()</code> 方法，可確認 <code>List</code> 中是否有指定的元素。舉例來說，如果您有一份公司員工姓名清單，則可以使用 <code>contains()</code> 方法確認 <code>List</code> 中是否包含指定的姓名。</li>
</ol>
<p>在 <code>numbers</code> List 中，呼叫 <code>contains()</code> 方法，並提供 List 中的一個整數。<code>numbers.contains(4)</code> 會傳回 <code>true</code> 值。接著，呼叫 <code>contains()</code> 方法，並提供一個不存在於 List 中的整數。<code>numbers.contains(7)</code> 會傳回 <code>false</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Contains 4? <span class="subst">$&#123;numbers.contains(<span class="number">4</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Contains 7? <span class="subst">$&#123;numbers.contains(<span class="number">7</span>)&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>已完成的程式碼應如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> numbers = listOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">    println(<span class="string">&quot;List: <span class="variable">$numbers</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Size: <span class="subst">$&#123;numbers.size&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Access elements of the list</span></span><br><span class="line">    println(<span class="string">&quot;First element: <span class="subst">$&#123;numbers[<span class="number">0</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Second element: <span class="subst">$&#123;numbers[<span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Last index: <span class="subst">$&#123;numbers.size - <span class="number">1</span>&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Last element: <span class="subst">$&#123;numbers[numbers.size - <span class="number">1</span>]&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;First: <span class="subst">$&#123;numbers.first()&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Last: <span class="subst">$&#123;numbers.last()&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use the contains() method</span></span><br><span class="line">    println(<span class="string">&quot;Contains 4? <span class="subst">$&#123;numbers.contains(<span class="number">4</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Contains 7? <span class="subst">$&#123;numbers.contains(<span class="number">7</span>)&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>執行程式碼。以下是輸出結果。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List: [1, 2, 3, 4, 5, 6]</span><br><span class="line">Size: 6</span><br><span class="line">First element: 1</span><br><span class="line">Second element: 2</span><br><span class="line">Last index: 5</span><br><span class="line">Last element: 6</span><br><span class="line">First: 1</span><br><span class="line">Last: 6</span><br><span class="line">Contains 4? true</span><br><span class="line">Contains 7? false</span><br></pre></td></tr></table></figure>

<h4 id="清單為唯讀狀態"><a href="#清單為唯讀狀態" class="headerlink" title="清單為唯讀狀態"></a>清單為唯讀狀態</h4><ol>
<li>刪除 <code>Kotlin Playground</code> 中的程式碼，並替換成以下程式碼。<code>colors</code> List 已初始化為一份包含 3 個顏色的清單，以 <code>Strings</code> 表示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> colors = listOf(<span class="string">&quot;green&quot;</span>, <span class="string">&quot;orange&quot;</span>, <span class="string">&quot;blue&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>請注意，您無法在唯讀 <code>List</code> 中新增或變更元素。看看如果嘗試將項目加入 List，或嘗試將 List 中的元素設定為新的值，藉此修改 List 元素，會發生什麼情況。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">colors.add(<span class="string">&quot;purple&quot;</span>)</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">&quot;yellow&quot;</span></span><br></pre></td></tr></table></figure>

<p>執行程式碼，系統會顯示幾條錯誤訊息。基本上，這些錯誤表示 <code>List</code> 的 <code>add()</code> 方法不存在，且您無法變更元素的值。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-lists/img/dd21aaccdf3528c6_1920.png?hl=zh-tw" width="70%" height="70%"></p>
<ol start="4">
<li>移除不正確的程式碼。</li>
</ol>
<p>您已經瞭解到，唯讀 List 無法變更。不過，有些 List 作業並不會變更 List，只會傳回新的 List。其中兩個是 <code>reversed()</code> 和 <code>sorted()</code>。<code>reversed()</code> 函式會傳回新的 List，其中元素會依<span class="label primary">相反順序</span>排序；<code>sorted()</code> 會傳回新的 List，元素會以<span class="label primary">遞增順序</span>排序。</p>
<ol>
<li><p>新增程式碼可反轉 <code>colors</code> List。列印輸出結果。這是一份新 List，其中包含了以相反順序排序的 colors 元素。</p>
</li>
<li><p>加入第二行程式碼可列印原始 <code>List</code>，如此您便能看到原始 List 並未變更。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Reversed list: <span class="subst">$&#123;colors.reversed()&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;List: <span class="variable">$colors</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Reversed list: [blue, orange, green]</span><br><span class="line">List: [green, orange, blue]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>新增程式碼，使用 <code>sorted()</code> 函式傳回 List 的已排序版本。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Sorted list: <span class="subst">$&#123;colors.sorted()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sorted list: [blue, green, orange]</span><br></pre></td></tr></table></figure>
<ul>
<li>輸出內容是一份新的顏色 List，該 List 依<span class="label primary">字母順序</span>排列。</li>
</ul>
<ol start="4">
<li>也可以嘗試在未排序的<span class="label primary">數字清單</span>上使用 <code>sorted()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> oddNumbers = listOf(<span class="number">5</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">1</span>)</span><br><span class="line">println(<span class="string">&quot;List: <span class="variable">$oddNumbers</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Sorted list: <span class="subst">$&#123;oddNumbers.sorted()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List: [5, 3, 7, 1]</span><br><span class="line">Sorted list: [1, 3, 5, 7]</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="可變動-List-簡介"><a href="#可變動-List-簡介" class="headerlink" title="可變動 List 簡介"></a>可變動 List 簡介</h4><p>可變動 List 在建立後可以修改。您可以新增、移除或變更項目。可變動 List 提供唯讀 List 的全部功能。可變動 List 的類型為 <code>MutableList</code>，您可以透過呼叫 <code>mutableListOf()</code> 來建立。</p>
<h5 id="建立-MutableList"><a href="#建立-MutableList" class="headerlink" title="建立 MutableList"></a>建立 MutableList</h5><ol>
<li>刪除 <code>main()</code> 中的現有程式碼。</li>
<li>在 <code>main()</code> 函式中，建立一個空白的可變動 List，並指派給名為 <code>entrees</code> 的 <code>val</code> 變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> entrees = mutableListOf()</span><br></pre></td></tr></table></figure>

<p>如果嘗試執行程式碼，就會發生下列錯誤。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not enough information to infer type variable T</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong>當建立 <b>MutableList</b> 或 <b>List</b> 時，Kotlin 會嘗試<strong>從傳遞的引數中推論清單中包含的元素類型</strong>。舉例來說，當您編寫 <b>listOf(“noodles”)</b> 時，Kotlin 會推論您要建立 <b>String</b> 清單。初始化不含元素的<strong>空白清單</strong>時，Kotlin <strong>無法推論元素的類型</strong>，因此您必須明確指出類型。為此，只要在 <b>mutableListOf</b> 或 <b>listOf</b> 後的角括號中加上類型即可。(在說明文件中，這可能會顯示為 <code>&lt;T&gt;</code>，其中 <b>T</b> 代表<strong>類型參數</strong>)。</p>
          </div>

<ol start="3">
<li>修正變數宣告，指定您要建立 <code>String</code> 類型的可變動 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> entrees = mutableListOf&lt;String&gt;()</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>另一個修正錯誤的方法，就是預先指定變數的資料類型。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> entrees: MutableList&lt;String&gt; = mutableListOf()</span><br></pre></td></tr></table></figure>
<ul>
<li><code>val</code> 可用於可變動 List，因為 <code>entrees</code> 變數包含對 List 的參照；即使 List 內容有所變更，參照也不會改變。</li>
</ul>
<ol start="5">
<li>列印 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entrees: []</span><br></pre></td></tr></table></figure>
<ul>
<li>空白清單的輸出內容會顯示 <code>[]</code>。</li>
</ul>
<h5 id="在清單中新增元素"><a href="#在清單中新增元素" class="headerlink" title="在清單中新增元素"></a>在清單中新增元素</h5><p>新增、移除及更新元素時，可變動清單會變得非常有趣。</p>
<ol>
<li><p>使用 <code>entrees.add(&quot;noodles&quot;)</code>. 將 “noodles” 新增至 List。如果成功將元素新增至 List，<code>add()</code> 函式會傳回 <code>true</code>，否則傳回 <code>false</code>。</p>
</li>
<li><p>列印 List，確認確實已新增 “noodles”。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Add noodles: <span class="subst">$&#123;entrees.add(<span class="string">&quot;noodles&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>輸出內容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add noodles: true</span><br><span class="line">Entrees: [noodles]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>將另一個項目 “spaghetti” 新增至 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Add spaghetti: <span class="subst">$&#123;entrees.add(<span class="string">&quot;spaghetti&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>產生的 entrees List 現在包含兩個項目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add spaghetti: true</span><br><span class="line">Entrees: [noodles, spaghetti]</span><br></pre></td></tr></table></figure>

<p>與其使用 <code>add()</code> 逐一新增元素，您可以使用 <code>addAll()</code> 一次新增多個元素並傳入 List。</p>
<ol start="4">
<li>建立 <code>moreItems</code> List。您不需要變更這個 List，因此請將其設定為 <code>val</code>，不可變動。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> moreItems = listOf(<span class="string">&quot;ravioli&quot;</span>, <span class="string">&quot;lasagna&quot;</span>, <span class="string">&quot;fettuccine&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>使用 <code>addAll()</code>，將新 List 上的所有項目新增至 <code>entrees</code>。列印產生的 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Add list: <span class="subst">$&#123;entrees.addAll(moreItems)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>輸出內容顯示新增 List 成功。entrees List 現在共有 5 個項目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Add list: true</span><br><span class="line">Entrees: [noodles, spaghetti, ravioli, lasagna, fettuccine]</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>現在，請嘗試在這份 List 中新增一個數字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">entrees.add(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>作業失敗，發生錯誤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The integer literal does not conform to the expected type String</span><br></pre></td></tr></table></figure>

<p>這是因為 <code>entrees</code> List 需要 <code>String</code> 類型的元素，而您嘗試新增的是 <code>Int</code>。請記住，僅在 List 中新增正確資料類型的元素。否則，您將收到編譯錯誤。</p>
<ol start="7">
<li>請移除不正確的程式碼行，確保編譯程式碼。</li>
</ol>
<h5 id="移除-List-中的元素"><a href="#移除-List-中的元素" class="headerlink" title="移除 List 中的元素"></a>移除 List 中的元素</h5><ol>
<li>呼叫 <code>remove()</code> 即可將 “spaghetti” 從 List 中移除。再次列印 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Remove spaghetti: <span class="subst">$&#123;entrees.remove(<span class="string">&quot;spaghetti&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>移除 “spaghetti” 會傳回 <code>true</code>，因為該元素存在於 List 中，可以成功移除。List 現在還剩 4 個項目。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove spaghetti: true</span><br><span class="line">Entrees: [noodles, ravioli, lasagna, fettuccine]</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>如果您嘗試移除 List 中沒有的項目，會發生什麼事？請嘗試使用 <code>entrees.remove(&quot;rice&quot;)</code> 從 List 中移除 “rice”。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Remove item that doesn&#x27;t exist: <span class="subst">$&#123;entrees.remove(<span class="string">&quot;rice&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>remove()</code> 方法會傳回 <code>false</code>，因為元素不存在，所以無法移除。List 保持不變，還是只有 4 個項目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove item that doesn&#x27;t exist: false</span><br><span class="line">Entrees: [noodles, ravioli, lasagna, fettuccine]</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>您還可以指定要移除的元素索引。使用 <code>removeAt()</code> 移除索引 <code>0</code> 處的項目。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Remove first element: <span class="subst">$&#123;entrees.removeAt(<span class="number">0</span>)&#125;</span>&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><code>removeAt(0)</code> 的傳回值是從 List 中移除的第一個元素 (“noodles”)。<code>entrees</code> List 現在還剩 3 個項目。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remove first element: noodles</span><br><span class="line">Entrees: [ravioli, lasagna, fettuccine]</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>如要清除整個 List，請呼叫 <code>clear()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">entrees.clear()</span><br><span class="line">println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>輸出內容現在會顯示空白 List。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entrees: []</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>透過 Kotlin，您可使用 <code>isEmpty()</code> 函式，檢查 List 是否為空白。請嘗試列印輸出 <code>entrees.isEmpty()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Empty? <span class="subst">$&#123;entrees.isEmpty()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>輸出結果應為 <code>true</code>，因為 List 目前為空白，沒有元素。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Empty? true</span><br></pre></td></tr></table></figure>

<p>以下是以上可變動 List 撰寫的所有程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> entrees = mutableListOf&lt;String&gt;()</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add individual items using add()</span></span><br><span class="line">    println(<span class="string">&quot;Add noodles: <span class="subst">$&#123;entrees.add(<span class="string">&quot;noodles&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Add spaghetti: <span class="subst">$&#123;entrees.add(<span class="string">&quot;spaghetti&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a list of items using addAll()</span></span><br><span class="line">    <span class="keyword">val</span> moreItems = listOf(<span class="string">&quot;ravioli&quot;</span>, <span class="string">&quot;lasagna&quot;</span>, <span class="string">&quot;fettuccine&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Add list: <span class="subst">$&#123;entrees.addAll(moreItems)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove an item using remove()</span></span><br><span class="line">    println(<span class="string">&quot;Remove spaghetti: <span class="subst">$&#123;entrees.remove(<span class="string">&quot;spaghetti&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Remove item that doesn&#x27;t exist: <span class="subst">$&#123;entrees.remove(<span class="string">&quot;rice&quot;</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove an item using removeAt() with an index</span></span><br><span class="line">    println(<span class="string">&quot;Remove first element: <span class="subst">$&#123;entrees.removeAt(<span class="number">0</span>)&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Clear out the list</span></span><br><span class="line">    entrees.clear()</span><br><span class="line">    println(<span class="string">&quot;Entrees: <span class="variable">$entrees</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check if the list is empty</span></span><br><span class="line">    println(<span class="string">&quot;Empty? <span class="subst">$&#123;entrees.isEmpty()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="迴圈-List"><a href="#迴圈-List" class="headerlink" title="迴圈 List"></a>迴圈 List</h4><p>如要對 List 中的每個項目執行作業，您可以透過 List 執行迴圈 (也就是迭代整個 List)。迴圈功能可與 <code>Lists</code> 和 <code>MutableLists</code> 搭配使用。</p>
<h5 id="While-迴圈"><a href="#While-迴圈" class="headerlink" title="While 迴圈"></a>While 迴圈</h5><p>其中一種迴圈類型為 <code>while</code> 迴圈。在 Kotlin 中，<code>while</code> 迴圈以 <code>while</code> 關鍵字開頭。迴圈中包含一個程式碼區塊 (位於大括號中)，只要括號中的運算式為 <code>true</code> 即可不斷執行。為避免程式碼永久執行 (又稱「無限迴圈」)，程式碼區塊必須包含用來變更運算式值的邏輯，這樣一來，運算式最終將產生 <code>false</code>，系統將停止執行迴圈。屆時，系統可結束 <code>while</code> 迴圈，並繼續執行該迴圈之後的程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (expression) &#123;</span><br><span class="line">    <span class="comment">// While the expression is true, execute this code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> while 迴圈不必包含 List (<a href="https://play.kotlinlang.org/byExample/02_control_flow/02_Loops">這裡</a>的範例)，但適合 List 使用。</p>
          </div>

<p>使用 <code>while</code> 迴圈疊代整個 List。建立變數，以在 List 中追蹤您目前查看的 index。這個 index 變數會保持每次增加 1，直到達到 List 的最後一個索引，然後您便可結束迴圈。</p>
<ol>
<li><p>刪除 Kotlin Playground 中現有的程式碼，得到一個空白的 <code>main()</code> 函式。</p>
</li>
<li><p>假設您正在籌辦派對。建立一份 List，其中每個元素都代表每個家庭所回覆的賓客人數。第一個家庭表示自家會有 2 人參加。第二個家庭表示自家會有 4 人參加，依此類推。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> guestsPerFamily = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>確認賓客總數。撰寫迴圈找到答案。為賓客總數建立 <code>var</code>，並將其初始化為 <code>0</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> totalGuests = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>初始化 <code>index</code> 變數的 <code>var</code>，如前文所述。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>撰寫 <code>while</code> 迴圈，以迭代整個清單。條件是只要 <code>index</code> 值小於 List 的大小，系統就會一直執行程式碼區塊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (index &lt; guestsPerFamily.size) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在迴圈中，請在目前的 <code>index</code> 處取得 List 元素，並將該元素加入賓客變數總數。請注意，<code>totalGuests += guestsPerFamily[index]</code> 和 <code>totalGuests = totalGuests + guestsPerFamily[index]</code> 相同。</li>
</ol>
<p>迴圈的最後一行會使用 <code>index++</code> 將 <code>index</code> 變數遞增 1，這樣下一個迴圈迭代會查看 List 中的下一個家庭。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (index &lt; guestsPerFamily.size) &#123;</span><br><span class="line">    totalGuests += guestsPerFamily[index]</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> guestsPerFamily = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">    <span class="keyword">var</span> totalGuests = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (index &lt; guestsPerFamily.size) &#123;</span><br><span class="line">        println(<span class="string">&quot;index: <span class="variable">$index</span>&quot;</span>)</span><br><span class="line">        totalGuests += guestsPerFamily[index]</span><br><span class="line">        println(<span class="string">&quot;totalGuests: <span class="variable">$totalGuests</span>&quot;</span>)</span><br><span class="line">        index ++</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">index: 0</span><br><span class="line">totalGuests: 2</span><br><span class="line">index: 1</span><br><span class="line">totalGuests: 6</span><br><span class="line">index: 2</span><br><span class="line">totalGuests: 7</span><br><span class="line">index: 3</span><br><span class="line">totalGuests: 10</span><br></pre></td></tr></table></figure>
<ul>
<li>根據以上結果，可以看出 <code>index</code> 加 1 時，<code>totalGuest</code> 也隨之增加。</li>
</ul>
<ol start="7">
<li>您可以在 <code>while</code> 迴圈之後列印輸出結果。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> ... &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Total Guest Count: <span class="variable">$totalGuests</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>執行程式，輸出內容如下。只需手動把 List 中的數字加起來，就能驗證正確答案。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Total Guest Count: 10</span><br></pre></td></tr></table></figure>

<p>以下是完整的程式碼片段：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> guestsPerFamily = listOf(<span class="number">2</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">var</span> totalGuests = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> index = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (index &lt; guestsPerFamily.size) &#123;</span><br><span class="line">    totalGuests += guestsPerFamily[index]</span><br><span class="line">    index++</span><br><span class="line">&#125;</span><br><span class="line">println(<span class="string">&quot;Total Guest Count: <span class="variable">$totalGuests</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="For-迴圈"><a href="#For-迴圈" class="headerlink" title="For 迴圈"></a>For 迴圈</h5><p><code>for</code> 迴圈是另一種類型的迴圈。這可讓迴圈 List 作業更加輕鬆。這會以 Kotlin 中的 <code>for</code> 關鍵字開頭，在大括號中放置程式碼區塊。用來執行程式碼區塊的條件在括號中表示。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (number <span class="keyword">in</span> numberList) &#123;</span><br><span class="line">   <span class="comment">// For each element in the list, execute this code block</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在這個範例中，變數 <code>number</code> 設為等於 <code>numberList</code> 的第一個元素，並執行程式碼區塊。接著，<code>number</code> 變數會自動更新為 <code>numberList</code> 的下一個元素，然後再次執行程式碼區塊。對清單的每個元素重複此操作，直到觸及 <code>numberList</code> 的結尾為止。</p>
<ol>
<li>刪除 Kotlin Playground 中的現有程式碼，並替換成以下程式碼：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> names = listOf(<span class="string">&quot;Jessica&quot;</span>, <span class="string">&quot;Henry&quot;</span>, <span class="string">&quot;Alicia&quot;</span>, <span class="string">&quot;Jose&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增 <code>for</code> 迴圈，以輸出 <code>names</code> List 中的所有項目。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> names) &#123;</span><br><span class="line">    println(name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這比直接撰寫為 <code>while</code> 迴圈要簡單許多！</p>
<ol start="3">
<li>輸出內容如下：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jessica</span><br><span class="line">Henry</span><br><span class="line">Alicia</span><br><span class="line">Jose</span><br></pre></td></tr></table></figure>

<p>List 的一個常見作業就是對每個 List 元素嘗試執行某個操作。</p>
<ol start="4">
<li>修改迴圈，使其列印輸出人員姓名的字元數。提示：您可以使用 <code>String</code> 的 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/length.html">length</a> 屬性找出 <code>String</code> 中的字元數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> names = listOf(<span class="string">&quot;Jessica&quot;</span>, <span class="string">&quot;Henry&quot;</span>, <span class="string">&quot;Alicia&quot;</span>, <span class="string">&quot;Jose&quot;</span>)</span><br><span class="line"><span class="keyword">for</span> (name <span class="keyword">in</span> names) &#123;</span><br><span class="line">    println(<span class="string">&quot;<span class="variable">$name</span> - Number of characters: <span class="subst">$&#123;name.length&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸出內容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Jessica - Number of characters: 7</span><br><span class="line">Henry - Number of characters: 5</span><br><span class="line">Alicia - Number of characters: 6</span><br><span class="line">Jose - Number of characters: 4</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> 以下是您可以使用 <b>for</b> 迴圈執行的其他一些變體，包括將它們用於具有特定步驟的範圍 (而不是每次遞增 1)。<br><code>for (item in list) print(item) // Iterate over items in a list<br>for (item in 'b'..'g') print(item) // Range of characters in an alphabet<br>for (item in 1..5) print(item) // Range of numbers<br>for (item in 5 downTo 1) print(item) // Going backward<br>for (item in 3..6 step 2) print(item) // Prints: 35</code><br>您可以在本程式碼研究室結尾的說明文件中找到更多資訊。</p>
          </div>

<hr>
<h4 id="靈活運用"><a href="#靈活運用" class="headerlink" title="靈活運用"></a>靈活運用</h4><p>在當地餐廳訂餐時，客戶通常會一次訂購多種商品。List 最適合用來儲存訂單相關資訊。此外，您也可運用類別和繼承的知識，來建立更完善、可擴充的 Kotlin 程式，而不是將所有程式碼放在 main() 函式中。</p>
<p>在接下來的一系列工作中，請建立一個 Kotlin 程式，用於訂購不同的食物組合。</p>
<p>首先請查看最後一個程式碼的範例輸出內容。腦力激盪一下，想想您需要建立哪些類別，以協助妥善規劃所有資料？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Order #1</span><br><span class="line">Noodles: $10</span><br><span class="line">Total: $10</span><br><span class="line"></span><br><span class="line">Order #2</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Chef&#x27;s Choice: $5</span><br><span class="line">Total: $15</span><br></pre></td></tr></table></figure>
<p>從輸出內容中，您可發現：</p>
<ul>
<li>有一份訂單列表</li>
<li>每筆訂單都有一個編號</li>
<li>每筆訂單都可包含 <code>Noodles(麵條)</code> 和 <code>Vegetables(蔬菜)</code> 等商品的列表</li>
<li>每個商品都有價格</li>
<li>每筆訂單都有 <code>Total(總價)</code>，也就是個別商品價格的總和</li>
</ul>
<p>您可以建立類別來代表 <code>Order</code>，也可以建立類別來代表每項食品，例如 <code>Noodles</code> 或 <code>Vegetables</code>。您可能還會發現 <code>Noodles</code> 和 <code>Vegetables</code> 有相似之處，因為這兩者均是食品，而且都有價格。您可以建立 <code>Item</code> 類別，其中包含 <code>Noodle</code> 類別和 <code>Vegetable</code> 類別都可以繼承的共用屬性。這樣一來，您就不用複製 <code>Noodle</code> 類別和 <code>Vegetable</code> 類別中的邏輯。</p>
<ol>
<li>畫面上會顯示下列範例程式碼。專業開發人員經常需要閱讀其他人的程式碼，例如，當他們加入新專案，或投入其他人建立的功能時。閱讀及理解程式碼是一項重要技能。</li>
</ol>
<p>請花點時間檢查該程式碼，瞭解具體情況。複製這段程式碼並貼到 Kotlin Playground 中執行。在貼上這段新程式碼之前，請務必刪除 Kotlin Playground 中的所有現有程式碼。觀察輸出內容，看看它是否有助於您進一步理解程式碼。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Item</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> price: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Noodles</span> : <span class="type">Item</span>(<span class="string">&quot;Noodles&quot;</span>, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span> : <span class="type">Item</span>(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> noodles = Noodles()</span><br><span class="line">    <span class="keyword">val</span> vegetables = Vegetables()</span><br><span class="line">    println(noodles)</span><br><span class="line">    println(vegetables)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>您應該會看到類似以下的輸出內容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Noodles@5451c3a8</span><br><span class="line">Vegetables@76ed5528</span><br></pre></td></tr></table></figure>

<p>以下是程式碼更為詳細的說明。首先是一個名為 <code>Item</code> 的類別，其中建構函式會使用 2 個參數：用於商品的 <code>name</code> (做為字串) 和 <code>price</code> (做為整數)。這兩項屬性在傳遞後皆維持不變，因此標示為 <code>val</code>。由於 <code>Item</code> 是父項類別，子類別由它擴充而來，因此該類別會標上 <code>open</code> 關鍵字。</p>
<p><code>Noodles</code> 類別建構函式不含任何參數，但會從 <code>Item</code> 擴充，並透過傳遞 “Noodles” (做為名稱) 與價格 10 呼叫父類別建構函式。<code>Vegetables</code> 類別相似，但會以 “Vegetables” 與價格 5 呼叫父類別建構函式。</p>
<p><code>main()</code> 函式會初始化 <code>Noodles</code> 和 <code>Vegetables</code> 類別的新物件例項，並將其列印至輸出內容。</p>
<h5 id="覆寫-toString-方法"><a href="#覆寫-toString-方法" class="headerlink" title="覆寫 toString() 方法"></a>覆寫 toString() 方法</h5><p>當您將物件例項列印至輸出內容時，系統會呼叫物件的 <code>toString()</code> 方法。在 Kotlin 中，每個類別都會自動繼承 <code>toString()</code> 方法。這個方法的預設實作只會傳回物件類型，其中包含例項的記憶體位址。建議您覆寫 <code>toString()</code>，以便傳回比 <code>Noodles@5451c3a8</code> 和 <code>Vegetables@76ed5528</code> 更有意義且容易使用的結果。</p>
<ol>
<li>在 <code>Noodles</code> 類別中，覆寫 <code>toString()</code> 方法，然後使其傳回 <code>name</code>。請注意，<code>Noodles</code> 會繼承父項類別 <code>Item</code> 的 <code>name</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Noodles</span> : <span class="type">Item</span>(<span class="string">&quot;Noodles&quot;</span>, <span class="number">10</span>) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">return</span> name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>針對 <code>Vegetables</code> 類別重複相同步驟。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>() : Item(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">       <span class="keyword">return</span> name</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行程式碼。現在，輸出內容看起來更有用：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Noodles</span><br><span class="line">Vegetables</span><br></pre></td></tr></table></figure>

<h5 id="透過訂單自訂蔬菜"><a href="#透過訂單自訂蔬菜" class="headerlink" title="透過訂單自訂蔬菜"></a>透過訂單自訂蔬菜</h5><p>為使麵條更有吸引力，您可以在訂單中包含不同的蔬菜。</p>
<ol>
<li>在 <code>main()</code> 函式中，不要初始化不含輸入引數的 <code>Vegetables</code> 例項，而是傳遞客戶想要的特定蔬菜。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> vegetables = Vegetables(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Sprouts&quot;</span>, <span class="string">&quot;Onion&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果現在嘗試編譯程式碼，系統會顯示以下錯誤訊息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Too many arguments for public constructor Vegetables() defined in Vegetables</span><br></pre></td></tr></table></figure>

<p>您正在將 3 個字串引數傳遞至 <code>Vegetables</code> 類別建構函式，因此需要修改 <code>Vegetables</code> 類別。</p>
<ol start="2">
<li>更新 <code>Vegetables</code> 類別標頭，以擷取 3 個字串參數，如以下程式碼所示：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>(<span class="keyword">val</span> topping1: String,</span><br><span class="line">                 <span class="keyword">val</span> topping2: String,</span><br><span class="line">                 <span class="keyword">val</span> topping3: String) : Item (<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>現在，您的程式碼會重新編譯。不過，只有客戶想每次都訂購三種蔬菜時，這個解決方法才適用。如果客戶想訂購一種或五種蔬菜，就沒有辦法了。</p>
</li>
<li><p>您可以在 <code>Vegetables</code> 類別的建構函式中接受一份蔬菜清單 (長度不限) 以修正此問題，而不用使用每個蔬菜的屬性。<code>List</code> 只能包含 <code>Strings</code>，因此輸入參數的類型為 <code>List&lt;String&gt;</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>(<span class="keyword">val</span> toppings: List&lt;String&gt;) : Item(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br></pre></td></tr></table></figure>

<p>這不是最完美的解決方法，因為在 <code>main()</code> 中，您需要先變更程式碼來建立配料清單，然後才將其傳遞至 <code>Vegetables</code> 建構函式。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Vegetables(listOf(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Sprouts&quot;</span>, <span class="string">&quot;Onion&quot;</span>))</span><br></pre></td></tr></table></figure>

<p>還有更好的解決方法。</p>
<ol start="5">
<li>在 Kotlin 中，<code>vararg</code> 修改程式可讓您將類型相同、數量可變的引數傳遞給函式或建構函式。這樣一來，您就可以提供不同的蔬菜做為單個字串，而非 List。</li>
</ol>
<p>變更 <code>Vegetables</code> 的類別定義，以採用類型為 <code>String</code> 的 <code>vararg</code> <code>toppings</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>(<span class="keyword">vararg</span> <span class="keyword">val</span> toppings: String) : Item(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> 您只能將一個參數標示為 <code>vararg</code>，且通常是 List 中的最後一個參數。</p>
          </div>

<ol start="6">
<li><code>main()</code> 函式中的程式碼現在正常運作。透過傳遞任何數量的配料字串，即可建立 <code>Vegetables</code> 例項。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">val</span> vegetables = Vegetables(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Sprouts&quot;</span>, <span class="string">&quot;Onion&quot;</span>)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>現在，請修改 <code>Vegetables</code> 類別的 <code>toString()</code> 方法，使其傳回同樣提及以下配料格式的 <code>String</code>：<code>Vegetables Cabbage, Sprouts, Onion</code>。</li>
</ol>
<p>以商品名稱 (<code>Vegetables</code>) 開頭。接著使用 <code>joinToString()</code> 方法將所有配料加入單一字串。使用 <code>+</code> 運算子將兩個部分加起來，之間留有空格。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>(<span class="keyword">vararg</span> <span class="keyword">val</span> toppings: String) : Item(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + toppings.joinToString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>執行程式，輸出內容應為：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Noodles</span><br><span class="line">Vegetables Cabbage, Sprouts, Onion</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> 如要指定半形逗號以外的分隔符，請將所需的分隔符字串做為引數傳遞至 <code>joinToString()</code> 方法。範例：<code>joinToString(&quot; &quot;)</code> 以空格分隔每個商品。</p>
          </div>

<ol start="9">
<li>編寫程式時，您需要考量所有可能的輸入內容。如果 <code>Vegetables</code> 建構函式中沒有任何輸入引數，請使用較容易的方式處理 <code>toString()</code> 方法。</li>
</ol>
<p>由於客戶想訂購蔬菜，但並未具體說明要哪些蔬菜，其中一種解決方法就是為他們提供預設由廚師選擇的蔬菜。</p>
<p>如未傳遞任何配料，請更新 <code>toString()</code> 方法以傳回 <code>Vegetables Chef&#39;s Choice</code>。使用您先前學過的 <code>isEmpty()</code> 方法。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">    <span class="keyword">if</span> (toppings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$name</span> Chef&#x27;s Choice&quot;</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + toppings.joinToString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>更新 <code>main()</code> 函數，以測試在兩種情況下建立 <code>Vegetables</code> 例項的可能性：不含任何建構函式引數以及含有多個引數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> noodles = Noodles()</span><br><span class="line">    <span class="keyword">val</span> vegetables = Vegetables(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Sprouts&quot;</span>, <span class="string">&quot;Onion&quot;</span>)</span><br><span class="line">    <span class="keyword">val</span> vegetables2 = Vegetables()</span><br><span class="line">    println(noodles)</span><br><span class="line">    println(vegetables)</span><br><span class="line">    println(vegetables2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>確認輸出內容符合預期。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Noodles</span><br><span class="line">Vegetables Cabbage, Sprouts, Onion</span><br><span class="line">Vegetables Chef&#x27;s Choice</span><br></pre></td></tr></table></figure>

<h5 id="建立一個訂單"><a href="#建立一個訂單" class="headerlink" title="建立一個訂單"></a>建立一個訂單</h5><p>現在您擁有了一些食物，可以建立訂單了。在程式的 <code>Order</code> 類別中封裝訂單的邏輯。</p>
<ol>
<li>想想看 <code>Order</code> 類別可以使用哪些屬性和方法。如果有所幫助，請再次參考以下的最終程式碼輸出內容範例。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Order #1</span><br><span class="line">Noodles: $10</span><br><span class="line">Total: $10</span><br><span class="line"></span><br><span class="line">Order #2</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Chef&#x27;s Choice: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #3</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Carrots, Beans, Celery: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #4</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Cabbage, Onion: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #5</span><br><span class="line">Noodles: $10</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Spinach: $5</span><br><span class="line">Total: $25</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>您可能已經想到以下幾點：</li>
</ol>
<p>訂單類別<br>屬性：訂單號碼、商品清單<br>方法：新增商品、新增多個商品、列印訂單摘要 (含價格)</p>
<ol start="3">
<li><p>首先關注屬性，每個屬性的資料類型應該是什麼？它們對於類別應為公開還是私人？它們應該做為引數傳遞還是在類別中定義？</p>
</li>
<li><p>您可以透過多種方式來實作，以下是一個解決方法。建立含有整數 <code>orderNumber</code> 建構函式參數的 <code>class</code> <code>Order</code>。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(<span class="keyword">val</span> orderNumber: <span class="built_in">Int</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>您可能無法預先知道訂單中的所有商品，因此無需將商品 List 作為引數傳遞。這可以宣告為頂層類別變數，並初始化為空白的 <code>MutableList</code>，用於儲存 <code>Item</code> 類型的元素。標示變數 <code>private</code>，讓系統只允許這個類別直接修改商品 List。這種做法可以防止此類別以外的程式碼意外修改清單。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(<span class="keyword">val</span> orderNumber: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> itemList = mutableListOf&lt;Item&gt;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>現在，請將方法加入類別定義中。您可以隨意為每種方法挑選合理的名稱，目前每個方法內的實作邏輯則可以留空。此外，還要決定需要哪些函式引數和傳回值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(<span class="keyword">val</span> orderNumber: <span class="built_in">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> itemList = mutableListOf&lt;Item&gt;()</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(newItem: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(newItems: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><code>addItem()</code> 方法似乎最直接，因此先實作該函式。該函式會擷取新的 <code>Item</code>，而該方法應將其新增至 <code>itemList</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(newItem: <span class="type">Item</span>)</span></span> &#123;</span><br><span class="line">    itemList.add(newItem)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>接下來請實作 <code>addAll()</code> 方法。該方法會擷取唯讀商品 List。將所有商品加入內部商品 List。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(newItems: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span> &#123;</span><br><span class="line">    itemList.addAll(newItems)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>接著，請實作 <code>print()</code> 方法，藉此將所有商品及其價格的摘要以及訂單的總價輸出至輸出內容。<br>請先列印輸出訂單號碼。接下來，使用迴圈迭代訂單清單中的所有商品。請輸出每個商品及其對應價格。同時，保留到目前為止的總價，並在疊代整個清單時繼續增加總價。最後，輸出總價。嘗試自行實作這個邏輯。如需相關協助，請查看下列解決方法。</li>
</ol>
<p>建議您加入貨幣符號，讓輸出內容更容易閱讀。以下是實作該解決方法的一個方式。此程式碼使用 <code>$</code> 貨幣符號，但也可以視需要換算成當地幣別符號。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">    println(<span class="string">&quot;Order #<span class="subst">$&#123;orderNumber&#125;</span>&quot;</span>)</span><br><span class="line">    <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (item <span class="keyword">in</span> itemList) &#123;</span><br><span class="line">        println(<span class="string">&quot;<span class="subst">$&#123;item&#125;</span>: $<span class="subst">$&#123;item.price&#125;</span>&quot;</span>)</span><br><span class="line">        total += item.price</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">&quot;Total: $<span class="subst">$&#123;total&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>針對 <code>itemList</code> 中的每個 <code>item</code>，請輸出 <code>item</code> (這將觸發要在 <code>item</code> 上呼叫的 <code>toString()</code>)，然後是商品的 <code>price</code>。同樣，在執行迴圈之前，請將 <code>total</code> 整數變數初始化為 <code>0</code>。接著，在 <code>total</code> 中加入目前商品的價格，繼續增加總價。</p>
<h5 id="建立多個訂單"><a href="#建立多個訂單" class="headerlink" title="建立多個訂單"></a>建立多個訂單</h5><ol>
<li><p>在 <code>main()</code> 函式中建立 <code>Order</code> 例項，藉此測試程式碼。請先刪除 <code>main()</code> 函式中現有的內容。</p>
</li>
<li><p>您可以使用這些訂單範例，也可以自行建立訂單。嘗試使用訂單中各種不同的商品組合，確保測試了程式碼中的所有程式碼路徑。例如，在 <code>Order</code> 類別中測試 <code>addItem()</code> 和 <code>addAll()</code> 方法，建立不含引數與含有引數的 <code>Vegetables</code> 例項，依此類推。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> order1 = Order(<span class="number">1</span>)</span><br><span class="line">    order1.addItem(Noodles())</span><br><span class="line">    order1.print()</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> order2 = Order(<span class="number">2</span>)</span><br><span class="line">    order2.addItem(Noodles())</span><br><span class="line">    order2.addItem(Vegetables())</span><br><span class="line">    order2.print()</span><br><span class="line"></span><br><span class="line">    println()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> order3 = Order(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> items = listOf(Noodles(), Vegetables(<span class="string">&quot;Carrots&quot;</span>, <span class="string">&quot;Beans&quot;</span>, <span class="string">&quot;Celery&quot;</span>))</span><br><span class="line">    order3.addAll(items)</span><br><span class="line">    order3.print()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上述程式碼的輸出內容應如下所示。確認總價已正確相加。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Order #1</span><br><span class="line">Noodles: $10</span><br><span class="line">Total: $10</span><br><span class="line"></span><br><span class="line">Order #2</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Chef&#x27;s Choice: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #3</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Carrots, Beans, Celery: $5</span><br><span class="line">Total: $15</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="改善程式碼"><a href="#改善程式碼" class="headerlink" title="改善程式碼"></a>改善程式碼</h4><h5 id="保留訂單清單"><a href="#保留訂單清單" class="headerlink" title="保留訂單清單"></a>保留訂單清單</h5><p>如果您建構能實際在麵店中使用的程式，請務必追蹤所有客戶訂單的清單。</p>
<ol>
<li><p>建立 List 以儲存所有訂單。它是唯讀 List 還是可變動 List 嗎？</p>
</li>
<li><p>將這段程式碼新增至 <code>main()</code> 函式。首先，請將 List 初始化為空白。接著，每次建立訂單時，將訂單加入 List 中。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ordersList = mutableListOf&lt;Order&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> order1 = Order(<span class="number">1</span>)</span><br><span class="line">    order1.addItem(Noodles())</span><br><span class="line">    ordersList.add(order1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> order2 = Order(<span class="number">2</span>)</span><br><span class="line">    order2.addItem(Noodles())</span><br><span class="line">    order2.addItem(Vegetables())</span><br><span class="line">    ordersList.add(order2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> order3 = Order(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> items = listOf(Noodles(), Vegetables(<span class="string">&quot;Carrots&quot;</span>, <span class="string">&quot;Beans&quot;</span>, <span class="string">&quot;Celery&quot;</span>))</span><br><span class="line">    order3.addAll(items)</span><br><span class="line">    ordersList.add(order3)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於訂單會隨著時間增加，因此 List 應為 <code>Order</code> 類型的 <code>MutableList</code>。然後使用 <code>MutableList</code> 上的 <code>add()</code> 方法新增每個訂單。</p>
<ol start="3">
<li>建立訂單 List 後，您可以使用迴圈來列印每個訂單。在訂單之間列印空白行，讓輸出內容更容易閱讀。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ordersList = mutableListOf&lt;Order&gt;()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (order <span class="keyword">in</span> ordersList) &#123;</span><br><span class="line">        order.print()</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這麼做會移除 <code>main()</code> 函式中的重複程式碼，讓程式碼更容易閱讀！輸出內容應與先前相同。</p>
<h5 id="實作訂單的建構工具模式"><a href="#實作訂單的建構工具模式" class="headerlink" title="實作訂單的建構工具模式"></a>實作訂單的建構工具模式</h5><p>如果要讓 Kotlin 程式碼更簡潔，您可以使用<span class="label primary">建構工具模式</span>來建立訂單。<span class="label primary">建構工具模式</span>是程式設計中的設計模式，可逐步指導您建構複雜的物件。</p>
<ol>
<li>請傳回已變更的 <code>Order</code>，不要傳回 <code>Order</code> 類別中 <code>addItem()</code> 和 <code>addAll()</code> 方法的 <code>Unit</code> (或不傳回任何內容)。Kotlin 提供關鍵字 <code>this</code> 以參照目前的物件例項。在 <code>addItem()</code> 和 <code>addAll()</code> 方法中，您會透過傳回 <code>this</code> 來傳回目前的 <code>Order</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(newItem: <span class="type">Item</span>)</span></span>: Order &#123;</span><br><span class="line">    itemList.add(newItem)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(newItems: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span>: Order &#123;</span><br><span class="line">    itemList.addAll(newItems)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>現在，在 <code>main()</code> 函式中，您可以將呼叫鏈結在一起，如以下程式碼所示。這個程式碼會建立新的 <code>Order</code>，並充分運用建構工具模式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> order4 = Order(<span class="number">4</span>).addItem(Noodles()).addItem(Vegetables(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Onion&quot;</span>))</span><br><span class="line">ordersList.add(order4)</span><br></pre></td></tr></table></figure>

<p><code>Order(4)</code> 會傳回 <code>Order</code> 例項，您之後可以在上面呼叫 <code>addItem(Noodles()).addItem() </code> 方法會傳回相同的 <code>Order</code> 例項 (採用新的狀態)，您可以用再次在上面呼叫 <code>addItem()</code> 的方式處理蔬菜。傳回的 <code>Order</code> 結果可以儲存在 <code>order4</code> 變數中。</p>
<p>用來建立 <code>Orders</code> 的現有程式碼仍可使用，因此可保持不變。雖然並非一定要鏈結這些呼叫，但這是一種常見且推薦的做法，可讓您善用函式的傳回值。</p>
<ol start="3">
<li>此時您甚至不需要將訂單儲存在變數中。在 <code>main()</code> 函式中 (在列印輸出訂單的最終迴圈之前)，直接建立 <code>Order</code>，並將其新增至 <code>orderList</code>。如果每種方法呼叫都自成一行，程式碼也更容易讀取。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">ordersList.add(</span><br><span class="line">    Order(<span class="number">5</span>)</span><br><span class="line">        .addItem(Noodles())</span><br><span class="line">        .addItem(Noodles())</span><br><span class="line">        .addItem(Vegetables(<span class="string">&quot;Spinach&quot;</span>)))</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行程式碼，以下是預期的輸出內容：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Order #1</span><br><span class="line">Noodles: $10</span><br><span class="line">Total: $10</span><br><span class="line"></span><br><span class="line">Order #2</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Chef&#x27;s Choice: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #3</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Carrots, Beans, Celery: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #4</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Cabbage, Onion: $5</span><br><span class="line">Total: $15</span><br><span class="line"></span><br><span class="line">Order #5</span><br><span class="line">Noodles: $10</span><br><span class="line">Noodles: $10</span><br><span class="line">Vegetables Spinach: $5</span><br><span class="line">Total: $25</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="所有程式碼"><a href="#所有程式碼" class="headerlink" title="所有程式碼"></a>所有程式碼</h4><p>以下是 <code>Item</code>、<code>Noodles</code>、<code>Vegetables</code> 和 <code>Order</code> 類別的程式碼。此外，<code>main()</code> 函式也會顯示這些類別的使用方式。實作這項程式的方法有很多，因此您的程式碼可能會略有不同。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">Item</span>(<span class="keyword">val</span> name: String, <span class="keyword">val</span> price: <span class="built_in">Int</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Noodles</span> : <span class="type">Item</span>(<span class="string">&quot;Noodles&quot;</span>, <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">return</span> name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vegetables</span>(<span class="keyword">vararg</span> <span class="keyword">val</span> toppings: String) : Item(<span class="string">&quot;Vegetables&quot;</span>, <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">toString</span><span class="params">()</span></span>: String &#123;</span><br><span class="line">        <span class="keyword">if</span> (toppings.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;<span class="variable">$name</span> Chef&#x27;s Choice&quot;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> name + <span class="string">&quot; &quot;</span> + toppings.joinToString()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>(<span class="keyword">val</span> orderNumber: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> itemList = mutableListOf&lt;Item&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addItem</span><span class="params">(newItem: <span class="type">Item</span>)</span></span>: Order &#123;</span><br><span class="line">        itemList.add(newItem)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">addAll</span><span class="params">(newItems: <span class="type">List</span>&lt;<span class="type">Item</span>&gt;)</span></span>: Order &#123;</span><br><span class="line">        itemList.addAll(newItems)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">print</span><span class="params">()</span></span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Order #<span class="subst">$&#123;orderNumber&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">var</span> total = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> (item <span class="keyword">in</span> itemList) &#123;</span><br><span class="line">            println(<span class="string">&quot;<span class="subst">$&#123;item&#125;</span>: $<span class="subst">$&#123;item.price&#125;</span>&quot;</span>)</span><br><span class="line">            total += item.price</span><br><span class="line">        &#125;</span><br><span class="line">        println(<span class="string">&quot;Total: $<span class="subst">$&#123;total&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> ordersList = mutableListOf&lt;Order&gt;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add an item to an order</span></span><br><span class="line">    <span class="keyword">val</span> order1 = Order(<span class="number">1</span>)</span><br><span class="line">    order1.addItem(Noodles())</span><br><span class="line">    ordersList.add(order1)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add multiple items individually</span></span><br><span class="line">    <span class="keyword">val</span> order2 = Order(<span class="number">2</span>)</span><br><span class="line">    order2.addItem(Noodles())</span><br><span class="line">    order2.addItem(Vegetables())</span><br><span class="line">    ordersList.add(order2)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add a list of items at one time</span></span><br><span class="line">    <span class="keyword">val</span> order3 = Order(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> items = listOf(Noodles(), Vegetables(<span class="string">&quot;Carrots&quot;</span>, <span class="string">&quot;Beans&quot;</span>, <span class="string">&quot;Celery&quot;</span>))</span><br><span class="line">    order3.addAll(items)</span><br><span class="line">    ordersList.add(order3)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Use builder pattern</span></span><br><span class="line">    <span class="keyword">val</span> order4 = Order(<span class="number">4</span>)</span><br><span class="line">        .addItem(Noodles())</span><br><span class="line">        .addItem(Vegetables(<span class="string">&quot;Cabbage&quot;</span>, <span class="string">&quot;Onion&quot;</span>))</span><br><span class="line">    ordersList.add(order4)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create and add order directly</span></span><br><span class="line">    ordersList.add(</span><br><span class="line">        Order(<span class="number">5</span>)</span><br><span class="line">            .addItem(Noodles())</span><br><span class="line">            .addItem(Noodles())</span><br><span class="line">            .addItem(Vegetables(<span class="string">&quot;Spinach&quot;</span>))</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Print out each order</span></span><br><span class="line">    <span class="keyword">for</span> (order <span class="keyword">in</span> ordersList) &#123;</span><br><span class="line">        order.print()</span><br><span class="line">        println()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><ul>
<li>清單(List) 是特定類型元素的有序集合，例如 <code>Strings</code> List。</li>
<li>索引(Index) 是反映元素位置的整數位置 (例如 <code>myList[2]</code>)。</li>
<li>在 List 中，第一個元素位於索引 <code>0</code> 處 (例如 <code>myList[0]</code>)，最後一個元素則位於 <code>myList.size-1</code> 處 (例如 <code>myList[myList.size-1]</code> 或 <code>myList.last()</code>)。</li>
<li>清單(List) 分為兩種類型：<code>List</code> 和 <code>MutableList</code>。</li>
<li><code>List</code> 處於唯讀狀態，在初始化後無法修改。不過，您可以執行 <code>sorted()</code> 和 <code>reversed()</code> 等作業，這些作業可在不變更原始 List 的情況下傳回新 List。</li>
<li><code>MutableList</code> 建立後可以修改，例如新增、移除或修改元素。</li>
<li>您可以使用 <code>addAll()</code> 將商品清單新增至可變動 List。</li>
<li>使用 <code>while</code> 迴圈執行程式碼區塊，直到運算式評估為 <code>false</code> 並結束迴圈為止。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (expression) &#123;</span><br><span class="line"></span><br><span class="line">// While the expression is true, execute this code block</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用 <code>for</code> 迴圈疊代清單的所有商品：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for (item in myList) &#123;</span><br><span class="line"></span><br><span class="line">// Execute this code block for each element of the list</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>vararg</code> 修飾符可讓您將數量可變的引數傳遞給函式或建構函式。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>List</tag>
        <tag>MutableList</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(15)-編寫檢測設備測試</title>
    <url>/2023/09/19/Android%E7%AD%86%E8%A8%98-15-%E7%B7%A8%E5%AF%AB%E6%AA%A2%E6%B8%AC%E8%A8%AD%E5%82%99%E6%B8%AC%E8%A9%A6/</url>
    <content><![CDATA[<blockquote>
<p>在先前的程式碼研究室中，您已學會如何建立及執行<code>單元測試(Unit Test)</code>，本程式碼研究室著重於<code>檢測設備測試(Instrumentation Test)</code>。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li><code>檢測設備測試(Instrumentation Test)</code>的樣貌。</li>
<li>如何執行<code>檢測設備測試(Instrumentation Test)</code>。</li>
<li>如何撰寫<code>檢測設備測試(Instrumentation Test)</code>。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="下載本程式碼研究室的範例程式碼"><a href="#下載本程式碼研究室的範例程式碼" class="headerlink" title="下載本程式碼研究室的範例程式碼"></a>下載本程式碼研究室的範例程式碼</h4><p>在本程式碼研究室中，您將使用 <code>Tip Time</code> 應用程式進行檢測設備測試。</p>
<div class="note no-icon success">
            <p><strong>範例程式碼網址：</strong><br><a href="https://github.com/google-developer-training/android-basics-kotlin-tip-compute-app-solutions">https://github.com/google-developer-training/android-basics-kotlin-tip-compute-app-solutions</a></p><p><strong>含有範例程式碼的模組名稱：</strong> <b>main</b></p>
          </div>

<hr>
<h4 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h4><ol>
<li>開啟 <code>Tip Time</code> 應用程式。</li>
<li><code>Tip Time</code> 應用程式有一個畫面，會顯示供使用者輸入<strong>帳單金額的文字輸入方塊</strong>、<strong>選取小費百分比的圓形按鈕</strong>，以及<strong>計算小費的按鈕</strong>。</li>
</ol>
<img src="https://i.imgur.com/ztAXhLI.png" width="30%" height="30%">

<hr>
<h4 id="建立檢測設備測試目錄"><a href="#建立檢測設備測試目錄" class="headerlink" title="建立檢測設備測試目錄"></a>建立檢測設備測試目錄</h4><p>本程式碼研究室的範例程式碼可以正常運作，但缺少測試和測試目錄。我們必須先新增目錄，之後再撰寫任何類型的測試，才能進行檢測設備測試。下載範例程式碼後，請按照下列步驟新增檢測設備測試的類別。</p>
<div class="note no-icon success">
            <p>注意： 建立新專案時會自動產生這些測試目錄。</p>
          </div>

<ol>
<li>最簡單的做法是先從「Android」檢視畫面切換至「Project」檢視畫面。在左上方的專案窗格中，按一下「Android」下拉式選單，然後選取「Project」(專案)。</li>
<li>按一下第一個下拉式選單，然後依序點選「app」-&gt;「src」。</li>
<li>用滑鼠右鍵按一下「src」，然後選取「New」-&gt;「Directory」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/73b014c84f89b0f0_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="4">
<li>選取「androidTest&#x2F;java」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/c4b99c44611ae609_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="5">
<li>現在會在專案結構中看到「src」-&gt;「androidTest」目錄。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/5f6643d80a7ef0f8_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="6">
<li>用滑鼠右鍵按一下「java」目錄，然後依序選取「New」-&gt;「Package」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/8f8a590b7bdc01b3_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="7">
<li><p>在視窗中輸入<code>com.example.tiptime</code>，然後按下 Return 鍵。</p>
</li>
<li><p>最後，用滑鼠右鍵按一下「com.example.tiptime」，然後依序選取「New」-&gt;「Kotlin Class&#x2F;File」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/26ff162c120e18d1_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="9">
<li>在出現的視窗中輸入 <code>CalculatorTests</code>，然後從下拉式選單中選取「Class」，並按下 Return 鍵。</li>
</ol>
<hr>
<h4 id="撰寫第一個檢測設備測試"><a href="#撰寫第一個檢測設備測試" class="headerlink" title="撰寫第一個檢測設備測試"></a>撰寫第一個檢測設備測試</h4><p>現在請撰寫檢測設備測試。請按照下列步驟測試 20% 小費的功能。</p>
<ol>
<li>開啟您剛剛建立的檔案，該程式碼會看起來像這樣：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tiptime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTests</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>檢測設備測試需要用到 <a href="https://developer.android.com/reference/android/test/InstrumentationTestRunner">InstrumentationTestRunner</a>，才能在裝置或模擬器上執行測試。有其他數個檢測執行工具，但在這個測試中，我們將使用 <code>AndroidJUnit4</code> 測試執行工具。如要指定測試執行工具，我們必須使用以下項目為類別加上註解：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTests</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><strong>Tip Time</strong> 應用程式是由單一活動 <code>MainActivity</code> 組成。若要與活動互動，您必須先啟動測試案例(Test Case)。在 <code>CalculatorTests</code> 類別中加入以下內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@get:Rule</span>()</span><br><span class="line"><span class="keyword">val</span> activity = ActivityScenarioRule(MainActivity::<span class="keyword">class</span>.java)</span><br></pre></td></tr></table></figure>

<p><code>ActivityScenarioRule</code> 來自 <code>AndroidX</code> 測試程式庫。並指示裝置啟動開發人員指定的活動。您需要使用 <code>@get:Rule</code> 加上註解，指定應在各項測試之前於類別中執行後續規則。在本例中，該規則為啟動活動。測試規則是測試所需的基本工具，最終，您也會學到如何自行撰寫。</p>
<ol start="4">
<li>接下來，您需要撰寫測試邏輯本身。建立函式並呼叫 <code>calculate_20_percent_tip()</code>，並透過 <code>@Test</code> 註解加上註解。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculate_20_percent_tip</span><span class="params">()</span></span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Espresso"><a href="#Espresso" class="headerlink" title="Espresso"></a>Espresso</h5><p>本課程主要使用 <code>Espresso</code> 進行檢測設備測試。<code>Espresso</code> 是一種程式庫，可供您在用 Android Studio 建立 Android 專案時立即使用，並可讓您透過程式碼與 UI 元件互動。</p>
<p>此刻，您可能已注意到 Android Studio 提供許多自動完成功能。使用 <code>Espresso</code> 的一大挑戰，就是如果尚未匯入程式庫，系統便無法自動完成方法。所以，如果您未研究說明文件，您會很難在 <code>Espresso</code> 中瀏覽可用方法。在這些課程中，我們將提供完成測試所需的方法。</p>
<p>首先，您必須撰寫程式碼，才能在「Cost of Service」輸入文字檢視區塊中輸入帳單金額。依序前往「app」-&gt;「src」-&gt;「main」-&gt;「res」-&gt;「layout」-&gt;「activity_main.xml」，指示 <code>TextInputEditText</code> 的 ID 為 <code>cost_of_service_edit_text</code>。複製 ID 名稱，稍後將用於測試。</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-instrumentation-tests/img/a113fb63b50f7674_1920.png?hl=zh-tw" width="80%" height="80%">

<h5 id="實作測試函式"><a href="#實作測試函式" class="headerlink" title="實作測試函式"></a>實作測試函式</h5><p>您現在可以在測試類別的 <code>calculate_20_percent_tip()</code> 函式中撰寫測試邏輯。</p>
<ol>
<li>首先，請使用 <code>onView()</code> 函式尋找可互動的使用者介面元件 (在此案例中為 <code>TextInputEditText</code>)。<code>onView()</code> 函式採用 <code>ViewMatcher</code> 物件參數。<code>ViewMatcher</code> 基本上是符合特定條件的 UI 元件，在此例中則是具有 <code>R.id.cost_of_service_edit_text</code> ID 的元件。</li>
</ol>
<p>函式 <code>withId()</code> 會傳回 <code>ViewMatcher</code>，這是 ID 傳遞至其的使用者介面元件。<code>onView()</code> 會傳回 <code>ViewInteraction</code>，我們可以與該物件互動，就像在操控裝置一樣。若要輸入文字，請在 <code>ViewInteraction</code> 上呼叫 <code>perform()</code>。然後，<code>perform()</code> 會採用 <code>ViewAction</code> 物件。有許多方法會傳回 <code>ViewAction</code>，但現在我們正在使用 <code>typeText()</code> 方法。在 <code>activity_main.xml</code> 中，可以看到預設的小費選項為 20%，因此目前您不必指定要選取的小費選項。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.cost_of_service_edit_text))</span><br><span class="line">    .perform(typeText(<span class="string">&quot;50.00&quot;</span>))</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意：</strong> 在較小的裝置上，因上一個步驟需輸入文字而開啟的鍵盤可能會擋住按鈕。如果您使用較小的裝置，可以將此方法鏈結至上述指示，藉此關閉鍵盤：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">.perform(ViewActions.closeSoftKeyboard())</span><br></pre></td></tr></table></figure>
          </div>

<ol start="2">
<li>現在按一下「Calculate」(計算) 按鈕進行測試。此程式碼的格式類似於我們用來輸入文字的格式。使用者介面元件並不相同，因此傳遞至 <code>withId()</code> 函式的 ID 名稱會不同。但在方法中的唯一差別是，<code>ViewAction</code> 不同；會以 <code>click()</code> 函式取代 <code>typeText()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.calculate_button))</span><br><span class="line">    .perform(click())</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>最後，您必須宣告顯示正確的小費。我們預計小費為 $10.00。在這項測試中，請確認 ID 為 <code>tip_result</code> 的 <code>TextView</code> 包含字串形式的預期小費值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">onView(withId(R.id.tip_result))</span><br><span class="line">    .check(matches(withText(containsString(<span class="string">&quot;$10.00&quot;</span>))))</span><br></pre></td></tr></table></figure>

<p>當系統顯示提示時，請選取下列匯入：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> androidx.test.espresso.assertion.ViewAssertions.matches</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matchers.containsString</span><br></pre></td></tr></table></figure>

<p>在本例中，您使用名為 <code>check()</code> 的不同互動，採用 <code>ViewAssertion</code>。您可以將 <code>ViewAssertion</code> 視為 UI 元件使用的特殊 <code>Espresso</code> 斷言。斷言是指 <code>TextView</code> 的內容與包含 “$10.00” 字串的文字相符。</p>
<p>執行測試前，請確認匯入內容和程式碼正確無誤，看起來應如下所示 (匯入順序不同並無影響)：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.tiptime</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.Espresso.onView</span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.action.ViewActions.click</span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.action.ViewActions.typeText</span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.assertion.ViewAssertions.matches</span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.matcher.ViewMatchers.withId</span><br><span class="line"><span class="keyword">import</span> androidx.test.espresso.matcher.ViewMatchers.withText</span><br><span class="line"><span class="keyword">import</span> androidx.test.ext.junit.rules.ActivityScenarioRule</span><br><span class="line"><span class="keyword">import</span> androidx.test.ext.junit.runners.AndroidJUnit4</span><br><span class="line"><span class="keyword">import</span> org.hamcrest.Matchers.containsString</span><br><span class="line"><span class="keyword">import</span> org.junit.Rule</span><br><span class="line"><span class="keyword">import</span> org.junit.Test</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith(AndroidJUnit4::class)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CalculatorTests</span> &#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@get:Rule</span>()</span><br><span class="line">   <span class="keyword">val</span> activity = ActivityScenarioRule(MainActivity::<span class="keyword">class</span>.java)</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">calculate_20_percent_tip</span><span class="params">()</span></span> &#123;</span><br><span class="line">       onView(withId(R.id.cost_of_service_edit_text))</span><br><span class="line">           .perform(typeText(<span class="string">&quot;50.00&quot;</span>))</span><br><span class="line"></span><br><span class="line">       onView(withId(R.id.calculate_button)).perform(click())</span><br><span class="line"></span><br><span class="line">       onView(withId(R.id.tip_result))</span><br><span class="line">           .check(matches(withText(containsString(<span class="string">&quot;$10.00&quot;</span>))))</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果您正在使用模擬器，請務必同時查看模擬器和 Android Studio 的視窗。請以執行單元測試的相同做法執行單元測試，也就是用滑鼠右鍵按一下函式左邊的紅色&#x2F;綠色箭頭按鈕，然後選取第一個選項。看看會發生什麼事吧！</p>
<img src="https://i.imgur.com/Pt0hv4o.gif" width="30%" height="30%">

<hr>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><ul>
<li>Android Studio 會在建立專案時產生必要的測試類別。不過，如果您的專案沒有這些類別，您可以手動建立。</li>
<li>測試規則會在每次在測試類別中進行測試之前執行。</li>
<li><a href="https://developer.android.com/training/testing/espresso/basics"><code>Espresso</code></a> 是檢測設備測試的基本元件，使得使用程式碼就能與使用者介面元件互動。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Automated Testing</tag>
        <tag>Instrumentation Test</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(14)-打造更優質的使用者體驗</title>
    <url>/2023/09/18/Android%E7%AD%86%E8%A8%98-14-%E6%89%93%E9%80%A0%E6%9B%B4%E5%84%AA%E8%B3%AA%E7%9A%84%E4%BD%BF%E7%94%A8%E8%80%85%E9%AB%94%E9%A9%97/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://m2.material.io/design/introduction/">Material</a> 是 Google 打造的設計系統，提供相關指南、元件，以及支援使用者介面設計最佳做法的工具。在本此篇文章中，我們將根據建議的 UI 最佳做法，更新小費計算機應用程式，確保使用者享有流暢的使用體驗。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/5743ac5ee2493d7_1920.png?hl=zh-tw" width="30%" height="30%">

<p><strong>學習目標</strong></p>
<ul>
<li>如何在應用程式中使用 Material Design 元件</li>
<li>如何從 Image Asset Studio 匯入 Material 圖示，使得可在應用程式中使用 Material 圖示</li>
<li>如何建立及套用新樣式</li>
<li>如何設定顏色以外的佈景主題屬性</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h4><p>您在先前的程式碼研究室已建構 <strong>Tip Time</strong> 應用程式，這是一款小費計算機應用程式，且提供可自訂小費的選項。您的應用程式使用者介面看似像如下螢幕截圖。功能可以運作，但看起來更像原型。這些欄位看起來並未完全對齊。就提升樣式和間距的一致性，以及使用 Material Design 元件而言，肯定還有改進空間。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/6685eaafba30960a_1920.png?hl=zh-tw" width="30%" height="30%">

<hr>
<h4 id="Material-元件"><a href="#Material-元件" class="headerlink" title="Material 元件"></a>Material 元件</h4><p><a href="https://m3.material.io/components">Material元件 (Material Components) </a>是常見的使用者介面小工具，可協助您輕鬆在應用程式中導入 Material 樣式。這份說明文件說明如何使用及自訂質感設計元件。每個元件都有通用的 Material Design 指南，而 Android 適用的元件則有 Android 平台專屬的指南。如果所選平台沒有某個元件，您可以從已加標籤的圖表取得充足資訊，重新建立該元件。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/c4a4db857bb36c3f_1920.png?hl=zh-tw" width="70%" height="70%">

<p>透過 Material Design Components(元件)，您的應用程式能夠以更一致的方式，與使用者裝置上的其他應用程式搭配運作。如此一來，在某個應用程式中學到的使用者介面操作模式即可沿用到其他應用程式，這樣使用者就能更快瞭解如何使用您的應用程式。因此，建議您<a href="https://medium.com/androiddevelopers/we-recommend-material-design-components-81e6d165c2dd">盡可能使用 Material Components</a>，而非使用 Material 小工具。Material 元件更加靈活且可自訂，而且您將在下一個工作中學到這些知識。</p>
<p>您需要將 <code>Material Design Components (MDC)</code> 程式庫做為依附元件加入專案中。根據預設，您的專案應該已經包含這一行。請在應用程式的 build.gradle 檔案中，確認最新版程式庫包含這項依附元件。詳情請參閱 Material Design 網站的<a href="https://m2.material.io/develop/android/docs/getting-started/">入門指南</a>頁面。</p>
<p><code>app/build.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    implementation <span class="string">&#x27;com.google.android.material:material:&lt;version&gt;&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="文字欄位-Text-Fields"><a href="#文字欄位-Text-Fields" class="headerlink" title="文字欄位(Text Fields)"></a>文字欄位(Text Fields)</h5><p>在小費計算機應用程式中，版面配置頂端會顯示目前服務費的 EditText 欄位。此 EditText 欄位可正常運作，但文字欄位的外觀和行為不符合最新質感設計南要求。</p>
<p>如果想使用新元件，請先在 Material Design 網站上瞭解相關資訊。根據<a href="https://m2.material.io/components/text-fields/android">文字欄位指南</a>所述，文字欄位分成兩種類型：<br>實心的文字欄位(左)、含外框的文字欄位(右)。<br><img src="https://lh3.googleusercontent.com/NKeAqZqJLJwvWEuU4J3vuA6XgGKKW6VAlP4FRgIqXbx5jcXr8m00dt6NtVbmFPwFfvIxAEkkUac24QVCRL_wQ2SiGxjreaaVUZAir_nNs0rVj0DZ_f2a=w1064-v0" width="70%" height="70%"></p>
<p>若要建立上述文字欄位，請使用 MDC 程式庫中內含 <code>TextInputEditText</code> 的 <code>TextInputLayout</code>。您可以輕鬆自訂 Material Design 文字欄位，執行以下操作：</p>
<ul>
<li>顯示始終可見的文字或標籤</li>
<li>在文字欄位中顯示圖示</li>
<li>顯示小幫手或錯誤訊息</li>
</ul>
<p>在本程式碼研究室的第一項工作中，您要將服務費 <code>EditText</code> 替換為 Material Design 的text欄位 (由 <code>TextInputLayout</code> 和 <code>TextInputEditText</code> 所組成)。</p>
<ol>
<li><p>在 Android Studio 中開啟 Tip Time 應用程式，前往 <code>activity_main.xml</code> 版面配置檔案。其中應包含有小費計算機版面配置的 <code>ConstraintLayout</code>。</p>
</li>
<li><p>如要查看 Material Design text欄位的 XML 樣式示例，請返回<a href="https://m2.material.io/components/text-fields/android">text欄位的 Android 指南</a>。您應該會看到類似下列內容的程式碼片段：</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/textField&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">&quot;@string/label&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>看到這個示例後，請插入 Material Design 文字欄位做為 <code>ConstraintLayout</code> 的第一個子項 (在<code>EditText</code> 欄位前)。您將在後續步驟中移除 <code>EditText</code> 欄位。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/textField&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:hint</span>=<span class="string">&quot;@string/label&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/cost_of_service&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>您應該會看到 <code>TextInputLayout</code> 元素有錯誤。您尚未在父項 <code>ConstraintLayout</code> 中適當的限制此檢視畫面。系統也無法辨識字串資源。您會在後續步驟中修正這些錯誤。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/344a98d866c7f68c_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="4">
<li>在文字欄位中加入垂直和水平限制條件，以便正確放置於父項 <code>ConstraintLayout</code> 中。您尚未刪除 <code>EditText</code>，因此請從 <code>EditText</code> 剪下及貼上下列屬性，並加入 <code>TextInputLayout</code> 中：constraints、resource ID <code>cost_of_service</code>、<code>160dp</code> 的版面配置寬度、<code>wrap_content</code> 的版面配置高度，以及hint text <code>@string/cost_of_service</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;160dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:hint</span>=<span class="string">&quot;@string/cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>畫面上可能會顯示錯誤訊息，指出 <code>cost_of_service</code> ID 與 <code>EditText</code> 的資源 ID 相同，但您目前可以忽略這項錯誤 (將用幾個步驟移除 <code>EditText</code>)。</p>
<ol start="5">
<li>接著確認 <code>TextInputEditText</code> 元素具有所有適當的屬性。從 <code>EditText</code> 的輸入類型剪下並貼上至 <code>TextInputEditText</code>。將 <code>TextInputEditText</code> 的 resource ID 變更為 <code>cost_of_service_edit_text</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span> <span class="attr">...</span> &gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/cost_of_service_edit_text&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:inputType</span>=<span class="string">&quot;numberDecimal&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>保持原本 <code>match_parent</code> 的寬度和 <code>wrap_content</code> 的高度即可。設定 <code>match_parent</code> 的寬度時，<code>TextInputEditText</code> 的寬度會與父項 <code>TextInputLayout</code> 相同，也就是 <code>160dp</code>。</p>
<ol start="6">
<li><p>您現在已從 <code>EditText</code> 複製所有相關資訊，請進一步刪除版面配置中的 <code>EditText</code>。</p>
</li>
<li><p>版面配置的「Design」檢視畫面應該會顯示以下預覽內容。「Cost of Service」欄位現在會以 Material Design 文字欄位的形式呈現。</p>
</li>
</ol>
<p>您目前無法執行這個應用程式，因為 <code>calculateTip()</code> 方法的 MainActivity.kt 檔案發生錯誤。回顧先前的程式碼研究室，如果您的專案已啟用檢視區塊繫結(Binding)，Android 會根據resource ID 名稱在繫結物件中建立屬性。擷取服務費的來源欄位已在 XML 版面配置中有所變更，因此 Kotlin 程式碼也需要隨之更新。</p>
<p>您現在將從resource ID 為 <code>cost_of_service_edit_text</code> 的 <code>TextInputEditText</code> 元素擷取使用者輸入內容。在 MainActivity 中，使用 <code>binding.costOfServiceEditText</code> 存取儲存於其中的文字字串。<code>calculateTip()</code> 方法的其餘部分則不受影響。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">calculateTip</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get the decimal value from the cost of service text field</span></span><br><span class="line">    <span class="keyword">val</span> stringInTextField = binding.costOfServiceEditText.text.toString()</span><br><span class="line">    <span class="keyword">val</span> cost = stringInTextField.toDoubleOrNull()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>接著，執行應用程式並測試是否仍然正常運作。請注意，輸入時，「Cost of Service」標籤顯示在您輸入的內容上方的方式。小費仍會照常計算。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/b4a27e58f63417b7_1920.png?hl=zh-tw" width="30%" height="30%"> 

<h5 id="切換鈕-Switches"><a href="#切換鈕-Switches" class="headerlink" title="切換鈕(Switches)"></a>切換鈕(Switches)</h5><p>Material Design 指南中也提供<a href="https://m2.material.io/develop/android/components/switches">切換鈕</a>的說明。切換鈕這種小工具可用來開啟或關閉設定。</p>
<ol>
<li><p>請參閱 Android 指南以瞭解 Material 的<a href="https://m2.material.io/develop/android/components/switches">切換按鈕</a>。您將會瞭解提供切換鈕 Material 樣式的 SwitchMaterial 小工具 (來自 MDC 程式庫)。如果您持續捲動瀏覽指南，就會看到 XML 範例。</p>
</li>
<li><p>若要使用 <code>SwitchMaterial</code>，您必須在版面配置中明確指定 <code>SwitchMaterial</code>，且使用完整的路徑名稱。</p>
</li>
</ol>
<p>在 <code>activity_main.xml</code> 版面配置中，將 XML 標記從 <code>Switch</code> 變更為 <code>com.google.android.material.switchmaterial.SwitchMaterial</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.switchmaterial.SwitchMaterial</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/round_up_switch&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行應用程式，確認應用程式是否仍可編譯。應用程式沒有明顯異動。不過，使用 MDC 程式庫中的 <code>SwitchMaterial</code> (而非 Android 平台的 Switch) 的好處便是當更新 <code>SwitchMaterial</code> 程式庫的實作時 (例如質感設計指南變更)，您不需要執行變更，就能免費取得更新版小工具。這有助於應用程式永不過時。</li>
</ol>
<p>現在您已看到兩個例子，瞭解使用現成的 Material Design 元件對使用者介面有何好處，也明白這種做法如何讓應用程式更符合 Material Design 指南。請注意，您隨時可以前往<a href="https://m2.material.io/develop/android/">這個網站</a>，探索 Android 提供的其他 Material Design 元件。</p>
<hr>
<h4 id="圖示-Icons"><a href="#圖示-Icons" class="headerlink" title="圖示(Icons)"></a>圖示(Icons)</h4><p>圖示(Icons)是一種符號，可透過視覺呈現的方式協助使用者瞭解使用者介面的預定功能，而且通常會以使用者預期在實體世界遇到的物體為靈感。圖示設計往往會將詳細資料精細程度降至供使用者熟悉所需的最低程度。舉例來說，現實生活中的鉛筆是用來寫字，因此對應的圖示通常表示建立、新增或編輯項目。</p>
<h5 id="在應用程式中呈現圖示"><a href="#在應用程式中呈現圖示" class="headerlink" title="在應用程式中呈現圖示"></a>在應用程式中呈現圖示</h5><p>就應用程式中的圖示而言，建議您採用向量可繪項目，而不是針對不同螢幕密度提供不同版本的點陣圖圖像。向量可繪項目是以 XML 檔案表示，用於儲存如何建立圖像的操作說明，而非儲存組成該圖像的實際像素。向量可繪項目可以任意縮放，而不會減損圖像品質或增加檔案大小。</p>
<h5 id="提供的圖示"><a href="#提供的圖示" class="headerlink" title="提供的圖示"></a>提供的圖示</h5><p>Material Design 提供多種圖示，並依常見類別排列，方便您視需求選擇使用。查看<a href="https://fonts.google.com/icons">圖示清單</a>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/bfdb896506790c69_1920.png?hl=zh-tw" width="70%" height="70%">

<p>繪製這些圖示時，也可以使用實心、含外框、圓角、雙色和銳利這五種主題，並加上顏色。</p>
<table>
<thead>
<tr>
<th align="center">實心</th>
<th align="center">含外框</th>
<th align="center">圓角</th>
<th align="center">雙色</th>
<th align="center">銳利</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/3bf33d3756ecbc26_1920.png?hl=zh-tw" width="30%" height="30%"></td>
<td align="center"><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/8e38326e16364a77_1920.png?hl=zh-tw" width="30%" height="30%"></td>
<td align="center"><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/150940d440a179b_1920.png?hl=zh-tw" width="30%" height="30%"></td>
<td align="center"><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/d80f7e2b888a0eeb_1920.png?hl=zh-tw" width="30%" height="30%"></td>
<td align="center"><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/a72f07895ce9cccc_1920.png?hl=zh-tw" width="30%" height="30%"></td>
</tr>
</tbody></table>
<h5 id="新增圖示"><a href="#新增圖示" class="headerlink" title="新增圖示"></a>新增圖示</h5><p>在這項工作中，您要在應用程式中新增三個向量可繪項目圖示：</p>
<ol>
<li>服務費文字欄位旁邊的圖示</li>
<li>服務問題旁邊的圖示</li>
<li>小費四捨五入提示旁邊的圖示</li>
</ol>
<p>以下是應用程式最終版本的螢幕截圖。新增圖示後，您將配合這些圖示的位置調整版面配置。請注意，新增圖示會造成欄位和計算按鈕向右移動</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/8c4225390dd1fb20_1920.png?hl=zh-tw" width="30%" height="30%">

<h5 id="新增向量可繪項目素材資源"><a href="#新增向量可繪項目素材資源" class="headerlink" title="新增向量可繪項目素材資源"></a>新增向量可繪項目素材資源</h5><p>您可以直接在 Android Studio 的 Asset Studio 中建立這些圖示，做為向量可繪項目。</p>
<ol>
<li><p>開啟應用程式視窗左側的「Resource Manager」分頁。</p>
</li>
<li><p>按一下「+」圖示，然後選取「Vector Asset」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/6dabda0f4bc1f6ed_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="3">
<li>確認已選取「Asset Type」中標示「Clip Art」的圓形按鈕。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/914786d2d8b4025_1920.png?hl=zh-tw" width="60%" height="60%">

<ol start="4">
<li>按一下「Clip Art:」旁的按鈕，選取其他插圖圖像。在隨即顯示的提示中，在顯示的視窗中輸入「”call made」。您將使用這個箭頭圖示來代表「round up tip」選項。請選取該圖示，然後點選「OK」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/e7f607e4f576d75c_1920.png?hl=zh-tw" width="60%" height="60%">

<ol start="5">
<li><p>將圖示重新命名為 <code>ic_round_up</code>。在為圖示檔案命名時，建議使用前置字串 ic_。將「Size」保留為 <code>24 dp x 24 dp</code>，並將「Color」保留為黑色 <code>000000</code>。</p>
</li>
<li><p>按一下「Next」。</p>
</li>
<li><p>接受預設目錄位置，然後按一下「Finish」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/200aed40ee987672_1920.png?hl=zh-tw" width="60%" height="60%">

<ol start="8">
<li>針對另外兩個圖示重複步驟 2 到 7：</li>
</ol>
<ul>
<li>服務問題圖示：搜尋「room service」圖示，並將其儲存為 <code>ic_service</code>。</li>
<li>服務費圖示：搜尋「store」圖示，並將其儲存為 <code>ic_store</code>。</li>
</ul>
<ol start="9">
<li>完成後，「Resource Manager」分頁會顯示以下螢幕截圖所列的畫面。此外，<code>res/drawable</code> 資料夾也會列出三個向量可繪項目，即 <code>ic_round_up</code>、<code>ic_service</code> 和 <code>ic_store</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/c2d8b22f0fb55ce0_1920.png?hl=zh-tw" width="40%" height="40%">

<h5 id="支援舊版-Android"><a href="#支援舊版-Android" class="headerlink" title="支援舊版 Android"></a>支援舊版 Android</h5><p>您剛剛在應用程式中新增了向量可繪項目，但請特別注意，Android 5.0 (API 級別 21) 版本之前的 Android 平台不支援向量可繪項目。</p>
<p>根據專案設定方式，Tip Time 應用程式的最低 SDK 版本為 API 19。這表示該應用程式可以在執行 Android 平台 19 以上版本的 Android 裝置上執行。</p>
<p>如要讓您的應用程式在舊版 Android 裝置上運作 (稱為回溯相容性)，請在應用程式的 <code>build.gradle</code> 檔案中新增 <code>vectorDrawables</code> 元素。這樣您就能在 API 21 以下版本的平台上使用向量可繪項目，而不需要在建構專案時轉換成 PNG。詳情請參閱這個頁面。</p>
<p><code>app/build.gradle</code></p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">  defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">    vectorDrawables.useSupportLibrary = <span class="keyword">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="插入圖示和位置元素"><a href="#插入圖示和位置元素" class="headerlink" title="插入圖示和位置元素"></a>插入圖示和位置元素</h5><p>您將使用 <code>ImageViews</code> 在應用程式中顯示圖示。這是最終顯示 UI 的方式。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/5ed07dfeb648bd62_1920.png?hl=zh-tw" width="40%" height="40%">

<ol>
<li><p>開啟 <code>activity_main.xml</code> 版面配置。</p>
</li>
<li><p>先找出服務費文字欄位旁邊的商店圖示。在 <code>TextInputLayout</code> 前插入新的 <code>ImageView</code>，做為 <code>ConstraintLayout</code> 的第一個子項。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">   &lt;<span class="attr">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>ImageView</code> 上設定適當的屬性來保留 <code>ic_store</code> 圖示。將 ID 設定為 <code>icon_cost_of_service</code>。將 <code>android:src</code> 屬性設定為可繪製資源 <code>@drawable/ic_store</code>，而 XML 該行旁邊會顯示圖示的預覽。<br>此外，由於圖片僅用於裝飾用途，請設定 <code>android:importantForAccessibility=&quot;no&quot;</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/icon_cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_store&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note no-icon primary">
            <p><code>android:importantForAccessibility=&quot;no&quot;</code> 表示： 裝飾用的圖片或所傳達資訊不具意義的圖片不需要內容標籤。</p>
          </div>

<p><code>ImageView</code> 應該會出現錯誤，因為檢視區塊尚未受到限制。接下來，您將修復此問題。</p>
<ol start="4">
<li>以兩個步驟定位 <code>icon_cost_of_service</code>。首先新增 <code>ImageView</code> 的限制 (此步驟)，然後更新旁邊 <code>TextInputLayout</code> 的限制 (步驟 5)。下圖說明設定限制條件的方式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/d982b1b1f0131630_1920.png?hl=zh-tw" width="30%" height="30%">

<p>在 <code>ImageView</code> 上，您想要將起始邊緣限制為父項檢視畫面 (<code>app:layout_constraintStart_toStartOf=&quot;parent&quot;</code>) 的起始邊緣。</p>
<p>比起旁邊的文字欄位，該圖示看起來是垂直置中，因此應將此 <code>ImageView</code> 的頂端 (<code>layout_constraintTop_toTopOf</code>) 限制在文字欄位頂端，並將此 <code>ImageView</code> 的底部 (<code>layout_constraintBottom_toBottomOf</code>) 限制為文字欄位的底部。如要參照文字欄位，請使用資源 ID <code>@id/cost_of_service</code>。預設行為是指將兩個限制條件套用至相同維度 (例如頂端和底部限制條件) 的小工具時，系統會同樣套用這兩個限制條件。這會讓圖示以服務費欄位為基準垂直置中。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/icon_cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_store&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;@id/cost_of_service&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>在「Design」檢視畫面中，圖示和文字欄位仍會重疊。這將在下一個步驟中修正。</p>
<ol start="5">
<li>新增圖示前，文字欄位定位於父項的開頭，現在，必須移到右側。請更新 <code>cost_of_service</code> 文字欄位與 <code>icon_cost_of_service</code> 相關的限制條件。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/bb55ea0cddaa2a12_1920.png?hl=zh-tw" width="30%" height="30%">

<p><code>TextInputLayout</code> 的起始邊緣應限制為 <code>ImageView</code> 的結束邊緣 (<code>@id/icon_cost_of_service</code>)。若要在兩個檢視畫面之間加入間距，請在 <code>TextInputLayout</code> 上加入 <code>16dp</code> 的起始邊界。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/cost_of_service&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/icon_cost_of_service&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.textfield.TextInputEditText</span> <span class="attr">...</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">com.google.android.material.textfield.TextInputLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>完成上述所有變更後，圖示應正確放置在文字欄位旁邊。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/23dcae5c3931903f_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="6">
<li>接著在「How was the service?」旁插入服務鈴鐺圖示 <code>TextView</code>。雖然您可以在 <code>ConstraintLayout</code> 內的任何位置宣告 <code>ImageView</code>，但如果在 XML 版面配置中的 <code>TextInputLayout</code> 後方、<code>service_question TextView</code> 前方插入新 <code>ImageView</code>，XML 版面配置會更清楚易懂。</li>
</ol>
<p>為新的 <code>ImageView</code> 指派 <code>@+id/icon_service_question</code> 資源 ID。針對 <code>ImageView</code> 和服務問題 <code>TextView</code> 設定適當的限制條件。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/38c2dcb4cb18b5a_1920.png?hl=zh-tw" width="30%" height="30%">

<p>此外，請為 <code>service_question TextView</code> 加上 <code>16dp</code> 邊界，讓服務問題與上方的服務費欄位之間有更多垂直空間。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/icon_service_question&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_service&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;@+id/service_question&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@+id/service_question&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/service_question&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/how_was_the_service&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginVertical</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@+id/icon_service_question&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/cost_of_service&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>此時，「Design」檢視畫面應如下圖所示。「Cost of Service」欄位和服務問題 (以及各自的圖示) 看起來很清楚，但圓形按鈕的位置並不適當，而且不會與上方的內容垂直對齊。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/578834f5bd3a2d2a_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="8">
<li>將圓形按鈕向右移至服務問題下方，改善圓形按鈕的位置。這表示更新 <code>RadioGroup</code> 限制條件。將 <code>RadioGroup</code> 的起始邊緣限制為 <code>service_question TextView</code> 的起始邊緣。<code>RadioGroup</code> 上的所有其他屬性都將維持不變。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/bf454f3f1617024d_1920.png?hl=zh-tw" width="30%" height="30%">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_options&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@id/service_question&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="9">
<li><p>接下來，請將 <code>ic_round_up</code> 的圖示加到「Round up tip?」切換鈕旁的版面配置。請嘗試自行完成此操作，如果遇到困難，可以參考下方的 XML。您可以將新的 ImageView 資源 ID 指派給 <code>icon_round_up</code>。</p>
</li>
<li><p>在版面配置 XML 中的 <code>RadioGroup</code> 後方、<code>SwitchMaterial</code> 小工具前方插入新 <code>ImageView</code>。</p>
</li>
<li><p>指派 <code>icon_round_up</code> 的資源 ID 給 <code>ImageView</code>，然後將 <code>src</code> 設為圖示 <code>@drawable/ic_round_up</code> 的可繪項目。請將 <code>ImageView</code> 的開頭限制為父項的開頭，並讓圖示以 <code>SwitchMaterial</code> 為基準垂直置中。</p>
</li>
<li><p>更新 <code>SwitchMaterial</code>，將其放於圖示旁邊，並將起始邊界設為 <code>16dp</code>。針對 <code>icon_round_up</code> 和 <code>round_up_switch</code> 產生的 XML 應如下所示。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">ImageView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/icon_round_up&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:importantForAccessibility</span>=<span class="string">&quot;no&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:src</span>=<span class="string">&quot;@drawable/ic_round_up&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;@id/round_up_switch&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;@id/round_up_switch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.switchmaterial.SwitchMaterial</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/round_up_switch&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">...</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginStart</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintStart_toEndOf</span>=<span class="string">&quot;@id/icon_round_up&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>「Design」檢視畫面應如下圖所示。這三個圖示均已正確定位。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/8781ecbd11859cc4_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="14">
<li>如果比較此畫面與最終的應用程式螢幕截圖，就會發現計算按鈕也會移動，並垂直對齊服務費欄位、服務問題、圓形按鈕選項和小費四捨五入問題。只要將「Calculate」按鈕的起始位置限制為 <code>round_up_switch</code> 的起始位置，就能達到此效果。此外，在計算按鈕與上方切換鈕之間，也會加入 <code>8dp</code> 垂直邊界。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/84348568e13d9e32_1920.png?hl=zh-tw" width="30%" height="30%">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/calculate_button&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@id/round_up_switch&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>最後，也務必為 <code>TextView</code> 的上邊界增加 <code>8dp</code>，設定 <code>tip_result</code> 的位置。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/8e21f52be710340d_1920.png?hl=zh-tw" width="30%" height="30%">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_result&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ol start="16">
<li>執行應用程式，畫面應該看起來像下方的螢幕截圖。使元素垂直對齊並增加元素之間的間距，這些元素就不會擁擠。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/1f2ef2c0c9a9bdc7_1920.png?hl=zh-tw" width="30%" height="30%">


<p>我的實作畫面：<br><img src="https://i.imgur.com/DulTyY5.png" width="30%" height="30%"></p>
<hr>
<h4 id="樣式與主題-Styles-and-Themes"><a href="#樣式與主題-Styles-and-Themes" class="headerlink" title="樣式與主題(Styles and Themes)"></a>樣式與主題(Styles and Themes)</h4><p><a href="https://medium.com/androiddevelopers/android-styling-themes-vs-styles-ebe05f917578">樣式(style)</a>是單一類型小工具的檢視畫面屬性值集合。舉例來說，TextView 樣式可指定字型顏色、字型大小和背景顏色等。只要將這些屬性擷取為樣式，就能輕鬆將樣式套用至版面配置的多個檢視畫面，並在同一處維護樣式。</p>
<p>在這項工作中，您要先建立文字檢視區塊、圓形按鈕和切換鈕小工具的樣式。</p>
<h5 id="建立樣式"><a href="#建立樣式" class="headerlink" title="建立樣式"></a>建立樣式</h5><p>如果在「res &gt; values」目錄沒有名為 <code>styles.xml</code> 的新檔案，請建立該檔案。在「values」目錄上按一下滑鼠右鍵，然後依序選取「New」&gt;「Values Resource File」，即可建立檔案。呼叫　<code>styles.xml</code>。新檔案包含下列內容。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立新的 <code>TextView</code> 樣式，使整個應用程式中的文字保持一致。只需在 <code>styles.xml</code> 中定義樣式一次，就能將該樣式套用至版面配置中的所有 <code>TextViews</code>。雖然您可以從頭開始定義樣式，但您可以從 MDC 程式庫中現有的 <code>TextView</code> 樣式延伸。</li>
</ol>
<p>設定元件樣式時，一般而言，您應從所用小工具類型的父項樣式中延伸。這麼做有兩個非常重要的理由：第一是確認已在元件中設定所有重要的預設值，第二是樣式會持續繼承日後的父項樣式變更。</p>
<p>您可以視需要為樣式命名，但建議採用以下慣例。若是繼承父項 Material 樣式，請將 <code>MaterialComponents</code> 替換成您的應用程式名稱 (<code>TipTime</code>)，藉此以類似方式命名樣式。這麼做會將您的變更移到各自的命名空間，進而避免在 Material 元件日後推出新樣式時發生衝突。示例：</p>
<p>您的樣式名稱 <code>Widget.TipTime.TextView</code> 繼承父項樣式 <code>Widget.MaterialComponents.TextView</code></p>
<p>請此內容加至 <code>styles.xml</code> 檔案中 <code>resources</code> 的開頭標記與結尾標記之間。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Widget.TipTime.TextView&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.MaterialComponents.TextView&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>設定 <code>TextView</code> 樣式，使其會覆寫屬性 <code>android:minHeight</code>,<code>android:gravity</code>, 和 <code>android:textAppearance</code>.</li>
</ol>
<p><code>android:minHeight</code> 設定 <code>TextView</code> 上的高度下限為 48dp。根據 <a href="https://m3.material.io/components/lists/overview#specs">Material Design 指南</a>的規定，任一列的最小高度應為 48 dp。</p>
<p>設定 <code>android:gravity</code> 屬性就可將 <code>TextView</code> 中的文字垂直置中。(請參閱下方的螢幕截圖。)重力可控制檢視畫面中內容本身的定位方式。由於實際文字內容的高度不會佔據整個 48dp，所以 <code>center_vertical</code> 值會將 <code>TextView</code> 內的文字垂直置中 (但不變更水平位置)。其他可能的重力值包括 <code>center</code>、<code>center_horizontal</code>、<code>top</code> 和 <code>bottom</code>。歡迎嘗試其他重心值，瞭解這對文字的影響。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/6a7ecc6a49a858e9_1920.png?hl=zh-tw" width="30%" height="30%">

<p>將文字外觀屬性值設為 <code>?attr/textAppearanceBody1</code>。<code>TextAppearance</code> 是一組預先製作的樣式，用於文字大小、字型和其他文字屬性。如要查看 Material Design 提供的其他可用文字外觀，請參閱<a href="https://m2.material.io/develop/android/theming/typography">字體排版比例清單</a>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Widget.TipTime.TextView&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.MaterialComponents.TextView&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:minHeight&quot;</span>&gt;</span>48dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textAppearance&quot;</span>&gt;</span>?attr/textAppearanceBody1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>activity_main.xml</code> 的每個 <code>TextView</code> 上新增樣式屬性，即可將 <code>Widget.TipTime.TextView</code> 樣式套用到 <code>service_question TextView</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/service_question&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;@style/Widget.TipTime.TextView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在新增此樣式前，<code>TextView</code> 的字型看起來很小，且字型顏色是灰色：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/4d54a3179f0c6f8d_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="6">
<li>新增樣式之後，<code>TextView</code> 外觀如下。現在，<code>TextView</code> 看起來與版面配置的其餘部分更一致。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/416d3928f9c3d3de_1920.png?hl=zh-tw" width="30%" height="30%">

<p>將相同的 <code>Widget.TipTime.TextView</code> 樣式套用到 <code>tip_result TextView</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_result&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">style</span>=<span class="string">&quot;@style/Widget.TipTime.TextView&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/3ebe16aa8c5bc010_1920.png?hl=zh-tw" width="30%" height="30%">

<div class="note no-icon success">
            <p><strong>注意：</strong>如果您在樣式中指定屬性 (例如將 <b>android:textSize</b> 設為 <b>18sp</b>)，也在版面配置檔案中指定同一屬性 (例如將 <b>android:textSize</b> 設為 <b>14sp</b>)，則實際套用至畫面內容的會是您在版面配置中設定的值 (<b>14sp</b>)。</p>
          </div>

<ol start="6">
<li>相同的文字樣式應套用至切換按鈕中的文字標籤。不過，您無法將 <code>SwitchMaterial</code> 小工具設定為 <code>TextView</code> 樣式。<code>TextView</code> 樣式只能套用到 <code>TextViews</code>。因此需要建立用於切換按鈕的新樣式。屬性的 <code>minHeight</code>、<code>gravity</code> 和 <code>textAppearance</code> 皆相同。差別在於樣式名稱與父項不同，因為您現在要繼承 MDC 程式庫的 <code>Switch</code> 樣式。樣式名稱也應與父項樣式名稱相同。</li>
</ol>
<p>您的樣式名稱 <code>Widget.TipTime.CompoundButton.Switch</code> 繼承父項樣式 <code>Widget.MaterialComponents.CompoundButton.Switch.</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Widget.TipTime.CompoundButton.Switch&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.MaterialComponents.CompoundButton.Switch&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:minHeight&quot;</span>&gt;</span>48dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textAppearance&quot;</span>&gt;</span>?attr/textAppearanceBody1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>如果想讓文字視覺效果保持一致，圓形按鈕是最後一項需要留意的元素。您無法將 <code>TextView</code> 樣式或 <code>Switch</code> 樣式套用至 <code>RadioButton</code> 小工具。而是，您必須建立用於圓形按鈕的新樣式。您可以從 MDC 程式庫的 <code>RadioButton</code> 樣式延伸。</li>
</ol>
<p>建立此樣式時，也在圓形按鈕文字與圓形影像內容之間加入邊框間距。<code>paddingStart</code> 是您尚未使用的新屬性。邊框間距是指檢視區塊內容與檢視區塊邊界之間的空間大小。<code>paddingStart</code> 屬性只會在元件的開頭設定邊框間距。以下是圓形按鈕的 <code>paddingStart</code> 分別設為 0 dp 與 8 dp 的差異。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/4c1aa37bbdadab1d_1920.png?hl=zh-tw" width="20%" height="20%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/35a96c994b82539e_1920.png?hl=zh-tw" width="20%" height="20%">

<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Widget.TipTime.CompoundButton.RadioButton&quot;</span></span></span><br><span class="line"><span class="tag"><span class="attr">parent</span>=<span class="string">&quot;Widget.MaterialComponents.CompoundButton.RadioButton&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:paddingStart&quot;</span>&gt;</span>8dp<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textAppearance&quot;</span>&gt;</span>?attr/textAppearanceBody1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>(選用) 建立 <code>dimens.xml</code> 檔案以更方便<span class="label primary">管理常用值</span>。您可以採用與上述 <code>styles.xml</code> 檔案相同的方式建立檔案。選取「values」目錄、按一下滑鼠右鍵，然後依序選取「New」&gt;「Values Resource File」。</li>
</ol>
<p>在這個小型應用程式中，您重複設定最小高度兩次。目前當然可以管理，但要是有 4 個、6 個、10 個或更多個元件共用相同的值，就會迅速失控。記住逐一變更每個項目的做法不僅繁瑣，而且容易出錯。您可以依序點選「res」&gt;「values」，建立另一個名為 <code>dimens.xml</code> 的實用資源檔案，保留可命名的常用尺寸。將常用值標準化為已命名的尺寸，就能更輕鬆管理應用程式。<code>TipTime</code> 很小，因此我們不會在此選用步驟外使用此應用程式。不過，如果您在正式環境中擁有較複雜的應用程式，且可能會與設計團隊合作，則 <code>dimens.xml</code> 可讓您輕鬆地頻繁變更這些值。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">dimen</span> <span class="attr">name</span>=<span class="string">&quot;min_text_height&quot;</span>&gt;</span>48dp<span class="tag">&lt;/<span class="name">dimen</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>與其直接設定 <code>48dp</code>，您可以改為更新 <code>styles.xml</code> 檔案，使用 <code>@dimen/min_text_height</code>。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Widget.TipTime.TextView&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Widget.MaterialComponents.TextView&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:minHeight&quot;</span>&gt;</span>@dimen/min_text_height<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:gravity&quot;</span>&gt;</span>center_vertical<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:textAppearance&quot;</span>&gt;</span>?attr/textAppearanceBody1<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h5 id="將這些樣式加入您的佈景主題"><a href="#將這些樣式加入您的佈景主題" class="headerlink" title="將這些樣式加入您的佈景主題"></a>將這些樣式加入您的佈景主題</h5><p>您可能已經注意到，您尚未將新的 <code>RadioButton</code> 和 <code>Switch</code> 樣式套用至各別的小工具。這是因為您需要使用佈景主題屬性來設定應用程式佈景主題中的 <code>radioButtonStyle</code> 和 <code>switchStyle</code>。讓我們複習一下何為主題。</p>
<p>佈景主題是一組具名資源 (名為佈景主題屬性)，方便之後在樣式、版面配置等中參照。您可以指定整個應用程式、活動或檢視區塊階層的佈景主題，而不只是指定個別 <code>View</code>。您先前在 <code>themes.xml</code> 中設定了 <code>colorPrimary</code> 和 <code>colorSecondary</code> 等佈景主題屬性，藉此修改應用程式的佈景主題，然後在應用程式和其元件中使用這些佈景主題。</p>
<p><code>radioButtonStyle</code> 和 <code>switchStyle</code> 是其他可設定的主題屬性。您為這些佈景主題屬性提供的樣式資源，會套用至每個圓形按鈕以及佈景主題所套用的檢視區塊階層中的每個切換按鈕。</p>
<p>此外，還有適用於 <code>textInputStyle</code> 的主題屬性，當中指定的樣式資源會套用至應用程式中的所有文字輸入欄位。如要讓 <code>TextInputLayout</code> 呈現加上外框的文字欄位外觀 (如 Material Design 指南所述)，可以使用 MDC 程式庫中定義為 <code>Widget.MaterialComponents.TextInputLayoutOutlinedBox</code> 的 <code>OutlinedBox</code> 樣式。這是您將使用的樣式。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/2b2a5836a5d9bedf_1920.png?hl=zh-tw" width="30%" height="30%">

<ol>
<li>修改 <code>themes.xml</code> 檔案，讓主題參照所需樣式。設定佈景主題屬性的方式與先前在程式碼研究室中宣告 <code>colorPrimary</code> 和 <code>colorSecondary</code> 佈景主題屬性的方式相同。不過，相關的佈景主題屬性為 <code>textInputStyle</code>、<code>radioButtonStyle</code> 和 <code>switchStyle</code>。您會使用先前為 <code>RadioButton</code> 和 <code>Switch</code> 建立的樣式，以及 Material <code>OutlinedBox</code> 的文字欄位的樣式。</li>
</ol>
<p>將下列內容複製到 <code>res/values/themes.xml</code> 而複製到應用程式佈景主題的樣式標記。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;textInputStyle&quot;</span>&gt;</span>@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;radioButtonStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.RadioButton<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;switchStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.Switch<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><code>res/values/themes.xml</code> 檔案看起來會像這樣。您可以視需要在 XML 中加入註解 (以 <code>&lt;!--</code> 和 <code>--&gt;</code> 表示)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        ...</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> <span class="attr">tools:targetApi</span>=<span class="string">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Text input fields --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;textInputStyle&quot;</span>&gt;</span>@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Radio buttons --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;radioButtonStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.RadioButton<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Switches --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;switchStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.Switch<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>請務必對 <code>themes.xml (night)</code> 中的深色佈景主題進行相同變更。您的 <code>res/values-night/themes.xml</code> 檔案看起來會像這樣。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Application theme for dark theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.MaterialComponents.DayNight.DarkActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        ...</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> <span class="attr">tools:targetApi</span>=<span class="string">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Text input fields --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;textInputStyle&quot;</span>&gt;</span>@style/Widget.MaterialComponents.TextInputLayout.OutlinedBox<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- For radio buttons --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;radioButtonStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.RadioButton<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- For switches --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;switchStyle&quot;</span>&gt;</span>@style/Widget.TipTime.CompoundButton.Switch<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>執行應用程式並查看變更。文字欄位的 <code>OutlinedBox</code> 樣式看起來更好，所有文字現在看起來都一致！</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/31ac15991713b031_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/3e861407146c9ed4_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>我的實作畫面：</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/py1EnmF.png">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://i.imgur.com/Juo2DFT.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<hr>
<h4 id="加強使用者體驗"><a href="#加強使用者體驗" class="headerlink" title="加強使用者體驗"></a>加強使用者體驗</h4><p>隨著您即將完成應用程式，除了應該使用預期的工作流程測試應用程式外，也應在其他使用者情境中進行測試。您可能會發現，稍微修改程式碼就能大幅提升使用者體驗。</p>
<h5 id="旋轉裝置"><a href="#旋轉裝置" class="headerlink" title="旋轉裝置"></a>旋轉裝置</h5><ol>
<li>旋轉裝置，切換為<strong>橫向模式</strong>。您可能需要先啟用「自動旋轉」設定，這項設定位於裝置的「<a href="https://support.google.com/android/answer/9083864?hl=zh-Hant">快速設定</a>」選單中。此外，也可以依序前往「設定」&gt;「螢幕」&gt;「進階」，就能找到「自動旋轉螢幕」選項。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/f2edb1ae9926d5f1_1920.png?hl=zh-tw" width="30%" height="30%">

<p>在模擬器中，您可以使用靠近裝置右上角的模擬器選項，將畫面向右或向左旋轉。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/2bc08f73d28968cb_1920.png?hl=zh-tw" width="10%" height="10%">

<ol start="2">
<li>您會發現部分使用者介面元件 (包括「Calculate」按鈕) 遭到截斷。這顯然使您無法使用應用程式！</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/d73499f9c9d2b330_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="3">
<li>若要解決這個問題，請在 <code>ConstraintLayout</code> 四周加入 <code>ScrollView</code>，然後執行Reformat code。您的 XML 看起來有些像這樣。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ScrollView</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line">   <span class="tag">&lt;/<span class="name">ConstraintLayout</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">ScrollView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>再次執行並測試應用程式。將裝置旋轉為橫向模式時，您應能捲動 UI 來存取計算按鈕，並查看小費計算結果。此修正功能不僅可用於橫向模式，而且也適用於其他不同尺寸的 Android 裝置。現在無論裝置螢幕大小為何，使用者都可以捲動瀏覽版面配置。</li>
</ol>
<img src="https://i.imgur.com/lzCsDea.gif" width="70%" height="70%">

<h5 id="按下-Enter-鍵隱藏鍵盤"><a href="#按下-Enter-鍵隱藏鍵盤" class="headerlink" title="按下 Enter 鍵隱藏鍵盤"></a>按下 Enter 鍵隱藏鍵盤</h5><p>您可能已注意到，輸入服務費後，鍵盤仍會保持顯示狀態。每次使用「calculate」按鈕都需要手動隱藏鍵盤會有點麻煩。改為按下 Enter 鍵時，讓鍵盤自動隱藏。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/e2c3a3dbc40218a2_1920.png?hl=zh-tw" width="30%" height="30%">

<p>您可以定義文字欄位的鍵事件監聽器，使得可回應於使用者輕觸特定按鍵的事件。鍵盤上每個可能的輸入項目選項都有相關聯的按鍵碼，包括 Enter 鍵。請注意，螢幕小鍵盤 (又稱為螢幕鍵盤) 與實體鍵盤不同。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/1c95d7406d3847fe_1920.png?hl=zh-tw" width="30%" height="30%">

<p>在這項工作中，您要在文字欄位中設定按鍵事件監聽器，用於監聽使用者何時按下 Enter 鍵。偵測到這項事件後，就要隱藏鍵盤。</p>
<p>複製以下輔助方法，並貼到 MainActivity 類別中。您可以插入在 MainActivity 類別的大括號之前。<code>handleKeyEvent()</code> 是一種私人輔助函式，可以在 <code>keyCode</code> 輸入參數等於 <code>KeyEvent</code>.<code>KEYCODE_ENTER</code> 時隱藏螢幕小鍵盤。<a href="https://developer.android.com/reference/android/view/inputmethod/InputMethodManager">InputMethodManager</a> 可控制是否要顯示螢幕鍵盤、隱藏螢幕鍵盤，及讓使用者能夠自行選擇要顯示的螢幕鍵盤。如果系統處理了按鍵事件，此方法會傳回 true，否則會傳回 false。</p>
<p><code>MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handleKeyEvent</span><span class="params">(view: <span class="type">View</span>, keyCode: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">   <span class="keyword">if</span> (keyCode == KeyEvent.KEYCODE_ENTER) &#123;</span><br><span class="line">       <span class="comment">// Hide the keyboard</span></span><br><span class="line">       <span class="keyword">val</span> inputMethodManager =</span><br><span class="line">           getSystemService(Context.INPUT_METHOD_SERVICE) <span class="keyword">as</span> InputMethodManager</span><br><span class="line">       inputMethodManager.hideSoftInputFromWindow(view.windowToken, <span class="number">0</span>)</span><br><span class="line">       <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>現在，請在 <code>TextInputEditText</code> 小工具上附加按鍵事件監聽器。請記住，您可以透過 <code>binding.costOfServiceEditText</code> 等繫結物件存取 <code>TextInputEditText</code> 小工具。</li>
</ol>
<p>請在 <code>costOfServiceEditText</code> 上呼叫 <code>setOnKeyListener()</code> 方法，然後傳入 <code>OnKeyListener</code>。這個做法類似在應用程式中使用 <code>binding.calculateButton.setOnClickListener &#123; calculateTip() &#125;</code>，設定「calculate」按鈕點擊事件監聽器。</p>
<p>在檢視畫面上設定按鍵事件監聽器的程式碼較為複雜，但大致來說，<code>OnKeyListener</code> 具有可在使用者按下按鍵時觸發的 <code>onKey()</code> 方法。<code>onKey()</code> 方法採用 3 個輸入引數：檢視畫面、已按下按鍵的程式碼，及按鍵事件 (您不會用到，因此您可以將其稱作「<code>_</code>」)。呼叫 <code>onKey()</code> 方法時，應呼叫 <code>handleKeyEvent()</code> 方法，並傳遞檢視畫面和按鍵碼引數。編寫此功能的語法為 <code>view, keyCode, _ -&gt; handleKeyEvent(view, keyCode)</code>。其實這種語法稱為 lambda 運算式，您將在後續單元中進一步瞭解 lambda。</p>
<p>請新增程式碼，設定活動 <code>onCreate()</code> 方法內文字欄位的按鍵事件監聽器。這樣一來，就能在建立版面配置後，以及使用者開始與活動互動前，立即附加按鍵事件監聽器。</p>
<p><code>MainActivity.kt</code></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">   setContentView(binding.root)</span><br><span class="line"></span><br><span class="line">   binding.calculateButton.setOnClickListener &#123; calculateTip() &#125;</span><br><span class="line"></span><br><span class="line">   binding.costOfServiceEditText.setOnKeyListener &#123; view, keyCode, _ -&gt; handleKeyEvent(view, keyCode)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>測試新的變更是否正常運作。執行應用程式並輸入服務費。按下鍵盤上的 Enter 鍵就會隱藏螢幕鍵盤。</li>
</ol>
<h5 id="選用-調整向量可繪項目的色調"><a href="#選用-調整向量可繪項目的色調" class="headerlink" title="(選用) 調整向量可繪項目的色調"></a>(選用) 調整向量可繪項目的色調</h5><p>在此選用工作中，您將依據主題的主要顏色為圖示上色，讓淺色主題和深色主題中的圖示看起來不同 (如下所示)。這項變更是為了美化 UI，使圖示更貼合應用程式主題。</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/77092f702beb1cfb_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/80a390087905eb29_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<p>如先前所述，與點陣圖圖像相比，<code>VectorDrawables</code> 的優點之一就是能夠縮放圖像及上色。下方的 XML 代表鈴鐺圖示。請留意 <code>android:tint</code> 和 <code>android:fillColor</code> 這兩種顏色屬性。</p>
<p><code>ic_service.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:width</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:height</span>=<span class="string">&quot;24dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:viewportWidth</span>=<span class="string">&quot;24&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:viewportHeight</span>=<span class="string">&quot;24&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:tint</span>=<span class="string">&quot;?attr/colorControlNormal&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">path</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:fillColor</span>=<span class="string">&quot;@android:color/white&quot;</span></span></span><br><span class="line"><span class="tag">     <span class="attr">android:pathData</span>=<span class="string">&quot;M2,17h20v2L2,19zM13.84,7.79c0.1,-0.24 0.16,-0.51 0.16,-0.79 0,-1.1 -0.9,-2 -2,-2s-2,0.9 -2,2c0,0.28 0.06,0.55 0.16,0.79C6.25,8.6 3.27,11.93 3,16h18c-0.27,-4.07 -3.25,-7.4 -7.16,-8.21z&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/aab70a5d4eaabdc7_1920.png?hl=zh-tw" width="30%" height="30%">

<p>如果有色調，則會覆寫可繪項目的任何 <code>fillColor</code> 指令。在這種情況下，系統會用 <code>colorControlNormal</code> 佈景主題屬性覆寫白色顏色。<code>colorControlNormal</code> 是小工具的「一般」(未選取&#x2F;未啟用狀態) 顏色。目前是灰色。</p>
<p>我們針對應用程式執行的一項視覺強化操作，就是根據應用程式佈景主題的主要顏色為可繪項目調色。在淺色主題中，圖示會顯示為 <code>@color/green</code>；在深色主題中，圖示則會顯示為 <code>@color/green_light</code>，也就是 <code>?attr/colorPrimary</code>。根據應用程式主題的主要顏色為可繪項目上色，可以讓版面配置中的元素看起來更融合一致。這樣也不必複製淺色主題和深色主題的各組圖示。只要準備 1 組向量可繪項目就好，而且色調會根據 <code>colorPrimary</code> 主題屬性而改變。</p>
<ol>
<li>變更 ic_service.xml 中 android:tint 屬性的值</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:tint=&quot;?attr/colorPrimary&quot;</span><br></pre></td></tr></table></figure>

<p>在 Android Studio 中，圖示現在有適當的色調。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-polished-user-experience/img/f0b8f59dbf00a20b_1920.png?hl=zh-tw" width="70%" height="70%">

<p><code>colorPrimary</code> 主題屬性指向的值會因淺色主題和深色主題而有所不同。</p>
<ol start="2">
<li>重複上述步驟，變更其他向量可繪項目的色調</li>
</ol>
<p><code>ic_store.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:tint</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>ic_round_up.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">vector</span> <span class="attr">...</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:tint</span>=<span class="string">&quot;?attr/colorPrimary&quot;</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">vector</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>執行應用程式，確認圖示在淺色和深色主題中的顯示方式不同。</p>
</li>
<li><p>作為最後的清理步驟，請記得重新設定應用程式中所有 XML 和 Kotlin 程式碼檔案的格式。</p>
</li>
</ol>
<p>我的實作畫面：</p>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://i.imgur.com/l5p0Vf5.png">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://i.imgur.com/Tijw0A1.png">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Material Design</tag>
        <tag>Material Component</tag>
        <tag>User Experience</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(13)-更改應用圖示</title>
    <url>/2023/09/17/Android%E7%AD%86%E8%A8%98-13-%E6%9B%B4%E6%94%B9%E6%87%89%E7%94%A8%E5%9C%96%E7%A4%BA/</url>
    <content><![CDATA[<blockquote>
<p>使用 Android Studio 中的 Image Asset Studio 工具，更改應用程式的啟動器圖示(launcher icon)。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何變更應用程式的啟動器圖示</li>
<li>如何在 Android Studio 中使用 <strong>Image Asset Studio</strong> 產生啟動器圖示素材資源</li>
<li>自動調整圖示的含意，以及其包含兩個圖層的原因</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="應用程式圖示-App-Icons-簡介"><a href="#應用程式圖示-App-Icons-簡介" class="headerlink" title="應用程式圖示(App Icons)簡介"></a>應用程式圖示(App Icons)簡介</h4><p>應用程式圖示(app icon)是辨認應用程式的重要方式，通常會在多個位置顯示，包括主畫面、「所有應用程式」畫面和「設定」應用程式。<br>應用程式圖示亦稱為啟動器圖示(launcher icon)，啟動器(Launcher)是指您在 Android 裝置上按下主畫面按鈕，以檢視和整理應用程式、新增小工具和捷徑等操作時看到的圖示。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/491033b9aaa5d6bb_1920.png?hl=zh-tw" width="30%" height="30%">

<p>如果您用過不同的 Android 裝置，可能會發現啟動器的體驗會因裝置製造商不同而有差異。有時候，裝置製造商會打造品牌專屬的自訂啟動器體驗。在這過程中，不同製造商可能會以不同形狀顯示應用程式圖示，而不是上圖顯示的圓形圖示。</p>
<p>例如，他們會以正方形、圓角正方形或方圓形 (介於正方形和圓形之間) 顯示所有應用程式圖示。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/16e235142627947_1920.png?hl=zh-tw" width="50%" height="50%">

<p>不論裝置製造商選擇哪種形狀，其目的都是為了讓所有應用程式圖示能在單一裝置上顯示統一的形狀，以便提供更一致的使用者體驗。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/3c94e41bcbfd9a3c_1920.png?hl=zh-tw" width="30%" height="30%">

<p>這就是 Android 平台支援自動調整圖示 (自 API 級別 26 起) 的原因。為應用程式實作自動調整圖示後，您的應用程式就能因應各種裝置，適當地顯示高品質的應用程式圖示。</p>
<p>本程式碼研究室提供小費計算機啟動器圖示的圖片來源檔案，以供您練習。您會使用 Android Studio 中名為「Image Asset Studio」的工具，來產生各種所需啟動器圖示的版本。之後，您便可將所學知識應用到變更其他應用程式的應用程式圖示上！</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/8346813da9e7c99e_1920.png?hl=zh-tw" width="15%" height="15%">

<hr>
<h4 id="啟動器圖示-Launcher-Icons"><a href="#啟動器圖示-Launcher-Icons" class="headerlink" title="啟動器圖示(Launcher Icons)"></a>啟動器圖示(Launcher Icons)</h4><p>這步驟的目的是讓啟動器圖示有精美的外觀 (清晰簡潔)，而不受裝置型號或螢幕密度所影響。具體來說，螢幕像素密度是指螢幕上每英寸的像素數 (或以 dpi 表示)。如果是中密度(medium-density)裝置 (mdpi)，螢幕上每英寸像素數為 160；至於 extra-extra-extra-high-density 密度的裝置 (xxxhdpi)，螢幕上每英寸像素數則為 640。</p>
<p>為符合不同螢幕密度的裝置，您須提供不同版本的應用程式圖示。</p>
<h5 id="探索啟動器圖示檔案"><a href="#探索啟動器圖示檔案" class="headerlink" title="探索啟動器圖示檔案"></a>探索啟動器圖示檔案</h5><ol>
<li><p>請開啟 Android Studio 中的「小費計算機專案」。由於是從範本開始建立應用程式，應該已有 Android Studio 提供的預設啟動器圖示。</p>
</li>
<li><p>在「Project」視窗中，切換至「Project」檢視畫面。系統會根據檔案儲存電腦中的檔案結構，在專案中顯示檔案。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/8a9317d3f5e6dba6_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="3">
<li>前往資源目錄 (app &gt; src &gt; main &gt; res)，然後展開部分 <code>mipmap</code> 資料夾。您應將 Android 應用程式的啟動器圖示素材資源放在這些 <code>mipmap</code> 資料夾中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/2e9641406d006778_1920.png?hl=zh-tw" width="30%" height="30%">

<p><code>mdpi</code>、<code>hdpi</code>、<code>xhdpi</code> 等都是像素密度限定詞，您可以將其附加到資源目錄名稱 (例如 <code>mipmap</code>) 上，表示這些資源適用於特定螢幕密度的裝置。以下列出 Android 的<a href="https://developer.android.com/training/multiscreen/screendensities#TaskProvideAltBmp">像素密度限定詞</a>：</p>
<ul>
<li><code>mdpi</code>：適用於中密度螢幕 (約 160 dpi) 的資源</li>
<li><code>hdpi</code>：適用於高密度螢幕 (約 240 dpi) 的資源</li>
<li><code>xhdpi</code>：適用於 extra-high 密度螢幕 (約 320 dpi) 的資源</li>
<li><code>xxhdpi</code>：適用於 extra-extra-high 像素密度螢幕 (約 480dpi) 的資源。</li>
<li><code>xxxhdpi</code>：適用於 extra-extra-extra-high 密度螢幕 (約 640 dpi) 的資源</li>
<li><code>nodpi</code>：不論螢幕的像素密度為何都不能縮放的資源</li>
<li><code>anydpi</code>：可調整為各種密度的資源</li>
</ul>
<ol start="4">
<li>按一下圖片檔，您就會看到預覽畫面。<code>ic_launcher.png</code> 檔案包含圖示的正方形版本，<code>ic_launcher_round.png</code> 檔案則包含圖示的圓形版本。每個資源目錄中都會提供這兩個版本。</li>
</ol>
<p>舉例來說，以下是 res &gt; mipmap-xxxhdpi &gt; ic_launcher_round.png 的顯示效果。另請注意，相應的資源素材尺寸位於右上方。此圖片的尺寸為 192px x 192px。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/c5d4f66cfbf1c046_1920.png?hl=zh-tw" width="30%" height="30%"></p>
<p>而這是 res &gt; mipmap-mdpi &gt; ic_launcher_round.png 的顯示效果。尺寸只有 48px x 48px。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/aadadc11db9ef0f0_1920.png?hl=zh-tw" width="30%" height="30%"></p>
<p>如您所見，這些點陣圖圖片檔是由固定的像素格線組成，是針對特定螢幕解析度而建立的。因此，如果您調整其大小，畫質可能會降低。</p>
<p>如果你縮小點陣圖圖片，由於您去除像素資訊，因此應該沒問題。如果您大幅放大點陣圖圖片，由於 Android 需要推測並填入缺少的像素資訊，因此圖片會顯得模糊不清。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>為了避免應用程式圖示模糊不清，請務必為每個密度級別 (例如 <b>mdpi</b>、<b>hdpi</b>、<b>xhdpi</b> 等) 提供不同的應用程式圖示點陣圖圖片。請注意，裝置螢幕密度未必剛好是 160dpi、240dpi、320dpi 等等…Android 會根據目前螢幕的密度，按最接近的密度級別選取資源，然後再將其縮小。</p>
          </div>

<hr>
<h4 id="自動調整圖示"><a href="#自動調整圖示" class="headerlink" title="自動調整圖示"></a>自動調整圖示</h4><h5 id="前景與背景圖層"><a href="#前景與背景圖層" class="headerlink" title="前景與背景圖層"></a>前景與背景圖層</h5><p>自 <a href="https://developer.android.com/about/versions/oreo">Android 8.0 版本</a> (API 級別 26) 起，系統便支援自動調整啟動器圖示，能讓應用程式圖示更加靈活，也能呈現出有趣的視覺效果。對開發人員來說，這表示應用程式圖示是由前景和背景這兩個圖層組成。</p>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-change-app-icon/img/1af36983e3677abe.gif" width="50%" height="50%">

<p>在上述例子中，白色的 Android 圖示位於前景圖層，藍色和白色的格線位於背景圖層。前景圖層會堆疊在背景圖層上方。然後，系統會在其上套用遮罩 (本例子套用圓形遮罩)，以產生圓形的應用程式圖示。</p>
<h5 id="探索自動調整圖示檔案"><a href="#探索自動調整圖示檔案" class="headerlink" title="探索自動調整圖示檔案"></a>探索自動調整圖示檔案</h5><p>請查看 Android Studio 專案範本提供的預設自動調整圖示檔案。</p>
<ol>
<li>在 Android Studio 的「Project」視窗中，找出並展開「res &gt; mipmap-anydpi-v26」 資源目錄。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/46626096e5e73515_1920.png?hl=zh-tw" width="30%" height="30%">

<div class="note no-icon success">
            <p><strong>注意：</strong>自動調整圖示新增到平台的 API 級別 26，因此自動調整圖示應是在具有 <b>-v26</b> 資源限定詞的 <b>mipmap</b> 資源目錄中宣告。這表示此目錄中的資源僅適用於執行 API 26 (Android 8.0) 以上版本的裝置。執行舊版平台的裝置會忽略此目錄中的資源檔案。</p>
          </div>

<ol start="2">
<li><p>開啟其中一個 XML 檔案，例如 <code>ic_launcher.xml</code>。您應該會看到：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">adaptive-icon</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">background</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/ic_launcher_background&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">foreground</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/ic_launcher_foreground&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">monochrome</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/ic_launcher_foreground&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">adaptive-icon</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>請注意，<code>&lt;adaptive-icon&gt;</code> 元素如何藉由向應用程式圖示的 <code>&lt;background&gt;</code> 和 <code>&lt;foreground&gt;</code> 圖層分別提供資源可繪項目，以完成對它們的宣告。</p>
</li>
<li><p>返回「Project」檢視畫面，然後尋找宣告可繪項目的位置：「drawable」&gt;「ic_launcher_ background.xml」和「drawable-v24」&gt;「ic_launcher_foreground.xml」。</p>
</li>
<li><p>切換至「Design」檢視畫面，查看每個圖層的預覽效果 (左側是背景、右側是前景)。</p>
</li>
</ol>
<div style="display: flex;justify-content: center;">
    <div style="width:30%;float:left;margin-right:10px;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/5ee8395bb0bcd6f_1920.png?hl=zh-tw">
    </div>
    <div style="width:30%;float:left;">
        <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/2056a49400206309_1920.png?hl=zh-tw">
    </div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div>

<ol start="6">
<li>以上兩者都是向量可繪項目檔案，皆沒有以像素為單位的固定尺寸。如果您切換到「Code」檢視畫面，就會看到使用 <code>&lt;vector&gt;</code> 元素對向量可繪項目做出的 XML 宣告。</li>
</ol>
<p>雖然向量可繪項目(vector drawable)和點陣圖(bitmap)圖片描述的都是圖像，但二者之間仍有重大差異。</p>
<p>除了各像素的色彩資訊外，點陣圖圖片對其持有的圖片不太理解。另一方面，向量圖形則瞭解如何繪製用於定義圖片的形狀。這些操作說明是由一組點、線、曲線以及相關色彩資訊所組成。這種做法的好處，在於向量圖形可以針對各種螢幕密度的任意畫布尺寸進行縮放，而不會降低畫質。</p>
<p>「<a href="https://developer.android.com/develop/ui/views/graphics/vector-drawable-resources">向量可繪項目(vector drawable)</a>」是指 Android 實作的向量圖形，以便在行動裝置上提供彈性。您可以利用這些<a href="https://developer.android.com/reference/kotlin/android/graphics/drawable/VectorDrawable">可能元素</a>在 XML 中對其加以定義。您只需定義圖片一次，而不必針對所有密度級別提供點陣圖素材資源的版本。這樣可以縮減應用程式的大小，讓應用程式更便於維護。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong>選擇使用向量可繪項目或點陣圖圖片時，需要<a href="https://medium.com/androiddevelopers/understanding-androids-vector-image-format-vectordrawable-ab09e41d5c68">權衡優缺點</a>。舉例來說，圖示由簡單的形狀組成，因此可以向量可繪項目便不失為理想的選擇；而圖片則難以透過一系列形狀加以描述。在這種情況下，使用點陣圖素材資源會更有效率。</p>
          </div>

<hr>
<h4 id="下載新素材資源"><a href="#下載新素材資源" class="headerlink" title="下載新素材資源"></a>下載新素材資源</h4><p>接下來，請下載下面 2 個新的素材資源，以便為小費計算機應用程式建立自動調整圖示。別擔心，您不用理解向量可繪項目檔案的所有細節。您可以使用設計工具自動產生其中的內容。</p>
<ol>
<li><p>下載 <a href="https://raw.githubusercontent.com/google-developer-training/android-basics-kotlin-tip-calculator-app-solution/main/app/src/main/res/drawable-anydpi-v26/ic_launcher_background.xml"><code>ic_launcher_background.xml</code></a>，即背景圖層的向量可繪項目。如果瀏覽器僅顯示檔案而並未下載，請依序選取「File」&gt;「Save Page As…」，將檔案儲存到您的電腦。</p>
</li>
<li><p>下載 <a href="https://raw.githubusercontent.com/google-developer-training/android-basics-kotlin-tip-calculator-app-solution/main/app/src/main/res/drawable-anydpi-v26/ic_launcher_foreground.xml"><code>ic_launcher_foreground.xml</code></a>，即前景圖層的向量可繪項目。</p>
</li>
</ol>
<p>請注意，系統對這些前景和背景圖層素材資源設有特定要求，例如兩者的大小都必須為 108dp x 108dp。如要進一步瞭解相關要求，請參閱<a href="https://developer.android.com/reference/kotlin/android/graphics/drawable/AdaptiveIconDrawable">這篇文章</a>；您也可以參閱 Material 網站上的 <a href="https://m2.material.io/design/platform-guidance/android-icons.html">Android 圖示設計指南</a>。</p>
<p>由於圖示的邊緣可能會依據裝置製造商的遮罩形狀而遭到裁剪，因此請務必將圖示的重要資訊放在<a href="https://medium.com/google-design/designing-adaptive-icons-515af294c783">「安全區域」</a>，亦即位於圖層中央且直徑為 66dp 的圓形範圍。位於該安全區域之外的內容不應含有重要資訊 (例如背景顏色)，這樣即使遭到裁剪也不會有任何影響。</p>
<hr>
<h4 id="變更應用程式圖示"><a href="#變更應用程式圖示" class="headerlink" title="變更應用程式圖示"></a>變更應用程式圖示</h4><p>返回 Android Studio 以使用新素材資源。</p>
<ol>
<li>請先刪除具備 Android 圖示和綠色格狀背景的舊版可繪製資源。在「Project」檢視畫面中，在檔案上按一下滑鼠右鍵，然後選擇「Delete」。</li>
</ol>
<p>刪除以下檔案：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drawable/ic_launcher_background.xml</span><br><span class="line">drawable-v24/ic_launcher_foreground.xml</span><br></pre></td></tr></table></figure>

<p>您可以取消勾選「Safe delete (with usage search)」方塊，然後按一下「OK」。</p>
<ol start="2">
<li>建立新的<code>圖片素材資源(Image Asset)</code>。在「res」目錄上按一下滑鼠右鍵，然後依序選擇「New」&gt;「Image Asset」。或者，您也可以點選「Resource Manager」分頁標籤，然後按一下「+」圖示並選取「Image Asset」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/e9c481d4823a371_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="3">
<li><p>系統會開啟 Android Studio 的「Image Asset Studio」工具。</p>
</li>
<li><p>保留預設設定：<br>Icon Type: <code>Launcher Icons (Adaptive and Legacy)</code><br>Name: <code>ic_launcher</code></p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/27554596e4c0bdc6_1920.png?hl=zh-tw" width="90%" height="90%">
</li>
<li><p>選取「Foreground Layer」分頁籤標後，前往「Source Asset」子區段。在「Path」欄位中，按一下資料夾圖示。</p>
</li>
<li><p>系統會顯示彈出式視窗，方便您瀏覽電腦及選取檔案。找出你剛在電腦上下載的新 <code>ic_launcher_foreground.xml</code> 檔案位置。檔案可能儲存在電腦的「下載」資料夾中。找到後，按一下「開啟」。</p>
</li>
<li><p>「Path」現已更新為新前景向量可繪項目的位置。維持「Layer Name」為「ic_launcher_foreground」，而「Asset Type」為「Image」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/29ae558130f1119b_1920.png?hl=zh-tw" width="40%" height="40%">

<ol start="8">
<li><p>接下來，切換至「Background Layer」分頁標籤。保留預設值。按一下「Path」的資料夾圖示。</p>
</li>
<li><p>找出剛才下載的 <code>ic_launcher_background.xml</code> 檔案位置。按一下「Open」。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/8d1caf48e35b4560_1920.png?hl=zh-tw" width="40%" height="40%">

<ol start="10">
<li>選取新的資源檔案時，預覽內容應會隨之更新。以下是使用新前景和背景圖層的畫面。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/1b4696b1ac6e657d_1920.png?hl=zh-tw" width="50%" height="50%">

<p>利用兩個圖層呈現應用程式圖示後，裝置製造商 (稱為原始設備製造商或簡稱 OEM) 可能會根據 Android 裝置建立不同的形狀，如上方預覽所示。原始設備製造商 (OEM) 提供的遮罩可套用至裝置上的所有應用程式圖示。</p>
<p>這個遮罩會套用到應用程式圖示的前景和背景圖層上。以下是圓形遮罩和正方形遮罩的例子。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/fd16968065745024_1920.png?hl=zh-tw" width="60%" height="60%">

<p>如果為應用程式圖示的兩個圖層都套用圓形遮罩，就會產生一個含有藍色格線背景的圓形圖示，當中包含 Android 圖示 (如上方左圖)。或者，您可以套用正方形遮罩，產生如上方右圖的應用程式圖示。</p>
<p>此外，使用兩個圖層可以呈現有趣的視覺效果，原因為這兩個圖層可以單獨移動或縮放。請查看「Design Considerations」底下的這篇<a href="https://medium.com/google-design/designing-adaptive-icons-515af294c783">網誌文章</a>，瞭解一些視覺效果的有趣例子。由於您無法預知使用者會使用哪種裝置，或是 OEM 會為您的圖示套用哪種遮罩，因此您必須設定自動調整圖示，以免重要資訊遭到截斷。</p>
<ol start="11">
<li>請確認前景圖層的主要內容 (在本例中為服務鈴圖示) 位於安全區域內，不會遭到不同遮罩形狀裁剪。如果重要內容會遭到裁剪或顯得過小，您可以使用各圖層「Scaling」區段下方的「Resize」滑桿進行調整。在本例子中，您不需要調整大小，因此可將大小保持為 100%。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/f6420a0476bcd44c_1920.png?hl=zh-tw" width="40%" height="40%">

<ol start="12">
<li><p>按一下「Next」。</p>
</li>
<li><p>這個步驟是「Confirm Icon Path」。按一下個別檔案即可查看預覽畫面。畫面底部也會顯示一則警示，提醒將會覆蓋部分現有檔案 (以紅色顯示)。別擔心，這些是用於先前應用程式圖示的舊檔案。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/5c5280cd079c4a86_1920.png?hl=zh-tw" width="70%" height="70%">

<ol start="14">
<li><p>預設值沒有問題，請按一下「Finish」。</p>
</li>
<li><p>確認 mipmap 資料夾中所有產生的素材資源皆正確顯示。例如：</p>
<div style="display: flex;justify-content: center;">
<div style="width:20%;float:left;margin-right:10px;">
    <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/6e03dc79a82c2e0d_1920.png?hl=zh-tw">
</div>
<div style="width:20%;float:left;">
    <img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/954e70ddbc5b7901_1920.png?hl=zh-tw">
</div>
<div style="clear:both;"></div><!--這是用來清除上方的浮動效果-->
</div></li>
</ol>
<h5 id="將向量可繪項目檔案移到-v26-目錄"><a href="#將向量可繪項目檔案移到-v26-目錄" class="headerlink" title="將向量可繪項目檔案移到 -v26 目錄"></a>將向量可繪項目檔案移到 -v26 目錄</h5><p>您可能會發現到，背景素材資源位於 <code>drawable-v24</code> 資料夾，前景素材資源位於 <code>drawable</code> 資料夾，具體取決於您應用程式的最低 SDK 版本。這是因為背景素材資源包含漸變效果，是 Android 7.0 版本 (亦稱為 API 版本 24，因此使用 <code>-v24</code> 資源限定詞) 起開始提供的功能。前景素材資源未包含漸層效果，所以會放在基本 <code>drawable</code> 資料夾中。</p>
<p>請將兩個向量可繪項目檔案都移到 <code>-v26</code> 資源目錄中，而不要將前景和背景素材資源分別放在兩個不同的 <code>drawable</code> 資料夾。由於這些素材資源只會用於自動調整圖示，只有 API 26 以上版本才需要這兩個可繪項目。下列資料夾結構可協助您輕鬆找出及管理自動調整圖示檔案。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drawable-anydpi-v26</span><br><span class="line">   ic_launcher_background.xml</span><br><span class="line">   ic_launcher_foreground.xml</span><br><span class="line">mipmap-anydpi-v26</span><br><span class="line">   ic_launcher.xml</span><br><span class="line">   ic_launcher_round.xml</span><br></pre></td></tr></table></figure>

<ol>
<li><p>請先建立 <code>drawable-anydpi-v26</code> 目錄。在「res」資料夾上按一下滑鼠右鍵。依序選取「New」&gt;「Android Resource Directory」。</p>
</li>
<li><p>畫面上顯示「New Resource Directory」對話方塊。選取下列選項：<br>「Directory name」：<code>drawable-anydpi-v26</code><br>「Resource type」：<code>drawable</code> (從下拉式選單選取)<br>「Source set」：<code>main</code> (保留預設值)</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/14b170ecd615cdca_1920.png?hl=zh-tw" width="70%" height="70%">

<p>按一下「OK」。在「Project」檢視畫面中，確認您已建立新的資源目錄「res &gt; drawable-anydpi-v26」。</p>
<ol start="3">
<li><p>在 <code>ic_launcher_foreground.xml</code> 檔案上按一下滑鼠左鍵，並將檔案從「drawable」資料夾拖曳至「drawable-anydpi-v26」資料夾。請注意，將資源放在「any dpi」目錄中，就表示這是可依據任何密度加以縮放的資源。</p>
</li>
<li><p>在 <code>ic_launcher_background.xml</code> 上按一下滑鼠左鍵，並從「drawable-v24」資料夾拖曳至「drawable-anydpi-v26」資料夾。</p>
</li>
<li><p>如果 <code>drawable-v24</code> 資料夾目前沒有任何內容，請刪除該資料夾。接著在該資料夾上按一下滑鼠右鍵，然後選取「Delete」。</p>
</li>
<li><p>點閱專案中的所有 <code>drawable</code> 和 <code>mipmap</code> 檔案，確定這些圖示的預覽畫面正確無誤。</p>
</li>
</ol>
<h5 id="測試應用程式"><a href="#測試應用程式" class="headerlink" title="測試應用程式"></a>測試應用程式</h5><ol>
<li>測試新的應用程式圖示是否會顯示。在你的裝置 (模擬器或實體裝置) 上執行應用程式。</li>
<li>按下裝置的主畫面按鈕。</li>
<li>向上滑動即可顯示「所有應用程式」清單。</li>
<li>尋找你剛才更新的應用程式。畫面中應會顯示新的應用程式圖示。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-icon/img/a0173e1403278227_1920.png?hl=zh-tw" width="15%" height="15%">

<p>注意：視裝置型號而定，您可能會看到不同形狀的啟動器圖示。儘管如此，您的前景圖層應會顯示於背景圖層上方，且已套用某種類型的遮罩。</p>
<h5 id="自動調整及舊版啟動器圖示"><a href="#自動調整及舊版啟動器圖示" class="headerlink" title="自動調整及舊版啟動器圖示"></a>自動調整及舊版啟動器圖示</h5><p>現在，自動調整圖示可以正常運作，您可能會好奇，為什麼無法刪除所有應用程式圖示的點陣圖圖片。您仍然需要這些檔案，才能讓應用程式在舊版 Android 裝置上呈現高品質圖示，這也就是所謂的回溯相容性。</p>
<p>在執行 Android 8.0 以上版本 (API 版本 26 以上版本) 的裝置上：</p>
<p>您可以使用<strong>自動調整圖示</strong> (前景向量可繪項目、背景向量可繪項目以及在上方套用 OEM 遮罩的組合)。專案中的相關檔案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res/drawable-anydpi-v26/ic_launcher_background.xml</span><br><span class="line">res/drawable-anydpi-v26/ic_launcher_foreground.xml</span><br><span class="line">res/mipmap-anydpi-v26/ic_launcher.xml</span><br><span class="line">res/mipmap-anydpi-v26/ic_launcher_round.xml</span><br></pre></td></tr></table></figure>

<p>在執行 Android 8.0 以下版本的裝置上 (但高於應用程式最低 API 級別要求)：<br>系統會使用舊版啟動器圖示 (不同密度級別 mipmap 資料夾中的點陣圖圖片)。專案中的相關檔案如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">res/mipmap-mdpi/ic_launcher.png</span><br><span class="line">res/mipmap-mdpi/ic_launcher_round.png</span><br><span class="line">res/mipmap-hdpi/ic_launcher.png</span><br><span class="line">res/mipmap-hdpi/ic_launcher_round.png</span><br><span class="line">res/mipmap-xhdpi/ic_launcher.png</span><br><span class="line">res/mipmap-xhdpi/ic_launcher_round.png</span><br><span class="line">res/mipmap-xxdpi/ic_launcher.png</span><br><span class="line">res/mipmap-xxdpi/ic_launcher_round.png</span><br><span class="line">res/mipmap-xxxdpi/ic_launcher.png</span><br><span class="line">res/mipmap-xxxdpi/ic_launcher_round.png</span><br></pre></td></tr></table></figure>

<p>基本上，Android 在較舊裝置上會退改用點陣圖圖片，且不支援自動調整圖示。</p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Material Design</tag>
        <tag>App Icon</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(12)-更改應用主題</title>
    <url>/2023/09/16/Android%E7%AD%86%E8%A8%98-12-%E6%9B%B4%E6%94%B9%E6%87%89%E7%94%A8%E4%B8%BB%E9%A1%8C/</url>
    <content><![CDATA[<blockquote>
<p>為應用選擇顏色，並利用主題在應用中一致地使用這個顏色。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何根據「Material Design原則」為應用程式選取有效顏色</li>
<li>如何為應用程式主題設定顏色</li>
<li>色彩的 RGB 元件</li>
<li>如何將樣式套用到 <code>View</code></li>
<li>使用主題變更應用程式的外觀</li>
<li>瞭解色彩對比的重要性</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="設計與顏色"><a href="#設計與顏色" class="headerlink" title="設計與顏色"></a>設計與顏色</h4><h5 id="Material-Design"><a href="#Material-Design" class="headerlink" title="Material Design"></a>Material Design</h5><ul>
<li><a href="https://m2.material.io/design/introduction">Material Design</a>以現實世界及物質紋理為靈感來源，包括物體反映光線和產生陰影的樣態。這套系統提供指南，協助您瞭解如何以具備可讀性、吸引力和一致性的方式建構應用程式 UI。</li>
<li><a href="https://m2.material.io/design/material-theming/overview.html#material-theming">Material Theming</a>可讓您針對應用程式調整質感設計，同時提供自訂顏色、字體和形狀指引。</li>
<li>Material Design 提供內建的基準主題，您可以直接套用，然後視需求微幅或大幅自訂，根據應用程式情況調整使用 Material 的方式。</li>
</ul>
<h5 id="顏色相關資訊"><a href="#顏色相關資訊" class="headerlink" title="顏色相關資訊"></a>顏色相關資訊</h5><p>無論是在現實世界或數位領域中，色彩無所不在。首先必須知道，並不是每個人都以相同方式看見顏色，因此您必須選擇可讓使用者有效使用應用程式的顏色。選用具備適當色彩對比度的顏色只是打造<a href="https://developer.android.com/guide/topics/ui/accessibility?hl=zh-tw">無障礙應用程式</a>的一環。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/55f93a1ea75d644a_1920.png?hl=zh-tw" width="30%" height="30%">

<p><a href="https://developer.android.com/reference/kotlin/android/graphics/Color">顏色</a>可用 3 個十六進位數字表示，#00-#FF (0-255) 代表該色彩的紅色、綠色和藍色 (RGB) 元件。數字越高，元件成分就越多。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/e0349c33dd6fbafe_1920.png?hl=zh-tw" width="30%" height="30%">

<p>請注意，您也可以定義顏色，包括 Alpha 值 #00-#FF，其代表透明度 (#00 &#x3D; 0% &#x3D; 完全透明，#FF &#x3D; 100% &#x3D; 完全不透明)。如果包含 Alpha 值，其為 4 個十六進位數字 (ARGB) 中的第一個。如果沒有 Alpha 值，系統會假設 #FF &#x3D; 100% 不透明。</p>
<p>不過，您不需要自行產生十六進位數字。您可透過幾款工具挑選顏色，讓系統為您產生數字。</p>
<p>您可能曾在 Android 應用程式的 <code>colors.xml</code> 檔案中看過某些範例，例如 100% 黑色 (R&#x3D;#00，G&#x3D;#00，B&#x3D;#00) 和 100% 白色 (R&#x3D;#FF，G&#x3D;#FF，B&#x3D;#FF)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span>#FFFFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="主題"><a href="#主題" class="headerlink" title="主題"></a>主題</h4><p>樣式可指定 <code>View</code> 的屬性，例如字型顏色、字型大小、背景顏色等。</p>
<p>**主題(Theme)**是套用至整個應用程式、活動或檢視區塊階層 (而不只是個別 <code>View</code>) 的樣式集合。將主題套用至應用程式、活動、檢視畫面或檢視區塊群組時，該主題會套用至該元素及其所有子項。主題也可以將樣式套用至非檢視元素，例如狀態列和視窗背景。</p>
<h5 id="建立Empty-Activity專案"><a href="#建立Empty-Activity專案" class="headerlink" title="建立Empty Activity專案"></a>建立Empty Activity專案</h5><p>如果您使用自己的應用程式，則可略過此部分。如果需要應用程式進行作業，請按照下列步驟建立「Empty Activity」應用程式。</p>
<ol>
<li>開啟 Android Studio。</li>
<li>使用Empty Activit範本建立新的 Kotlin 專案。</li>
<li>使用「TipTime」名稱。如果您未執行任何其他程式碼研究室，也可以保留預設名稱「My Application」。</li>
<li>請選取最低 API 級別 19 (KitKat)。</li>
<li>Android Studio 完成應用程式建立後，開啟 <code>activity_main.xml</code> (「app」&gt;「res」&gt;「layout」&gt;「activity_main.xml」)。</li>
<li>視需要切換至「程式碼」檢視畫面。</li>
<li>請將所有文字替換為此 XML：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">LinearLayout</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_margin</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/primary_color&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;12sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/button&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;48dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_marginTop</span>=<span class="string">&quot;8dp&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:gravity</span>=<span class="string">&quot;center_vertical&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/secondary_color&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textAllCaps</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:textSize</span>=<span class="string">&quot;12sp&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">com.google.android.material.floatingactionbutton.FloatingActionButton</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">&quot;center_horizontal&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:contentDescription</span>=<span class="string">&quot;@string/email_icon&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:srcCompat</span>=<span class="string">&quot;@android:drawable/ic_dialog_email&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="8">
<li>開啟 <code>strings.xml</code> (依序點選「app」&gt;「res」&gt;「values」&gt;「strings.xml」)。</li>
<li>請將所有文字替換為此 XML：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>TipTime<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;primary_color&quot;</span>&gt;</span>Primary color<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;button&quot;</span>&gt;</span>Button<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;secondary_color&quot;</span>&gt;</span>Secondary color<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;email_icon&quot;</span>&gt;</span>email icon<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>執行您的應用程式。應用程式應如以下螢幕截圖所示。</li>
</ol>
<img src="https://i.imgur.com/OigfAN0.png" width="30%" height="30%">

<p>應用程式包含 <code>TextView</code> 和 <code>Button</code>，可讓您查看顏色選項在實際 Android 應用程式中的呈現效果。在後續步驟中，我們會將按鈕顏色變更為主題的主要顏色。</p>
<h5 id="瞭解主題顏色"><a href="#瞭解主題顏色" class="headerlink" title="瞭解主題顏色"></a>瞭解主題顏色</h5><p>Android 應用程式 UI 的不同部分使用不同的顏色。為協助您在應用程式中以有意義的方式使用顏色，並一致地進行套用，主題系統會將顏色分為 <a href="https://m2.material.io/design/material-theming/implementing-your-theme.html#color">12 個已命名屬性</a> (與文字、圖示等項目使用的顏色相關)。您的主題不需指定所有屬性。您將會選擇主要和次要顏色，以及透過這些顏色繪製的文字和圖示顏色。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/af6c8e0d93135130_1920.png?hl=zh-tw" width="70%" height="70%">

<p>「上層」顏色會用於繪製在不同介面上的文字和圖示。</p>
<table>
<thead>
<tr>
<th align="left">#</th>
<th align="left">名稱</th>
<th align="left">主題屬性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1</td>
<td align="left">Primary(主要)</td>
<td align="left">colorPrimary</td>
</tr>
<tr>
<td align="left">2</td>
<td align="left">Primary Variant(主要變化版本)</td>
<td align="left">colorPrimaryVariant</td>
</tr>
<tr>
<td align="left">3</td>
<td align="left">Secondary(次要)</td>
<td align="left">colorSecondary</td>
</tr>
<tr>
<td align="left">4</td>
<td align="left">Secondary Variant(次要變化版本)</td>
<td align="left">colorSecondaryVariant</td>
</tr>
<tr>
<td align="left">5</td>
<td align="left">Background(背景)</td>
<td align="left">colorBackground</td>
</tr>
<tr>
<td align="left">6</td>
<td align="left">Surface(介面)</td>
<td align="left">colorSurface</td>
</tr>
<tr>
<td align="left">7</td>
<td align="left">Error(錯誤)</td>
<td align="left">colorError</td>
</tr>
<tr>
<td align="left">8</td>
<td align="left">On Primary(上層主要)</td>
<td align="left">colorOnPrimary</td>
</tr>
<tr>
<td align="left">9</td>
<td align="left">On Secondary(上層次要)</td>
<td align="left">colorOnSecondary</td>
</tr>
<tr>
<td align="left">10</td>
<td align="left">On Background(上層背景)</td>
<td align="left">colorOnBackground</td>
</tr>
<tr>
<td align="left">11</td>
<td align="left">On Surface(上層介面)</td>
<td align="left">colorOnSurface</td>
</tr>
<tr>
<td align="left">12</td>
<td align="left">On Error(上層錯誤)</td>
<td align="left">colorOnError</td>
</tr>
</tbody></table>
<p>查看預設主題中定義的顏色。</p>
<ol>
<li><p>在 Android Studio 中開啟 <code>themes.xml</code> (「app」&gt;「res」&gt;「value」&gt;「topics」&gt;「topics.xml」)。</p>
</li>
<li><p>請注意，主題名稱 (<code>Theme.TipTime</code>) 是依據您的應用程式名稱命名。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Base.Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.Material3.DayNight.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your light theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_light_primary&lt;/item&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.TipTime&quot;</span> /&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>請注意，XML 行也需指定父項主題 Theme.Material3.DayNight.NoActionBar。DayNight 是質感元件庫中預先定義的主題，NoActionBar 表示不顯示動作列。</p>
</li>
</ol>
<div class="note no-icon success">
            <p><strong>注意：</strong> 主題中未定義主題顏色屬性會採用父項主題的顏色。</p>
          </div>

<ol start="4">
<li>瀏覽檔案中的項目。請注意，名稱與上圖中的名稱類似：<code>colorPrimary</code>、<code>colorSecondary</code> 等。</li>
</ol>
<p><code>themes.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span> <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Base.Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Theme.Material3.DayNight.NoActionBar&quot;</span>&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your light theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- &lt;item name=&quot;colorPrimary&quot;&gt;@color/my_light_primary&lt;/item&gt; --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Primary brand color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimary&quot;</span>&gt;</span>@color/purple_500<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorPrimaryVariant&quot;</span>&gt;</span>@color/purple_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnPrimary&quot;</span>&gt;</span>@color/white<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Secondary brand color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondary&quot;</span>&gt;</span>@color/teal_200<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorSecondaryVariant&quot;</span>&gt;</span>@color/teal_700<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;colorOnSecondary&quot;</span>&gt;</span>@color/black<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Status bar color. --&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">item</span> <span class="attr">name</span>=<span class="string">&quot;android:statusBarColor&quot;</span> <span class="attr">tools:targetApi</span>=<span class="string">&quot;l&quot;</span>&gt;</span>?attr/colorPrimaryVariant<span class="tag">&lt;/<span class="name">item</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="comment">&lt;!-- Customize your theme here. --&gt;</span></span></span><br><span class="line"><span class="language-xml">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">name</span>=<span class="string">&quot;Theme.TipTime&quot;</span> <span class="attr">parent</span>=<span class="string">&quot;Base.Theme.TipTime&quot;</span> /&gt;</span><span class="language-xml"></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>另請注意，Android Studio 會在左側邊界繪製一小塊顏色範例。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/fe8f8c774074ca13_1920.png?hl=zh-tw" width="70%" height="70%"></p>
<ol start="6">
<li>最後請注意，系統會將顏色指定為顏色資源 (例如 <code>@color/purple_500</code>)，而非直接使用 RGB 值。</li>
<li>開啟 <code>colors.xml</code> (「app」(應用程式) &gt;「res」&gt;「values」(值) &gt;「colors.xml」)，您會看到每個顏色資源的十六進位值。提醒您，開頭的 <code>#FF</code> 為 Alpha 值，表示顏色為 100% 不透明。</li>
</ol>
<p><code>colors.xml</code></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;purple_200&quot;</span>&gt;</span>#FFBB86FC<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;purple_500&quot;</span>&gt;</span>#FF6200EE<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;purple_700&quot;</span>&gt;</span>#FF3700B3<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;teal_200&quot;</span>&gt;</span>#FF03DAC5<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;teal_700&quot;</span>&gt;</span>#FF018786<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;black&quot;</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">color</span> <span class="attr">name</span>=<span class="string">&quot;white&quot;</span>&gt;</span>#FFFFFFFF<span class="tag">&lt;/<span class="name">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="選擇應用程式主題顏色"><a href="#選擇應用程式主題顏色" class="headerlink" title="選擇應用程式主題顏色"></a>選擇應用程式主題顏色</h4><p>您已大致上瞭解主題屬性，現在讓我們挑選顏色！最簡單的方法就是使用<a href="https://m3.material.io/theme-builder#/custom">色彩工具</a>，也就是 Material 團隊提供的網頁式應用程式。</p>
<ol>
<li><p>左側選取Core Color，右側會自動生成Light Scheme和Dark Scheme。</p>
<img src="https://i.imgur.com/qPQOqot.png">
</li>
<li><p>點選右上角的Export，可產出 <code>material-theme.zip</code> 檔案，在這邊我們選擇產生Android Views(XML)</p>
<img src="https://i.imgur.com/37S03RF.png">
</li>
<li><p>下載後，即可將資料夾內的 <code>values &gt; colors.xml、themes.xml</code> 和 <code>values-night &gt; themes.xml</code> 檔案套用到應用程式當中。</p>
<img src="https://i.imgur.com/eZNKqHs.png" width="70%" height="70%"></li>
</ol>
<hr>
<h4 id="深色主題"><a href="#深色主題" class="headerlink" title="深色主題"></a>深色主題</h4><p>應用程式範本包含預設的淺色主題，以及<a href="https://developer.android.com/guide/topics/ui/look-and-feel/darktheme?hl=zh-tw">深色主題</a>變化版本。深色主題使用較深、較柔和的色彩，且：</p>
<ul>
<li>可大幅減少耗電量 (視裝置的螢幕技術而定)。</li>
<li>可改善低視能及對明亮光線敏感使用者的可視性。</li>
<li>能讓所有人在低光源環境中輕鬆使用裝置。</li>
</ul>
<h5 id="試用深色主題"><a href="#試用深色主題" class="headerlink" title="試用深色主題"></a>試用深色主題</h5><p>您可以在裝置上啟用深色模式，以查看主題在深色模式下的呈現效果。</p>
<div class="note no-icon success">
            <p><strong>注意：</strong> 深色主題僅適用於搭載 API 28 (Android 9) 或 API 29 (Android 10) 以上版本的裝置或模擬器。</p>
          </div>

<p>API 28 (Android 9)</p>
<ol>
<li>再次執行應用程式。</li>
<li>切換至「設定」應用程式。</li>
<li>在「電池」部分中，尋找「省電模式」。<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/5f5098d8d63acfa9_1920.png?hl=zh-tw" width="50%" height="50%"></li>
<li>按下「立即開啟」。</li>
</ol>
<p>API 29 (Android 10) 以上版本</p>
<ol>
<li>再次執行應用程式。</li>
<li>切換至「設定」應用程式。</li>
<li>在「顯示」部分中，尋找「深色主題」切換按鈕。<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-change-app-theme/img/6d9dc1ab3d19f8e6_1920.png?hl=zh-tw" width="50%" height="50%"></li>
<li>將「深色主題」切換至「開啟」位置，裝置將會切換至夜間模式。</li>
</ol>
<p>返回您的應用程式，看看兩者間的差異。<br><img src="https://i.imgur.com/DGUydto.png" width="50%" height="50%"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>View</tag>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(11)-計算小費</title>
    <url>/2023/09/15/Android%E7%AD%86%E8%A8%98-11-%E8%A8%88%E7%AE%97%E5%B0%8F%E8%B2%BB/</url>
    <content><![CDATA[<blockquote>
<p>瞭解如何編寫與小費計算機應用程式中 UI 元素互動的 Kotlin 程式碼，方便你計算小費。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>Android 應用程式的基本結構。</li>
<li>如何讀取 UI 中的值，將這些值寫入程式碼並進行操控。</li>
<li>如何使用資料檢視繫結 (而不是 <code>findViewById()</code>) 來更輕鬆地編寫與檢視畫面互動的程式碼。</li>
<li>如何搭配 <code>Double</code> 資料類型使用 Kotlin 中的十進位數字。</li>
<li>如何將數字的格式設定為貨幣。</li>
<li>如何使用字串參數來動態建立字串。</li>
<li>如何在 Android Studio 中使用 <strong>Logcat</strong> 來找出應用程式的問題。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="範例應用程式總覽"><a href="#範例應用程式總覽" class="headerlink" title="範例應用程式總覽"></a>範例應用程式總覽</h4><p><strong>Tip Time</strong> 應用程式會提供小費計算機所需的所有 UI，但不顯示用於計算小費的程式碼。系統顯示「<strong>Calculate</strong>」按鈕，但該按鈕尚無法正常運作。</p>
<ul>
<li>使用者可以使用「<strong>Cost of Service</strong>」<code>EditText</code> 輸入服務費用。</li>
<li><code>RadioButtons</code> 清單可讓使用者選取小費百分比，</li>
<li><code>Switch</code> 可讓使用者選擇是否應將小費四捨五入。</li>
<li>小費金額顯示在 <code>TextView</code> 中</li>
<li>「<strong>Calculate</strong>」<code>Button</code> 會通知應用程式從其他欄位取得資料並計算小費金額。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-tip-calculator/img/ebf5c40d4e12d4c7_1920.png?hl=zh-tw" width="30%" height="30%">

<h5 id="應用程式專案結構"><a href="#應用程式專案結構" class="headerlink" title="應用程式專案結構"></a>應用程式專案結構</h5><p>IDE 中的應用程式專案由多個部分組成，包括 Kotlin 程式碼、XML 版面配置，以及字串和圖片等其他資源。</p>
<ol>
<li>在 Android Studio 中開啟 <strong>Tip Time</strong> 專案。</li>
<li>如果系統未顯示「Project」視窗，請選取 Android Studio 左側的「Project」分頁標籤。</li>
<li>從下拉式選單中選擇 <strong>Android</strong> 檢視畫面 (如果尚未選取該檢視畫面)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-tip-calculator/img/2a83e2b0aee106dd_1920.png?hl=zh-tw" width="30%" height="30%">

<ul>
<li>Kotlin 檔案 (或 Java 檔案) 的 <strong>java</strong> 資料夾</li>
<li><code>MainActivity</code> - 小費計算機邏輯的所有 Kotlin 程式碼所屬的類別</li>
<li>應用程式資源的 <strong>res</strong> 資料夾</li>
<li><code>activity_main.xml</code> - Android 應用程式的版面配置檔案</li>
<li><code>strings.xml</code> - 包含 Android 應用程式的字串資源</li>
<li><strong>Gradle Scripts</strong> 資料夾</li>
</ul>
<p><strong>Gradle</strong> 是 Android Studio 使用的自動建構系統。當您變更程式碼、新增資源或對應用程式進行其他變更時，<strong>Gradle</strong> 會判斷變更的內容，並採取必要步驟來重新建構應用程式。它還會在模擬器或實體裝置上安裝您的應用程式，並控管其執行作業。</p>
<hr>
<h4 id="檢視區塊繫結-Binding"><a href="#檢視區塊繫結-Binding" class="headerlink" title="檢視區塊繫結(Binding)"></a>檢視區塊繫結(Binding)</h4><p>為了計算小費，程式碼必須存取所有 <strong>UI 元素</strong>才能讀取使用者的輸入內容。程式碼必須先找到 <code>View</code> 的參照 (例如 <code>Button</code> 或 <code>TextView</code>)，然後才能呼叫 <code>View</code> 上的方法或存取其屬性。</p>
<p>Android 架構提供 <code>findViewById()</code> 方法，可根據您的需求執行動作，即在指定 <code>View</code> ID 的情況下傳回其參照)。這種方法有用，但隨著您在應用程式中新增更多檢視畫面，而 UI 也變得更加複雜，使用 <code>findViewById()</code> 可能有點麻煩。</p>
<p>為方便起見，Android 還提供一項名為**檢視繫結(Binding)**的功能。只要提前多做一點工作，檢視繫結就能讓您在 UI 的檢視畫面中更輕鬆、更快速地呼叫方法。您必須在 <strong>Gradle</strong> 中為應用程式啟用檢視繫結，並對程式碼進行一些變更。</p>
<h5 id="啟用檢視繫結"><a href="#啟用檢視繫結" class="headerlink" title="啟用檢視繫結"></a>啟用檢視繫結</h5><ol>
<li>開啟應用程式的 <code>build.gradle</code> 檔案 <strong>build.gradle.kts (:app)</strong></li>
<li>在 <code>android</code> 部分中，新增以下行：</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">buildFeatures &#123;</span><br><span class="line">    viewBinding = true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>注意以下訊息：「Gradle files have changed since last project sync」。<br>按下「Sync Now」。</li>
<li>按下「Sync Now」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-tip-calculator/img/349d99c67c2f40f1_1920.png?hl=zh-tw" width="70%" height="70%">

<p>片刻過後，您應該會在 Android Studio 視窗底部看到訊息「<strong>Gradle sync finished</strong>」。</p>
<h5 id="初始化繫結物件"><a href="#初始化繫結物件" class="headerlink" title="初始化繫結物件"></a>初始化繫結物件</h5><p>在先前的程式碼研究室中，您已經看到屬於 <code>MainActivity</code> 類別的 <code>onCreate()</code> 方法。這是應用程式啟動並初始化 <code>MainActivity</code> 時最先呼叫的內容之一。您將建立並初始化繫結物件一次，而無須為應用程式中的每個 <code>View</code> 呼叫 <code>findViewById()</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-tip-calculator/img/674d243aa6f85b8b_1920.png?hl=zh-tw" width="70%" height="70%">

<ol>
<li>開啟 <code>MainActivity.kt</code> (依序點選「app」&gt;「java」&gt;「com.example.tiptime」&gt;「MainActivity」)。</li>
<li>將 <code>MainActivity</code> 類別的所有現有程式碼替換為此程式碼，設定 <code>MainActivity</code> 以使用檢視繫結。</li>
</ol>
<p>原程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成Binding：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding <span class="comment">//創建延遲初始化的binding變數</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        binding = ActivityMainBinding.inflate(layoutInflater) <span class="comment">//將xml(activity_main.xml)實例化為相應的View物件，並使用binding存取View物件</span></span><br><span class="line">        setContentView(binding.root) <span class="comment">//設定activity檢視畫面:使用binding.root代替資源ID(R.layout.activity_main)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>此行在繫結物件的類別中宣告頂層變數。之所以在此層級定義該變數，是因為將在 <code>MainActivity</code> 類別的多種方法中使用該變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> binding: ActivityMainBinding</span><br></pre></td></tr></table></figure>

<p><a href="https://developer.android.com/topic/libraries/data-binding/generated-binding">點此查看如何創建<strong>binding classes</strong></a></p>
<p><code>lateinit</code> 關鍵字是全新內容。應保證程式碼先初始化變數，然後再使用該變數。否則，您的應用程式將當機。</p>
<div class="note no-icon success">
            <p><strong>lateinit：延遲初始化</strong><br>當我們要綁定一個 <b>TextView</b>，必須先對 <b>textView</b> 這個變數指定 <b>null</b>，進行初始化；後續在指定 <b>textView</b> 的 <b>text</b> 屬性時，也要先確認 <b>textView</b> 是不為空的。</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MainActivity</span> : <span class="type">AppCompatActivity</span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> textView: TextView? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你能確定 <b>textView</b> 這個變數在後續一定會被初始化，也不想每次都用問號來判斷變數是否為空，那你可以加個 <b>lateinit</b> 關鍵字來修飾這個變數：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">lass MainActivity : AppCompatActivity() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">lateinit</span> <span class="keyword">var</span> textView: TextView</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="type">Bundle</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        textView = findViewById(R.id.textView)</span><br><span class="line">        textView.text = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
          </div>

<ol start="4">
<li>此行會初始化 <code>binding</code> 物件，您將使用該物件存取 <code>activity_main.xml</code> 版面配置中的 <code>Views</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding = ActivityMainBinding.inflate(layoutInflater)</span><br></pre></td></tr></table></figure>

<ul>
<li>LayoutInflater：將layout <strong>XML</strong><code>(activity_main.xml)</code> 文件實例化為其相應的 <code>View</code> 物件。</li>
</ul>
<ol start="5">
<li>設定Activity的內容檢視畫面。此行將指定應用程式中檢視畫面階層的根層級 <code>binding.root</code>，而不是傳遞版面配置 <code>R.layout.activity_main</code> 的資源 ID。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">setContentView(binding.root)</span><br></pre></td></tr></table></figure>

<p>回想父檢視畫面和子檢視畫面的概念；<code>root(根)</code>層級可連結所有這些檢視畫面。</p>
<ul>
<li>現在應用程式中需要 <code>View</code> 的參照時，可從 <code>binding</code> 物件中取得，而無須呼叫 <code>findViewById()</code>。</li>
<li><code>binding</code> 物件會自動為應用程式中每個擁有 ID 的 <code>View</code> 定義參照。</li>
<li>使用檢視繫結這種方式更為簡潔，通常您甚至無須建立變數來保留 <code>View</code> 的參照，只要直接在繫結物件中使用該變數即可。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Old way with findViewById()</span></span><br><span class="line"><span class="keyword">val</span> myButton: Button = findViewById(R.id.my_button)</span><br><span class="line">myButton.text = <span class="string">&quot;A button&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Better way with view binding</span></span><br><span class="line"><span class="keyword">val</span> myButton: Button = binding.myButton</span><br><span class="line">myButton.text = <span class="string">&quot;A button&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Best way with view binding and no extra variable</span></span><br><span class="line">binding.myButton.text = <span class="string">&quot;A button&quot;</span></span><br></pre></td></tr></table></figure>
<hr>
<h4 id="計算小費"><a href="#計算小費" class="headerlink" title="計算小費"></a>計算小費</h4><p>使用者輕觸「Calculate」按鈕時，系統開始計算小費。須執行的動作包括檢查 UI，瞭解具體<strong>服務費</strong>用以及使用者想給的<strong>小費百分比</strong>。運用這些資訊，您可以計算服務費用的<strong>總金額</strong>並顯示小費金額。</p>
<h5 id="將點擊事件監聽器新增至按鈕"><a href="#將點擊事件監聽器新增至按鈕" class="headerlink" title="將點擊事件監聽器新增至按鈕"></a>將點擊事件監聽器新增至按鈕</h5><p>第一步是新增點擊事件監聽器，以指定使用者輕觸「Calculate」按鈕時，該按鈕應執行的操作。</p>
<ol>
<li>呼叫 <code>setContentView()</code> 之後，在「Calculate」按鈕上設定點擊事件監聽器，並讓它呼叫 <code>calculateTip()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.calculateButton.setOnClickListener&#123; calculateTip() &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>仍在 <code>MainActivity</code> 類別中 (但在 <code>onCreate()</code> 之外)，新增名為 <code>calculateTip()</code> 的函式。在這裡新增程式碼，檢查 UI 並計算小費。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateTip</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="取得服務費用"><a href="#取得服務費用" class="headerlink" title="取得服務費用"></a>取得服務費用</h5><p>如要計算小費，首先須計算服務費用。文字會儲存在 <code>EditText</code> 中，但您必須使用它做為數字，以便用於計算。您可能還記得其他程式碼研究室中介紹過的 <code>Int</code> 類型，但 <code>Int</code> 只能保留整數。如要在應用程式中使用十進位數字，請使用名為 <code>Double</code> 的資料類型，而並非 <code>Int</code>。<br>如要進一步瞭解 <a href="https://kotlinlang.org/docs/basic-types.html#numbers">Kotlin 中的數字資料類型</a>，請參閱説明文件。Kotlin 提供用於將 <code>String</code> 轉換為 <code>Double</code> 的方法 (稱為 <code>toDouble()</code>)。</p>
<ol>
<li>首先，請取得服務費用的文字。在 <code>calculateTip()</code> 方法中，取得「Cost of Service」<code>EditText</code>的文字屬性，然後指派給稱為 <code>stringInTextField</code> 的變數。<br>(請記住，您可以使用 <code>binding</code> 物件存取 UI 元素，還可以根據 UI 元素採用駝峰式大小寫形式的資源 ID 來參照 UI 元素。)</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stringInTextField = binding.costOfService.text <span class="comment">//抓取服務費用的文字</span></span><br></pre></td></tr></table></figure>

<p>請注意結尾處的 <code>.text</code>。第一部分，<code>binding.costOfService</code> 參照服務費用的 UI 元素。在結尾處加上 <code>.text</code> 表示要取得該結果 (<code>EditText</code> 物件) 並從中取得 <code>text</code> 屬性。這就是所謂的鏈結，是 Kotlin 中一種很常見的模式。</p>
<ol start="2">
<li>接下來，將文字轉換為<strong>十進位數字</strong>。在 <code>stringInTextField</code> 上呼叫 <code>toDouble()</code>，並儲存在名為 <code>cost</code> 的變數中。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cost = stringInTextField.toDouble() <span class="comment">//將stringInTextField轉成Double</span></span><br></pre></td></tr></table></figure>

<p>透過在 <code>Editable</code> 上呼叫 <code>toString()</code> 將其轉換為 <code>String</code>。</p>
<ol start="3">
<li>在 <code>binding.costOfService.text</code> 上呼叫 <code>toString()</code> 並將其轉換為 <code>String</code>：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> stringInTextField = binding.costOfService.text.toString() <span class="comment">//抓取服務費用的文字並轉成String</span></span><br></pre></td></tr></table></figure>

<p>現在，<code>stringInTextField.toDouble()</code> 可以正常運作。</p>
<p>此時，<code>calculateTip()</code> 方法應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateTip</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stringInTextField = binding.costOfService.text.toString() <span class="comment">//抓取服務費用的文字並轉成String</span></span><br><span class="line">    <span class="keyword">val</span> cost = stringInTextField.toDouble() <span class="comment">//將stringInTextField轉成Double</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="取得小費百分比"><a href="#取得小費百分比" class="headerlink" title="取得小費百分比"></a>取得小費百分比</h5><p>到目前為止，您已取得服務費用。現在您需要使用者從 <code>RadioButtons</code> 的 <code>RadioGroup</code> 中選取的小費百分比。</p>
<ol>
<li>在 <code>calculateTip()</code> 中，取得 <code>tipOptions</code> <code>RadioGroup</code> 的 <code>checkedRadioButtonId</code> 屬性，並將其指派給名為 <code>selectedId</code> 的變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> selectedId = binding.tipOptions.checkedRadioButtonId</span><br></pre></td></tr></table></figure>

<p>現在您知道選取哪個 <code>RadioButton</code> (<code>R.id.option_twenty_percent</code>、<code>R.id.option_eighteen_percent</code> 或 <code>R.id.fifteen_percent</code> 其中之一)，但還需要相應的百分比。您可以編寫一系列 <code>if/else</code> 陳述式，但使用 <code>when</code> 運算式會簡單許多。</p>
<p>新增下列行即可取得小費百分比。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> tipPercentage = <span class="keyword">when</span> (selectedId) &#123;</span><br><span class="line">    R.id.option_twenty_percent -&gt; <span class="number">0.20</span></span><br><span class="line">    R.id.option_eighteen_percent -&gt; <span class="number">0.18</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="number">0.15</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此時，<code>calculateTip()</code> 方法應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateTip</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stringInTextField = binding.costOfService.text.toString()</span><br><span class="line">    <span class="keyword">val</span> cost = stringInTextField.toDouble()</span><br><span class="line">    <span class="keyword">val</span> selectedId = binding.tipOptions.checkedRadioButtonId</span><br><span class="line">    <span class="keyword">val</span> tipPercentage = <span class="keyword">when</span> (selectedId) &#123;</span><br><span class="line">        R.id.option_twenty_percent -&gt; <span class="number">0.20</span></span><br><span class="line">        R.id.option_eighteen_percent -&gt; <span class="number">0.18</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0.15</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="計算小費並四捨五入"><a href="#計算小費並四捨五入" class="headerlink" title="計算小費並四捨五入"></a>計算小費並四捨五入</h5><p>現在您已得知服務費用和小費百分比，要計算小費就十分容易：只要將費用乘以小費百分比，即可計算出小費，即「小費 &#x3D; 服務費用 *小費百分比」。您可以視需要將該值四捨五入。</p>
<ol>
<li>在 <code>calculateTip()</code> 中您新增的其他程式碼後面，將 <code>tipPercentage</code> 乘以 <code>cost</code>，然後將計算出的值指派給名為 <code>tip</code> 的變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> tip = cost * tipPercentage</span><br></pre></td></tr></table></figure>
<p>請注意，使用 <code>var</code> 而非 <code>val</code>。這是因為使用者選取該選項時，您可能需要將這個值四捨五入，因此值可能會有所異動。</p>
<p>如果是 <code>Switch</code> 元素，請檢查 <code>isChecked</code> 屬性，確認切換按鈕是否「開啟」。<br>2. 將四捨五入切換按鈕的 <code>isChecked</code> 屬性指派給名為 <code>roundUp</code> 的變數。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> roundUp = binding.roundUpSwitch.isChecked</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p>字詞「四捨五入」是指將小數點四捨五入至最接近的整數值，但在這種情況下，您只會無條件進位或無條件進位至最接近的指定基數倍數。您可以使用 <b>ceil()</b> 函式來執行這項操作。有數個函式都採用該名稱，但您需要的是在 <b>kotlin.math</b> 中定義的函式。您可以新增 <b>import</b> 陳述式，但在這種情況下，較簡單的做法是直接使用 <b>kotlin.math.ceil()</b> 告知 Android Studio 您所需的函式。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-tip-calculator/img/32c29f73a3f20f93_1920.png?hl=zh-tw" width="70%" height="70%"></p>
          </div>

<ol start="3">
<li>新增 <code>if</code> 陳述式，用於在 <code>roundUp</code> 為 <strong>true</strong> 時將小費上限指派給 <code>tip</code> 變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(roundUp) &#123;</span><br><span class="line">    tip = kotlin.math.ceil(tip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="設定小費格式"><a href="#設定小費格式" class="headerlink" title="設定小費格式"></a>設定小費格式</h5><p>您的應用程式幾乎可以正常運作。您已計算小費，現在只要設定小費格式並加以顯示即可。</p>
<p>正如您所預期的那樣，Kotlin 提供用於為不同類型的數字設定格式的方法。但小費金額會略有不同，它代表貨幣價值。不同的國家&#x2F;地區使用不同的貨幣，並且在設定十進位數字的格式方面有不同的規則。例如，以美元為單位時，1234.56 的格式應為 $1,234.56 美元，但以歐元為單位時，格式應為 €1.234,56 歐元。幸好，Android 架構提供用於將數字的格式設定為貨幣的方法，因此您不必瞭解所有可能的做法。系統會根據使用者在手機上選擇的語言和其他設定，自動設定貨幣格式。如要進一步瞭解<a href="https://developer.android.com/reference/java/text/NumberFormat?hl=zh-tw">數字格式</a>，請參閱 Android 開發人員說明文件。</p>
<ol>
<li>在 <code>calculateTip()</code> 中的其他程式碼後面，呼叫 <code>NumberFormat.getCurrencyInstance()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">NumberFormat.getCurrencyInstance()</span><br></pre></td></tr></table></figure>

<p>系統會為您提供數字格式設定工具，以便您將數字格式設為貨幣。</p>
<ol start="2">
<li>使用數字格式設定工具時，可將 <code>format()</code> 方法的呼叫鏈結至 <code>tip</code>，並將結果指派給名為 <code>formattedTip</code> 的變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> formattedTip = NumberFormat.getCurrencyInstance().format(tip)</span><br></pre></td></tr></table></figure>

<p>從可能的匯入內容清單中選擇 **NumberFormat (java.text)**。</p>
<h5 id="顯示小費"><a href="#顯示小費" class="headerlink" title="顯示小費"></a>顯示小費</h5><p>現在，您必須在應用程式的小費金額 <code>TextView</code> 元素中顯示小費。您可以將 <code>formattedTip</code> 指派給 <code>text</code> 屬性，不過最好能夠加上標籤説明金額代表的意義。在使用英文的美國，系統可能會顯示「Tip Amount: $12.34」，但使用其他語言時，數字可能需要出現在字串開頭甚或中間。Android 架構提供名為「字串參數」的機制，讓翻譯應用程式的人可視需要變更數字的顯示位置。</p>
<ol>
<li>開啟 <code>strings.xml</code> (「app」&gt;「res」&gt;「values」&gt;「strings.xml」)</li>
<li>將 <code>tip_amount</code> 字串從 <code>Tip Amount</code> 變更為 <code>Tip Amount: %s</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;tip_amount&quot;</span>&gt;</span>Tip Amount: %s<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>%s</code> 插入已設定格式的貨幣。</p>
<ol start="3">
<li>現在請設定 <code>tipResult</code> 的文字。返回 <code>calculateTip()</code> 方法，呼叫 <code>getString(R.string.tip_amount, formattedTip</code>)，然後將其指派給小費結果 <code>TextView</code> 的 <code>text</code> 屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">binding.tipResult.text = getString(R.string.tip_amount, formattedTip)</span><br></pre></td></tr></table></figure>

<p>此時，<code>calculateTip()</code> 方法應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateTip</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> stringInTextField = binding.costOfService.text.toString()</span><br><span class="line">    <span class="keyword">val</span> cost = stringInTextField.toDouble()</span><br><span class="line">    <span class="keyword">val</span> selectedId = binding.tipOptions.checkedRadioButtonId</span><br><span class="line">    <span class="keyword">val</span> tipPercentage = <span class="keyword">when</span> (selectedId) &#123;</span><br><span class="line">        R.id.option_twenty_percent -&gt; <span class="number">0.20</span></span><br><span class="line">        R.id.option_eighteen_percent -&gt; <span class="number">0.18</span></span><br><span class="line">        <span class="keyword">else</span> -&gt; <span class="number">0.15</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> tip = tipPercentage * cost</span><br><span class="line">    <span class="keyword">val</span> roundUp = binding.roundUpSwitch.isChecked</span><br><span class="line">    <span class="keyword">if</span> (roundUp) &#123;</span><br><span class="line">        tip = kotlin.math.ceil(tip)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> formattedTip = NumberFormat.getCurrencyInstance().format(tip)</span><br><span class="line">    binding.tipResult.text = getString(R.string.tip_amount, formattedTip)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>開發應用程式 (以及檢視預覽畫面) 時，建議您為該 <code>TextView</code> 設定預留位置。</p>
<ol>
<li>開啟 <code>activity_main.xml</code> (依序點選「App」&gt;「Res」&gt;「Layout」&gt;「activity_main.xml」)。</li>
<li>找出 <code>tip_result</code> <code>TextView</code>。</li>
<li>移除包含 <code>android:text</code> 屬性的那一行。</li>
<li>新增設定為 <code>tools:text</code> 屬性的 <code>Tip Amount: $10</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">tools:text=&quot;Tip Amount: $10&quot;</span><br></pre></td></tr></table></figure>
<p>由於這是預留位置，因此無須將字串擷取至資源。執行應用程式時，它不會顯示。</p>
<p>最後，執行應用程式。輸入費用金額並選取一些選項，然後按「Calculate」按鈕。<br><img src="https://i.imgur.com/U2IJMOB.gif" width="30%" height="30%"></p>
<hr>
<h4 id="測試並偵錯"><a href="#測試並偵錯" class="headerlink" title="測試並偵錯"></a>測試並偵錯</h4><p>如果使用者未輸入任何文字，<code>stringInTextField</code> 顯示空白，會發生什麽？</p>
<ol>
<li>在模擬器中執行應用程式，但使用「Run」&gt;「Debug ‘app’」，而不是使用「Run」&gt;「Run ‘app’」。</li>
<li>請嘗試費用、小費金額以及小費是否四捨五入的不同組合，並確認您在各種情況下輕觸「Calculate」時是否能夠取得預期結果。</li>
<li>現在，請嘗試刪除「Cost of Service」欄位中的所有文字，然後輕觸「Calculate」。糟糕，您的程式已當機。</li>
</ol>
<p>在空字串或不代表有效十進位數字的字串上呼叫 <code>toDouble()</code> 時，將無法運作。幸好，Kotlin 也提供名為 <code>toDoubleOrNull()</code> 的方法，可用於處理這些問題。如果可以，系統會傳回十進位數字；如果發生問題，系統會傳回 <code>null</code>。</p>
<ol>
<li>在 <code>calculateTip()</code> 中，變更宣告 <code>cost</code> 變數的那一行，呼叫 <code>toDoubleOrNull()</code> 而非呼叫 <code>toDouble()</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> cost = stringInTextField.toDoubleOrNull()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在此行後面加入陳述式，檢查 <code>cost</code> 是否為 <code>null</code>，如果是，系統會從該方法傳回。<code>return</code> 指令表示在不執行其餘指令的情況下結束方法。如果系統必須傳回一個值，您應使用包含運算式的 <code>return</code> 指令來指定該值。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cost == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次執行應用程式。</li>
<li>如果「Cost of Service」欄位中沒有任何文字，請輕觸「Calculate」。這次，應用程式並未當機！做得好 — 您已找到並修正錯誤！</li>
</ol>
<h5 id="處理其他情況"><a href="#處理其他情況" class="headerlink" title="處理其他情況"></a>處理其他情況</h5><p>如果使用者執行以下操作：</p>
<ol>
<li>輸入服務費用的有效金額</li>
<li>輕觸「Calculate」以計算小費</li>
<li>刪除服務費用</li>
<li>再次輕觸「Calculate」？</li>
</ol>
<p>第一次，系統會按預期計算並顯示小費。第二次，由於您剛剛新增的檢查，<code>calculateTip()</code> 方法會提早傳回結果，但應用程式仍會顯示先前的小費金額。這可能會讓使用者感到困惑，因此建議新增一些程式碼，以便在出現問題時清除小費金額。</p>
<ol>
<li><p>如要確認發生這個問題，請輸入有效的服務費用，然後輕觸「Calculate」(計算)，接著刪除文字後再次輕觸「Calculate」(計算)。系統仍會顯示第一次的小費值。</p>
</li>
<li><p>在剛剛新增的 <code>if</code> 中，在 <code>return</code> 陳述式之前新增一行，用於將 <code>tipResult</code> 的 <code>text</code> 屬性設為空字串。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (cost == <span class="literal">null</span>) &#123;</span><br><span class="line">    binding.tipResult.text = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣，系統會在從 <code>calculateTip()</code> 傳回結果之前清除小費金額。</p>
<ol start="3">
<li>再次執行應用程式，然後嘗試處理上述情況。再次輕觸「Calculate」時，第一次的小費值應該會消失。</li>
</ol>
<hr>
<h4 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h4><p><a href="https://carterchen247.medium.com/kotlin%E4%BD%BF%E7%94%A8%E5%BF%83%E5%BE%97-%E5%8D%81%E4%B8%80-lateinit-vs-lazy-1ef96bc5b3b3">Kotlin使用心得（十一）：lateinit vs lazy</a></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Binding</tag>
        <tag>View Binding</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(10)-建立適用於Android的XML版面配置</title>
    <url>/2023/09/02/Android%E7%AD%86%E8%A8%98-10-%E5%BB%BA%E7%AB%8B%E9%81%A9%E7%94%A8%E6%96%BCAndroid%E7%9A%84XML%E7%89%88%E9%9D%A2%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<blockquote>
<p>瞭解新版的 UI 元件，例如可編輯的文字欄位、圓形按鈕，以及為小費計算器應用程式建立版面配置的切換按鈕。你將會使用 XML，而不使用 Android Studio 中的版面配置編輯器，來編輯應用程式的版面配置。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何在 Android 中讀取及寫入 XML 版面配置</li>
<li>如何建構簡易表單，用於使用者文字輸入和選項</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="啟動專案"><a href="#啟動專案" class="headerlink" title="啟動專案"></a>啟動專案</h4><p>使用 Android 應用程式建立簡易的計算機簡易版。<br>完成後小費計算機應用程式會如下所示：</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/bcc5260318477c14_1920.png?hl=zh-tw" width="30%" height="30%">

<p>您需要使用 Android 提供的下列 UI 元素：</p>
<ul>
<li><code>EditText</code> - 用於輸入及傳送訊息</li>
<li><code>TextView</code> - 顯示服務條款和小費金額等文字</li>
<li><code>RadioButton</code>：每個小費選項的可選取圓形按鈕</li>
<li><code>RadioGroup</code> - 將圓形按鈕選項分組</li>
<li><code>Switch</code> - 開啟&#x2F;關閉切換按鈕，選擇是否將小費四捨五入</li>
</ul>
<h5 id="建立一個空白活動專案"><a href="#建立一個空白活動專案" class="headerlink" title="建立一個空白活動專案"></a>建立一個空白活動專案</h5><ol>
<li>首先，在 Android Studio 中使用 空白活動 範本來建立新品的 Kotlin 專案。</li>
<li>呼叫應用程式「Tip Time」，最低 API 級別為 19 (KitKat)。套件名稱為 com.example.tiptime。</li>
</ol>
<hr>
<h4 id="閱讀及瞭解-XML"><a href="#閱讀及瞭解-XML" class="headerlink" title="閱讀及瞭解 XML"></a>閱讀及瞭解 XML</h4><p>如果不想使用自己熟悉的版面配置編輯器，您可以修改描述使用者介面的 XML 來建構應用程式的版面配置。瞭解使用 XML 瞭解及修改 UI 版面配置對 Android 開發人員的重要性。</p>
<p>您將會查看並編輯 XML 檔案，為這個應用程式定義 UI 版面配置。XML 是可延伸標記語言的一種，這是一種利用文字文件來描述資料的方式。由於 XML 是可擴充且極具彈性的功能，所以有許多種不同的用途，包括定義 Android 應用程式的 UI 版面配置。您或許可以在先前的程式碼研究室中回想起，「<code>strings.xml</code>」這個 XML 檔案中的其他資源也定義了其他資源。</p>
<p>Android 應用程式的使用者介面是由元件（小工具）的元件階層組成，以及這些元件的螢幕版面配置。請注意，這些版面配置本身是 UI 元件。</p>
<p>您必須說明畫面上的 UI 元素檢視畫面階層。舉例來說，<code>ConstraintLayout</code> (父項) 可包含 <code>Buttons</code>、<code>TextViews</code>、<code>ImageViews</code> 或其他檢視畫面 (子項)。請注意，<code>ConstraintLayout</code>是 <code>ViewGroup</code> 的子類別。可讓您靈活設定子項的位置或調整大小。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/74c7c563d18fffd4_1920.png?hl=zh-tw" width="70%" height="70%">

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/32df120272b2331d_1920.png?hl=zh-tw" width="40%" height="40%">

<p>每個 UI 元素都會在 XML 檔案中以 XML 元素出現。每個元素的開頭和結尾都是代碼，而每個標記的開頭都是 <code>&lt;</code>，結尾則是 <code>&gt;</code>。就像是您可以使用版面配置編輯器 (設計) 設定 UI 元素的屬性，XML 元素也可以具有「屬性」。簡單來說，上述 UI 元素的 XML 可能如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">text</span>=<span class="string">&quot;Hello World!&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/8dea708333aebabe_1920.png?hl=zh-tw" width="80%" height="80%">

<p>以下是一個實際範例。</p>
<ol>
<li>開啟 <code>activity_main.xml</code> (「app」&gt;「res」&gt;「layout」&gt;「activity_main.xml」)</li>
<li>您可能會注意到應用程式顯示包含「Hello World!」的 <code>TextView</code>。如 <code>ConstraintLayout</code> 中所述，您在使用這個範本建立的先前的專案中看過。</li>
<li>在版面配置編輯器的右上方，找到「Code」、「Split」和「Design」檢視畫面的選項。</li>
<li>選取「Code」檢視。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/6203bec920791bcc_1920.png?hl=zh-tw" width="50%" height="50%">

<p><code>activity_main.xml</code> 中的 XML 如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintBottom_toBottomOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintLeft_toLeftOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintRight_toRightOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>請注意縮排。Android Studio 會自動執行上述作業，顯示元素階層。<code>TextView</code> 已縮排，因為 <code>ConstraintLayout</code> 裡包含這個項目。<code>ConstraintLayout</code> 是父項，<code>TextView</code> 是子節點。每個元素的屬性會以縮排的方式顯示，表示該元素屬於該元素的一部分。</li>
<li>請注意色彩編碼：檔案的類似部分會繪製成同一顏色，方便您比對。請特別注意，Android Studio 會繪製用相同顏色元素的開始和結尾。</li>
</ol>
<h5 id="XML-標記、元素和屬性"><a href="#XML-標記、元素和屬性" class="headerlink" title="XML 標記、元素和屬性"></a>XML 標記、元素和屬性</h5><p>以下是 <code>TextView</code> 元素的簡化版本，方便您查看部分重要部分：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>

<p>包含 <code>&lt;TextView</code> 的行則是標記的開頭，而 <code>/&gt;</code> 行則是標記結尾。標有 <code>android:text=&quot;Hello World!&quot;</code> 的行是標記的屬性。這代表 <code>TextView</code> 將要顯示的文字。這 3 行是常用的元素 (又稱為空白元素代碼)，也就是說，如果您利用獨立的「start-tag」和「end-tag」編寫程式碼，例如：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">TextView</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>另一個常見的例子是空白元素標記，編寫時盡可能減少這類標記的行數，然後將代碼的結尾與行前的行結合。因此，您可能會在兩行中看到空白元素標記 (沒有屬性的話，甚至只有一行)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- with attributes, two lines --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<p>由於 <code>ConstraintLayout</code> 元素是以獨立開始和結束標記寫成，因此必須含有其他元素。以下是含有 <code>TextView</code> 元素的 <code>ConstraintLayout</code> 元素簡化版本：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>如要將另一個 <code>View</code> 新增為 <code>ConstraintLayout</code> 的子項 (例如 <code>TextView</code> 下的 <code>Button</code>)，其會在 <code>TextView</code> 標記 <code>/&gt;</code> 的結尾，並且在 <code>ConstraintLayout</code> 的結尾標記之前，如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Hello World!&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;Calculate&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="進一步瞭解版面配置的-XML"><a href="#進一步瞭解版面配置的-XML" class="headerlink" title="進一步瞭解版面配置的 XML"></a>進一步瞭解版面配置的 XML</h5><ol>
<li><p>查看 <code>ConstraintLayout</code> 的標記，您會發現這顯示為 <code>androidx.constraintlayout.widget.ConstraintLayout</code>，而非和 <code>TextView</code> 一樣只有 <code>ConstraintLayout</code>。這是因為 <code>ConstraintLayout</code> 是 <strong>Android Jetpack</strong> 的一部分，而其中的程式碼程式庫在 Android 核心平台之外提供了額外功能。<strong>Jetpack</strong> 提供了一些實用功能，可協助您輕鬆建構應用程式。您會發現此 UI 元件因為是以「<code>androidx</code>」開頭，所以屬於 <strong>Jetpack</strong> 的一部分。</p>
</li>
<li><p>您可能會發現開頭為 <code>xmlns</code>: 的行數，後接 <code>android</code>、<code>app</code> 和 <code>tools</code>。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;</span><br><span class="line">xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;</span><br><span class="line">xmlns:tools=&quot;http://schemas.android.com/tools&quot;</span><br></pre></td></tr></table></figure>

<p><code>xmlns</code> 代表 XML 命名空間，而每一行分別定義一個「結構定義」或相關詞彙。舉例來說，<code>android:</code> 命名空間會標示 Android 系統定義的屬性。版面配置 XML 中的所有屬性都是從其中一個命名空間開始執行。</p>
<ol start="3">
<li><p>XML 元素之間的空白字元不會對電腦產生意義，但可讓 XML 更易於閱讀。</p>
</li>
<li><p>您可以對 XML 新增註解，就跟使用 Kotlin 程式碼一樣。開頭是 <code>&lt;!--</code>，結尾是<code>--&gt;</code>。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- this is a comment in XML --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- this is a</span></span><br><span class="line"><span class="comment">multi-line</span></span><br><span class="line"><span class="comment">Comment.</span></span><br><span class="line"><span class="comment">And another</span></span><br><span class="line"><span class="comment">Multi-line comment --&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>請注意檔案的第一行：</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br></pre></td></tr></table></figure>

<p>用於表示檔案是 XML 檔案，但並非所有 XML 檔案都會包含這類檔案。</p>
<hr>
<h4 id="在-XML-中建立版面配置"><a href="#在-XML-中建立版面配置" class="headerlink" title="在 XML 中建立版面配置"></a>在 XML 中建立版面配置</h4><ol>
<li>在 <code>activity_main.xml</code> 中，請切換至「Split」 畫面，即可查看 設計編輯器 旁的 XML。「設計編輯器」可讓您預覽 UI 版面配置。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/a03bcf5beacb4b45_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="2">
<li>請嘗試點選其他行 (<code>ConstraintLayout</code> 下和 <code>TextView</code>下一行)，然後可注意到會選取到「Design Editor」中對應的畫面。反之亦然。舉例來說，如果您在「Design Editor」中按一下 <code>TextView</code>，系統就會醒目顯示對應的 XML。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/1abc54a646c39f66_1920.png?hl=zh-tw" width="90%" height="90%">

<h5 id="刪除-TextView"><a href="#刪除-TextView" class="headerlink" title="刪除 TextView"></a>刪除 TextView</h5><ol>
<li><p>您現在不需要 <code>TextView</code>，請將其刪除。請務必從 <code>&lt;TextView</code> 至 <code>/&gt;</code> 結尾全部刪除。</p>
</li>
<li><p>在 <code>ConstraintLayout</code> 中加入 <code>16dp</code> 邊框間距，避免 UI 與螢幕邊緣過度擁擠。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">...</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="新增服務費用文字欄位"><a href="#新增服務費用文字欄位" class="headerlink" title="新增服務費用文字欄位"></a>新增服務費用文字欄位</h5><p>在這個步驟中，您必須新增 UI 元素，才能在應用程式中輸入服務費用。您必須使用 <code>EditText</code> 元素，讓使用者在應用程式中輸入或修改文字。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/7746dedb0d79923f_1920.png?hl=zh-tw" width="30%" height="30%">

<p>目前的版面配置檔案應該會如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:app</span>=<span class="string">&quot;http://schemas.android.com/apk/res-auto&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:tools</span>=<span class="string">&quot;http://schemas.android.com/tools&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:padding</span>=<span class="string">&quot;16dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:context</span>=<span class="string">&quot;.MainActivity&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/plain_text_input&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:inputType</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">androidx.constraintlayout.widget.ConstraintLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>請注意，<code>EditText</code> 會加上紅色底線。</p>
</li>
<li><p>將滑鼠游標移到指標上，系統就會顯示「檢視畫面不受限」的錯誤訊息，您對在舊版程式碼研究室中的這類程式碼應該十分熟悉。先前提過，<code>ConstraintLayout</code> 的子項設有限制，因此版面配置會熟悉該如何排列。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/40c17058bd6786f_1920.png?hl=zh-tw" width="80%" height="80%">

<ol start="5">
<li>將這些限制新增至 <code>EditText</code> 可固定在父項的左上角。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br><span class="line">app:layout_constraintTop_toTopOf=&quot;parent&quot;</span><br></pre></td></tr></table></figure>

<p>加入新限制條件後，<code>EditText</code> 元素會如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/plain_text_input&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toTopOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">&quot;text&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="查看編輯文字屬性"><a href="#查看編輯文字屬性" class="headerlink" title="查看編輯文字屬性"></a>查看編輯文字屬性</h5><p>請仔細檢查您貼上的所有 <code>EditText</code> 屬性，確保它們與您應用程式中的方式搭配運作。</p>
<ol>
<li>找出設為 <code>@+id/plain_text_input</code> 的 <code>id</code> 屬性。</li>
<li>將 <code>id</code> 屬性變更為較為適當的名稱 <code>@+id/cost_of_service</code>。</li>
</ol>
<div class="note no-icon success">
            <p><strong>注意</strong>： 資源 ID 是元素專屬的資源名稱，當您透過「Layout Editor」新增 <b>View</b> 或其他資源時，Android Studio 會自動為資源指派資源 ID。手動輸入 XML 時，您必須手動宣告資源 ID。XML 檔案中的新資料檢視 ID 必須以 <b>@+id</b> 前置字元來定義，這樣 Android Studio 才能將該 ID 新增為新的資源 ID。</p><p>為資源取個清楚易懂的名稱，以便您知道資源的參照對象，但全都應以小寫字母輸入，並以底線分隔字詞。</p><p>如要參照應用程式程式碼中的資源 ID，請使用 <b>R.<type>.<name></b>；例如 <b>R.string.roll</b>。如為 View ID，<b><code>&lt;type&gt;</code></b> 則為 <b>id</b>，例如 <b>R.id.button</b>。</p>
          </div>

<ol start="3">
<li><p>查看 <code>layout_height</code> 屬性。已設為 <code>wrap_content</code>，表示高度會和當中的內容高度相同。沒關係，因為只有 1 行文字。</p>
</li>
<li><p>查看 <code>layout_width</code> 屬性。已設為 <code>match_parent</code>，但你無法在 <code>ConstraintLayout</code> 的子項中設定 <code>match_parent</code>。此外，文字欄位不需要那麼寬。設為 <code>160dp</code> 的固定寬度，但應預留足夠空間，讓使用者輸入服務費用。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/1f82a5e86ae94fd2_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="5">
<li>找到新的 <code>inputType</code> 屬性，這是一項新功能。屬性值為 <code>&quot;text&quot;</code>，表示使用者可在畫面上的欄位中輸入任何文字字元 (英數字元、符號等)。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:inputType=&quot;text&quot;</span><br></pre></td></tr></table></figure>

<p>不過，假如您只想在 EditText 中輸入數字，因為該欄位代表貨幣金額。</p>
<ol start="6">
<li>清除 <code>text</code> 字詞，但保留引號。</li>
<li>輸入 <code>number</code> 的位置。輸入「n」後，Android Studio 會顯示包含「n」的可能完成項目清單。</li>
</ol>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-xml-layouts/img/99b04cbd21e74693.gif" width="50%" height="50%">

<ol start="8">
<li>選擇 <code>numberDecimal</code>，這個類型可限制只顯示含小數點的數字。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:inputType=&quot;numberDecimal&quot;</span><br></pre></td></tr></table></figure>

<p>如要查看輸入類型的其他選項，請參閱開發人員說明文件中的 <a href="https://developer.android.com/develop/ui/views/touch-and-input/keyboard-input/style">指定輸入法類型</a>。</p>
<ol start="9">
<li>在 <code>EditText</code> 中加入 <code>hint</code> 屬性，藉此說明使用者應在欄位中輸入的內容。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:hint=&quot;Cost of Service&quot;</span><br></pre></td></tr></table></figure>

<p>您也會看到「Design Editor」將其更新。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/824454d2a316efb1_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="10">
<li>在模擬器中執行應用程式。看起來應該像這樣：</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/c9d413de53b0853d_1920.png?hl=zh-tw" width="30%" height="30%">

<h5 id="新增服務問題"><a href="#新增服務問題" class="headerlink" title="新增服務問題"></a>新增服務問題</h5><p>在這個步驟中，您必須新增 <code>TextView</code> 問題說明：”How was the service?”請嘗試輸入，不要複製&#x2F;貼上。你可以透過 Android Studio 提供建議的做法。</p>
<ol>
<li>關閉 <code>EditText</code> 標記 <code>/&gt;</code> 後，新增一行然後開始輸入 <code>&lt;TextView</code></li>
<li>從建議中選取 <code>TextView</code>，Android Studio 就會自動為 <code>TextView</code> 新增 <code>layout_width</code> 和 <code>layout_height</code> 屬性。</li>
<li>請為這兩個屬性選擇 <code>wrap_content</code>，因為 <code>TextView</code> 只需要與當中的文字內容一樣大。</li>
<li>新增含有 <code>&quot;How was the service?&quot;</code> 的 <code>text</code> 屬性</li>
<li>使用 <code>/&gt;</code> 關閉標記。</li>
<li>請注意，在「Design Editor」中 <code>TextView</code> 會與 <code>EditText</code> 重疊。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/ac09d5cae6ae2455_1920.png?hl=zh-tw" width="30%" height="30%">

<p>垂直部分 <code>TextView</code> 應低於服務費用文字欄位。水平部分要讓 <code>TextView</code> 對齊父項的邊緣。</p>
<ol start="7">
<li>為 <code>TextView</code> 加上水平限制，限制它的起點到父項的起點。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:layout_constraintStart_toStartOf=&quot;parent&quot;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>在 <code>TextView</code> 中加入垂直限制，將 <code>TextView</code> 的上緣限制在服務費用 <code>View</code> 的底部邊緣。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">app:layout_constraintTop_toBottomOf=&quot;@id/cost_of_service&quot;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>在 <code>TextView</code> 新增資源 ID。您稍後必須參考這個資料檢視，因為我們建議您新增更多檢視點，並將這些項目互相衝突。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">android:id=&quot;@+id/service_question&quot;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="新增提示選項"><a href="#新增提示選項" class="headerlink" title="新增提示選項"></a>新增提示選項</h4><p>接下來，您需要為各個使用者選項提供<code>圓形按鈕(RadioButton)</code>選項。</p>
<p>共有三個選項：</p>
<ul>
<li>極佳 (20%)</li>
<li>不錯 (18%)</li>
<li>一般 (15%)</li>
</ul>
<ol>
<li>瀏覽<a href="https://developer.android.com/guide/topics/ui/controls/radiobutton?hl=zh-tw#kotlin">圓形按鈕(RadioButton)指南</a>，瞭解 <code>RadioGroup</code> 是父項，以及 <code>RadioButtons</code> 是子項。</li>
</ol>
<div class="note no-icon primary">
            <p>在建立每個圓形按鈕選項時，請在版面配置中建立 <code>RadioButton</code>。 不過，由於圓形按鈕彼此互斥，因此必須在 <code>RadioGroup</code> 內將這些按鈕設成一個群組。把它們設成一個群組，系統即可確保一次只能選取一個圓形按鈕。</p>
          </div>

<ol start="2">
<li>返回 Android Studio 中的版面配置，將 <code>RadioGroup</code> 和 <code>RadioButton</code> 新增至應用程式。</li>
<li>在 <code>TextView</code> 元素之後，仍顯示在 <code>ConstraintLayout</code> 中，開始輸入 <code>&lt;RadioGroup</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/aee75ba409dc51aa_1920.png?hl=zh-tw" width="30%" height="30%">

<ol start="4">
<li>將 <code>RadioGroup</code> 的 <code>layout_width</code> 和 <code>layout_height</code> 設為 <code>wrap_content</code>。</li>
<li>新增設為 <code>@+id/tip_options</code> 的資源 ID。</li>
<li>使用 <code>&gt;</code> 關閉起始標記。</li>
<li>Android Studio 會加上 <code>&lt;/RadioGroup&gt;</code>。和 <code>ConstraintLayout</code> 一樣，<code>RadioGroup</code> 元素內部也會包含其他元素，因此建議您將元素移到單獨的線條。</li>
</ol>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-xml-layouts/img/b66934aa214811ad.gif" width="60%" height="60%">

<ol start="8">
<li>將 <code>RadioGroup</code> 限制在服務問題下方 (垂直)，並限制父項的開頭 (水平)。</li>
<li>將 <code>android:orientation</code> 屬性設為 <code>vertical</code>。如要指定某列的 <code>RadioButtons</code>，可以將方向設為 <code>horizontal</code>。</li>
</ol>
<h5 id="新增圓形按鈕"><a href="#新增圓形按鈕" class="headerlink" title="新增圓形按鈕"></a>新增圓形按鈕</h5><ol>
<li>在 <code>RadioGroup</code> 的最後一個屬性後方，在 <code>&lt;/RadioGroup&gt;</code> 結束標記之前加上 <code>RadioButton</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_options&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/service_question&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- add RadioButtons here --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>layout_width</code> 和 <code>layout_height</code> 設為 <code>wrap_content</code>。</li>
<li>將 <code>@+id/option_twenty_percent</code> 的資源 ID 指派給 <code>RadioButton</code>。</li>
<li>將文字設為 <code>Amazing (20%)</code>。</li>
<li>使用 <code>/&gt;</code> 關閉標記。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/53cb416b368e9612_1920.png?hl=zh-tw" width="30%" height="30%">

<p>接著為 <code>Good (18%)</code> 和 <code>Okay (15%)</code> 選項新增 2 個圓形按鈕(RadioButton)。</p>
<p>以下是新增完成的XML：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_options&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/service_question&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:orientation</span>=<span class="string">&quot;vertical&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_twenty_percent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">&quot;Amazing (20%)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_eighteen_percent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">&quot;Good (18%)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">RadioButton</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:id</span>=<span class="string">&quot;@+id/option_fifteen_percent&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">android:text</span>=<span class="string">&quot;Okay (15%)&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">RadioGroup</span>&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/bab25b6a35d4ce52_1920.png?hl=zh-tw" width="30%" height="30%">

<h5 id="新增預設選項"><a href="#新增預設選項" class="headerlink" title="新增預設選項"></a>新增預設選項</h5><p>目前未選取任何提示選項。系統預設會選取其中一個圓形按鈕選項。<br><code>RadioGroup</code> 上有一個屬性可讓您指定要先檢查哪一個按鈕。名稱是 <code>checkedButton</code>，並設為所選圓形按鈕的按鈕資源。</p>
<ol>
<li>在 <code>RadioGroup</code> 上，將 <code>android:checkedButton</code> 屬性設為 <code>@id/option_twenty_percent</code>。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">RadioGroup</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_options&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:checkedButton</span>=<span class="string">&quot;@id/option_twenty_percent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">...</span></span></span><br></pre></td></tr></table></figure>

<p>根據預設，系統會選取 20% 的小費選項！現在這開始看起來像小費計算機了！</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/c412e7f16590cd33_1920.png?hl=zh-tw" width="30%" height="30%">

<hr>
<h4 id="完成版面配置的其餘部分"><a href="#完成版面配置的其餘部分" class="headerlink" title="完成版面配置的其餘部分"></a>完成版面配置的其餘部分</h4><p>現在已進入版面配置的最後一個部分。請新增 <code>Switch</code>、<code>Button</code> 和 <code>TextView</code> 以顯示小費金額。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/bcc5260318477c14_1920.png?hl=zh-tw" width="30%" height="30%">

<h5 id="新增切換鈕，讓小費四捨五入"><a href="#新增切換鈕，讓小費四捨五入" class="headerlink" title="新增切換鈕，讓小費四捨五入"></a>新增切換鈕，讓小費四捨五入</h5><p>接下來，您將使用 <a href="https://developer.android.com/reference/kotlin/android/widget/Switch"><code>Switch</code></a> 小工具，讓使用者選取「Yes」或「No」是否要將小費四捨五入。</p>
<p>您想要 <code>Switch</code> 的寬度和父項一樣，因此您可能會認為寬度應該設為 <code>match_parent</code>。如前文所述，您無法在 <code>ConstraintLayout</code> 的 UI 元素上設定 <code>match_parent</code>。相反地，您需要限制檢視畫面的開始和結束時間，並將寬度設為 <code>0dp</code>。將寬度設為 <code>0dp</code> 可讓系統不要計算寬度，只要嘗試與檢視畫面中的限制條件相符即可。</p>
<div class="note no-cion success">
            <p><strong>注意</strong>：您無法在 <b>match_parent</b> 中使用 <b>ConstraintLayout</b> 的任何資料檢視。而是使用 <b>0dp</b>，也就是相符條件。</p>
          </div>

<ol>
<li>在 <code>RadioGroup</code> 的 XML 後方加入 <code>Switch</code> 元素。</li>
<li>如上所述，將 <code>layout_width</code> 設為 <code>0dp</code></li>
<li>將 <code>layout_height</code> 設為 <code>wrap_content</code> 這會將 <code>Switch</code> 觀看內容與內部內容高度一樣。</li>
<li>將 <code>id</code> 屬性設為 <code>@+id/round_up_switch</code>。</li>
<li>將 <code>text</code> 屬性設為 <code>Round up tip?</code>。這會做為 <code>Switch</code> 的標籤使用。</li>
<li>將 <code>Switch</code> 的起始點限制為 <code>tip_options</code> 的起始邊緣，並將結尾點限制為父項的終點邊緣。</li>
<li>將 <code>Switch</code> 的頂端限制在 <code>tip_options</code> 的底部。</li>
<li>使用 <code>/&gt;</code> 關閉標記。</li>
</ol>
<p>如果切換按鈕預設為開啟，且有 <code>android:checked</code> 的屬性，則可能的值為 <code>true</code> (開啟) 或 <code>false</code> (關閉)。</p>
<ol start="9">
<li>將 <code>android:checked</code> 屬性設為 <code>true</code></li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Switch</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/round_up_switch&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:checked</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Round up tip?&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;@id/tip_options&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/tip_options&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<div class="note no-icon danger">
            <p><strong>注意</strong>：如果您將滑鼠遊標懸停在 XML 版面配置中的 <code>Switch</code> 元素上，Android Studio 會顯示以下建議：「使用 <code>AppCompat</code> 的 <code>SwitchCompat</code>，或 <code>Material</code> 資料庫的 <code>SwitchMaterial</code>」。稍後您將在建構小費計算機應用程式的程式碼研究室中實作此建議，因此您可以忽略這則警告。</p>
          </div>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/d374fab984650296_1920.png?hl=zh-tw" width="50%" height="50%">

<h5 id="新增計算按鈕"><a href="#新增計算按鈕" class="headerlink" title="新增計算按鈕"></a>新增計算按鈕</h5><p>接著，您必須新增 <code>Button</code> 來向使用者說明小費的計算方式。您想將按鈕設為與上層最寬，因此水平限制和寬度與 <code>Switch</code> 相同。</p>
<ol>
<li>在 <code>Switch</code> 後方加上 <code>Button</code>。</li>
<li>請將寬度設為 <code>0dp</code>，方法與 <code>Switch</code> 相同。</li>
<li>將高度設為 <code>wrap_content</code>。</li>
<li>為資源 ID <code>@+id/calculate_button</code> 輸入文字，格式為<code>「&quot;Calculate&quot;」</code>。</li>
<li>將 <code>Button</code> 的上方邊緣固定到<code>Switch</code>的底部邊緣</li>
<li>將起始邊緣限制為上層的起點，以及將結尾邊緣設為父項的終點邊緣。</li>
<li>使用 <code>/&gt;</code> 關閉標記。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:id</span>=<span class="string">&quot;@+id/calculate_button&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_width</span>=<span class="string">&quot;0dp&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">android:text</span>=<span class="string">&quot;Calculate&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/round_up_switch&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintStart_toStartOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/5338cf87c61d15c9_1920.png?hl=zh-tw" width="50%" height="50%">

<h5 id="新增小費計算結果"><a href="#新增小費計算結果" class="headerlink" title="新增小費計算結果"></a>新增小費計算結果</h5><p>就快完成了版面配置！在這個步驟中，您會為小費的結果加上 <code>TextView</code>、將其放在<code>「Calculate」</code>按鈕下方，並且與結尾處對齊，而非與其他 UI 元素一樣放在開始處。</p>
<ol>
<li>新增具有 ID 為 <code>tip_result</code> 且 ID 為 <code>Tip Amount</code> 的 <code>TextView</code>。</li>
<li>將 <code>TextView</code> 的結尾邊緣限制在父項的終點邊緣。</li>
<li>限制「Calculate」按鈕的上方與下方的邊緣。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/tip_result&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintEnd_toEndOf</span>=<span class="string">&quot;parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:layout_constraintTop_toBottomOf</span>=<span class="string">&quot;@id/calculate_button&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;Tip Amount&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>

<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/9644bcdabbd8d7d1_1920.png?hl=zh-tw" width="50%" height="50%">

<ol start="4">
<li>執行應用程式。看起來應該要像這個螢幕截圖一樣。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-xml-layouts/img/e4ed552fa9fbe4ce_1920.png?hl=zh-tw" width="30%" height="30%">

<p>實際執行畫面：</p>
<img src="https://i.imgur.com/iSz3wCT.png" width="30%" height="30%">

<hr>
<h4 id="採用完善程式設計做法"><a href="#採用完善程式設計做法" class="headerlink" title="採用完善程式設計做法"></a>採用完善程式設計做法</h4><h5 id="擷取字串"><a href="#擷取字串" class="headerlink" title="擷取字串"></a>擷取字串</h5><ol>
<li><p>按一下字串；將滑鼠游標懸停在顯示的黃色燈泡圖示上，然後按一下旁邊的三角形圖示；選擇「Extract String Resource」。字串資源的預設名稱沒有問題。您可以視需要根據提示選擇使用 <code>amazing_service</code>、<code>good_service</code> 和 <code>ok_service</code>，讓名稱更加描述性。</p>
</li>
<li><p>如果畫面上未顯示「Project」視窗，請按一下視窗左側的「Project」分頁標籤。</p>
</li>
<li><p>開啟 <strong>app &gt; res &gt; values &gt; string.xml</strong> 查看所有 UI 字串資源。</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;app_name&quot;</span>&gt;</span>Tip Time<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;cost_of_service&quot;</span>&gt;</span>Cost of Service<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;how_was_the_service&quot;</span>&gt;</span>How was the service?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;amazing_service&quot;</span>&gt;</span>Amazing (20%)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;good_service&quot;</span>&gt;</span>Good (18%)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;ok_service&quot;</span>&gt;</span>Okay (15%)<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;round_up_tip&quot;</span>&gt;</span>Round up tip?<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;calculate&quot;</span>&gt;</span>Calculate<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">string</span> <span class="attr">name</span>=<span class="string">&quot;tip_amount&quot;</span>&gt;</span>Tip Amount<span class="tag">&lt;/<span class="name">string</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="重新格式化-XML"><a href="#重新格式化-XML" class="headerlink" title="重新格式化 XML"></a>重新格式化 XML</h5><ol>
<li>在 <code>activity_main.xml</code> 中，選擇「Edit」&gt;「Select All」。</li>
<li>依序選擇「Code」&gt;「Reformat Code」。</li>
</ol>
<p>以確保縮排一致，且可能會將 UI 元素的部分 XML 重新排序，例如將單一元素的所有 android: 屬性放在一起。</p>
<hr>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><ul>
<li>XML (擴充標記語言) 可用來管理文字，由標記、元素和屬性構成。</li>
<li>使用 XML 定義 Android 應用程式的版面配置。</li>
<li>使用 <code>EditText</code> 可讓使用者輸入內容或編輯文字。</li>
<li><code>EditText</code> 可提示用戶指定該欄位的內容。</li>
<li>指定 <code>android:inputType</code> 屬性，以限制用戶可輸入 <code>EditText</code> 欄位的文字類型。</li>
<li>列出包含 <code>RadioButtons</code> 的獨家選項清單 (使用 <code>RadioGroup</code> 分組)。</li>
<li><code>RadioGroup</code> 可以是垂直或水平，而您也可以指定要最初選取的 <code>RadioButton</code>。</li>
<li>使用 <code>Switch</code> 可讓用戶在兩個選項之間切換。</li>
<li>您不必使用個別的 <code>TextView</code>，就可以將標籤新增至 <code>Switch</code>。</li>
<li><code>ConstraintLayout</code> 中的每個子項都必須包含垂直和水平限制條件。</li>
<li>使用「start」和「end」限制條件來處理由左至右 (LTR) 和右至左 (RTL) 的語言。</li>
<li>限制屬性名稱會依照 <code>layout_constraint&lt;Source&gt;_to&lt;Target&gt;Of</code> 的格式提供。</li>
<li>如要讓 <code>View</code> 盡可能適用於目標 <code>ConstraintLayout</code>，請將開頭和結尾限制為父項的開頭和結尾，然後將寬度設為 <code>0dp</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>XML</tag>
        <tag>Layout</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(9)-Kotlin中的類別與繼承</title>
    <url>/2023/09/01/Android%E7%AD%86%E8%A8%98-9-Kotlin%E4%B8%AD%E7%9A%84%E9%A1%9E%E5%88%A5%E8%88%87%E7%B9%BC%E6%89%BF/</url>
    <content><![CDATA[<blockquote>
<p>若要建構較為複雜的應用程式，必須深入瞭解類別與繼承的運作方式，以便充分運用 Android 平台所提供的功能。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>建立Kotlin程式，並使用繼承實作類別階層。</li>
<li>擴充類別、覆寫現有的功能，並新增功能。</li>
<li>選擇變數適用的適當瀏覽權限修飾符。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="什麼是類別階層？"><a href="#什麼是類別階層？" class="headerlink" title="什麼是類別階層？"></a>什麼是類別階層？</h4><p>使用者習慣為類似的屬性和行為項目分門別類，甚至排列一些類型的階層。舉例來說，在<code>蔬菜</code>等廣泛的類別下，可以細分為<code>豆類</code>等類型。豆類下可以再細分為<code>豌豆、四季豆、扁豆、鷹嘴豆、大豆</code>等。</p>
<p>而這可用階層表示，因為<code>豆類包含或沿用蔬菜的所有屬性</code> (例如兩者均為可食用植物)。以此類推，豌豆、四季豆、扁豆都有豆類的屬性，外加豆類獨有的屬性。</p>
<p>以下說明如何以程式設計術語表示上述關係。如果在 Kotlin 中將 <code>Vegetable(蔬菜)</code> 設為類別，即可建立 <code>Legume(豆類)</code> 做為子項，或 <code>Vegetable</code>類別的<span class="label danger">子類別</span>。即 <code>Legume</code>類別會<span class="label danger">繼承</span> (也可使用) <code>Vegetable</code>類別<span class="label danger">所有的屬性和方法</span>。</p>
<p>以下的類別階層圖表可顯示這項關係。您可以參照 <code>Vegetable</code> 做為 <code>Legume</code> 類別的父項或父類別。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/87e0a5eb0f85042d_1920.png?hl=zh-tw" width="50%" height="50%">

<p>接著建立 <code>Legume</code> 的子類別 (例如 <code>Lentil(扁豆)</code> 和 <code>Chickpea(鷹嘴豆)</code>)，然後繼續展開類別階層。這會將 <code>Legume</code> 設為 <code>Vegetable</code> 的子項或子類別，同時也設為 <code>Lentil</code> 和 <code>Chickpea</code> 的父項或父類別。<code>Vegetable</code> 是這個階層的「根」層級或頂層 (或基礎) 類別。</p>
<div class="note no-icon success">
            <ul><li>類別階層：父項和子項階層分類的排列方式。階層圖的父項通常顯示在子項上方。</li><li>子項或子類別：在階層中位於其他類別下方的任何類別。</li><li>父項、父類別或基礎類別：包含一個以上子項類別的任何類別。</li><li>根層級或頂層類別：在類別階層頂端 (或根層級) 的類別。</li><li>繼承：子項類別包含 (或繼承) 父項類別所有的屬性和方法時，您可以分享並重複使用程式碼，讓程式更容易瞭解和維護。</li></ul>
          </div>

<h5 id="Android-類別中的繼承"><a href="#Android-類別中的繼承" class="headerlink" title="Android 類別中的繼承"></a>Android 類別中的繼承</h5><p>舉例來說，Android 的 <code>View</code> 類別代表螢幕上負責繪圖和事件處理的長方形區域。<code>TextView</code> 類別是 <code>View</code> 類別的子類別，代表 <code>TextView</code> 繼承 <code>View</code> 類別的所有屬性和功能，並新增向使用者顯示文字的特定邏輯。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/c39a8aaa5b013de8_1920.png?hl=zh-tw" width="60%" height="60%">

<p>更進一步來說，<a href="https://developer.android.com/reference/kotlin/android/widget/EditText"><code>EditText</code></a> 和 <a href="https://developer.android.com/reference/kotlin/android/widget/Button"><code>Button</code></a> 類別是 <code>TextView</code> 類別的子項。這些類別繼承 <code>TextView</code> 和 <code>View</code> 類別所有的屬性和方法，並新增專屬的特定邏輯。例如，<code>EditText</code> 加入可編輯螢幕上文字的專屬功能。</p>
<p><code>EditText</code> 可以直接加入 <code>TextView</code> 類別的子類別，同時加入 <code>View</code> 類別的子類別，不必在 <code>EditText</code> 類別複製及貼上 <code>View</code> 和 <code>TextView</code> 類別的所有邏輯。然後，<code>EditText</code> 類別中的程式碼可以致力讓 <code>UI 元件</code>不同於其他檢視畫面。</p>
<p>在 <code>developers.android.com</code> 網站 Android 類別的<a href="https://developer.android.com/reference/kotlin/android/widget/Button?hl=zh-tw">文件資訊頁面</a>頂端上，即可找到類別階層圖。如果您在階層頂端看到 <code>kotlin.Any</code>，原因是 <span class="label primary">Kotlin 中所有類別都有相同的父類別「Any」</span>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/1ce2b1646b8064ab_1920.png?hl=zh-tw" width="40%" height="40%">

<hr>
<h4 id="建立基礎類別"><a href="#建立基礎類別" class="headerlink" title="建立基礎類別"></a>建立基礎類別</h4><h5 id="住宅類別階層"><a href="#住宅類別階層" class="headerlink" title="住宅類別階層"></a>住宅類別階層</h5><p>該程式使用<code>住宅和樓層空間、樓層和居民</code>做為範例，示範類別階層的運作方式。</p>
<p>以下是您要建構的類別階層圖。根層級的 <code>Dwelling(住宅)</code> 會指定住宅為 true 的屬性和功能 (類似於藍圖)。接著，您會看到<code>方形小屋(SquareCabin)</code>、<code>圓型茅屋(RoundHut)</code>，以及 <code>圓塔(RoundTower，也就是多樓層的 RoundHut)</code>。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/de1387ca7fc26c81_1920.png?hl=zh-tw" width="50%" height="50%">

<p>實作的類別：</p>
<ul>
<li><code>Dwelling</code>：代表非特定遮蔽處的基本類別，包含所有住宅通用資訊。</li>
<li><code>SquareCabin</code>：正方形樓層面積的木製正方形小屋。</li>
<li><code>RoundHut</code>：茅草建造的圓形茅屋，包含圓形樓層面積和 RoundTower 的父項。</li>
<li><code>RoundTower</code>：石頭建造的圓塔，包含圓形樓層面積和多個樓層。</li>
</ul>
<h5 id="建立抽象住宅類別"><a href="#建立抽象住宅類別" class="headerlink" title="建立抽象住宅類別"></a>建立抽象住宅類別</h5><p>「abstract」(抽象) 類別是因為未完整實作，無法執行個體化的類別。您可以將其視為草圖。草圖包含專案的靈感和規劃，但往往缺少資訊建構專案。請使用<code>草圖(abstract class)</code> 建立<code>藍圖(class)</code>，然後建構實際的<code>物件執行個體(object/instance)</code>。</p>
<p>建立父類別常見的好處是，包含所有子類別通用的屬性和函式。如果<code>不知道屬性的值和函式的實作</code>，請將類別設為<code>抽象</code>。舉例來說，<code>Vegetables</code> 包含許多所有蔬菜通用的屬性，但您無法為非特定蔬菜建立執行個體，因為您沒有具體資訊，例如形狀或顏色。因此，<code>Vegetable</code> 是抽象類別，由子類別確定每種蔬菜的特定詳細資料。</p>
<p>抽象類別的宣告是以 <code>abstract</code> 關鍵字做為開頭。</p>
<p><code>Dwelling</code> 是 <code>Vegetable</code> 的抽象類別，它會包含很多類型的住宅通用的屬性和函式，但不知道屬性確切的值和函式實作的詳細資料。</p>
<ol>
<li>前往 Kotlin Playground：<a href="https://developer.android.com/training/kotlinplayground%E3%80%82">https://developer.android.com/training/kotlinplayground。</a></li>
<li>在編輯器中，刪除 main() 函式中的 println(“Hello, world!”)。</li>
<li>然後在 main() 函式下方加入以下程式碼，建立名為 Dwelling 的 abstract 類別</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>()&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新增建材的屬性"><a href="#新增建材的屬性" class="headerlink" title="新增建材的屬性"></a>新增建材的屬性</h5><p>在這個 <code>Dwelling</code> 類別中，您可以定義所有住宅為 true 的建材，即使建材會因不同的住宅而異。所有住宅都使用建材建構。</p>
<ol start="4">
<li>在 <code>Dwelling</code> 中，建立類型 <code>String</code> 的 <code>buildingMaterial</code> 變數以代表建材。因為建材不會變更，請使用 <code>val</code> 做為建材不可變的變數。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>()&#123;</span><br><span class="line">    <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行程式後，您會看到以下錯誤訊息。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Property must be initialized or be <span class="keyword">abstract</span></span><br></pre></td></tr></table></figure>

<p><code>buildingMaterial</code> 屬性沒有值。其實您「無法」指定值，因為非特定的建築物不會使用任何特定建材。所以如錯誤訊息所示，您可以在 <code>buildingMaterial</code> 的宣告中前置 <code>abstract</code> 關鍵字，表示不會在這裡定義此屬性。</p>
<ol start="6">
<li>在變數定義中加入 <code>abstract</code> 關鍵字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>重新執行程式後，將不會出現錯誤。</li>
<li>在 <code>main()</code> 函式中建立 <code>Dwelling</code> 的執行個體，並執行程式碼。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> dwelling = Dwelling()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>錯誤訊息的原因是，無法建立抽象 <code>Dwelling</code> 類別的執行個體。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Cannot create an instance of an <span class="keyword">abstract</span> <span class="keyword">class</span></span><br></pre></td></tr></table></figure>

<ol start="10">
<li>刪除不正確的程式碼。</li>
</ol>
<p>目前完成的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新增容量屬性"><a href="#新增容量屬性" class="headerlink" title="新增容量屬性"></a>新增容量屬性</h5><p>住宅的另一個屬性是<code>居住的人數</code>。</p>
<p>所有住宅的容量都不會變更。但 <code>Dwelling</code> 父類別中無法設定<code>容量</code>。如果是特定類型的住宅，請在子類別定義容量。</p>
<p>在 <code>Dwelling</code> 中，新增名為 <code>capacity</code> 的 <code>abstract</code> 整數 <code>val</code>。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>()&#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="新增居民數目的私有屬性"><a href="#新增居民數目的私有屬性" class="headerlink" title="新增居民數目的私有屬性"></a>新增居民數目的私有屬性</h5><p>所有住宅都有很多 <code>residents(居民)</code> 居住在其中 (數目可能小於或等於 capacity)，所以為了繼承並使用屬性，請定義所有子類別 <code>Dwelling</code> 中的 <code>residents</code> 屬性。</p>
<p>您可以將 <code>residents</code> 參數傳遞至 <code>Dwelling</code> 類別建構函式。<code>residents</code> 屬性為 <code>var</code>，因為建立執行個體後，可以變更居民數目。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br></pre></td></tr></table></figure>

<p><code>residents</code> 屬性會標示 <code>private</code> 關鍵字。<code>Private(私有)</code> 是 Kotlin 的<a href="https://kotlinlang.org/docs/visibility-modifiers.html#classes-and-interfaces">可見度修飾符</a>，即只有這個類別能看到 (並使用) <code>residents</code> 屬性。程式其他位置無法存取此屬性。您可以使用 <code>private</code> 關鍵字標示屬性或方法。否則，在未指定瀏覽權限修飾符時，這些屬性和方法會預設為 <code>public</code>，並可透過程式的其他位置存取。有鑑於住宅的居民數目通常是私人資訊 (相對於建材或建築物容量)，這樣的決定很合理。</p>
<p>使用住宅的 <code>capacity</code> 和目前 <code>residents</code> 定義的數目，您可以建立函式 <code>hasRoom()</code>，判斷住宅是否空房容納其他居民。您可以在 <code>Dwelling</code> 類別中定義並實作 <code>hasRoom()</code> 函式，因為計算所有住宅是否有空房，使用的是相同的公式。如果 <code>residents</code> 的數目<span class="label danger">小於</span> <code>capacity</code>，<code>Dwelling</code> 中會顯示<span class="label danger">空房</span>，然後此函式會根據比較值傳回 <code>true</code> 或 <code>false</code> 。</p>
<p>新增 <code>hasRoom()</code> 函式至 <code>Dwelling</code> 類別。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成的程式碼如下：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="建立子類別"><a href="#建立子類別" class="headerlink" title="建立子類別"></a>建立子類別</h4><h5 id="建立-SquareCabin-子類別"><a href="#建立-SquareCabin-子類別" class="headerlink" title="建立 SquareCabin 子類別"></a>建立 SquareCabin 子類別</h5><ol>
<li>在 <code>Dwelling</code> 類別下方，建立名為 <code>SquareCabin</code> 的類別。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>接著，您必須指出 <code>SquareCabin</code> 和 <code>Dwelling</code> 的關連。在程式碼中，您要指出 <code>SquareCabin</code> 是 <code>Dwelling</code> 的延伸模組 (或 <code>Dwelling</code>) 的子類別，因為 <code>SquareCabin</code> 會提供 <code>Dwelling</code> 抽象部分的實作)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>: <span class="type">Dwelling</span>()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>從父類別延伸時，您必須傳入父類別必要的參數。<code>Dwelling</code> 要求 <code>residents</code> 數目做為輸入內容。您可以傳入居民的固定數目 (例如 <code>3</code>)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>: <span class="type">Dwelling</span>(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>但若要程式更有彈性，並可以使用 <code>SquareCabins</code> 居民的變數數目，請在 <code>SquareCabin</code> 類別定義中，將 <code>residents</code> 設為參數。請勿將 <code>residents</code> 宣告為 <code>val</code>,，因為您會重複使用父項類別 <code>Dwelling</code> 中宣告的屬性。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>): Dwelling(residents)</span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意</strong>：使用這些類別定義後，系統會在背景中執行很多操作。</p><p>在類別標頭中，您會看到 <b>class SquareCabin(residents: Int) …</b><br>這其實是 <b>class SquareCabin constructor(residents: Int) …</b> 的簡寫</p><p>透過類別建立物件執行個體時，系統會呼叫 <b>constructor</b>。例如，當您呼叫 <b>SquareCabin(4)</b> 時，系統會呼叫 <b>SquareCabin</b> 的 <b>constructor</b>，並初始化物件執行個體。</p><p>根據類別中的資訊 (包括引數中傳遞的資訊)，<b>constructor</b> 會建構執行個體。類別繼承父項的屬性和函式後，<b>constructor</b> 會呼叫父項類別的 <b>constructor</b>，完成物件執行個體的初始化作業。</p><p>因此，使用 <b>SquareCabin(4)</b> 建立執行個體時，程式會執行 <b>SquareCabin</b> 的 <b>constructor</b>，並基於繼承關係，同時執行 <b>Dwelling</b> 建構函式。<b>Dwelling</b> 類別定義指定其建構函式需要 <b>residents</b> 參數，所以在 <b>SquareCabin</b> 類別定義中，您會看到 <b>residents</b> 傳遞至 <b>Dwelling</b> 建構函式。在後續的程式碼研究室中，您將深入瞭解建構函式。</p>
          </div>

<ol start="4">
<li>執行程式碼。</li>
<li>這會導致錯誤發生。</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Class &#x27;SquareCabin&#x27; is not abstract and does not implement abstract base class member public abstract val buildingMaterial: String defined in Dwelling</span><br></pre></td></tr></table></figure>

<p>宣告抽象函式和變數和 <code>promise</code> 一樣，您會在之後提供值並實作。以<code>變數</code>來說，即代表您<span class="label danger">必須提供值給抽象類別的子類別</span>。以<code>函式</code>來說，即<span class="label danger">子類別必須實作函式主體</span>。</p>
<p>在 <code>Dwelling</code> 類別中，您已定義 <code>abstract</code> 變數為 <code>buildingMaterial</code>。<code>SquareCabin</code> 是 <code>Dwelling</code> 的子類別，所以必須提供 <code>buildingMaterial</code> 的值。使用 <code>override</code> 關鍵字，指出父項類別<span class="label danger">已定義</span>這個屬性，並會在此類別中<span class="label danger">覆寫</span>。</p>
<ol start="6">
<li>在 <code>SquareCabin</code> 類別中，<code>override</code> <code>buildingMaterial</code> 屬性並指派屬性的值為 <code>&quot;Wood&quot;</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>): Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>對 <code>capacity</code> 執行相同動作，例如 <code>6</code> 位居民可以住在 <code>SquareCabin</code>。<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>): Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>完成的程式碼應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>若要測試程式碼，請在程式中建立 <code>SquareCabin</code> 的執行個體。</p>
<h5 id="使用-SquareCabin"><a href="#使用-SquareCabin" class="headerlink" title="使用 SquareCabin"></a>使用 SquareCabin</h5><ol>
<li>在 <code>Dwellin</code> 和 <code>SquareCabin</code> 類別定義前，插入空白的 <code>main()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>main()</code> 函式中，建立容納 <code>6</code> 位居民，名為 <code>squareCabin</code> 的 <code>SquareCabin</code> 執行個體。新增建材、容量的輸出陳述式，以及 <code>hasRoom()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Capacity: <span class="subst">$&#123;squareCabin.capacity&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Material: <span class="subst">$&#123;squareCabin.buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Has room? <span class="subst">$&#123;squareCabin.hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<div class="note no-icon primary">
            <p>在 <code>SquareCabin</code> 類別中未定義 <code>hasRoom()</code> 函式，但在 <code>Dwelling</code> 類別中為已定義。因為 <code>SquareCabin</code> 是 <code>Dwelling</code> 類別的子類別，所以會<strong>無條件繼承</strong> <code>hasRoom()</code> 函式。<code>SquareCabin</code> 的<strong>所有執行個體目前已可呼叫 <code>hasRoom()</code> 函式</strong>，如程式碼片段 <code>squareCabin.hasRoom()</code> 所示。</p>
          </div>

<p>執行程式碼，程式碼會輸出以下內容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>您已建立容納 <code>6</code> 位居民 (亦等於 <code>capacity</code>) 的 <code>squareCabin</code>，因此 <code>hasRoom()</code> 會傳回 <code>false</code>。使用較少的 <code>residents</code> 嘗試初始化 <code>SquareCabin</code>，並再次執行程式後，<code>hasRoom()</code> 會傳回 <code>true</code>。</p>
<p>residents(居民)改成5：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h5 id="使用-with-簡化程式碼"><a href="#使用-with-簡化程式碼" class="headerlink" title="使用 with 簡化程式碼"></a>使用 with 簡化程式碼</h5><p>在 <code>println()</code> 陳述式中，每次參考 <code>squareCabin</code> 的屬性或函式時，請注意您必須重複 <code>squareCabin.</code> 的原因。因為複製及貼上輸出陳述式時，可能會發生錯誤。</p>
<p>使用類別的特定執行個體，且必須存取該執行個體的多個屬性和函式時，可以使用 <code>with</code> 陳述式說明：<span class="label primary">「對這個執行個體物件執行下列所有作業」</span>。以關鍵字 <code>with</code> 開頭，接著是括號中的執行個體名稱，後面加上大括號，包含您要執行的作業。</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">with (instanceName) &#123;</span><br><span class="line">    <span class="comment">// all operations to do with instanceName</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">with(squareCabin) &#123;</span><br><span class="line">    println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下是已完成的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>程式碼可正常執行，並顯示相同的輸出內容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="建立-RoundHut-子類別"><a href="#建立-RoundHut-子類別" class="headerlink" title="建立 RoundHut 子類別"></a>建立 RoundHut 子類別</h5><ol>
<li>與 <code>SquareCabin</code> 使用相同的方式，新增另一個子類別 <code>(RoundHut)</code> 至 <code>Dwelling</code>。</li>
<li>覆寫 <code>buildingMaterial</code> 並指定值為 <code>&quot;Straw&quot;</code>。</li>
<li>覆寫 <code>capacity</code> 並設為 <code>4</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundHut</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>main()</code> 中，建立容納 <code>3</code> 位居民的 <code>RoundHut</code> 執行個體，並輸出 <code>roundHut</code> 的資訊。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundHut) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行程式碼，整個程式的輸出內容應為：</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Round Hut</span><br><span class="line">=========</span><br><span class="line">Material: Straw</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>目前的類別階層如下所示，其中 <code>Dwelling</code> 是根層級類別，而 <code>SquareCabin</code> 和 <code>RoundHut</code> 是 <code>Dwelling</code> 的子類別。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/c19084f4a83193a0_1920.png?hl=zh-tw" width="50%" height="50%"></p>
<h5 id="建立-RoundTower-子類別"><a href="#建立-RoundTower-子類別" class="headerlink" title="建立 RoundTower 子類別"></a>建立 RoundTower 子類別</h5><p>這個類別階層最後一個類別是圓塔。圓塔就像是石頭建造、多個樓層的圓形小屋。所以您可以將 <code>RoundTower</code> 設為 <code>RoundHut</code> 的子類別。</p>
<ol>
<li>建立 <code>RoundTower</code> 類別，即 <code>RoundHut</code> 的子類別。將 <code>residents</code> 參數新增至 <code>RoundTower</code> 的建構函式，然後將該參數傳遞至 <code>RoundHut</code> 父類別的建構函式。</li>
<li>將 <code>buildingMaterial</code> 覆寫為 <code>&quot;Stone&quot;</code>。</li>
<li>將 <code>capacity</code> 設為 <code>4</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(residents: <span class="built_in">Int</span>): RoundHut(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>執行這個程式碼後，您會看到錯誤訊息。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">This type <span class="keyword">is</span> <span class="keyword">final</span>, so it cannot be inherited from</span><br><span class="line"><span class="comment">//他的類型是最終類型(final)，因此不能繼承</span></span><br></pre></td></tr></table></figure>

<p>這個錯誤代表無法將 <code>RoundHut</code> 類別設為子類別 (或繼承該類別)。根據預設，在 Kotlin 中，類別為<code>最終類別(final)</code>，且無法加入子類別。只能繼承 <code>abstract</code> 類別，或標示 <code>open</code> 關鍵字的類別。因此，您必須以 <code>open</code> 關鍵字標示 <code>RoundHut</code> 類別，才能繼承類別。</p>
<ol start="5">
<li>請在 <code>RoundHut</code> 宣告開頭加入 <code>open</code> 關鍵字。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>在 <code>main()</code> 中，建立 <code>roundTower</code> 的執行個體，並輸出相關資訊</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundHut) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundTower) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Tower\n==========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完整程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundHut) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundTower) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Tower\n==========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(residents: <span class="built_in">Int</span>) : RoundHut(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Round Hut</span><br><span class="line">=========</span><br><span class="line">Material: Straw</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Round Tower</span><br><span class="line">==========</span><br><span class="line">Material: Stone</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Has room? <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h5 id="新增多個樓層至-RoundTower"><a href="#新增多個樓層至-RoundTower" class="headerlink" title="新增多個樓層至 RoundTower"></a>新增多個樓層至 RoundTower</h5><p><code>RoundHut</code> (圓形茅屋) 是單層建築物。塔通常是多層 (樓層)。<br>想一下容量，塔的樓層越多，容量就越多。<br>您可以修改 <code>RoundTower</code> 為多個樓層，並根據樓層數調整容量。</p>
<ol>
<li>更新 <code>RoundTower</code> 建構函式，並接受另一個整數參數 <code>val</code> <code>floors</code>作為樓層的數量。將其置於 <code>residents</code> 之後。請注意，您不必傳遞參數至父項 <code>RoundHut</code> 建構函式，因為 <code>floors</code> 是在 <code>RoundTower</code> 中定義的，而 <code>RoundHut</code> 沒有 <code>floors</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(residents: <span class="built_in">Int</span>, <span class="keyword">val</span> floors: <span class="built_in">Int</span>) : RoundHut(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行程式碼。在 <code>main()</code> 方法中建立 <code>roundTower</code> 時發生錯誤，因為您未提供 <code>floors</code> 引數的數字。您可以新增遺漏的引數。</li>
</ol>
<p>您也可以在 <code>RoundTower</code> 的類別定義中，新增 <code>floors</code> 的預設值，如下所示。接著，如果 <code>floors</code> 的值未傳遞至建構函式，您可以使用預設值來建立物件執行個體。</p>
<ol start="3">
<li>在程式碼中，在 <code>floors</code> 的宣告後方加上 <code>= 2</code>，即可指派預設值 <code>2</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(residents: <span class="built_in">Int</span>, <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>執行程式碼。程式碼目前應該可以編譯，因為 <code>RoundTower(4)</code> 已可使用 <code>2</code> 個樓層的預設值，建立 <code>RoundTower</code> 物件執行個體。</p>
</li>
<li><p>在 <code>RoundTower</code> 類別中，更新 <code>capacity</code> 即可乘以樓層數。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span> * floors</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行程式碼，並留意 <code>RoundTower</code> <code>2</code> 個層樓的容量目前為 <code>8</code>。</li>
</ol>
<p>以下是已完成的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br><span class="line">    <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundHut) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundTower) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Tower\n==========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(residents: <span class="built_in">Int</span>) : Dwelling(residents) &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(</span><br><span class="line">    residents: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span> * floors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">Round Hut</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Material: Straw</span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">Round Tower</span><br><span class="line">==========</span><br><span class="line">Material: Stone</span><br><span class="line">Capacity: <span class="number">8</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="修改階層中的類別"><a href="#修改階層中的類別" class="headerlink" title="修改階層中的類別"></a>修改階層中的類別</h4><h5 id="計算樓層面積"><a href="#計算樓層面積" class="headerlink" title="計算樓層面積"></a>計算樓層面積</h5><p>在本練習中，您將瞭解在<code>抽象類別</code>中，如何宣告<code>抽象函式</code>，並在<code>子類別</code>實作<code>函式</code>。<br>所有住宅都有<code>樓層面積</code>，但根據住宅的形狀，計算方式會有所不同。</p>
<p><strong>定義住宅類別的 <code>floorArea()</code></strong></p>
<ol>
<li>首先，新增 <code>abstract</code> <code>floorArea()</code> 函式至 <code>Dwelling</code> 類別。傳回 <code>Double</code>。<code>Double</code> 是資料類型 (例如 String 和 Int)，並用於浮點數目，即包含小數點與其後小數部分的數字 (例如 5.8793)。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span></span><br></pre></td></tr></table></figure>

<p>抽象類別中定義的所有<code>抽象方法</code>必須在其<code>子類別</code>中實作。執行程式碼前，您必須在子類別中實作 <code>floorArea()</code>。</p>
<p><strong>實作 <code>SquareCabin</code> 的 <code>floorArea()</code></strong><br>和 <code>buildingMaterial</code> 和 <code>capacity</code> 一樣，既然要實作父項類別定義的 <code>abstract</code> 函式，就必須使用 <code>override</code> 關鍵字。</p>
<ol>
<li>在 <code>SquareCabin</code> 類別中，以關鍵字 <code>override</code> 做為開頭，接著實際實作 <code>floorArea()</code> 函式，如下所示。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>傳回計算的<code>樓層面積</code>。長方形或正方形的面積是邊長乘以另一個邊長。函式主體是 <code>return length * length</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> length * length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>長度不是類別中的變數，也與所有執行個體不同，所以您可以新增長度，做為 <code>SquareCabin</code> 類別的建構函式參數。</p>
<ol start="3">
<li>變更 <code>SquareCabin</code> 的類別定義，並新增 <code>Double</code> 類型的 <code>length</code> 參數。請宣告屬性為 <code>val</code>，因為建築物的長度不變。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>, <span class="keyword">val</span> length: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br></pre></td></tr></table></figure>

<p>所以 <code>Dwelling</code> 和所有子類別都包含 <code>residents</code>，做為建構函式的引數。因為這是 <code>Dwelling</code> 建構函式的第一個引數，所以最佳做法是將該引數設為所有子類別建構函式的<code>第一個引數</code>，並以<code>相同的順序</code>在<code>所有類別</code>定義中放置引數。因此，請在 <code>residents</code> 參數後方插入新的 <code>length</code> 參數。</p>
<ol start="4">
<li>在 <code>main()</code> 中更新 <code>squareCabin</code> 執行個體的建立作業。傳遞 <code>50.0</code> 至 <code>SquareCabin</code> 建構函式，做為 <code>length</code>。</li>
</ol>
<p>原本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>)</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>, <span class="number">50.0</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>squareCabin</code> 的 <code>with</code> 陳述式中，新增樓層面積的輸出陳述式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>執行程式碼會發生以下錯誤</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;floorArea&#x27;</span> overrides nothing</span><br></pre></td></tr></table></figure>

<p>造成錯誤的原因是也必須在 <code>RoundHut</code> 中實作 <code>floorArea()</code>。</p>
<hr>
<h4 id="實作-RoundHut-的-floorArea"><a href="#實作-RoundHut-的-floorArea" class="headerlink" title="實作 RoundHut 的 floorArea()"></a>實作 RoundHut 的 floorArea()</h4><p>請以相同方式，實作 <code>RoundHut</code> 的樓層面積。<code>RoundHut</code> 也是 <code>Dwelling</code> 的直接子類別，所以您必須使用 <code>override</code> 關鍵字。</p>
<p>圓形住宅的樓層面積是 <code>PI * 半徑 * 半徑</code>。</p>
<p><code>PI</code> 是數學值，由數學程式庫定義。程式庫是程式外部定義的函式和數的集合，可供程式使用。若要使用程式庫的函式或值，您必須說明編譯器要使用的函式或值。方法是在程式匯入函式或值。若要在程式中使用 PI，請匯入 <code>kotlin.math.PI</code>。</p>
<ol>
<li>從 Kotlin 數學程式庫匯入 <code>PI</code>。在檔案頂端的 <code>main()</code> 前放置下列內容。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.PI</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>實作 <code>RoundHut</code> 的 <code>floorArea()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>更新 <code>RoundHut</code> 建構函式，並傳入 <code>radius</code>。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(</span><br><span class="line">   residents: <span class="built_in">Int</span>,</span><br><span class="line">   <span class="keyword">val</span> radius: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>main()</code> 中，傳遞 <code>10.0</code> 的 <code>radius</code> 至 <code>RoundHut</code> 建構函式，即可更新 <code>roundHut</code> 的初始化作業。</li>
</ol>
<p>原本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>, <span class="number">10.0</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>在 <code>roundHut</code> 的 <code>with</code> 陳述式中，加入輸出陳述式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<h5 id="實作-RoundTower-的-floorArea"><a href="#實作-RoundTower-的-floorArea" class="headerlink" title="實作 RoundTower 的 floorArea()"></a>實作 RoundTower 的 floorArea()</h5><p>程式碼無法執行，並因為下列錯誤失敗：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Error: No value passed <span class="keyword">for</span> parameter <span class="string">&#x27;radius&#x27;</span></span><br></pre></td></tr></table></figure>

<p>在 <code>RoundTower</code> 中，若要程式順利編譯，其實不必實作 <code>floorArea()</code>，因為圓塔會繼承 <code>RoundHut</code> 的樓層面積，但為了使用相同的 <code>radius</code> 引數做為其父項 <code>RoundHut</code>，您必須更新 <code>RoundTower</code> 類別定義。</p>
<ol>
<li>變更 <code>RoundTower</code> 的建構函式，讓其也接受 <code>radius</code>。在 <code>residents</code> 後方和 <code>floors</code> 前放置 <code>radius</code>。建議您使用結尾列出包含預設值的變數。請記得傳遞 <code>radius</code> 至父項類別建構函式。</li>
</ol>
<p>原本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(</span><br><span class="line">    residents: <span class="built_in">Int</span>, </span><br><span class="line">    <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(</span><br><span class="line">    residents: <span class="built_in">Int</span>,</span><br><span class="line">    radius: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents, radius) &#123;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>更新 <code>main()</code> 中的 <code>roundTower</code> 初始化作業。</li>
</ol>
<p>原本：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>改成：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>, <span class="number">15.5</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>然後加入呼叫 <code>floorArea()</code> 的輸出陳述式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>您現在可以執行程式碼了！</p>
</li>
<li><p>請注意，<code>RoundTower</code> 的計算不正確，因為圓塔繼承 <code>RoundHut</code>，所以不會計算 <code>floors</code> 的數目。</p>
</li>
<li><p>在 <code>RoundTower</code> 中，<code>override</code> <code>floorArea()</code> 提供不同的實作，讓面積可以乘以樓層數。請注意，您可以在抽象類別 <code>(Dwelling)</code> 中定義函式、在子類別 <code>(RoundHut)</code> 中實作函式，然後在子類別 <code>(RoundTower)</code> 的子類別中，再次覆寫該函式。這是兩個類別的最佳做法，您可以繼承需要的功能，並覆寫不必要的功能。</p>
</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius * floors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>這個程式碼可以使用，但 <code>RoundHut</code> 父項類別中，已有方法可以避免重複的程式碼。您可以從父類別 <code>RoundHut</code> 呼叫 <code>floorArea()</code> 函式，該函式會傳回 <code>PI * radius * radius</code>。然後再將此結果乘以 <code>floors</code> 的數目。</p>
<ol start="7">
<li>在 <code>RoundTower</code> 中，更新 <code>floorArea()</code> 並使用 <code>floorArea()</code> 的父類別實作。使用 <code>super</code> 關鍵字呼叫父項中定義的函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.floorArea() * floors</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>再次執行程式碼，然後 <code>RoundTower</code> 會輸出多個樓層的正確樓層空間。</li>
</ol>
<p>以下是已完成的程式碼：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.PI</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>, <span class="number">50.0</span>)</span><br><span class="line">    <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>, <span class="number">10.0</span>)</span><br><span class="line">    <span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>, <span class="number">15.5</span>)</span><br><span class="line"></span><br><span class="line">    with(squareCabin) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundHut) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    with(roundTower) &#123;</span><br><span class="line">        println(<span class="string">&quot;\nRound Tower\n==========&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">        println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> length: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> length * length</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(residents: <span class="built_in">Int</span>,</span><br><span class="line">    <span class="keyword">val</span> radius: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> PI * radius * radius</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(residents: <span class="built_in">Int</span>, radius: <span class="built_in">Double</span>,</span><br><span class="line">    <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents, radius) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line">    <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span> * floors</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.floorArea() * floors</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸出內容應如下所示：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line">Floor area: <span class="number">2500.0</span></span><br><span class="line"></span><br><span class="line">Round Hut</span><br><span class="line">=========</span><br><span class="line">Material: Straw</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line">Floor area: <span class="number">314.1592653589793</span></span><br><span class="line"></span><br><span class="line">Round Tower</span><br><span class="line">==========</span><br><span class="line">Material: Stone</span><br><span class="line">Capacity: <span class="number">8</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line">Floor area: <span class="number">1509.5352700498956</span></span><br></pre></td></tr></table></figure>

<div class="note no-icon success">
            <p><strong>注意</strong>：以面積值來說，只顯示兩位數小數，使用者體驗會較好。面積不是本程式碼研究室的學習範圍，但您可以使用下列程式碼，輸出樓層面積：</p><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Floor area: %.2f&quot;</span>.format(floorArea()))</span><br></pre></td></tr></table></figure>
          </div>

<h5 id="允許新居民取得房間"><a href="#允許新居民取得房間" class="headerlink" title="允許新居民取得房間"></a>允許新居民取得房間</h5><p>新增功能，使用 <code>getRoom()</code> 函式增加 <code>1</code> 位居民的數目，讓新居民取得房間。這個邏輯適用所有住所，所以您可以在 <code>Dwelling</code> 中實作這個函式，同時所有子類別和其子項都可使用這個函式。</p>
<ul>
<li>使用 <code>if</code> 陳述式，只在有容量剩餘時，才能新增居民。</li>
<li>輸出結果訊息。</li>
<li>您可以使用 <code>residents++</code> 做為新增 <code>1</code> 至 <code>residents</code> 變數的函式 <code>residents = residents + 1</code> 簡寫。</li>
<li>在 <code>Dwelling</code> 類別中實作 <code>getRoom()</code> 函式。</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">getRoom</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &gt; residents) &#123; <span class="comment">//如果容量&gt;居住人數 (有空房)</span></span><br><span class="line">        residents++ <span class="comment">//讓新居民取得房間</span></span><br><span class="line">        println(<span class="string">&quot;You got a room!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Sorry, at capacity and no rooms left.&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增一些輸出陳述式至 <code>roundHut</code> 的 <code>with</code> 陳述式區塊，並觀察搭配使用 <code>getRoom()</code> 和 <code>hasRoom()</code> 的變化。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">getRoom()</span><br><span class="line">println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">getRoom()</span><br></pre></td></tr></table></figure>

<p>這些輸出陳述式的輸出內容：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Has room? <span class="literal">true</span></span><br><span class="line">You got a room!</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line">Sorry, at capacity and no rooms left.</span><br></pre></td></tr></table></figure>

<h5 id="調整圓形住宅的地毯"><a href="#調整圓形住宅的地毯" class="headerlink" title="調整圓形住宅的地毯"></a>調整圓形住宅的地毯</h5><p>假設您需要知道 <code>RoundHut</code> 和 <code>RoundTower</code> 的地毯側邊長度是多少。在 <code>RoundHut</code> 放置函式，供所有圓形住所使用。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-classes-and-inheritance/img/2e328a198a82c793_1920.png?hl=zh-tw" widtg="40%" height="40%">

<ol>
<li>首先，從 <code>kotlin.math</code> 程式庫匯入 <code>sqrt()</code> 函式。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> kotlin.math.sqrt</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>RoundHut</code> 類別中實作 <code>calculateMaxCarpetLength()</code> 函式。以下公式可以計算置於圓形居所的方形地毯長度：<code>sqrt(2) * radius</code>。詳情請見上圖。</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">calculateMaxCarpetLength</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> sqrt(<span class="number">2.0</span>) * radius</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>將 <code>Double</code> 值 <code>2.0</code> 傳至數學函式 <code>sqrt(2.0)</code>，因為函式的傳回類型為 <code>Double</code>，而非<code>Integer</code>。</p>
</li>
<li><p><code>RoundHut</code> 和 <code>RoundTower</code> 執行個體目前已可呼叫 <code>calculateMaxCarpetLength()</code> 方法。新增輸出陳述式至 <code>main()</code> 函式中的 <code>roundHut</code> 和 <code>roundTower</code>。</p>
</li>
</ol>
<hr>
<h4 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h4><figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Program that implements classes for different kinds of dwellings.</span></span><br><span class="line"><span class="comment">* Shows how to:</span></span><br><span class="line"><span class="comment">* Create class hierarchy, variables and functions with inheritance,</span></span><br><span class="line"><span class="comment">* abstract class, overriding, and private vs. public variables.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> kotlin.math.PI</span><br><span class="line"><span class="keyword">import</span> kotlin.math.sqrt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">   <span class="keyword">val</span> squareCabin = SquareCabin(<span class="number">6</span>, <span class="number">50.0</span>)</span><br><span class="line">   <span class="keyword">val</span> roundHut = RoundHut(<span class="number">3</span>, <span class="number">10.0</span>)</span><br><span class="line">   <span class="keyword">val</span> roundTower = RoundTower(<span class="number">4</span>, <span class="number">15.5</span>)</span><br><span class="line"></span><br><span class="line">   with(squareCabin) &#123;</span><br><span class="line">       println(<span class="string">&quot;\nSquare Cabin\n============&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   with(roundHut) &#123;</span><br><span class="line">       println(<span class="string">&quot;\nRound Hut\n=========&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">       getRoom()</span><br><span class="line">       println(<span class="string">&quot;Has room? <span class="subst">$&#123;hasRoom()&#125;</span>&quot;</span>)</span><br><span class="line">       getRoom()</span><br><span class="line">       println(<span class="string">&quot;Carpet size: <span class="subst">$&#123;calculateMaxCarpetLength()&#125;</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   with(roundTower) &#123;</span><br><span class="line">       println(<span class="string">&quot;\nRound Tower\n==========&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Material: <span class="subst">$&#123;buildingMaterial&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Capacity: <span class="subst">$&#123;capacity&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Floor area: <span class="subst">$&#123;floorArea()&#125;</span>&quot;</span>)</span><br><span class="line">       println(<span class="string">&quot;Carpet Length: <span class="subst">$&#123;calculateMaxCarpetLength()&#125;</span>&quot;</span>)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Defines properties common to all dwellings.</span></span><br><span class="line"><span class="comment">* All dwellings have floorspace,</span></span><br><span class="line"><span class="comment">* but its calculation is specific to the subclass.</span></span><br><span class="line"><span class="comment">* Checking and getting a room are implemented here</span></span><br><span class="line"><span class="comment">* because they are the same for all Dwelling subclasses.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> residents Current number of residents</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dwelling</span>(<span class="keyword">private</span> <span class="keyword">var</span> residents: <span class="built_in">Int</span>) &#123;</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">val</span> buildingMaterial: String</span><br><span class="line">   <span class="keyword">abstract</span> <span class="keyword">val</span> capacity: <span class="built_in">Int</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calculates the floor area of the dwelling.</span></span><br><span class="line"><span class="comment">    * Implemented by subclasses where shape is determined.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> floor area</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">abstract</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Checks whether there is room for another resident.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if room available, false otherwise</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">hasRoom</span><span class="params">()</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> residents &lt; capacity</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Compares the capacity to the number of residents and</span></span><br><span class="line"><span class="comment">    * if capacity is larger than number of residents,</span></span><br><span class="line"><span class="comment">    * add resident by increasing the number of residents.</span></span><br><span class="line"><span class="comment">    * Print the result.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">fun</span> <span class="title">getRoom</span><span class="params">()</span></span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (capacity &gt; residents) &#123;</span><br><span class="line">           residents++</span><br><span class="line">           println(<span class="string">&quot;You got a room!&quot;</span>)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           println(<span class="string">&quot;Sorry, at capacity and no rooms left.&quot;</span>)</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* A square cabin dwelling.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@param</span> residents Current number of residents</span></span><br><span class="line"><span class="comment">*  <span class="doctag">@param</span> length Length</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SquareCabin</span>(residents: <span class="built_in">Int</span>, <span class="keyword">val</span> length: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Wood&quot;</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">6</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calculates floor area for a square dwelling.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> floor area</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> length * length</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Dwelling with a circular floorspace</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> residents Current number of residents</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> radius Radius</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">open</span> <span class="keyword">class</span> <span class="title class_">RoundHut</span>(</span><br><span class="line">       residents: <span class="built_in">Int</span>, <span class="keyword">val</span> radius: <span class="built_in">Double</span>) : Dwelling(residents) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Straw&quot;</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> capacity = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calculates floor area for a round dwelling.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> floor area</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> PI * radius * radius</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    *  Calculates the max length for a square carpet</span></span><br><span class="line"><span class="comment">    *  that fits the circular floor.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> length of square carpet</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">calculateMaxCarpetLength</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> sqrt(<span class="number">2.0</span>) * radius</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Round tower with multiple stories.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> residents Current number of residents</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> radius Radius</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> floors Number of stories</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RoundTower</span>(</span><br><span class="line">       residents: <span class="built_in">Int</span>,</span><br><span class="line">       radius: <span class="built_in">Double</span>,</span><br><span class="line">       <span class="keyword">val</span> floors: <span class="built_in">Int</span> = <span class="number">2</span>) : RoundHut(residents, radius) &#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> buildingMaterial = <span class="string">&quot;Stone&quot;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// Capacity depends on the number of floors.</span></span><br><span class="line">   <span class="keyword">override</span> <span class="keyword">val</span> capacity = floors * <span class="number">4</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Calculates the total floor area for a tower dwelling</span></span><br><span class="line"><span class="comment">    * with multiple stories.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> floor area</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">floorArea</span><span class="params">()</span></span>: <span class="built_in">Double</span> &#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.floorArea() * floors</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">Square Cabin</span><br><span class="line">============</span><br><span class="line">Capacity: <span class="number">6</span></span><br><span class="line">Material: Wood</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line">Floor area: <span class="number">2500.0</span></span><br><span class="line"></span><br><span class="line">Round Hut</span><br><span class="line">=========</span><br><span class="line">Material: Straw</span><br><span class="line">Capacity: <span class="number">4</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line">You got a room!</span><br><span class="line">Has room? <span class="literal">false</span></span><br><span class="line">Sorry, at capacity and no rooms left.</span><br><span class="line">Floor area: <span class="number">314.1592653589793</span></span><br><span class="line">Carpet Length: <span class="number">14.142135623730951</span></span><br><span class="line"></span><br><span class="line">Round Tower</span><br><span class="line">==========</span><br><span class="line">Material: Stone</span><br><span class="line">Capacity: <span class="number">8</span></span><br><span class="line">Has room? <span class="literal">true</span></span><br><span class="line">Floor area: <span class="number">1509.5352700498956</span></span><br><span class="line">Carpet Length: <span class="number">21.920310216782976</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><p>瞭解如何：</p>
<ul>
<li>建立類別階層 (即類別的樹狀結構)，以及子項會繼承父項類別的功能。子類別會繼承屬性和函式。</li>
<li>建立 <code>abstract</code> 類別，其子類別會實作其餘的部分功能。所以 <code>abstract</code> 類別無法執行個體化。</li>
<li>建立 <code>abstract</code> 類別的子類別。</li>
<li>使用 <code>override</code> 關鍵字覆寫子類別的屬性和函式。</li>
<li>使用 <code>super</code> 關鍵字參考父項類別的函式和屬性。</li>
<li>建立類別 <code>open</code>，即可加入子類別。</li>
<li>建立屬性 <code>private</code>，然後只能在類別中使用該屬性。</li>
<li>使用 <code>with</code> 建構函式，多次呼叫相同的物件執行個體。</li>
<li>從 <code>kotlin.math</code> 程式庫匯入功能</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Layouts</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Classes</tag>
        <tag>Inheritance</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(8)-專案：Lemonade應用程式</title>
    <url>/2023/08/25/Android%E7%AD%86%E8%A8%98-8-%E5%B0%88%E6%A1%88-Lemonade%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>使用單元 1 中學到的技能，建構簡單的 Lemonade 應用程式。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>在 Google 上搜尋您在應用程式中不認得的字詞、錯誤訊息和程式碼片段。</li>
<li>測試程式碼、解讀錯誤，然後變更程式碼並重複測試。</li>
<li>回去閱讀先前在 Android 基本概念單元 1 中的內容，溫故知新。</li>
<li>將您知道可順利執行的程式碼 (例如專案內提供的程式碼，或是您先前在單元 1 中學到的其他應用程式的解決方案程式碼) 與您編寫的程式碼進行比對。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="應用程式總覽"><a href="#應用程式總覽" class="headerlink" title="應用程式總覽"></a>應用程式總覽</h4><p>我們將建立簡單的互動式行動應用程式，讓您可以使用該應用程式榨取一杯檸檬汁。</p>
<p>成品 Lemonade 應用程式將由單一畫面組成。使用者初次啟動應用程式時，系統會提示使用者輕觸檸檬樹的圖片，藉此挑選檸檬。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/1ce5b75b513d63c9_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>使用者在輕觸檸檬樹後便會看到一顆檸檬，可以輕觸以「擠壓」檸檬數次 (次數不固定，系統將隨機產生所需的擠壓次數)，才會移動到下一個畫面。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/fb63b41d58a83af7_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>使用者輕觸擠壓至正確次數後，便會看到玻璃杯圖片，可以「喝下」檸檬水。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/f8882c1688a0e3e7_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>按一下飲用檸檬汁之後，玻璃杯就會變成空的，使用者只要再次輕觸圖片，就能返回第一個畫面，再從檸檬樹中選取其他檸檬。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/951918f0c2d0464_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>這款應用程式的設計簡單，且提供單一活動。應用程式的不同狀態 (使用者選取檸檬、擠壓檸檬、喝檸檬汁、以及最後的空杯) 都會以「狀態機器」呈現。</p>
<p>雖然這聽起來像是空泛的理論術語，但這僅表示應用程式的狀態 (也就是要向使用者顯示哪些文字和圖片) 是取決於包含應用程式狀態的變數 (select 和 squeeze等等)。系統會一併更新應用程式的狀態會連同任何其他必要的變數，並在完成所有更新後分別設定使用者介面 (設定圖片和文字)。</p>
<p>系統已為您定義應用程式狀態的所有變數。您的工作是建構應用程式的版面配置並實作邏輯，讓使用者介面按預期在每個狀態之間轉換。</p>
<hr>
<h4 id="測試程式碼"><a href="#測試程式碼" class="headerlink" title="測試程式碼"></a>測試程式碼</h4><p>對於 Lemonade 應用程式 (以及日後的專案)，系統會提供一些自動化測試，讓您驗證程式碼是否可如預期般運作。Lemonade 應用程式的範例專案包含幾項測試，您可以執行測試，以確認是否已正確實作邏輯。</p>
<hr>
<h4 id="下載專案程式碼"><a href="#下載專案程式碼" class="headerlink" title="下載專案程式碼"></a>下載專案程式碼</h4><p>資料夾名稱是 <code>android-basics-kotlin-lemonade-app</code>。在 Android Studio 中開啟專案時，請選取這個資料夾。</p>
<div class="note success no-icon">
            <p>範例程式碼網址：</p><p><a href="https://github.com/google-developer-training/android-basics-kotlin-lemonade-app">https://github.com/google-developer-training/android-basics-kotlin-lemonade-app</a></p><p>具有範例程式碼的分支版本名稱：<b>main</b></p>
          </div>

<p>然後在 Android Studio 中開啟剛才下載完成的專案</p>
<hr>
<h4 id="建立使用者介面"><a href="#建立使用者介面" class="headerlink" title="建立使用者介面"></a>建立使用者介面</h4><p>Lemonade 應用程式只需要基本的版面配置；您只需要兩個檢視畫面，就能實作所有功能。</p>
<ol>
<li>為使用者提供操作說明的 <code>TextView</code>。</li>
<li>根據應用程式目前狀態 (例如要擠壓的檸檬) 顯示圖形的 <code>ImageView</code>。</li>
</ol>
<p>您的目標是運用您掌握的版面配置編輯器知識，建構如下版面配置：兩個檢視畫面都在畫面中央，且 <code>TextView</code> 位於 <code>ImageView</code> 上方。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/54581304e678827c_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>實際完成畫面：<br><img src="https://i.imgur.com/wIEw2fh.png" width="30%" height="30%"></p>
<hr>
<h4 id="讓應用程式與使用者互動"><a href="#讓應用程式與使用者互動" class="headerlink" title="讓應用程式與使用者互動"></a>讓應用程式與使用者互動</h4><p>版面配置完成之後，請開啟 <code>MainActivity.kt</code>。您可以在這裡實作所有應用程式的邏輯。您會發現已經有一些程式碼。且有許多標示為 <code>// TODO:</code> 的註解 (如以下範例所示)。這些都是您要完成的工作。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/b6c5858a42dec80_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<p>您必須實作下列三項基本工作，才能讓檸檬汁應用程式正常運作。</p>
<ol>
<li>設定 <code>lemonImage</code> <code>ImageView</code> 以回應使用者輸入的內容。</li>
<li>實作 <code>clickLemonImage()</code> 以更新應用程式的狀態。</li>
<li>實作 <code>setViewElements()</code>，以根據應用程式目前的狀態更新使用者介面。</li>
</ol>
<h5 id="步驟-1：設定-ImageView"><a href="#步驟-1：設定-ImageView" class="headerlink" title="步驟 1：設定 ImageView"></a>步驟 1：設定 ImageView</h5><p>輕觸圖片檢視畫面後，應用程式就會從一個狀態切換成其他狀態。在 <code>onCreate()</code> 結尾，需要設定兩個事件監聽器。</p>
<ol>
<li><code>setOnClickListener()</code> 應更新應用程式的狀態。方法是 <code>clickLemonImage()</code>。</li>
<li><code>setOnLongClickListener()</code> 會回應使用者長按圖片的事件 (例如，使用者輕觸圖片，而且沒有立即放開手指)。對於長按事件，畫面底部會顯示小工具 (稱為 Snackbar)，讓使用者知道他們擠壓檸檬的次數。這是透過 <code>showSnackbar()</code> 方法來完成。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/b07b78c6b607e94d_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<h5 id="步驟-2：實作-clickLemonImage"><a href="#步驟-2：實作-clickLemonImage" class="headerlink" title="步驟 2：實作 clickLemonImage()"></a>步驟 2：實作 clickLemonImage()</h5><p>完成前一個步驟後，每當使用者輕觸圖片時，系統就會呼叫 <code>clickLemonImage()</code> 方法。這個方法負責將應用程式從目前狀態移至下一個狀態，並視需要更新變數。有四種可能的狀態：<code>SELECT</code>、<code>SQUEEZE</code>、<code>DRINK</code> 和 <code>RESTART</code>；目前狀態會以 <code>lemonadeState</code> 變數呈現。這個方法需要針對每個狀態完成不同動作。</p>
<p><code>SELECT</code>：轉換為 <code>SQUEEZE</code> 狀態，透過呼叫 <code>pick()</code> 方法並將 <code>squeezeCount</code> (使用者擠壓檸檬的次數) 設為 0 來設定 <code>lemonSize</code> (需要擠壓的次數)。<br><code>SQUEEZE</code>：將 <code>squeezeCount</code> 增加 1，並將 <code>lemonSize</code> 減少 1。別忘了檸檬需要不同次數的擠壓，應用程式才會轉換其狀態。只有在新的 <code>lemonSize</code> 等於 0 時，才轉換至 <code>DRINK</code> 狀態。否則應用程式應保持在 <code>SQUEEZE</code> 狀態。<br><code>DRINK</code>：轉換為 <code>RESTART</code> 狀態，並將 <code>lemonSize</code> 設為 -1。<br><code>RESTART</code>：切換回 <code>SELECT</code> 狀態。<br>處理完所有更新和狀態轉換後，請務必呼叫 <code>setViewElements()</code>，根據新狀態更新使用者介面。</p>
<h5 id="步驟-3：實作-setViewElements"><a href="#步驟-3：實作-setViewElements" class="headerlink" title="步驟 3：實作 setViewElements()"></a>步驟 3：實作 setViewElements()</h5><p><code>setViewElements()</code> 方法負責根據應用程式的狀態更新使用者介面。文字和圖片應更新為下方顯示的值，以符合 <code>lemonadeState</code>。</p>
<p><code>SELECT：</code></p>
<ul>
<li>文字：按一下即可選取檸檬！</li>
<li>圖片：<code>R.drawable.lemon_tree</code></li>
</ul>
<p><code>SQUEEZE：</code><br>文字：按一下即可擠檸檬汁<br>圖片：<code>R.drawable.lemon_squeeze</code></p>
<p><code>DRINK：</code><br>文字：按一下即可喝檸檬水！<br>圖片：<code>R.drawable.lemon_drink</code></p>
<p><code>RESTART：</code><br>文字：按一下即可重新開始！<br>圖片：<code>R.drawable.lemon_restart</code></p>
<hr>
<h4 id="如何使用字串資源"><a href="#如何使用字串資源" class="headerlink" title="如何使用字串資源"></a>如何使用字串資源</h4><p>資源可用於定義顏色、圖片、版面配置、選單和字串值。這種做法的好處是沒有硬式編碼。這些資源檔案中定義了所有內容，您可以在應用程式的程式碼中參照。這些資源最簡單 (且最常見) 的使用方式是使用字串資源，允許具有彈性的本地化文字。</p>
<p>字串或靜態文字可儲存在稱為 <code>strings.xml</code> 的個別檔案中，<code>strings.xml</code> 位於 <code>res</code> 資料夾的值子資料夾內。</p>
<p>針對您想要在應用程式中顯示的每段文字 (即按鈕標籤或 <code>TextView</code> 內的文字)，您必須先定義 <code>res/values/strings.xml</code> 檔案中的文字。每個項目都是<code>索引鍵</code> (代表文字 ID) 和<code>值</code> (文字本身)。</p>
<p>舉例來說，如果您想讓按鈕顯示「Submit」(提交)，請在 res&#x2F;values&#x2F;strings.xml 中加入以下字串資源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="line">&lt;resources&gt;</span><br><span class="line">    &lt;string name=<span class="string">&quot;hello&quot;</span>&gt;Hello!&lt;/string&gt;</span><br><span class="line">    &lt;string name=<span class="string">&quot;submit_label&quot;</span>&gt;Submit&lt;/string&gt;</span><br><span class="line">&lt;/resources&gt;</span><br></pre></td></tr></table></figure>

<p>如要直接存取程式碼中的資源，只要使用 <code>getResources.getString()</code> 或 <code>getString()</code> 方法，即可依照資源 ID <code>R.string.submit_label</code> 來存取相應的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val submitText = getResources().getString(R.string.submit_label)</span><br></pre></td></tr></table></figure>

<p>如要直接將字串資源中的文字設定為 <code>TextView</code>，您可以呼叫 <code>TextView</code> 物件上的 <code>setText()</code>，並傳入資源 ID。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val infoTextView: TextView = findViewById(R.id.info_textview)</span><br><span class="line"></span><br><span class="line">infoTextView.setText(R.string.info_text)</span><br></pre></td></tr></table></figure>

<p>字串資源也可以包含特殊字元，以便設定文字格式。舉例來說，可能會有字串資源可讓您將其他文字插入字串。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;string name=<span class="string">&quot;ingredient_tablespoon&quot;</span>&gt;%1<span class="variable">$d</span> 歲是 %2<span class="variable">$s</span> 的年齡&lt;/string&gt;</span><br></pre></td></tr></table></figure>

<p>在程式碼中，您可以透過傳遞引數來存取字串資源，並設定字串資源的格式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">getResources().getString(R.string.ingredient_tablespoon, 3, <span class="string">&quot;Tina&quot;</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>宣告字串資源時，每個引數都會<code>依照顯示的順序編號 (1、2 等)</code>，並<code>以字母表示不同類型 (d 代表小數，s 代表字串等等)</code>。正確類型的引數可傳遞至 getString() 的呼叫。</li>
</ul>
<p>輸出結果：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">3 歲是 Tina 的年齡</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="執行應用程式"><a href="#執行應用程式" class="headerlink" title="執行應用程式"></a>執行應用程式</h4><p>完成結果如下所示：</p>
<img src="https://i.imgur.com/tjUqSOM.gif" width="30%" height="30%">

<hr>
<h4 id="測試應用程式"><a href="#測試應用程式" class="headerlink" title="測試應用程式"></a>測試應用程式</h4><ul>
<li>測試套件(Test Suite) - 包含所有「測試案例」的目標(target)。</li>
<li>測試案例(Test Case) - 這個類別包含相關功能的個別測試 (Lemonade 應用程式只有一個測試案例，但更大型的應用程式通常會有更多測試案例)。</li>
<li>測試(Test) - 用來測試特定項目的函式。</li>
</ul>
<p>測試案例可以有多個測試，且專案的測試套件可以有多個測試案例。</p>
<h5 id="執行測試"><a href="#執行測試" class="headerlink" title="執行測試"></a>執行測試</h5><p>若是單一測試案例，請開啟測試案例類別，然後按一下類別宣告左側的綠色箭頭。然後，從選單中選取「Run」選項。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/6c7b133bcc38ce87_1920.png?authuser=2&hl=zh-tw" width="60%" height="60%"></p>
<p>如果您有多個測試案例，也可以執行整個測試套件。就像執行應用程式一樣，您可以在「Run」選單中找到這個選項。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/ed1e07d2488ac446_1920.png?authuser=2&hl=zh-tw" width="50%" height="50%"></p>
<p>請注意，Android Studio 會預設為您所執行的最後一個目標 (應用程式、測試目標等)，因此如果選單仍顯示「Run」&gt;「Run ‘app’」，您可以依序選取「Run」&gt;「Run」以執行測試目標。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/13bd962d134241aa_1920.png?authuser=2&hl=zh-tw" width="40%" height="40%"></p>
<p>然後從彈出式選單中選擇測試目標。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-project-lemonade/img/903c7ed01fa7cebf_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%"></p>
<p>測試結果：<br><img src="https://i.imgur.com/FWHRMiW.png"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(7)-偵錯(Debugging)</title>
    <url>/2023/08/23/Android%E7%AD%86%E8%A8%98-7-%E5%81%B5%E9%8C%AFDebugging/</url>
    <content><![CDATA[<blockquote>
<p>只要是軟體使用者，很可能都曾遇到錯誤。「<code>bug</code>」是指某個軟體導致錯誤的行為，例如應用程式當機或功能無法正常運作。無論經驗為何，所有開發人員在撰寫程式碼時都會回報錯誤，而 Android 開發人員最重要的技能之一就是辨識及修正。</p>
</blockquote>
<p>bug的修正程序稱為<code>偵錯(debugging)</code>。知名電腦科學家 Brian Kernighan 曾表示，「最有效的偵錯工具至今仍在審慎考量，加上眾所皆知的印刷品聲明。」 您可能已經很熟悉先前程式碼研究室的 Kotlin’s println() 陳述式，但專業的 Android 開發人員會使用記錄功能來更妥善地整理程式的輸出內容。在這個程式碼研究室中，您將瞭解如何使用 Android Studio 中的記錄功能，以及如何將記錄用於偵錯工具。您將瞭解如何讀取錯誤訊息記錄 (稱為堆疊追蹤)，藉此找出並修正錯誤。</p>
<p><strong>學習目標</strong></p>
<ul>
<li>使用 <code>android.util.Logger</code> 寫入記錄檔。</li>
<li>瞭解不同記錄檔層級的使用時機。</li>
<li>使用記錄是一項簡單的強大工具。</li>
<li>如何在堆疊追蹤中尋找有意義的資訊。</li>
<li>搜尋錯誤訊息以解決應用程式當機問題。</li>
</ul>
<span id="more"></span>
<hr>
<h4 id="建立新專案"><a href="#建立新專案" class="headerlink" title="建立新專案"></a>建立新專案</h4><p>我們將從空白專案開始，先顯示一個空白專案來示範記錄陳述式及其偵錯用途，而不是使用大型的應用程式。<br>請先建立新的 Android Studio 專案，如圖所示。</p>
<ol>
<li><p>在「New Project」(新增專案) 畫面中，選擇「Empty Views Activity」(空白活動)。</p>
</li>
<li><p>將應用程式命名為「Debugging」。確認語言已設為 Kotlin，且其他維持不變。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-intro-debugging/img/60a1619c07fae8f5_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<hr>
<h4 id="對輸出進行記錄與偵錯"><a href="#對輸出進行記錄與偵錯" class="headerlink" title="對輸出進行記錄與偵錯"></a>對輸出進行記錄與偵錯</h4><p>在先前的課程中，您曾使用 Kotlin 的 <code>println()</code> 陳述式產生文字輸出。在 Android 應用程式中，記錄記錄的最佳做法是使用 <code>Log</code> 類別。記錄輸出功能有多種函式，採 <code>Log.v()</code>、<code>Log.d()</code>、<code>Log.i()</code>、<code>Log.w()</code> 或 <code>Log.e()</code> 格式。這些方法有兩種參數，第一個稱為「標記」，是<span class="label primary">識別記錄訊息來源 (例如記錄文字的類別名稱) 的字串</span>。第二個則是<span class="label primary">實際記錄訊息</span> 。</p>
<p>執行下列步驟，開始在空白專案中使用記錄功能。</p>
<ol>
<li>在 <code>MainActivity.kt</code> 的類別宣告之前，新增名為 <code>TAG</code> 的常數，並將該值設為類別的名稱 <code>MainActivity</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private const val TAG = <span class="string">&quot;MainActivity&quot;</span></span><br></pre></td></tr></table></figure>

<div class="note success no-icon">
            <p>注意： 記錄標記通常是在類別外宣告。雖然此變數是在 <b>MainActivity</b> 之外宣告，但會宣告為私人，因此只能在 <b>MainActivity.kt</b> 中存取。也就是說，您也可以宣告其他類別的 <b>TAG</b> 變數。</p>
          </div>

<ol start="2">
<li>向 MainActivity 類別新增一個名為 <code>logging()</code> 的新函數，如下所示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">logging</span></span>() &#123;</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>onCreate()</code> 中呼叫 <code>logging()</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    logging()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>執行應用程式以查看記錄。記錄檔隨即顯示在畫面底部的 <code>Logcat</code> 視窗中。在篩選框中輸入 <code>level:debug</code> ，藉此排除與您應用程式無關的任何記錄。</p>
</li>
<li><p>您應該會在輸出視窗中看到「Hello, world!」。如有需要，請在 <code>Logcat</code> 視窗頂端的搜尋框中輸入「hello」，即可搜尋所有記錄。</p>
</li>
</ol>
<hr>
<h4 id="記錄層級"><a href="#記錄層級" class="headerlink" title="記錄層級"></a>記錄層級</h4><p>造成不同記錄檔函式 (名稱不同) 的原因，原因是這些相對應的記錄層級不同。您可以根據要輸出的資訊類型，在 <code>Logcat</code> 輸出內容中使用不同記錄檔層級進行篩選。您會定期使用五個主要記錄層級。</p>
<table>
<thead>
<tr>
<th align="left">紀錄層級</th>
<th align="left">用途</th>
<th align="left">範例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">錯誤(ERROR)</td>
<td align="left">錯誤記錄會回報發生嚴重錯誤，例如應用程式當機的原因。</td>
<td align="left">Log.e(TAG, “The cake was left in the oven for too long and burned.”).</td>
</tr>
<tr>
<td align="left">警告(WARN)</td>
<td align="left">WARN 記錄較不嚴重，但仍會回報應修正的問題，以避免嚴重的錯誤。舉例來說，如果您呼叫的函式「已淘汰」，我們不建議使用該函式取代較新的函式。</td>
<td align="left">Log.w(TAG, “This oven does not heat evenly. You may want to turn the cake around halfway through to promote even browning.”)</td>
</tr>
<tr>
<td align="left">資訊(INFO)</td>
<td align="left">INFO 記錄提供實用資訊，例如成功完成的作業。</td>
<td align="left">Log.i(TAG, “The cake is ready to be served.”).println(“The cake has cooled.”)</td>
</tr>
<tr>
<td align="left">偵錯(DEBUG)</td>
<td align="left">DEBUG 記錄包含調查問題時可能會用到的資訊。這些版本不會顯示在發布版本中，例如您在 Google Play 商店發布的版本。</td>
<td align="left">Log.d(TAG, “Cake was removed from the oven after 55 minutes. Recipe calls for the cake to be removed after 50 - 60 minutes.”)</td>
</tr>
<tr>
<td align="left">詳細程度(VERBOSE)</td>
<td align="left">顧名思義，「VERBOSE」是最低的記錄層級。何謂偵錯記錄與詳細記錄其實有點主觀，但一般而言，詳細記錄可以在功能實作之後移除，而偵錯記錄在偵錯時可能仍然有用。這些版本不包含版本。</td>
<td align="left">Log.v(TAG, “Put the mixing bowl on the counter.”)Log.v(TAG, “Grabbed the eggs from the refrigerator.”)Log.v(TAG, “Plugged in the stand mixer.”)</td>
</tr>
</tbody></table>
<p>請注意，目前並沒有設定各類型記錄層級的使用規則，特別是使用 <code>DEBUG</code> 和 <code>VERBOSE</code> 的時機。軟體開發團隊可能會制定個別記錄層級的使用時機，或是決定不採用特定記錄層級 (例如 VERBOSE)。這兩個記錄層級有一重要的重點是，這些版本並沒有發布版本，因此使用記錄偵錯功能不會影響已發布應用程式的效能，而 <code>println()</code> 陳述式則保留在發布版本中，並對負面影響產生負面影響成效。</p>
<p>讓我們看看 Logcat 中各種不同的記錄層級。</p>
<ol>
<li>在 <code>MainActivity.kt</code> 中，將 <code>logging()</code> 方法的內容替換為下列內容。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">logging</span></span>() &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">&quot;ERROR: a serious error like an app crash&quot;</span>)</span><br><span class="line">    Log.w(TAG, <span class="string">&quot;WARN: warns about the potential for serious errors&quot;</span>)</span><br><span class="line">    Log.i(TAG, <span class="string">&quot;INFO: reporting technical information, such as an operation succeeding&quot;</span>)</span><br><span class="line">    Log.d(TAG, <span class="string">&quot;DEBUG: reporting technical information useful for debugging&quot;</span>)</span><br><span class="line">    Log.v(TAG, <span class="string">&quot;VERBOSE: more verbose than DEBUG logs&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>執行您的應用程式，並在 <code>Logcat</code> 中觀察輸出內容。輸入 <code>tag: MainActivity</code>，篩選出只顯示含有「MainActivity」代碼的記錄。</li>
</ol>
<img src="https://i.imgur.com/IZaKXLh.png">

<hr>
<h4 id="使用鍵-值搜尋查詢記錄"><a href="#使用鍵-值搜尋查詢記錄" class="headerlink" title="使用鍵&#x2F;值搜尋查詢記錄"></a>使用鍵&#x2F;值搜尋查詢記錄</h4><p>在 Android Studio 中，您可以直接透過主查詢欄位產生鍵&#x2F;值搜尋。這個查詢系統可提供精準的查詢結果，也能根據鍵&#x2F;值排除記錄。儘管您可以選擇使用規則運算式，但在查詢上並非必要。如要查看建議項目，請在查詢欄位中按下 Ctrl + Space 鍵。</p>
<img src="https://developer.android.com/static/studio/images/debug/logcat-query-suggestions.png?authuser=2&hl=zh-tw">

<p>以下提供幾個可用於查詢的鍵範例：</p>
<ul>
<li>tag：比對記錄項目的 tag 欄位。</li>
<li>package：比對記錄應用程式的套件名稱。</li>
<li>process：比對記錄應用程式的程序名稱。</li>
<li>message：比對記錄項目的訊息部分。</li>
<li>level：比對指定或更嚴重的記錄層級，例如 DEBUG。</li>
<li>age：比對項目時間戳記是否最新。值的指定方式是以數字後面加上代表時間單位的字母：s 代表秒數、m 代表分鐘數、h 代表小時數，d 則代表天數。例如，age: 5m 只會篩選出過去 5 分鐘內記錄的訊息。</li>
</ul>
<p>更詳細的介紹請點<a href="https://developer.android.com/studio/debug/logcat?authuser=2&hl=zh-tw">這裡</a>查看。</p>
<hr>
<h4 id="含有錯誤訊息的記錄"><a href="#含有錯誤訊息的記錄" class="headerlink" title="含有錯誤訊息的記錄"></a>含有錯誤訊息的記錄</h4><p>在空白專案中無法偵錯。Android 開發人員經常遇到許多錯誤，那就是應用程式當機，但用戶體驗不佳。讓我們新增一些程式碼，讓這個應用程式當機。</p>
<ol>
<li>將下列函式新增至 <code>logging()</code> 函式的 <code>MainActivity.kt</code>。這個程式碼以兩個數字開頭，並使用 <code>repeat</code> 來將分子除以五分子的結果。每次執行 <code>repeat</code> 區塊中的程式碼時，分母的值就會減少 1。在第 5 次和最後一次疊代時，應用程式嘗試除以 0。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">division</span></span>() &#123;</span><br><span class="line">    val numerator = 60</span><br><span class="line">    var denominator = 4</span><br><span class="line">    repeat(5) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">&quot;<span class="variable">$&#123;numerator / denominator&#125;</span>&quot;</span>)</span><br><span class="line">        denominator--</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增<code>division()</code> 函式到 <code>onCreate()</code> 中的 <code>logging()</code> 後。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line">    logging()</span><br><span class="line">    division()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>再次執行應用程式，向下捲動至 <code>MainActivity.kt</code> 類別中的記錄，即可查看先前定義的 <code>logging()</code> 函式中的日誌、「<code>division()</code>」函式的詳細記錄，以及說明應用程式為什麼當機的紅色錯誤記錄。</li>
</ol>
<hr>
<h4 id="堆疊追蹤剖析"><a href="#堆疊追蹤剖析" class="headerlink" title="堆疊追蹤剖析"></a>堆疊追蹤剖析</h4><p>說明當機的錯誤記錄 (也稱為例外狀況) 亦稱作堆疊追蹤。堆疊追蹤會顯示所有已觸發至例外狀況的函式，而且系統會從最近呼叫的時間開始呼叫。完整輸出內容如下所示。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Process: com.example.debugging, PID: 14581</span><br><span class="line">    java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.example.debugging/com.example.debugging.MainActivity&#125;: java.lang.ArithmeticException: divide by zero</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3449)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3601)</span><br><span class="line">        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)</span><br><span class="line">        at android.app.ActivityThread<span class="variable">$H</span>.handleMessage(ActivityThread.java:2066)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7656)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit<span class="variable">$MethodAndArgsCaller</span>.run(RuntimeInit.java:592)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)</span><br><span class="line">     Caused by: java.lang.ArithmeticException: divide by zero</span><br><span class="line">        at com.example.debugging.MainActivity.division(MainActivity.kt:21)</span><br><span class="line">        at com.example.debugging.MainActivity.onCreate(MainActivity.kt:14)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:8000)</span><br><span class="line">        at android.app.Activity.performCreate(Activity.java:7984)</span><br><span class="line">        at android.app.Instrumentation.callActivityOnCreate(Instrumentation.java:1309)</span><br><span class="line">        at android.app.ActivityThread.performLaunchActivity(ActivityThread.java:3422)</span><br><span class="line">        at android.app.ActivityThread.handleLaunchActivity(ActivityThread.java:3601)</span><br><span class="line">        at android.app.servertransaction.LaunchActivityItem.execute(LaunchActivityItem.java:85)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.executeCallbacks(TransactionExecutor.java:135)</span><br><span class="line">        at android.app.servertransaction.TransactionExecutor.execute(TransactionExecutor.java:95)</span><br><span class="line">        at android.app.ActivityThread<span class="variable">$H</span>.handleMessage(ActivityThread.java:2066)</span><br><span class="line">        at android.os.Handler.dispatchMessage(Handler.java:106)</span><br><span class="line">        at android.os.Looper.loop(Looper.java:223)</span><br><span class="line">        at android.app.ActivityThread.main(ActivityThread.java:7656)</span><br><span class="line">        at java.lang.reflect.Method.invoke(Native Method)</span><br><span class="line">        at com.android.internal.os.RuntimeInit<span class="variable">$MethodAndArgsCaller</span>.run(RuntimeInit.java:592)</span><br><span class="line">        at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:947)</span><br></pre></td></tr></table></figure>

<h5 id="如何查看錯誤"><a href="#如何查看錯誤" class="headerlink" title="如何查看錯誤"></a>如何查看錯誤</h5><ol>
<li><code>java.lang.RuntimeException:</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">java.lang.RuntimeException: Unable to start activity ComponentInfo&#123;com.example.debugging/com.example.debugging.MainActivity&#125;: java.lang.ArithmeticException: divide by zero</span><br></pre></td></tr></table></figure>
<p>第一行代表應用程式無法開始活動，這就是應用程式當機的原因。下一行會提供更多資訊。具體來說，該活動無法啟動的原因是 <code>ArithmeticException</code>。具體來說，<code>ArithmeticException</code> 的類型是「除以 0」。</p>
<ol start="2">
<li><code>Caused by:</code></li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.ArithmeticException: divide by zero</span><br><span class="line">        at com.example.debugging.MainActivity.division(MainActivity.kt:21)</span><br></pre></td></tr></table></figure>
<p>如果向下捲動頁面顯示「<code>Caused by:</code>」一行，表示發生「<code>除以 0</code>」的錯誤。另會顯示錯誤發生的確切函式 (<code>division()</code>) 和確切的行數 (21)。Logcat 視窗中的檔案名稱和行數是超連結。輸出結果也會列出發生錯誤的函式名稱 (<code>division()</code>) 和呼叫該函式的函式 (<code>onCreate()</code>)。</p>
<hr>
<h4 id="使用記錄檔找出並修正錯誤"><a href="#使用記錄檔找出並修正錯誤" class="headerlink" title="使用記錄檔找出並修正錯誤"></a>使用記錄檔找出並修正錯誤</h4><p>使用記錄陳述式，透過輸出分母值來避免除數為零的情況，從而節省時間。</p>
<ol>
<li>在 <code>Log.v()</code> 之前，新增 <code>Log.d()</code> 呼叫記錄分母。<code>Log.d()</code> 的用途是偵錯，因此可用來篩選詳細記錄。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Log.d(TAG, <span class="string">&quot;<span class="variable">$denominator</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>再次執行應用程式。雖然分母仍持續當機，但分母應該記錄多次。您可以使用篩選條件設定，只顯示含有 “MainActivity” 標記的記錄。</li>
</ol>
<img src="https://i.imgur.com/RmP1RGi.png">

<ol start="3">
<li>您可以看到有多個值輸出。當分母為 0 時，迴圈會在第五次疊代之前執行數次。如要修正錯誤，您可以將迴圈中的疊代次數從 5 變更為 4。再次執行應用程式時，應用程式不會再停止運作。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">division</span></span>() &#123;</span><br><span class="line">        val numerator = 60</span><br><span class="line">        var denominator = 4</span><br><span class="line">        repeat(4) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">&quot;<span class="variable">$denominator</span>&quot;</span>)</span><br><span class="line">            Log.v(TAG, <span class="string">&quot;<span class="variable">$&#123;numerator / denominator&#125;</span>&quot;</span>)</span><br><span class="line">            denominator--</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Debugging</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(6)-編寫單元測試</title>
    <url>/2023/08/23/Android%E7%AD%86%E8%A8%98-6-%E7%B7%A8%E5%AF%AB%E5%96%AE%E5%85%83%E6%B8%AC%E8%A9%A6/</url>
    <content><![CDATA[<blockquote>
<p>您已經編寫了一些 Android 程式碼，現在正好可以用一些測試程式碼來追蹤後續狀況。我們首先會看看一些測試的理念，然後深入研究 Android 專案中自動產生的測試，最後再為 Dice Roller 應用程式編寫您自己的測試！</p>
</blockquote>
<h4 id="測試的重要性"><a href="#測試的重要性" class="headerlink" title="測試的重要性"></a>測試的重要性</h4><ul>
<li>當應用程式逐漸成長，進行<code>手動測試</code>會比編寫<code>自動測試</code>花費更多精力。</li>
<li>開始建構專業級的應用程式時，如果<code>使用者數量龐大</code>，測試也會變得十分重要。</li>
<li>必須考到許多<code>不同類型的裝置</code>，而這些裝置又會執行<code>不同的 Android 版本</code>。</li>
<li>如果您在<code>發布新的程式碼之前</code>執行測試，就可以修改現有的程式碼，以免發布的應用程式出現非預期的行為。</li>
</ul>
<p><code>自動化測試</code>是透過軟體執行的測試，而<code>人工測試</code>則是由會直接與裝置互動的人員執行。若要確保產品使用者都能獲得良好的體驗，自動化測試和手動測試都是非常重要的一環。不過，自動化測試的準確度較高，也可以提升團隊的工作效率，因為員工不必手動執行測試，因此自動化測試的執行速度會比手動測試還要快。</p>
<span id="more"></span>

<hr>
<h4 id="深入探索單元測試"><a href="#深入探索單元測試" class="headerlink" title="深入探索單元測試"></a>深入探索單元測試</h4><p>單元測試一律位於 <code>test</code> 目錄中：<br><img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/f02b380da4e8f661_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%"></p>
<ol>
<li>開啟 <code>app/build.gradle</code> 檔案，然後查看依附元件。有部分依附元件會標記為 <code>testImplementation</code> 和 <code>androidTestImplementation</code>，分別是指<code>單元測試</code>和<code>檢測設備測試</code>。值得一提的是：</li>
</ol>
<p><code>app/build.gradle</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">testImplementation <span class="string">&#x27;junit:junit:4.12&#x27;</span></span><br></pre></td></tr></table></figure>

<p>用來驅動單元測試的 <code>JUnit</code> 程式庫，可讓您將程式碼標示為測試，以便採用可以測試應用程式碼的方式編譯和執行應用程式。</p>
<ol start="2">
<li>在 <code>test</code> 目錄中，開啟 <code>ExampleUnitTest.kt</code> 檔案。</li>
</ol>
<p>以下是單元測試的範例：<br><code>ExampleUnitTest.kt</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class ExampleUnitTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   fun <span class="function"><span class="title">addition_isCorrect</span></span>() &#123;</span><br><span class="line">       assertEquals(4, 2 + 2)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h5><p>雖然你已在 <code>Dice Roller</code> 應用程式中新增了一些程式碼，但可能並未編寫任何測試。因此，這裡只有一些由 Android Studio 自動建立的一般程式碼。這個任意測試可做為預留位置，以便開發人員用來編寫更多相關的測試。<br>這個程式碼區塊現在只會測試 <code>2 + 2 = 4</code>。答案當然是正確的。讓我們進一步瞭解實際情況：</p>
<ul>
<li>您必須先從 <code>org.junit.test</code> 程式庫匯入 <code>@</code> <code>Test</code> 註解，然後為測試函式加上該註解。您可以將註解視為一段程式碼的中繼資料標記，可改變程式碼的編譯方式。在這個範例中，<code>@Test</code> 註解可讓編譯器知道以下方法為測試，從而讓該方法據此執行。</li>
</ul>
<h5 id="函式宣告"><a href="#函式宣告" class="headerlink" title="函式宣告"></a>函式宣告</h5><p>註解之後是<code>函式宣告</code>，在這個範例中為 <code>addition_isCorrect()</code> 函式。在函式中，<code>assertEquals()</code> 函式會宣告<code>預期值</code>應等於透過商業邏輯取得的<code>實際值</code>。宣告方法是單元測試的最終目標。</p>
<p>最後，您要宣告從程式碼取得的結果處於特定狀態。如果結果狀態與預期狀態相符，即表示測試通過；如果結果狀態與預期狀態不符，即表示測試失敗。</p>
<p>在這個範例中，程式碼會比較兩個值，因此 <code>assertEquals()</code> 方法會使用 2 個參數，分別是<code>預期值</code>和<code>實際值</code>。顧名思義，<code>預期值是您預期出現的特定結果</code>，在本例中是 <code>4</code>。<code>實際值代表實際程式碼片段的結果</code>。一般而言，這樣會測試應用程式本身的程式碼片段。這個範例只有任意的程式碼片段，例如 <code>2 + 2</code>。請先執行這個測試，看看會發生什麼事。</p>
<div class="note info no-icon">
            <p><strong>注意：JUnit 程式庫有許多斷言(assertion)，常見的斷言(assertion)如下：</strong></p><table><thead><tr><th align="left">Assert</th><th align="left">Description</th></tr></thead><tbody><tr><td align="left">assertEquals()</td><td align="left">檢查預期值和實際值是否相同</td></tr><tr><td align="left">assertTrue()</td><td align="left">檢查condition為true</td></tr><tr><td align="left">assertFalse()</td><td align="left">檢查condition為false</td></tr><tr><td align="left">assertNull()</td><td align="left">檢查object為null</td></tr><tr><td align="left">assertNotNull()</td><td align="left">檢查object不為null</td></tr></tbody></table><p>For more information, see <a href="https://developer.android.com/reference/junit/framework/Assert?authuser=2">Assert</a>.</p>
          </div>

<h5 id="測試成功"><a href="#測試成功" class="headerlink" title="測試成功"></a>測試成功</h5><p>您可透過多種方法在 Android Studio 中執行測試，我們稍後會深入探討。不過，現在先以簡單明瞭為主。<br>按一下 <code>addition_isCorrect</code> 方法宣告旁的箭頭，然後選取「Run ‘ExampleUnitTest.addition_isCorrect’」。</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/78c943e851a33644_1920.png?authuser=2&hl=zh-tw" width="90%" height="90%">

<p>這就是所謂的正向測試，也就是說，斷言獲得確認。<code>2 + 2</code> 等於 <code>4</code>。或者，我們可以編寫負向測試，使斷言結果為負。例如：<code>2 + 2</code> 不等於 <code>5</code>。</p>
<p>在「Run」窗格中，螢幕截圖會如下所示：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/aa7d361d8e4826ef_1920.png?authuser=2&hl=zh-tw" width="90%" height="90%">

<p>許多指標都能表示測試成功，包括綠色勾號，以及所通過測試的數量。</p>
<h5 id="測試失敗"><a href="#測試失敗" class="headerlink" title="測試失敗"></a>測試失敗</h5><p>修改測試來看看測試失敗的情形。請將 <code>2 + 2</code> 變更為 <code>2 + 3</code>，然後再次執行測試。請注意，您只能以產生的程式碼進行實驗，進一步瞭解測試的運作方式。這些變更與 <code>Dice Roller</code> 功能並無任何關聯性。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class ExampleUnitTest &#123;</span><br><span class="line">   @Test</span><br><span class="line">   fun <span class="function"><span class="title">addition_isCorrect</span></span>() &#123;</span><br><span class="line">       assertEquals(4, 2 + 3)</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>完成其餘操作後，螢幕截圖會如下所示：<br><img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/751ac8089cf4c47c_1920.png?authuser=2&hl=zh-tw" width="90%" height="90%"></p>
<p>紅色文字代表測試失敗。在測試結果選單中，按一下項目即會提供錯誤訊息，指出測試失敗的原因。<br><img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/163708373e651ecc_1920.png?authuser=2&hl=zh-tw" width="90%" height="90%"></p>
<p>在這個例子中，錯誤訊息表示斷言失敗，因為預期結果為 <code>4</code>，但實際值是 <code>5</code>。由於您將實際值變更為 <code>2 + 3</code>，但預期值還是 <code>4</code>，所以這是合理的狀況。您也會看到測試失敗的行。在這個例子中，第 15 行測試失敗，註明為 <code>ExampleUnitTest.kt:15</code>。</p>
<p>最後，為求測試徹底，請將預期值從 <code>4</code> 變更為 <code>5</code>，然後再次執行測試。在出現問題的程式碼中，預期值與實際值相符，所以現在測試應已通過。</p>
<hr>
<h4 id="編寫第一個單元測試"><a href="#編寫第一個單元測試" class="headerlink" title="編寫第一個單元測試"></a>編寫第一個單元測試</h4><p>現在您已慢慢熟悉單元測試，您就可以自行編寫與 <code>Dice Roller</code> 應用程式更相關的單元測試。</p>
<p>您應該發現到，<code>Dice Roller</code> 應用程式的主要功能是以隨機號碼產生器為基礎。不過，人所共知，隨機號碼產生器難於測試，因為您無法確定隨機產生號碼的結果。這項測試旨在確保你擲出骰子，或是呼叫 <code>dice</code> 類別上的 <code>roll</code> 方法時，能夠取得正確的數字。您編寫的測試只會測試<code>隨機號碼產生器的結果</code>不會超出您為<code>產生器指定的數字範圍</code>。</p>
<ol>
<li><p>在 <code>ExampleUnitTest.kt</code> 檔案中，刪除產生的測試方法並匯入陳述式。您的檔案應如下所示：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/c06e8b402f293b5e_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">
</li>
<li><p>建立 <code>generates_number()</code> 函式：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">generates_number</span></span>() &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>@Test</code> 註解為 <code>generates_number()</code> 方法加上註解。請注意，嘗試呼叫 <code>@Test</code> 時，文字會顯示為紅色。這是因為找不到這個註解的<code>斷言</code>，所以您需要匯入斷言。按下 <code>Control+Enter</code>(在 Mac 上則為 <code>Options+Return</code>) 即可自動執行這項操作。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/bbe5791b9565588c_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<p>程式碼現在應如下所示：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/9a94c2bdf84adb61_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<ol start="4">
<li>建立 <code>Dice</code> 物件的執行個體</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">fun <span class="function"><span class="title">generates_number</span></span>() &#123;</span><br><span class="line">   val dice = Dice(6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="5">
<li><p>接下來，對這個執行個體呼叫 <code>roll()</code> 方法，並儲存傳回的值。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">fun <span class="function"><span class="title">generates_number</span></span>() &#123;</span><br><span class="line">   val dice = Dice(6)</span><br><span class="line">   val rollResult = dice.roll()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>最後提出實際斷言即可。換句話說，您需要聲明該方法傳回的值在您傳遞的側側邊數目以內。因此在這個例子中，<code>該值必須大於 0，且小於 7</code>。為符合此要求，請使用 <code>assertTrue()</code> 方法。請注意，嘗試呼叫 <code>assertTrue()</code> 方法時，文字會先顯示為紅色。這是因為找不到這個方法的宣告，所以您必須匯入宣告，做法與處理註解時類似。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/10eea07fc21bf998_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<p>然後選擇來自 <code>org.junit.Assert</code> 套件的選項：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/5dbfba2ba0e37ac9_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<p>如果將游標放在兩個括號之間並按下 <code>Control+P</code> (在 Mac 上則為 <code>Command+P</code>)，系統會顯示工具提示，當中會顯示方法使用的參數：</p>
<img src="https://developer.android.com/static/codelabs/android-basics-kotlin-write-unit-tests/img/865cf0ac47738e08_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<p><code>assertTrue()</code> 方法有兩個參數：<code>String</code> 和 <code>Boolean</code>。如果斷言失敗，字串即是控制台中顯示的訊息。布林值是條件陳述式。請將訊息設為：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;The value of rollResult was not between 1 and 6&quot;</span></span><br></pre></td></tr></table></figure>

<p>如前文所述，測試隨機號碼是一大挑戰，因為是隨機產生的號碼，所以無法預測號碼的值。所有唯一能做的，就是確保值不會超出特定範圍。請將條件參數設為：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollResult <span class="keyword">in</span> 1..6</span><br></pre></td></tr></table></figure>

<p>程式碼應該如下所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">fun <span class="function"><span class="title">generates_number</span></span>() &#123;</span><br><span class="line">   val dice = Dice(6)</span><br><span class="line">   val rollResult = dice.roll()</span><br><span class="line">   assertTrue(<span class="string">&quot;The value of rollResult was not between 1 and 6&quot;</span>, rollResult <span class="keyword">in</span> 1..6)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>按一下函式旁邊的箭頭，然後選取「Run ‘ExampleUnitTest.generates_number()’」，結果應顯示測試成功。</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Automated Testing</tag>
        <tag>Unit Test</tag>
        <tag>Assertion</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(5)-新增圖片至Dice Roller應用程式</title>
    <url>/2023/08/22/Android%E7%AD%86%E8%A8%98-5-%E6%96%B0%E5%A2%9E%E5%9C%96%E7%89%87%E8%87%B3Dice-Roller%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>將新增骰子的圖片至現有的<code>Dice Roller</code>Android應用程式。</p>
</blockquote>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/c7f0d42525da7431_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p><strong>學習目標</strong></p>
<ul>
<li>如何在應用程式執行時更新<code>ImageView</code>。</li>
<li>如何根據不同條件自訂應用程式行為(使用<code>when</code>陳述式)。</li>
</ul>
<span id="more"></span>

<hr>
<h4 id="更新應用程式的版面配置"><a href="#更新應用程式的版面配置" class="headerlink" title="更新應用程式的版面配置"></a>更新應用程式的版面配置</h4><p>新增顯示擲骰子結果圖片的<code>ImageView</code>，以取代版面配置中的<code>TextView</code>。</p>
<ol>
<li>在 Android Studio 中，開啟並執行先前程式碼研究室的 Dice Roller 應用程式。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/2e8416293e597725_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="2">
<li><p>刪除<code>TextView</code>，新增<code>ImageView</code>並放置在<code>Button</code>上方。</p>
</li>
<li><p>在「Pick a Resource」對話方塊中，選取「Sample data」下的「avatars」。這是您在下一項工作中新增骰子圖片前，暫時使用的圖片。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/91f6e2be0a01fbf_1920.png?authuser=2&hl=zh-tw" width="70%" heught="70%">

<ol start="4">
<li>在「Component Tree」中，您會看到兩項錯誤。<code>Button</code>不受垂直限制，<code>ImageView</code>則不受垂直或水平限制。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/b8c3b83124c31ff_1920.png?authuser=2&hl=zh-tw" width="70%" heught="70%">

<hr>
<h4 id="調整-ImageView-和-Button-的位置"><a href="#調整-ImageView-和-Button-的位置" class="headerlink" title="調整 ImageView 和 Button 的位置"></a>調整 ImageView 和 Button 的位置</h4><p>無論 Button 在什麼位置，ImageView 都必須垂直置於畫面中間。</p>
<ol>
<li>在<code>ImageView</code>中加入水平限制條件。將<code>ImageView</code>的左側連結至父項<code>ConstraintLayout</code>的左側邊緣，右側連結至父項的右側邊緣，使<code>ImageView</code>水平置中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/9848bb6319e11777_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<ol start="2">
<li>在<code>ImageView</code>加入垂直限制，然後連結<code>ImageView</code>的頂端與父項的頂端。<code>ImageView</code>會向上滑動至 <code>ConstraintLayout</code>的頂端。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/2d8d134e6292d48f_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<ol start="3">
<li><p>在<code>Button</code>中加入垂直限制，然後連結<code>Button</code>的頂端與<code>ImageView</code>底部。<code>Button</code>會向上滑動至 <code>ImageView</code>下方。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/b6d3dcee6c7a51fc_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">
</li>
<li><p>再次選取<code>ImageView</code>並加入垂直限制，然後連結<code>ImageView</code>的底部與父項的底部。這會讓<code>ImageView</code>在 <code>ConstraintLayout</code>中垂直置中。</p>
</li>
</ol>
<p>完成所有操作後，「Design」(設計) 檢視畫面應該如下所示，<code>ImageView</code>位於中央，<code>Button</code>則緊靠在下方。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/1b05a6d2fd56459f_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<hr>
<h4 id="新增骰子圖片"><a href="#新增骰子圖片" class="headerlink" title="新增骰子圖片"></a>新增骰子圖片</h4><h5 id="下載骰子圖片"><a href="#下載骰子圖片" class="headerlink" title="下載骰子圖片"></a>下載骰子圖片</h5><ol>
<li>開啟<a href="https://github.com/google-developer-training/android-basics-kotlin-dice-roller-with-images-app-solution/raw/master/dice_images.zip">這個網址</a>下載骰子圖片的 ZIP 檔案至電腦上。</li>
<li>解壓縮<code>dice_images</code>資料夾，可以看到骰子點數 1 到 6 共 6 張圖片。</li>
</ol>
<h5 id="新增骰子圖片至應用程式"><a href="#新增骰子圖片至應用程式" class="headerlink" title="新增骰子圖片至應用程式"></a>新增骰子圖片至應用程式</h5><ol>
<li>依序按一下選單中的「View」&gt;「Tool Windows」&gt;「Resource Manager」，或點選「Project」視窗左側的「Resource Manager」分頁標籤。</li>
<li>按一下「Resource Manager」下方的「+」圖示，然後選取「Import Drawables」，即可開啟檔案瀏覽器。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/67186ea5d631bc8a_1920.png?authuser=2&hl=zh-tw" width="40%" heught="40%">

<ol start="3">
<li>找出並選取這 6 個骰子圖片檔案。您可以選取第一個檔案，然後按住 Shift 鍵並選取其他檔案。</li>
<li>按一下「Open」。依序點選「Next」和「Import」，確認要匯入這 6 項資源。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/a45dff94a19e2722_1920.png?authuser=2&hl=zh-tw" width="70%" heught="70%">

<ol start="5">
<li>如果成功匯入檔案，應用程式的「Resource Manager」(資源管理員) (「app」(應用程式) &gt;「res」(解析度) &gt;「drawable」(可繪項目)) 中會顯示 6 張圖片。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/ab68f82b385fc83e_1920.png?authuser=2&hl=zh-tw"  width="30%" heught="30%">

<hr>
<h4 id="使用骰子圖片"><a href="#使用骰子圖片" class="headerlink" title="使用骰子圖片"></a>使用骰子圖片</h4><h5 id="更換範例顯示圖片"><a href="#更換範例顯示圖片" class="headerlink" title="更換範例顯示圖片"></a>更換範例顯示圖片</h5><ol>
<li>在「設計編輯器」中，選取<code>ImageView</code>。</li>
<li>在「Declared Attributes」部分的「Attributes」中，找到已設為該顯示圖片工具「srcCompat」屬性。</li>
</ol>
<ul>
<li>工具「srcCompat」屬性只會在建構應用程式時向開發人員顯示，所以在模擬器或裝置上執行應用程式時不會顯示。</li>
</ul>
<ol start="3">
<li>按一下顯示圖片的縮圖預覽。系統會開啟對話方塊，請選擇<code>ImageView</code>使用的新資源。</li>
<li>選取<code>dice_1</code>可繪項目，然後按一下「OK」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/1072e9fdd637afd9_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<p>接著，調整<code>ImageView</code>的寬度和高度，避免遮掩<code>Button</code>。</p>
<ol start="5">
<li>在「Constraints Widget」下方的「Attributes」視窗中，找出「layout_width」和「layout_height」屬性。</li>
</ol>
<ul>
<li>這兩項屬性目前設為「wrap_content」，即 ImageView 的高度和寬度與其中的內容 (來源圖片) 相同。</li>
</ul>
<ol start="6">
<li>將<code>ImageView</code>的寬度改設為固定的<code>160 dp</code>，並將高度設為固定的<code>200 dp</code>。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/9579582d8775e688_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<ol start="7">
<li>最後，由於<code>Button</code>太靠近圖片，在「限制小工具」中，設定上邊界 16dp。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-dice-roller-images/img/b53f7379bfba8c27_1920.png?authuser=2&hl=zh-tw" width="30%" heught="30%">

<hr>
<h4 id="按下按鈕時變更骰子圖片"><a href="#按下按鈕時變更骰子圖片" class="headerlink" title="按下按鈕時變更骰子圖片"></a>按下按鈕時變更骰子圖片</h4><p>更新 MainActivity 類別才能使用骰子圖片。</p>
<ol>
<li>刪除<code>TextView</code>相關的程式碼。</li>
<li>建立名為類型<code>ImageView</code>的<code>diceImage</code>的新變數。使用<code>findViewById()</code>方法，傳入<code>ImageView</code>、<code>R.id.imageView</code>的資源識別碼作為輸入引數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val diceImage: ImageView = findViewById(R.id.imageView)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>設定顯示骰子圖片</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diceImage.setImageResource(R.drawable.dice_2)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用<code>if/else</code>或<code>when</code>陳述式，根據擲骰子的結果顯示正確的骰子圖片。</li>
</ol>
<p>if&#x2F;else：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (diceRoll == 1) &#123;</span><br><span class="line">   diceImage.setImageResource(R.drawable.dice_1)</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (diceRoll == 2) &#123;</span><br><span class="line">   diceImage.setImageResource(R.drawable.dice_2)</span><br><span class="line">&#125;</span><br><span class="line"> ...</span><br></pre></td></tr></table></figure>

<p>when：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">when (diceRoll) &#123;</span><br><span class="line">   1 -&gt; diceImage.setImageResource(R.drawable.dice_1)</span><br><span class="line">   2 -&gt; diceImage.setImageResource(R.drawable.dice_2)</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>

<p>完成後如下方所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private fun <span class="function"><span class="title">rollDice</span></span>() &#123;</span><br><span class="line">    // Create new Dice object with 6 sides and roll it</span><br><span class="line">    val dice = Dice(6)</span><br><span class="line">    val diceRoll = dice.roll()</span><br><span class="line"></span><br><span class="line">    val diceImage: ImageView = findViewById(R.id.imageView)</span><br><span class="line"></span><br><span class="line">    // Update the dice image with the dice roll</span><br><span class="line">    when (diceRoll) &#123;</span><br><span class="line">        1 -&gt; diceImage.setImageResource(R.drawable.dice_1)</span><br><span class="line">        2 -&gt; diceImage.setImageResource(R.drawable.dice_2)</span><br><span class="line">        3 -&gt; diceImage.setImageResource(R.drawable.dice_3)</span><br><span class="line">        4 -&gt; diceImage.setImageResource(R.drawable.dice_4)</span><br><span class="line">        5 -&gt; diceImage.setImageResource(R.drawable.dice_5)</span><br><span class="line">        6 -&gt; diceImage.setImageResource(R.drawable.dice_6)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="最佳化程式碼"><a href="#最佳化程式碼" class="headerlink" title="最佳化程式碼"></a>最佳化程式碼</h4><p>呼叫<code>diceImage.setImageResource()</code>在陳述式中出現 6 次。<br>我們可以建立變數，儲存使用的資源識別碼。</p>
<p>更換程式碼，以下列取代。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val drawableResource = when (diceRoll) &#123;</span><br><span class="line">   1 -&gt; R.drawable.dice_1</span><br><span class="line">   2 -&gt; R.drawable.dice_2</span><br><span class="line">   3 -&gt; R.drawable.dice_3</span><br><span class="line">   4 -&gt; R.drawable.dice_4</span><br><span class="line">   5 -&gt; R.drawable.dice_5</span><br><span class="line">   6 -&gt; R.drawable.dice_6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">diceImage.setImageResource(drawableResource)</span><br></pre></td></tr></table></figure>

<p>這時<code>when</code>會顯示錯誤訊息：「‘when’ expression must be exhaustive, add necessary ‘else’ branch」。<br>原因在於 when 運算式的值已指派給 drawableResource，因此 when 必須詳盡無遺，也就是說，這個運算式必須處理所有可能的情況，以確保即使您變更為有 12 面的骰子，仍一律會傳回值。<br>若要修正錯誤，請將案例的 6 變更為 else。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val drawableResource = when (diceRoll) &#123;</span><br><span class="line">   1 -&gt; R.drawable.dice_1</span><br><span class="line">   2 -&gt; R.drawable.dice_2</span><br><span class="line">   3 -&gt; R.drawable.dice_3</span><br><span class="line">   4 -&gt; R.drawable.dice_4</span><br><span class="line">   5 -&gt; R.drawable.dice_5</span><br><span class="line">   <span class="keyword">else</span> -&gt; R.drawable.dice_6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">diceImage.setImageResource(drawableResource)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="在-ImageView-上設定適當的內容說明"><a href="#在-ImageView-上設定適當的內容說明" class="headerlink" title="在 ImageView 上設定適當的內容說明"></a>在 ImageView 上設定適當的內容說明</h4><p>更新 <code>ImageView</code>的內容說明，有助螢幕閱讀器說明內容。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">diceImage.contentDescription = diceRoll.toString()</span><br></pre></td></tr></table></figure>
<ul>
<li>螢幕閱讀器可以朗讀內容說明，因此如果螢幕上顯示骰子擲出「6」的圖片，內容說明會大聲朗讀「6」。</li>
</ul>
<hr>
<h4 id="採用完善的程式設計做法"><a href="#採用完善的程式設計做法" class="headerlink" title="採用完善的程式設計做法"></a>採用完善的程式設計做法</h4><p>使用者首次開啟應用程式時，應用程式顯示的空白畫面 (「Roll」按鈕除外) 看來很突兀。這可能會導致使用者不清楚應用程式的功能，因此您需要變更使用者介面，在首次啟動應用程式時顯示隨機擲骰子的畫面，並建立 Activity。這樣一來，使用者就較有可能理解，只要輕觸「Roll」按鈕就能擲骰子。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">    super.onCreate(savedInstanceState)</span><br><span class="line">    setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">    val rollButton: Button = findViewById(R.id.button)</span><br><span class="line">    rollButton.setOnClickListener &#123; rollDice() &#125;</span><br><span class="line"></span><br><span class="line">    // Do a dice roll when the app starts</span><br><span class="line">    rollDice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最終顯示的畫面：</p>
<img src="https://i.imgur.com/2ekxDp1.gif" width="30%" height="30%">]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(4)-在Kotlin中新增條件式行為</title>
    <url>/2023/08/22/Android%E7%AD%86%E8%A8%98-4-%E5%9C%A8Kotlin%E4%B8%AD%E6%96%B0%E5%A2%9E%E6%A2%9D%E4%BB%B6%E5%BC%8F%E8%A1%8C%E7%82%BA/</url>
    <content><![CDATA[<blockquote>
<p>Lucky Dice Roll 是一款以 Kotlin 為基礎的骰子遊戲，您可以在其中指定一個幸運數字。只要玩家擲出這個幸運數字，即可獲勝。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何使用<code>if</code>和<code>else</code>陳述式。</li>
<li>如何使用<code>大於(&gt;)</code>、<code>小於(&lt;)</code>和<code>等於(==)</code>等運算子來比較值。</li>
<li>如何使用<code>when</code>陳述式來根據指定值選擇選項。</li>
<li><code>Boolean</code>資料類型是什麼，以及如何使用<code>true</code>和<code>false</code>值來做出決策。</li>
</ul>
<hr>
<span id="more"></span>
<h3 id="建立-Lucky-Dice-Roll-遊戲"><a href="#建立-Lucky-Dice-Roll-遊戲" class="headerlink" title="建立 Lucky Dice Roll 遊戲"></a>建立 Lucky Dice Roll 遊戲</h3><h4 id="設定範例程式碼"><a href="#設定範例程式碼" class="headerlink" title="設定範例程式碼"></a>設定範例程式碼</h4><p>參考之前的<code>Dice Roller</code>程式並修改。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;rollResult&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice (val numSides: Int) &#123;</span><br><span class="line"></span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="檢查是否擲出幸運數字"><a href="#檢查是否擲出幸運數字" class="headerlink" title="檢查是否擲出幸運數字"></a>檢查是否擲出幸運數字</h4><ol>
<li>刪除println，並新增名為<code>luckyNumber</code>的<code>val</code>，將其設為<code>4</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增<code>if</code>陳述式，用於檢查<code>rollResult</code>是否等於(&#x3D;&#x3D;)<code>luckyNumber</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">    <span class="keyword">if</span> (rollResult == luckyNumber) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>大括號&#123;&#125;</code>內新增<code>println</code>陳述式，以列印<code>&quot;You win!&quot;</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">    <span class="keyword">if</span> (rollResult == luckyNumber) &#123;</span><br><span class="line">        println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在未擲出幸運數字時回應"><a href="#在未擲出幸運數字時回應" class="headerlink" title="在未擲出幸運數字時回應"></a>在未擲出幸運數字時回應</h4><ol>
<li>新增<code>else</code>陳述式以列印<code>&quot;You didn&#39;t win, try again!&quot;</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">    <span class="keyword">if</span> (rollResult == luckyNumber) &#123;</span><br><span class="line">        println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;You didn&#x27;t win, try again!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>新增<code>else if</code>陳述式，即可針對每次擲骰輸出不同訊息。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (rollResult == luckyNumber) &#123;</span><br><span class="line">        println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rollResult == 1) &#123;</span><br><span class="line">        println(<span class="string">&quot;So sorry! You rolled a 1. Try again!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rollResult == 2) &#123;</span><br><span class="line">        println(<span class="string">&quot;Sadly, you rolled a 2. Try again!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rollResult == 3) &#123;</span><br><span class="line">        println(<span class="string">&quot;Unfortunately, you rolled a 3. Try again!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rollResult == 5) &#123;</span><br><span class="line">        println(<span class="string">&quot;Don&#x27;t cry! You rolled a 5. Try again!&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;Apologies! You rolled a 6. Try again!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用-when-陳述式"><a href="#使用-when-陳述式" class="headerlink" title="使用 when 陳述式"></a>使用 when 陳述式</h4><ol>
<li>在程式的 main() 中，選取從第一個<code>if</code>陳述式至括住最後一個<code>else</code>陳述式的大括號<code>&#125;</code>之間的程式碼，然後刪除這些程式碼。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>建立<code>when</code>陳述式。由於<code>when</code>須針對擲出的結果進行測試，因此請將<code>rollResult</code>包含在括號<code>()</code>內。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line"></span><br><span class="line">    when (rollResult) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在<code>when</code>陳述式的大括號<code>&#123;&#125;</code>內，新增用來測試<code>luckyNumber</code>的陳述式<code>rollResult</code>。如果兩者相同，系統會顯示獲勝訊息。此陳述式如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">luckyNumber -&gt; println(<span class="string">&quot;You win!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在 main 函式中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line"></span><br><span class="line">    when (rollResult) &#123;</span><br><span class="line">        luckyNumber -&gt; println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>表示當 <code>rollResult</code> 等於 <code>luckyNumber</code> 時，就執行 <code>println(&quot;You win!&quot;)</code>。</li>
</ul>
<ol start="4">
<li>使用相同的模式為可能擲出的數字 1 至 6 (4 除外) 新增行和訊息，如下所示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">    </span><br><span class="line">    when (rollResult) &#123;</span><br><span class="line">        luckyNumber -&gt; println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">        1 -&gt; println(<span class="string">&quot;So sorry! You rolled a 1. Try again!&quot;</span>)</span><br><span class="line">        2 -&gt; println(<span class="string">&quot;Sadly, you rolled a 2. Try again!&quot;</span>)</span><br><span class="line">        3 -&gt; println(<span class="string">&quot;Unfortunately, you rolled a 3. Try again!&quot;</span>)</span><br><span class="line">        5 -&gt; println(<span class="string">&quot;Don&#x27;t cry! You rolled a 5. Try again!&quot;</span>)</span><br><span class="line">        6 -&gt; println(<span class="string">&quot;Apologies! You rolled a 6. Try again!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><p>if-else 的一般形式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (condition-is-true) &#123;</span><br><span class="line">    execute-this-code</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (condition-is-true) &#123;</span><br><span class="line">    execute-this-code</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    execute-this-code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>when 陳述式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">when (variable) &#123;</span><br><span class="line">    matches-value -&gt; execute-this-code</span><br><span class="line">    matches-value -&gt; execute-this-code</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="自行練習"><a href="#自行練習" class="headerlink" title="自行練習"></a>自行練習</h3><ol>
<li><p>將 myFirstDice 變更為包含 8 個面並執行程式碼。會發生什麼？<br>當您增加面數時，when 陳述式不會再涵蓋所有情況，因此如果出現未涵蓋的情況，系統不會顯示任何內容。</p>
</li>
<li><p>修正 when 陳述式，以涵蓋所有 8 個面。<br>使用 else 陳述式可捕捉所有未明確涵蓋的情況，而不必針對每個數字新增新的情況。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(8)</span><br><span class="line">    val rollResult = myFirstDice.roll()</span><br><span class="line">    val luckyNumber = 4</span><br><span class="line">    </span><br><span class="line">    when (rollResult) &#123;</span><br><span class="line">        luckyNumber -&gt; println(<span class="string">&quot;You win!&quot;</span>)</span><br><span class="line">        1 -&gt; println(<span class="string">&quot;So sorry! You rolled a 1. Try again!&quot;</span>)</span><br><span class="line">        2 -&gt; println(<span class="string">&quot;Sadly, you rolled a 2. Try again!&quot;</span>)</span><br><span class="line">        3 -&gt; println(<span class="string">&quot;Unfortunately, you rolled a 3. Try again!&quot;</span>)</span><br><span class="line">        5 -&gt; println(<span class="string">&quot;Don&#x27;t cry! You rolled a 5. Try again!&quot;</span>)</span><br><span class="line">        6 -&gt; println(<span class="string">&quot;Apologies! You rolled a 6. Try again!&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span> -&gt; println(<span class="string">&quot;Sorry! You rolled 7 or 8. Try again!&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice (val numSides: Int) &#123;</span><br><span class="line"></span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(3)-建立Dice Roller應用程式</title>
    <url>/2023/08/19/Android%E7%AD%86%E8%A8%98-3-%E5%BB%BA%E7%AB%8BDice-Roller%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>建立可執隨機擲骰子的 Kotlin 程式，當使用者「擲骰子」時，系統會隨機產生結果。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何透過程式輔助方式產生隨機數字來模擬擲骰子的動作。</li>
<li>如何透過建立含有變數和方法的 Dice 類別來建構程式碼。</li>
<li>如何建立類別的物件例項、修改其變數，以及呼叫其方法。</li>
</ul>
<hr>
<span id="more"></span>

<h4 id="使用隨機函式"><a href="#使用隨機函式" class="headerlink" title="使用隨機函式"></a>使用隨機函式</h4><p>如要擲骰子，需要設法呈現所有有效的骰子值。一般的 6 面骰子，可接受的結果有 1、2、3、4、5 和 6。<br><code>IntRange</code> 是一種資料類型，代表從起點到終點的整數範圍。<br>在這裡，我們使用 <code>IntRange</code> 定義骰子可能產生的值。</p>
<ol>
<li>在 <code>main() 函式</code> 中定義為名為 <code>diceRange</code> 的 <code>val</code>，並給定 1 到 6 的 IntRange，代表 6 面骰子可以擲出的整數範圍。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val diceRange = 1..6</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val diceRange = 1..6</code> 等於 <code>val diceRange: IntRange = 1..6</code></li>
</ul>
<ol start="2">
<li>使用 <code>random()</code> 的函式，產生並傳回指定範圍的隨機數字，將結果儲存在變數中。</li>
</ol>
<ul>
<li>在 main() 中，定義一個為名為 <code>randomNumber</code> 的 <code>val</code>。</li>
<li>將 <code>diceRange</code> 呼叫 <code>random()</code> 的結果，存在 <code>randomNumber</code>中 。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val randomNumber = diceRange.random()</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>執行程式碼數次印出 <code>randomNumber</code> ，可以發現隨機數字不一樣。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;隨機數字: <span class="variable">$&#123;randomNumber&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="建立骰子類別"><a href="#建立骰子類別" class="headerlink" title="建立骰子類別"></a>建立骰子類別</h4><p>我們可以建立骰子的<span class="label primary">程式輔助藍圖</span>，指出骰子有多個面，而且可以擲出隨機數字。此<span class="label primary">藍圖</span>稱為<span class="label primary">類別</span>。<br>接下來，就可以透過該類別建立實際的骰子物件，稱為<span class="label primary">「物件執行個體」</span>。例如建立有 12 個面或 4 個面的骰子。</p>
<h5 id="定義骰子類別"><a href="#定義骰子類別" class="headerlink" title="定義骰子類別"></a>定義骰子類別</h5><ul>
<li>在下列步驟中，會定義名為 <code>Dice</code> 的新類別來代表可投擲的骰子。</li>
</ul>
<ol>
<li>為了重新開始，請清除 <code>main()</code> 函式中的程式碼。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在這個 <code>main()</code> 函式下方，新增空白行，然後新增程式碼來建立 <code>Dice</code> 類別。如下所示，請先輸入關鍵字 <code>class</code>，然後輸入類別名稱，後面加左右大括號。請在左右大括號之間留出空格，以便放入類別的程式碼。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在類別定義中，您可以使用變數為類別指定一或多項屬性。真實的骰子可以有多個面、一種顏色或重量。在這項工作中，您的重點會放在骰子面數的屬性上。</li>
</ul>
<ol start="3">
<li>在 Dice 類別中，新增名為 <code>sides</code> 的 <code>var</code> 做為骰子的面數。將 sides 設為 6。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>var是可變變量，而val是不可變變量，var 在被賦予值後還能夠修改，但是val不行。</p>
</blockquote>
<h5 id="建立骰子類別的執行個體"><a href="#建立骰子類別的執行個體" class="headerlink" title="建立骰子類別的執行個體"></a>建立骰子類別的執行個體</h5><p>有了這個 Dice 類別，等同您掌握骰子的藍圖。如要讓程式中「實際」顯示骰子，就需要建立 Dice 物件例項。(如果您需要三個骰子，就要建立三個物件執行個體。)</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-in-kotlin/img/ba2038022410942c_1920.jpeg?authuser=2&hl=zh-tw" width="60%" height="60%">

<ol>
<li>如要建立 <code>Dice</code> 的<span class="label primary">物件執行個體</span>，請在 <code>main()</code> 函式中建立名為 <code>myFirstDice</code> 的 <code>val</code>，並將其<span class="label primary">初始化為 Dice 類別的執行個體</span>。</li>
</ol>
<ul>
<li>請注意類別名稱之後的<code>括號</code>，代表要從<code>類別</code>建立新的<code>物件執行個體</code>。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在已經有了根據藍圖建立的 <code>myFirstDice</code> 物件，便可以存取其<span class="label primary">屬性</span>。Dice 唯一的屬性是 <code>sides</code>。<br>如要存取 <code>myFirstDice</code> 的 <code>sides</code> 屬性，可以使用「點標記法」呼叫 <code>myFirstDice.sides</code>，讀音為「myFirstDice 點 sides」。</p>
<ol start="2">
<li>在 myFirstDice 宣告下方，新增 println() 陳述式，以輸出 myFirstDice. 的 sides 數量</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(myFirstDice.sides)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>執行程式，應會輸出 <code>Dice類別</code> 中定義的 <code>sides數量</code>。</li>
</ol>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()</span><br><span class="line">    println(myFirstDice.sides)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="擲骰子"><a href="#擲骰子" class="headerlink" title="擲骰子"></a>擲骰子</h4><p>在 <code>Dice類別</code> 中新增一個用來擲骰子的 <code>函式</code>。</p>
<ul>
<li>在類別中定義的函式也稱為<span class="label primary">「方法」</span>。</li>
</ul>
<ol>
<li>在 Dice 類別 sides 變數下方﹐插入一行空行，然後建立新的函式來擲骰子。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line"></span><br><span class="line">    fun <span class="function"><span class="title">roll</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>roll()</code> 方法中建立一個 <code>val</code> <code>randomNumber</code>，並呼叫 <code>random()</code> 以在 1..6 範圍內產生一個隨機數字。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line"></span><br><span class="line">    fun <span class="function"><span class="title">roll</span></span>() &#123;</span><br><span class="line">        val randomNumber = (1..6).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>產生<code>隨機數字</code>後將其輸出。完成的 roll() 方法應如以下程式碼所示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">roll</span></span>() &#123;</span><br><span class="line">    val randomNumber = (1..6).random()</span><br><span class="line">    println(randomNumber)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>如要實際投擲 <code>myFirstDice</code>，請在 <code>main()</code> 中對 <code>myFirstDice</code> 呼叫 <code>roll()</code> 方法，如 <code>myFirstDice.roll()</code>，讀音為「myFirstDice 點 roll()」。</li>
</ol>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()  </span><br><span class="line">    println(myFirstDice.sides)</span><br><span class="line">    myFirstDice.roll()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">    </span><br><span class="line">    fun <span class="function"><span class="title">roll</span></span>() &#123;</span><br><span class="line">        val randomNumber = (1..6).random()</span><br><span class="line">        println(randomNumber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">1</span><br></pre></td></tr></table></figure>
<ul>
<li><code>1</code>為隨機產生的數字</li>
</ul>
<hr>
<h4 id="傳回擲骰子的結果值"><a href="#傳回擲骰子的結果值" class="headerlink" title="傳回擲骰子的結果值"></a>傳回擲骰子的結果值</h4><p>將 <code>roll()</code> 方法的結果(產生的隨機數字)存在一個變數中，並回傳到 <code>main函式</code>。</p>
<ol>
<li><p>在 main() 中，修改顯示 myFirstDice.roll() 的行。建立名為 <code>diceRoll</code> 的 <code>val</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val diceRoll = myFirstDice.roll()</span><br></pre></td></tr></table></figure>
</li>
<li><p>變更 <code>roll()</code> 函式，以指定要傳回的資料類型。在本例子中，隨機數字是 <code>Int</code>，因此傳回類型為 <code>Int</code>。<br>指定傳回類型的語法為 <code>在函式名稱後面，在括號後加上冒號和空格，然後為函式的傳回類型加上 Int 關鍵字</code>。</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">    </span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..6).random()</span><br><span class="line">        println(randomNumber)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>roll()</code> 中移除 <code>println()</code> 陳述式，並以 <code>randomNumber</code> 的 <code>return</code> 來取代。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">    </span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..6).random()</span><br><span class="line">        <span class="built_in">return</span> randomNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>在 <code>main函式</code> 中輸出 <code>sides</code> 和 <code>diceRoll</code> 的值。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()</span><br><span class="line">    val diceRoll = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.sides&#125;</span> sided dice rolled <span class="variable">$&#123;diceRoll&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()  </span><br><span class="line">    val diceRoll = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.sides&#125;</span> sided dice rolled <span class="variable">$&#123;diceRoll&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">    </span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..6).random()</span><br><span class="line">        <span class="built_in">return</span> randomNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your 6 sided dice rolled 4!</span><br></pre></td></tr></table></figure>
<ul>
<li><code>6</code>為骰子的面數，<code>4</code>為1~6中隨機產生的數字</li>
</ul>
<hr>
<h4 id="變更骰子面數"><a href="#變更骰子面數" class="headerlink" title="變更骰子面數"></a>變更骰子面數</h4><p>不是所有骰子都有 6 面！骰子有各種形狀和尺寸，有 4 面、8 面，最多可到 120 面！</p>
<ol>
<li>在 <code>Dice</code> 類別的 <code>roll()</code> 方法中，將硬式編碼的 <code>1..6</code> 改為使用 <code>sides</code>。這樣，範圍與擲出的隨機數字便一律適用於面數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val randomNumber = (1..sides).random()</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 main() 函式中，在擲出的骰子結果下方，將 <code>myFirstDice</code> 的 <code>sides</code> 變更為 20。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">myFirstDice.sides = 20</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>複製下方的現有輸出陳述式，然後貼到變更面數的後面，然後將 <code>myFirstDice</code> 的輸出結果替換為對 <code>diceRoll</code> 呼叫 <code>roll()</code> 方法的輸出結果。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.sides&#125;</span> sided dice rolled <span class="variable">$&#123;myFirstDice.roll()&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice()  </span><br><span class="line">    val diceRoll = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.sides&#125;</span> sided dice rolled <span class="variable">$&#123;diceRoll&#125;</span>!&quot;</span>)</span><br><span class="line">     </span><br><span class="line">    myFirstDice.sides = 20</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.sides&#125;</span> sided dice rolled <span class="variable">$&#123;myFirstDice.roll()&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice &#123;</span><br><span class="line">    var sides = 6</span><br><span class="line">    </span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..sides).random()</span><br><span class="line">        <span class="built_in">return</span> randomNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your 6 sided dice rolled 2!</span><br><span class="line">Your 20 sided dice rolled 15!</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行為 <code>6面骰子</code> 的訊息，第二行為 <code>20面骰子</code> 的訊息</li>
</ul>
<hr>
<h4 id="自訂骰子"><a href="#自訂骰子" class="headerlink" title="自訂骰子"></a>自訂骰子</h4><p>修改 <code>Dice類別</code>，以便在<span class="label primary">建立新的執行個體時指定面數</span>。</p>
<ul>
<li>變更 <code>Dice類別定義</code> 就能提供面數，這與函式接受輸入引數的方式類似。</li>
</ul>
<ol>
<li>修改 <code>Dice類別定義</code>，以接受名為 <code>numSides</code> 的整數。類別中的程式碼不會改變。<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice(val numSides: Int) &#123;</span><br><span class="line">   // Code inside does not change.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在 <code>Dice類別</code> 中刪除 <code>sides變數</code>，並將用到 <code>sides</code> 的地方修改成 <code>numSides</code> 。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice(val numSides: Int) &#123;</span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..numSides).random()</span><br><span class="line">        <span class="built_in">return</span> randomNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>main()</code> 中，如要建立含有 6 個面的 <code>myFirstDice</code>，您現在必須提供面數做為 Dice 類別的引數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val myFirstDice = Dice(6)</span><br></pre></td></tr></table></figure>
<ul>
<li>在輸出陳述式中，將 sides 變更為 numSides。</li>
<li>然後在下方，刪除將 sides 變更為 20 的程式碼，因為該變數已不再存在。</li>
<li>請一併刪除下方的 println 陳述式。</li>
</ul>
<p>main() 函式應如下列程式碼所示：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    val diceRoll = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;diceRoll&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>新增程式碼來建立並輸出第二個名為 <code>mySecondDice</code> 的 <code>Dice物件</code>，這個骰子包含 <code>20</code> 個面。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val mySecondDice = Dice(20)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>新增用於投擲和輸出傳回值的輸出陳述式。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Your <span class="variable">$&#123;mySecondDice.numSides&#125;</span> sided dice rolled  <span class="variable">$&#123;mySecondDice.roll()&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)  </span><br><span class="line">    val diceRoll = myFirstDice.roll()</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;diceRoll&#125;</span>!&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    val mySecondDice = Dice(20) </span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;mySecondDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;mySecondDice.roll()&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice(val numSides: Int) &#123;</span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        val randomNumber = (1..numSides).random()</span><br><span class="line">        <span class="built_in">return</span> randomNumber</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your 6 sided dice rolled 3!</span><br><span class="line">Your 20 sided dice rolled 19!</span><br></pre></td></tr></table></figure>
<ul>
<li>第一行為 <code>第一個骰子(6面骰子)</code> 的執行結果，第二行為 <code>第二個骰子(20面骰子)</code> 的執行結果。</li>
</ul>
<hr>
<h4 id="採用完善程式設計做法"><a href="#採用完善程式設計做法" class="headerlink" title="採用完善程式設計做法"></a>採用完善程式設計做法</h4><p>編寫程式碼時，應保持簡潔。</p>
<ol>
<li>可以去除 <code>randomNumber</code> 變數，並直接傳回隨機數字。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在字串範本中呼叫 <code>myFirstDice.roll()</code> 並刪除 <code>diceRoll</code> 變數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;myFirstDice.roll()&#125;</span></span></span><br></pre></td></tr></table></figure>

<p>最終的程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myFirstDice = Dice(6)</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myFirstDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;myFirstDice.roll()&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line">    val mySecondDice = Dice(20)</span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;mySecondDice.numSides&#125;</span> sided dice rolled <span class="variable">$&#123;mySecondDice.roll()&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice (val numSides: Int) &#123;</span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h4><ul>
<li>對 <code>IntRange</code> 呼叫 <code>random()</code> 函式以產生隨機數字：<code>(1..6).random()</code></li>
<li><code>類別</code>就像是<code>物件的藍圖</code>，會包含<code>屬性</code>和<code>行為</code>，可做為<code>變數</code>和<code>函式</code>來實作。</li>
<li><code>類別的執行個體</code>代表一個<code>物件</code>，通常是實物，例如骰子。您可以對物件呼叫動作，並變更其屬性。</li>
<li>可以在建立執行個體時，為類別提供值。例如：<code>class Dice(val numSides: Int)</code>，然後使用 <code>Dice(6)</code> 建立執行個體。</li>
<li>函式可以傳回結果。在函式定義中指定要傳回的資料類型，並在函式主體中使用 <code>return</code> 來傳回一些內容。例如：<code>fun example(): Int &#123; return 5 &#125;</code></li>
</ul>
<hr>
<h4 id="自行練習"><a href="#自行練習" class="headerlink" title="自行練習"></a>自行練習</h4><p>建立 <code>Coin</code> 類別，讓它能夠翻轉、建立類別執行個體，以及拋擲一些硬幣！您會如何使用 <code>random()</code> 函式搭配範圍來完成硬幣拋擲動作呢？</p>
<p>程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val myCoin = Coin(2)  </span><br><span class="line">    println(<span class="string">&quot;Your <span class="variable">$&#123;myCoin.numSides&#125;</span> sided coin rolled <span class="variable">$&#123;myCoin.roll()&#125;</span>!&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Coin(val numSides: Int) &#123;</span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Your 2 sided coin rolled 1!</span><br></pre></td></tr></table></figure>
<ul>
<li>硬幣有正反2面，假設<code>1</code>為正面，<code>2</code>為反面。</li>
</ul>
<hr>
<h3 id="建立互動式的Dice-Roller應用程式"><a href="#建立互動式的Dice-Roller應用程式" class="headerlink" title="建立互動式的Dice Roller應用程式"></a>建立互動式的Dice Roller應用程式</h3><blockquote>
<p>建立一個 <span class="label primary">Dice Roller Android 應用程式</span>，讓使用者能在應用程式中按一下 <code>Button</code> 來擲骰子。擲骰子結果會顯示在螢幕上的 <code>TextView</code> 中。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>如何將 <code>Button</code> 新增至 Android 應用程式。</li>
<li>如何新增輕觸應用程式 <code>Button</code> 時的行為。</li>
<li>如何開啟及修改應用程式的 <code>Activity</code> 程式碼。</li>
<li>如何顯示 <code>Toast</code> 訊息。</li>
<li>如何在應用程式執行期間更新 <code>TextView</code> 的內容。</li>
</ul>
<hr>
<h4 id="設定應用程式"><a href="#設定應用程式" class="headerlink" title="設定應用程式"></a>設定應用程式</h4><p><strong>＊範例為使用 <span class="label danger">Empty View Activity</span> 構建App，非新版 <span class="label danger">Empty Activity</span></strong></p>
<ol>
<li>在 Create New Project(建立新專案) 中，使用 <code>Empty View Activity</code> 範本建立新的 Kotlin 專案。</li>
</ol>
<img src="https://i.imgur.com/PO7Hfug.png" width="70%" height="70%">

<ol start="2">
<li>將應用程式命名為「Dice Roller」，指定最低 API 級別 19 (KitKat)。</li>
</ol>
<img src="https://i.imgur.com/Sp5mb9j.png" width="70%" height="70%">

<h4 id="建立應用程式的版面配置"><a href="#建立應用程式的版面配置" class="headerlink" title="建立應用程式的版面配置"></a>建立應用程式的版面配置</h4><ol>
<li>開啟 <code>activity_main.xml</code>，在「Hello World」TextView 下方新增 <code>Button</code>。</li>
</ol>
<img src="https://i.imgur.com/7upqMzz.png" width="65%" height="65%">

<ul>
<li>TextView 和 Button 皆位於 ViewGroup 類型的 <code>ConstraintLayout</code> 中。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/ea4be68b34500570_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="2">
<li>由於 <code>Button</code> 位於 <code>ConstraintLayout</code> 內，因此您必須設定垂直和水平限制條件進行定位。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/b875e0147bf9e3f5_1920.png?authuser=2&hl=zh-tw" width="60%" height="60%">

<h4 id="安排按鈕的位置"><a href="#安排按鈕的位置" class="headerlink" title="安排按鈕的位置"></a>安排按鈕的位置</h4><p>新增從 Button 頂端到 TextView 底部的垂直限制條件。</p>
<ol>
<li>在「Design」檢視畫面中，按住 <code>Button</code> 上方邊緣有藍色邊框的白色圓圈。拖曳指標，並箭頭會遵循指標。當您移動到<code>「Hello World」TextView</code>底部邊緣時放開。這項操作會建立版面配置限制條件，且 <code>Button</code> 往上滑至 <code>TextView</code> 正下方。</li>
</ol>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/a1973a29e117dd8f.gif?authuser=2" width="30%" height="30%">

<ol start="2">
<li>查看「Layout Editor」(版面配置編輯器) 右側的「Attributes」(屬性)。請留意「Constraint Widget」中，新版面配置的限制條件設定為 <code>TextView</code> 的底部，例如 <code>Top → BottomOf textView (0dp)</code>。</li>
</ol>
<ul>
<li>(0dp) 表示邊界為 0。已發生缺少水平限制條件的錯誤。</li>
</ul>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/88b750fbe0504d93_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="3">
<li>新增從 <code>Button</code> 的左側至父項 <code>ConstraintLayout</code> 的左側的水平限制條件。並於右側重複操作，將 <code>Button</code> 的右邊緣連接到 <code>ConstraintLayout</code> 的右邊緣。結果看起來會像這樣</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/49de1c166b355ee1_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="4">
<li>在仍然選取 <code>Button</code> 的情況下，「Constraint Widget」應如下所示。您新增了兩個額外的限制條件：<code>Start → StartOf parent (0dp)</code> 和 <code>End → EndOf parent (0dp)</code>。這表示 <code>Button</code> 是水平置中於其父項 <code>ConstraintLayout</code> 中。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/dd1bac8adb275f79_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="5">
<li>執行應用程式，應如以下螢幕截圖所示。</li>
</ol>
<img src="https://i.imgur.com/Q7mNg9T.png" width="30%" height="30%">

<h4 id="變更按鈕文字"><a href="#變更按鈕文字" class="headerlink" title="變更按鈕文字"></a>變更按鈕文字</h4><ol>
<li>在版面配置編輯器中，如果已選取 Button，請前往「Attributes」，將「text」變更為「Roll」，然後按下 Enter 鍵 (Mac 則是按下 Return 鍵)。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/9adeab9db109913e_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="2">
<li>在「Component Tree」中，Button 旁邊會顯示橘色的警示三角形。只要游標懸停在三角形上，就會顯示訊息。Android Studio 在您的應用程式的程式碼中偵測到硬式編碼字串 (「Roll」)，因此建議您改用字串資源。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/6e9a5a173a49fc8b_1920.png?authuser=2&hl=zh-tw" width="50%" height="50%">

<ol start="3">
<li>在「Component Tree」中點選橘色三角形。在訊息底部的「Suggested Fix」下方，按一下「Fix」按鈕。(您可能需要向下捲動頁面。)</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/7206a03c9ba0d68d_1920.png?authuser=2&hl=zh-tw" width="50%" height="50%">

<ol start="4">
<li>系統隨即會開啟「Extract Resource」(擷取資源) 對話方塊。擷取字串代表擷取「Roll」文字，並在 strings.xml 中建立一個名為 roll 的字串資源 (app &gt; res &gt; values &gt; strings.xml)。由於預設值正確無誤，因此請按一下「OK」。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/78dc6e6f7abc1152_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="5">
<li>在「Attributes」中，Button 的 text 屬性現在會指向 @string&#x2F;roll</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/4fa3d5e4bce95d2_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<h4 id="設定-TextView-的樣式"><a href="#設定-TextView-的樣式" class="headerlink" title="設定 TextView 的樣式"></a>設定 TextView 的樣式</h4><p>小型「Hello, World!」訊息取代為數字以顯示搖骰子值，並放大字型，讓使用者一目瞭然。</p>
<ol>
<li>在「Design Editor」中選取 <code>TextView</code>，接著將 <code>TextView</code> 的 <code>textSize</code> 變更為 36sp，以便放大且易讀。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/ca5dbfd4f37a49e7_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<ol start="2">
<li>清除 <code>TextView</code> 的 <code>text</code> 屬性。您不用在 TextView 中顯示任何資訊，直到使用者擲骰子為止。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/da4031d0ef02f3c5_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<p>不過，當您編輯應用程式的版面配置和程式碼時，在 <code>TextView</code> 中查看部分文字會很有幫助。為此，您可以在 <code>TextView</code> 新增文字，這些文字只會顯示在版面配置預覽中，但在應用程式執行時不會顯示。</p>
<ol start="3">
<li><p>在「Common Attributes」下方找到「text」屬性，下方則顯示含有工具圖示的「text」屬性。text 屬性是在應用程式執行時顯示給使用者。<span class="label primary">含有工具圖示的「text」屬性是專為您 (開發人員) 設計的「tools text」屬性</span>。</p>
</li>
<li><p>在 <code>TextView</code> 中將工具文字設定為<code>「1」</code>(假設您有一個顯示「1」的骰子)。<code>「1」</code>只會出現在 Android Studio 的「Design Editor」(設計編輯器) 中，但當您在實際裝置或模擬器上執行應用程式時，畫面上不會顯示<code>「1」</code>。</p>
</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/eaf488ba04947f7f_1920.png?authuser=2&hl=zh-tw" width="30%" height="30%">

<h4 id="啟用自動匯入作業"><a href="#啟用自動匯入作業" class="headerlink" title="啟用自動匯入作業"></a>啟用自動匯入作業</h4><p>如果您同時使用更多類別，新增 import 陳述式會變得困難。幸好，使用他人提供的類別時，Android Studio 可協助您選擇正確的匯入作業。</p>
<p>在 macOS 中：<br>-&gt; 依序前往「File」(檔案) &gt;「New Project Settings」(新專案設定) &gt;「Preferences for New Project…」(新專案的偏好設定…) 開啟設定。<br>-&gt; 依序展開「Other Settings」(其他設定) &gt;「Auto Import」(自動匯入)。<br>-&gt; 在「Java」和「Kotlin」區段中，確定已勾選「Add unambiguous imports on the fly」(快速新增不明確的匯入) 和「Optimize imports on the fly (for current project)」(快速最佳化匯入 (適用於目前的專案))。<br>-&gt; 按下「OK」儲存變更，然後關閉設定。</p>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/1bedf6b103fd48c3_1920.png?authuser=2&hl=zh-tw" width="70%" height="70%">

<h4 id="提高按鈕互動性"><a href="#提高按鈕互動性" class="headerlink" title="提高按鈕互動性"></a>提高按鈕互動性</h4><h5 id="在點選按鈕時顯示訊息"><a href="#在點選按鈕時顯示訊息" class="headerlink" title="在點選按鈕時顯示訊息"></a>在點選按鈕時顯示訊息</h5><p>在按下按鈕時，畫面底部顯示簡短訊息。</p>
<ol>
<li><code>setContentView()</code> 呼叫後，將下列程式碼新增至 <code>onCreate()</code> 方法。<code>findViewById()</code> 方法會在版面配置中找到 <code>Button</code>。<code>R.id.button</code> 是 <code>Button</code> 的資源 ID，這是其專屬識別碼。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val rollButton: Button = findViewById(R.id.button)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>使用 <code>rollButton</code> 物件並呼叫 <code>setOnClickListener()</code> 方法，在物件上設定點擊事件監聽器，來監聽使用者是否點選 <code>Button</code>。</li>
</ol>
<ul>
<li>在方法名稱後面使用大括號，而不要使用括號。這是一個宣告 <code>Lambda</code> 的特殊語法，詳情請見未來程式碼研究室的內容。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollButton.setOnClickListener &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>呼叫 <code>Toast.makeText()</code> 即可建立內含文字 “Dice Rolled!” 的 <code>Toast</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val toast = Toast.makeText(this, <span class="string">&quot;Dice Rolled!&quot;</span>, Toast.LENGTH_SHORT)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>然後呼叫 <code>show()</code> 方法，讓 <code>Toast</code> 自行顯示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val toast = Toast.makeText(this, <span class="string">&quot;Dice Rolled!&quot;</span>, Toast.LENGTH_SHORT).show()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行應用程式，然後按一下「Roll」按鈕。浮動式訊息應會以彈出式視窗顯示在螢幕底部，而且不久後就會消失。</li>
</ol>
<img src="https://i.imgur.com/9vtBhag.png" width="30%" height="30%">

<h5 id="在點選按鈕時更新-TextView"><a href="#在點選按鈕時更新-TextView" class="headerlink" title="在點選按鈕時更新 TextView"></a>在點選按鈕時更新 TextView</h5><p>如果不想顯示臨時 <code>Toast</code> 訊息，您必須撰寫程式碼，並在點選「Roll」按鈕時更新畫面上的 <code>TextView</code>。</p>
<ol>
<li>註解 <code>Toast</code> 的程式碼行。</li>
<li>建立一個名稱為 <code>resultTextView</code> 的新變數，以便儲存 <code>TextView</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val resultTextView: TextView = findViewById(R.id.textView)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>將 <code>resultTextView</code> 上的文字設定為在雙引號內的　<code>6</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resultTextView.text = <span class="string">&quot;6&quot;</span></span><br></pre></td></tr></table></figure>

<h4 id="新增擲骰子邏輯"><a href="#新增擲骰子邏輯" class="headerlink" title="新增擲骰子邏輯"></a>新增擲骰子邏輯</h4><h5 id="新增-Dice-骰子-類別"><a href="#新增-Dice-骰子-類別" class="headerlink" title="新增 Dice (骰子) 類別"></a>新增 Dice (骰子) 類別</h5><ol>
<li><p>在 MainActivity 類別中加上最後一個大括號後，透過 <code>roll()</code> 方法建立 <code>Dice</code> 類別。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">class Dice(val numSides: Int) &#123;</span><br><span class="line"></span><br><span class="line">   fun roll(): Int &#123;</span><br><span class="line">       <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>將游標懸停在 <code>numSides</code> 上，畫面上就會顯示<code>「Property ‘numSides&#39; could be private」</code>彈出式視窗。</p>
</li>
</ol>
<ul>
<li>將 <code>numSides</code> 標示為 <code>private</code> 後，您只能在 <code>Dice</code> 類別中存取。由於只有使用 <code>numSides</code> 的程式碼才會位於 <code>Dice</code> 類別內，因此可為 <code>Dice</code> 類別指定這個引數 <code>private</code>。</li>
</ul>
<ol start="3">
<li>按一下「Make ‘numSides’ ‘private」，繼續透過 Android Studio 修正建議問題。</li>
</ol>
<h5 id="建立-rollDice-方法"><a href="#建立-rollDice-方法" class="headerlink" title="建立 rollDice() 方法"></a>建立 rollDice() 方法</h5><p>現在您已經新增 <code>Dice</code> 類別至應用程式，必須更新 <code>MainActivity</code> 才能使用該類別。如要妥善整理程式碼，請將所有擲骰子邏輯放入一個函式中。</p>
<ol>
<li>將點擊事件監聽器中將文字設定為 <code>&quot;6&quot;</code> 的程式碼替換為呼叫 <code>rollDice()</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollButton.setOnClickListener &#123;</span><br><span class="line">   rollDice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>因為尚未定義 <code>rollDice()</code>，Android Studio 會標記誤並以紅色顯示 <code>rollDice()</code>。滑鼠游標懸停在 <code>rollDice()</code> 上時，Android Studio 會顯示問題和可能的解決方法。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/21ef4d7c6c33e154_1920.png?authuser=2&hl=zh-tw" width="50%" height="50%">

<ol start="3">
<li>按一下「More actions…」開啟選單。(Mac 可按下 <code>Option+Enter</code> 開啟選單。)</li>
<li>選取<code>「Create function ‘rollDice&#39;」</code>。Android Studio 會為 MainActivity 中的函式建立空白定義。</li>
</ol>
<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-create-dice-roller-app-with-button/img/16bb603205fc3d3_1920.png?authuser=2&hl=zh-tw" width="50%" height="50%">

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">private fun <span class="function"><span class="title">rollDice</span></span>() &#123;</span><br><span class="line">    TODO(<span class="string">&quot;Not yet implemented&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="建立新的-Dice-物件例項"><a href="#建立新的-Dice-物件例項" class="headerlink" title="建立新的 Dice 物件例項"></a>建立新的 Dice 物件例項</h4><p>在這個步驟中，您必須建立 <code>rollDice()</code> 方法並擲骰子，然後在 <code>TextView</code> 中顯示結果。</p>
<ol>
<li>在 <code>rollDice()</code> 中刪除 TODO() 呼叫，並加入程式碼即可建立具有 6 個面的骰子。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val dice = Dice(6)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>呼叫 <code>roll()</code> 方法即可擲骰子，並將結果儲存在名為 <code>diceRoll</code> 的變數中。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val diceRoll = dice.roll()</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>呼叫 <code>findViewById()</code> 即可找到 <code>TextView</code>。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val resultTextView: TextView = findViewById(R.id.textView)</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>將 <code>diceRoll</code> 轉換成字串，並使用該字串更新 <code>resultTextView</code> 的文字。</li>
</ol>
<ul>
<li>變數 <code>diceRoll</code> 是數字，但 <code>TextView</code> 使用文字。您可以在 <code>diceRoll</code> 上使用 <code>toString()</code> 方法，將數字轉換為字串。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">resultTextView.text = diceRoll.toString()</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>執行應用程式，點選按鈕即可擲骰子。</li>
</ol>
<img src="https://i.imgur.com/wwWMfJ0.gif" width="30%" height="30%">

<h4 id="採用完善程式設計做法-1"><a href="#採用完善程式設計做法-1" class="headerlink" title="採用完善程式設計做法"></a>採用完善程式設計做法</h4><p>團隊合作時，理想的做法是以類似的方式撰寫程式碼，讓程式碼之間保持一致。因此，Android 提供樣式指南來說明如何編寫 Android 程式碼，包括命名慣例、格式和其他遵循的建議做法。</p>
<p>撰寫 Android 程式碼時遵循這些指南：<a href="https://developer.android.com/kotlin/style-guide?authuser=2&hl=zh-tw">Android 開發人員適用的 Kotlin 樣式指南</a>。</p>
<h5 id="清理您的程式碼"><a href="#清理您的程式碼" class="headerlink" title="清理您的程式碼"></a>清理您的程式碼</h5><ol>
<li>縮減程式碼<br>將程式碼縮減成較短行的程式碼，讓程式碼更精簡。以下範例是設定 <code>Button</code> 點擊事件監聽器的程式碼。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollButton.setOnClickListener &#123;</span><br><span class="line">    rollDice()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由於點擊事件監聽器的操作說明只有 1 行，因此您可以縮減 <code>rollDice()</code> 方法呼叫，將此呼叫和大括號全部置於一行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rollButton.setOnClickListener &#123; rollDice() &#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>重新設定程式碼格式<br>現在，您必須重新設定程式碼格式，確保程式碼符合 Android 建議的程式碼格式規範。</li>
</ol>
<p>在 <code>MainActivity.kt</code> 類別中，用 Windows 的鍵盤快速鍵 <code>Control+A</code> (Mac 則是 <code>Command+A</code>) 就可選取檔案中的所有文字。或者您可以在 Android Studio 的選單中依序點選<code>「Edit」&gt;「Select All」</code>。</p>
<p>選取檔案中的所有文字後，在 Android Studio 的選單中依序點選<code>「Code」&gt;「Reformat Code」</code>，或使用鍵盤快速鍵 <code>Ctrl+Alt+L</code> (Mac 則是 <code>Command+Option+L</code>)。</p>
<ul>
<li>這會更新程式碼的格式，包括空白字元、縮排等等。您可能還看不到任何變化，這很好。您的程式碼已正確格式化！</li>
</ul>
<ol start="3">
<li>為程式碼加上註解<br>為每個類別 (<code>MainActivity</code> 和 <code>Dice</code> 是您的應用程式中僅有的類別) 和您撰寫的每個方法新增註解。請在註解的開頭和結尾使用 <code>/**</code> 和 <code>*/</code> 符號，告訴系統這不是程式碼。系統在執行程式碼時會忽略這些行。</li>
</ol>
<h4 id="自行練習-1"><a href="#自行練習-1" class="headerlink" title="自行練習"></a>自行練習</h4><p>在應用程式中新增另一個骰子。按一下「Roll」按鈕應擲 2 個骰子。螢幕上應在 2 個不同的 <code>TextViews</code> 中顯示結果。</p>
<p>執行畫面：<br><img src="https://i.imgur.com/qUvahVG.png" width="30%" height="30%"></p>
<p>程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * This activity allows the user to roll a dice and view the result</span><br><span class="line"> * on the screen.</span><br><span class="line"> */</span><br><span class="line">class MainActivity : <span class="function"><span class="title">AppCompatActivity</span></span>() &#123;</span><br><span class="line">    override fun onCreate(savedInstanceState: Bundle?) &#123;</span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line"></span><br><span class="line">        val rollButton: Button = findViewById(R.id.button)</span><br><span class="line">        val rollButton2: Button = findViewById(R.id.button2)</span><br><span class="line"></span><br><span class="line">        val resultTextView: TextView = findViewById(R.id.textView)</span><br><span class="line">        val resultTextView2: TextView = findViewById(R.id.textView2)</span><br><span class="line"></span><br><span class="line">        //when click button</span><br><span class="line">        rollButton.setOnClickListener &#123;</span><br><span class="line">            // Update the screen with the dice roll</span><br><span class="line">            resultTextView.text = rollDice()</span><br><span class="line">        &#125;</span><br><span class="line">        rollButton2.setOnClickListener &#123;</span><br><span class="line">            // Update the screen with the dice roll</span><br><span class="line">            resultTextView2.text = rollDice()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Roll the dice and update the screen with the result.</span><br><span class="line">     */</span><br><span class="line">    private fun rollDice(): String &#123;</span><br><span class="line">        // Create new Dice object with 6 sides and roll it</span><br><span class="line">        val dice = Dice(6)</span><br><span class="line">        val diceRoll = dice.roll()</span><br><span class="line"></span><br><span class="line">        // <span class="built_in">return</span> random number</span><br><span class="line">        <span class="built_in">return</span> diceRoll.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Dice(private val numSides: Int) &#123;</span><br><span class="line"></span><br><span class="line">    fun roll(): Int &#123;</span><br><span class="line">        <span class="built_in">return</span> (1..numSides).random()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>IntRange</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(2)-建立Birthday Card應用程式</title>
    <url>/2023/07/27/Android%E7%AD%86%E8%A8%98-2-%E5%BB%BA%E7%AB%8BBirthday-Card%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>建構一個以文字格式顯示生日祝福語的 Android 應用程式。</p>
</blockquote>
<p><strong>學習目標</strong></p>
<ul>
<li>什麼是使用者介面元素，例如 Views 和 ViewGroups。</li>
<li>如何在應用程式的 TextView 中顯示文字。</li>
<li>如何在 TextView 上設定文字、字型和邊界等屬性。</li>
<li>使用 ImageView 將圖像新增至應用程式。</li>
</ul>
<span id="more"></span>

<hr>
<h3 id="設定Happy-Birthday應用程式"><a href="#設定Happy-Birthday應用程式" class="headerlink" title="設定Happy Birthday應用程式"></a>設定Happy Birthday應用程式</h3><h4 id="使用者介面"><a href="#使用者介面" class="headerlink" title="使用者介面"></a>使用者介面</h4><p>為了在畫面上顯示文字，我們將使用一種用於顯示文字的<code>View</code>，也就是<code>TextView</code>。<br><code>ViewGroup</code>是可在其中放入<code>View</code>物件的容器，負責排列內部的<code>View</code>。<br><code>ConstraintLayout</code>是其中一種<code>ViewGroup</code>，可協助您靈活地排列內部的<code>View</code>。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/b02cb13e267730fc_1920.png?authuser=2&hl=zh-tw" alt="1"></p>
<h4 id="版面配置編輯器"><a href="#版面配置編輯器" class="headerlink" title="版面配置編輯器"></a>版面配置編輯器</h4><p>Android Studio 提供一個稱為<span class="label primary">版面配置編輯器</span>的工具，排列<code>Views</code>和<code>ViewGroups</code>來建立使用者介面。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/fc4828e6a783234_1920.png?authuser=2&hl=zh-tw" alt="2"></p>
<ul>
<li>左側標記 (1) 的地方是您先前看過的「Project」(專案) 視窗，其中列出專案組成的所有檔案。</li>
<li>畫面中央會顯示 (4) 和 (5) 兩個繪圖，分別代表應用程式的螢幕版面配置。左側標記 (4) 的視窗顯示應用程式執行時呈現的近似效果，也就是所謂的「Design」(設計) 檢視畫面。</li>
<li>右側標記 (5) 的視窗代表「Blueprint」(藍圖) 檢視畫面，在執行特定操作時會很有用。</li>
<li>標記 (2) 的「Palette」(區塊面板) 視窗列出可新增到應用程式的各類 Views。</li>
<li>標記 (3) 的「Component Tree」(元件樹狀結構) 是另一種螢幕檢視畫面方式，列出螢幕的所有檢視畫面。</li>
<li>最右側標記 (6) 的視窗是「屬性」(Attributes)，顯示了 View 的各種屬性，您可在這裡加以變更。</li>
</ul>
<h4 id="變更Hello-World訊息"><a href="#變更Hello-World訊息" class="headerlink" title="變更Hello World訊息"></a>變更Hello World訊息</h4><p>我們使用版面配置編輯器將「Hello World!」變更為「生日快樂！」，之後再設定文字的樣式。</p>
<ol>
<li>展開「app」資料夾、「res」資料夾和「layout」資料夾。</li>
<li>按兩下<code>activity_main.xml</code>，系統隨即會在版面配置編輯器中開啟<code>activity_main.xml</code>。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/1f64a0a2623c9380_1920.png?authuser=2&hl=zh-tw" alt="3"></li>
<li>在「Component Tree」(元件樹狀結構) 中，按一下<code>TextView</code>，找到右側的「Attributes」(屬性)。</li>
<li>將「Declared Attributes」(宣告屬性) 部分中的<code>text</code>從「Hello World!」修改成「生日快樂！」。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/de37fe1f5ed1507e_1920.png?authuser=2&hl=zh-tw" alt="4"></li>
</ol>
<hr>
<h3 id="在版面配置中新增TextView"><a href="#在版面配置中新增TextView" class="headerlink" title="在版面配置中新增TextView"></a>在版面配置中新增TextView</h3><h4 id="刪除目前的TextView"><a href="#刪除目前的TextView" class="headerlink" title="刪除目前的TextView"></a>刪除目前的TextView</h4><ol>
<li>在版面配置編輯器中，按一下以選取位於版面配置中央的<code>TextView</code>。</li>
<li>按下 Delete 鍵。Android Studio 會刪除<code>TextView</code>，而您的應用程式在版面配置編輯器和「Component Tree」(元件樹狀結構) 中只會顯示<code>ConstraintLayout</code>。</li>
</ol>
<h4 id="新增TextView"><a href="#新增TextView" class="headerlink" title="新增TextView"></a>新增TextView</h4><ol>
<li>找出<code>TextView</code>。可以在「Common」類別和「Text」類別中找到它。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/e23ce742cec0ab41_1920.png?authuser=2&hl=zh-tw" alt="5"></li>
<li>將<code>TextView</code>從「Palette」(區塊面板) 拖曳到版面配置編輯器設計平面的左上方。<br><img src="https://developer.android.com/codelabs/basic-android-kotlin-training-birthday-card-app/img/6bbcb1bbc39df93a.gif?authuser=2" alt="6"></li>
<li>當新增了一個<code>TextView</code>，我們會注意到「Component Tree」(元件樹狀結構) 中有<span class="label danger">紅色驚嘆號</span>。</li>
<li>將滑鼠游標移到驚嘆號上，就會看到一則警示訊息，說明該檢視畫面未受到限制，且會在執行應用程式時跳到其他位置。接下來要修正這個問題。</li>
</ol>
<h4 id="放置TextView"><a href="#放置TextView" class="headerlink" title="放置TextView"></a>放置TextView</h4><ol>
<li>點選新增的<code>TextView</code>，在右側的「Attributes」(屬性) 中，找到「Layout」(版面配置) 部分中的<span class="label primary">「Constraint Widget」(限制小工具)</span>。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/b8811ae0b8d7acdf_1920.png?authuser=2&hl=zh-tw" alt="6"></li>
<li>按一下正方形頂端的<code>+</code>，可設定上邊界的數字欄位。該邊界是指從<code>TextView</code>到<code>容器(即 ConstraintLayout)</code>邊緣的距離。</li>
<li>將上邊界和左邊界變更為 16。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/ea087eb3bdbc771b_1920.png?authuser=2&hl=zh-tw" alt="7"></li>
<li>在「Attributes」(屬性) 中設定「text」(文字) 。</li>
</ol>
<h4 id="新增及放置另一個TextView"><a href="#新增及放置另一個TextView" class="headerlink" title="新增及放置另一個TextView"></a>新增及放置另一個TextView</h4><ol>
<li>從「區塊面板」將新的 TextView 拖曳到「版面配置編輯器」中的應用程式檢視畫面附近。</li>
<li>將右邊界和下邊界設為 16。</li>
<li>在「Attributes」(屬性) 中設定「text」(文字) 。<img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app/img/f547c1b45045984a_1920.png?authuser=2&hl=zh-tw" width="35%" height="35%"></li>
</ol>
<h3 id="新增文字樣式"><a href="#新增文字樣式" class="headerlink" title="新增文字樣式"></a>新增文字樣式</h3><p>在<code>TextView</code>「Attributes」(屬性) 視窗中的「Common Attributes」(一般屬性) 點開<span class="label success">「textAppearance」</span>，修改<span class="label primary">fontFamily</span>、<span class="label primary">textSize</span>和<span class="label primary">textColor</span>。</p>
<p>完成的畫面如下，可以根據自己的喜好修改：<br><img src="https://i.imgur.com/2Pkqa6r.png" width="35%" height="35%"></p>
<hr>
<h3 id="加入圖像"><a href="#加入圖像" class="headerlink" title="加入圖像"></a>加入圖像</h3><ol>
<li>按一下<a href="https://github.com/google-developer-training/android-basics-kotlin-birthday-card-with-image-app-solution/blob/master/androidparty.png">這裡</a>前往GitHub下載生日資訊卡的圖像。</li>
<li>在 Android Studio 中，按一下選單中的「View」&gt;「Tool Windows」&gt;「Resource Manager」，或按一下「Project」視窗左側的「Resource Manager」分頁標籤。</li>
<li>按一下「Resource Manager」下方的「+」圖示，然後選取「Import Drawables」，即可開啟檔案瀏覽器，選擇剛才下載的圖片檔。</li>
<li>如果圖像已成功匯入，Android Studio 會將圖像新增至「Drawable」清單。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/e4a7e2568ab80e33.png?authuser=2&hl=zh-tw" alt="8"></li>
</ol>
<hr>
<h3 id="新增ImageView"><a href="#新增ImageView" class="headerlink" title="新增ImageView"></a>新增ImageView</h3><h4 id="新增ImageView並設定圖像"><a href="#新增ImageView並設定圖像" class="headerlink" title="新增ImageView並設定圖像"></a>新增ImageView並設定圖像</h4><ol>
<li>在「Project」視窗中開啟「activity_main.xml」(「App」&gt;「Res」&gt;「Layout」&gt;「activity_main.xml」)。</li>
<li>在「版面配置編輯器」中，前往「Palette」，然後將<code>ImageView</code>拖曳至您的應用程式。請將其放在中央附近，且不要與任何文字重疊</li>
<li>在「Choose a Resource」對話方塊中，於「Drawable」清單中找到蛋糕圖像。</li>
</ol>
<h4 id="設定ImageView的位置和大小"><a href="#設定ImageView的位置和大小" class="headerlink" title="設定ImageView的位置和大小"></a>設定ImageView的位置和大小</h4><ol>
<li>在「版面配置編輯器」中按住並拖曳<code>ImageView</code>，但請注意，在「Design」檢視畫面內，應用程式畫面周圍會顯示粉紅色矩形。 粉紅色矩形代表用來放置<code>ImageView</code>的螢幕邊界</li>
<li>拖曳<code>ImageView</code>，讓左側和右側邊緣對齊粉紅色矩形。當您拉近時，Android Studio 會將圖像「貼齊」邊緣 (您將在稍後處理頂端和底端)。<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/25ab8b0401429ebd.gif?authuser=2" width="50%" height="50%"></li>
</ol>
<blockquote>
<p><code>ConstraintLayout</code> 中的<code>View</code>需要水平和垂直限制，才能讓<code>ConstraintLayout</code>知道如何定位。</p>
</blockquote>
<ol start="3">
<li><p>將游標懸停於<code>ImageView</code>外框頂端的圓圈上，並以另一個圓圈醒目顯示。</p>
</li>
<li><p>將圓圈拖曳到應用程式畫面頂端，當您拖曳圓圈時，會有箭頭連結圓圈與游標。在螢幕上拖曳，直到貼齊畫面頂端。您已新增從<code>ImageView</code>頂端至<code>ConstraintLayout</code>頂端的限制條件。</p>
<img src="https://developer.android.com/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/f3b70726695ea8c9.gif?authuser=2" width="50%" height="50%">
</li>
<li><p>新增從<code>ImageView</code>的底部到<code>ConstraintLayout</code>底部的限制。可能太靠近邊緣，無法像對頂端那樣拖動。這時可以在「Attributes」視窗的「Constraint Widget」中，點選底部的「+」來新增至限制條件。確保邊界為 0。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/cdde37ea44d6bc1a.png?authuser=2&hl=zh-tw" alt="11"></p>
</li>
<li><p>在「Attributes」窗格中，使用「Constraint Widget」在左側和右側新增 0 的邊界。 這項操作會自動建立對該指令的限制。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/1c58fd4afe6f83bb.png?authuser=2&hl=zh-tw" alt="12"></p>
</li>
</ol>
<blockquote>
<p>此時圖像已置中，但還沒有佔滿整個螢幕畫面。</p>
</blockquote>
<ol start="7">
<li>在「Constraint」部分的「Constraint Widget」下方，將「layout_width」和將「layout_height」設定為「0dp」。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/9fff7d632ac45a3d.png?authuser=2&hl=zh-tw" alt="13"></li>
<li>找出「scaleType」屬性，將「scaleType」設定為「centerCrop」，這樣圖像就會填滿螢幕，不會扭曲變形。<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/32350f1cf95adb1d.png?authuser=2&hl=zh-tw" alt="14"></li>
</ol>
<p>完成後圖片會填滿整個畫面：<br><img src="https://developer.android.com/static/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/b3ef159159143c95.png?authuser=2&hl=zh-tw" width="35%" height="35%"></p>
<h4 id="將ImageView移至文字後方"><a href="#將ImageView移至文字後方" class="headerlink" title="將ImageView移至文字後方"></a>將ImageView移至文字後方</h4><p>在「Component Tree」中點選並拖曳 ImageView 至 TextViews 正下方 ConstraintLayout。系統隨即會顯示一條三角形的藍色線條，以代表 ImageView 的位置。<br>將 ImageView 拖放到 ConstraintLayout 正下方即可。<br><img src="https://developer.android.com/codelabs/basic-android-kotlin-training-birthday-card-app-image/img/140649e77bd4f05b.gif?authuser=2" width="50%" height="50%"></p>
<p>最後完成如下圖：<br><img src="https://i.imgur.com/91FX7SR.png" width="35%" height="35%"></p>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
        <tag>Views</tag>
        <tag>ViewGroups</tag>
        <tag>TextView</tag>
        <tag>ImageView</tag>
      </tags>
  </entry>
  <entry>
    <title>Android筆記(1)-Kotlin簡介</title>
    <url>/2023/07/27/Android%E7%AD%86%E8%A8%98-1-Kotlin/</url>
    <content><![CDATA[<blockquote>
<p>Kotlin為Google宣布的Android官方開發語言</p>
</blockquote>
<p><a href="https://developer.android.com/training/kotlinplayground">點此可以線上練習編寫Kotlin</a></p>
<span id="more"></span>

<hr>
<h3 id="Kotlin練習"><a href="#Kotlin練習" class="headerlink" title="Kotlin練習"></a>Kotlin練習</h3><h4 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h4><p>首先我們看到第一個範例：印出Hello, world!</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;Hello, world!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，<span class="label success">fun</span>代表函式(function)，<span class="label primary">main</span>則是這個函式的名稱，也是Kotlin所需的主函式。</li>
<li>函式名稱後面一律加上兩個括號<code>()</code>，括號中的內容稱為「引數」，或簡短表示為<code>args</code>。</li>
<li>引數是指傳送到函式的值，可以是值、變數，甚至是其他函式。</li>
<li>而括號後方的大括號<code>&#123;&#125;</code>包起來的程式，是函式內部用於完成工作的程式碼。</li>
<li><code>println</code>是列印+換行的意思，會指示系統列印一行文字並換行。</li>
</ul>
<h4 id="建立生日訊息"><a href="#建立生日訊息" class="headerlink" title="建立生日訊息"></a>建立生日訊息</h4><h5 id="加入範例程式"><a href="#加入範例程式" class="headerlink" title="加入範例程式"></a>加入範例程式</h5><ol>
<li>在瀏覽器中開啟 <a href="https://developer.android.com/training/kotlinplayground%E3%80%82">https://developer.android.com/training/kotlinplayground。</a></li>
<li>加入範例程式碼：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, Rover!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already 5!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;5 is the very best age to celebrate!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="建立及使用變數"><a href="#建立及使用變數" class="headerlink" title="建立及使用變數"></a>建立及使用變數</h5><ol>
<li>將 Rover 的年齡儲存在變數中。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val age = 5</span><br></pre></td></tr></table></figure>

<ul>
<li><code>val</code> 是 Kotlin 使用的特殊字詞，稱為「關鍵字」，<code>age</code> 為變數名稱。</li>
</ul>
<p>如要輸出該變數的值，而不是文字，只要在前面加上美元符號的大括號內放入變數即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="variable">$&#123;variable&#125;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>將程式碼中兩個輸出陳述式的數字 5 改成 <code>age</code> 變數，如下所示</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span>!&quot;</span>)</span><br><span class="line">println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> is the very best age to celebrate!&quot;</span>)</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>更改 <code>age</code> 的值為天數來表示 Rover 的年齡(年齡x365)</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val age = 5 * 365</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>再次執行程式碼，您會發現兩條訊息現在都以天數顯示年齡。</li>
<li>最後調整一下訊息的文字</li>
</ol>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, Rover!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old!!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Happy Birthday, Rover!</span><br><span class="line">You are already 1825 days old!!</span><br><span class="line">1825 days old is the very best age to celebrate!</span><br></pre></td></tr></table></figure>

<h5 id="將文字放入變數"><a href="#將文字放入變數" class="headerlink" title="將文字放入變數"></a>將文字放入變數</h5><ol>
<li>在 <code>age</code> 的變數下方，新增名為 <code>name</code> 的變數代表壽星名字，並將值設為 “Rover”。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val name = <span class="string">&quot;Rover&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>用變數取代生日訊息中的名字 Rover，如下所示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>name</code> 變數將 Rover 加入年齡訊息中，如下所示。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    val name = <span class="string">&quot;Rover&quot;</span></span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Happy Birthday, Rover!</span><br><span class="line">You are already 1825 days old, Rover!</span><br><span class="line">1825 days old is the very best age to celebrate!</span><br></pre></td></tr></table></figure>

<h5 id="使用函式加上生日橫幅的邊框"><a href="#使用函式加上生日橫幅的邊框" class="headerlink" title="使用函式加上生日橫幅的邊框"></a>使用函式加上生日橫幅的邊框</h5><ol>
<li>建立函式來輸出邊框</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">printBorder</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;================================================&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>在 <code>main()</code> 函式中呼叫 <code>printBorder()</code> 函式</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    val name = <span class="string">&quot;Rover&quot;</span></span><br><span class="line">    printBorder()</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">    printBorder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="function"><span class="title">printBorder</span></span>() &#123;</span><br><span class="line">    println(<span class="string">&quot;================================================&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>在 <code>printBorder()</code> 函式中，使用 <code>repeat()</code> 重複邊框格式，最後加入 println() 來換行。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">printBorder</span></span>() &#123;</span><br><span class="line">    repeat(48) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    val name = <span class="string">&quot;Rover&quot;</span></span><br><span class="line">    printBorder()</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">    printBorder()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun <span class="function"><span class="title">printBorder</span></span>() &#123;</span><br><span class="line">    repeat(48) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">================================================</span><br><span class="line">Happy Birthday, Rover!</span><br><span class="line">You are already 1825 days old, Rover!</span><br><span class="line">1825 days old is the very best age to celebrate!</span><br><span class="line">================================================</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>使用引數變更邊框</li>
<li>新增名為 <code>border</code> 的變數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val border = <span class="string">&quot;%&quot;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>將 <code>border</code> 變數做為引數，傳遞至對 <code>printBorder()</code> 函式的呼叫中。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">printBorder(border)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改 <code>printBorder()</code> 函式中的引數，並使用 border 作為函式中的變數。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printBorder(border: String) &#123;</span><br><span class="line">    repeat(48) &#123;</span><br><span class="line">        <span class="built_in">print</span>(border)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>引數的名稱是 <code>border</code>、名稱後方有冒號 <code>:</code> 以及 <code>String</code> (引數的類型)。</li>
</ul>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    val name = <span class="string">&quot;Rover&quot;</span></span><br><span class="line">   	val border = <span class="string">&quot;%&quot;</span></span><br><span class="line">    printBorder(border)</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">    printBorder(border)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun printBorder(border: String) &#123;</span><br><span class="line">    repeat(48) &#123;</span><br><span class="line">        <span class="built_in">print</span>(border)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br><span class="line">Happy Birthday, Rover!</span><br><span class="line">You are already 1825 days old, Rover!</span><br><span class="line">1825 days old is the very best age to celebrate!</span><br><span class="line">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>將邊框變更為 <code>&quot;&#39;-._,-&#39;&quot;</code> 格式，並新增新變數 <code>timesToRepeat</code> 調整重複次數</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">val border = <span class="string">&quot;`-._,-&#x27;&quot;</span></span><br><span class="line">val timesToRepeat = 7</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>呼叫 <code>printBorder</code> 函式時，變成需要2個引數</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">printBorder(border, timesToRepeat)</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>新曾 <code>printBorder</code> 函式中的引數</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printBorder(border: String, timesToRepeat: Int) &#123;</span><br></pre></td></tr></table></figure>

<ul>
<li>有多個引數時，以半形逗號 <code>,</code> 分隔引數。</li>
</ul>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 5 * 365</span><br><span class="line">    val name = <span class="string">&quot;Rover&quot;</span></span><br><span class="line">   	val border = <span class="string">&quot;`-._,-&#x27;&quot;</span></span><br><span class="line">    val timesToRepeat = 7</span><br><span class="line">    printBorder(border, timesToRepeat)</span><br><span class="line">    println(<span class="string">&quot;Happy Birthday, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">    println(<span class="string">&quot;You are already <span class="variable">$&#123;age&#125;</span> days old, <span class="variable">$&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line">	println(<span class="string">&quot;<span class="variable">$&#123;age&#125;</span> days old is the very best age to celebrate!&quot;</span>)</span><br><span class="line">    printBorder(border, timesToRepeat)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun printBorder(border: String, timesToRepeat: Int) &#123;</span><br><span class="line">    repeat(timesToRepeat) &#123;</span><br><span class="line">        <span class="built_in">print</span>(border)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;</span><br><span class="line">Happy Birthday, Rover!</span><br><span class="line">You are already 1825 days old, Rover!</span><br><span class="line">1825 days old is the very best age to celebrate!</span><br><span class="line">`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;`-._,-&#x27;</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="建立一個多層且點上蠟燭的蛋糕"><a href="#建立一個多層且點上蠟燭的蛋糕" class="headerlink" title="建立一個多層且點上蠟燭的蛋糕"></a>建立一個多層且點上蠟燭的蛋糕</h4><ul>
<li>建立三個函式來繪製一個點上蠟燭的多層蛋糕。</li>
<li>在一個 repeat() 內部使用另一個 repeat()，建立「巢狀迴圈」。</li>
<li>先從大方向開始，再加入細節。這就是所謂的「由上而下開發」。</li>
</ul>
<p>最後需要完成的蛋糕如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ,,,,,,,,,,,,,,,,,,,,,,,,</span><br><span class="line"> ||||||||||||||||||||||||</span><br><span class="line">==========================</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br></pre></td></tr></table></figure>
<hr>
<h5 id="建立-main-函式"><a href="#建立-main-函式" class="headerlink" title="建立 main() 函式"></a>建立 main() 函式</h5><ol>
<li>建立變數 <code>age</code>，並將其設為 24。</li>
<li>建立第二個變數 <code>layers</code>，並將其設為 5。</li>
<li>呼叫函式 <code>printCakeCandles()</code>，並傳遞 age。</li>
<li>呼叫函式 <code>printCakeTop()</code>，並傳遞 age。</li>
<li>呼叫函式 <code>printCakeBottom()</code>，並傳遞 age 和 layers 的數量。</li>
</ol>
<ul>
<li>先將函式註解</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 24</span><br><span class="line">    val layers = 5</span><br><span class="line">    // printCakeCandles(age)</span><br><span class="line">    // printCakeTop(age)</span><br><span class="line">    // printCakeBottom(age, layers)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="建立-printCakeTop"><a href="#建立-printCakeTop" class="headerlink" title="建立 printCakeTop()"></a>建立 printCakeTop()</h5><p>printCakeTop() 函式是一行等號，用於輸出蛋糕頂端。<br><code>==========================</code></p>
<ol>
<li>建立函式 <code>printCakeTop()</code>，接收 <code>Int</code> 類型的 <code>age</code> 引數。</li>
<li>使用 repeat() 陳述式輸出單一等號 <code>age</code>+2 次。額外的兩個等號是為了讓蠟燭不會從蛋糕的側面掉下來。</li>
<li>repeat() 完成後，請在結尾輸出一行空白行(換行)。</li>
<li>移除 main() 中 <code>printCakeTop()</code> 的註解，因為該函式已存在</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printCakeTop(age: Int) &#123;</span><br><span class="line">    repeat(age+2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="建立-printCakeCandles"><a href="#建立-printCakeCandles" class="headerlink" title="建立 printCakeCandles()"></a>建立 printCakeCandles()</h5><p>每支蠟燭都由兩個符號組成：半形逗號 (,) 代表燭焰，豎線號 (|) 代表燭體。<br><code>,,,,,,,,,,,,,,,,,,,,,,,,</code><br><code>||||||||||||||||||||||||</code></p>
<ol>
<li>建立一個新函式 <code>printCakeCandles()</code>，接收 <code>Int</code> 類型的 <code>age</code> 引數。</li>
<li>印出一個空格，使蠟燭呈現以下的樣子</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ,,,,,,,,,,,,,,,,,,,,,,,,</span><br><span class="line"> ||||||||||||||||||||||||</span><br><span class="line">==========================</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 repeat() 陳述式輸出一個半形逗號 <code>,</code> 來代表燭焰(重複 <code>age</code> 次)，最後換行。</li>
<li>重複上述步驟來建立第二個 repeat() 陳述式，用來使用豎線號 <code>|</code> 輸出燭體。</li>
<li>在結尾使用 println() 輸出新的一行。</li>
<li>移除 main() 中 <code>printCakeCandles()</code> 的註解。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printCakeCandles(age: Int) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    repeat(age) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    repeat(age) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="建立-printCakeBottom"><a href="#建立-printCakeBottom" class="headerlink" title="建立 printCakeBottom()"></a>建立 printCakeBottom()</h5><p>使用這個函式繪製與 <code>age + 2</code> 等寬的蛋糕底部，且畫出的高度包含特定層數。</p>
<ul>
<li>函式需要兩個引數，一個用於寬度 <code>age</code>，一個用於高度 <code>layers</code>。</li>
<li>如要顯示蛋糕底部，請先重複 @ 符號 <code>age + 2</code> 次，即可顯示一層蛋糕。接著，重複輸出一層蛋糕 layers 次。</li>
</ul>
<p>重複 @ 符號 age + 2 次，繪製一層蛋糕：</p>
<ol>
<li>建立內含引數 age 和 layers 的函式 <code>printCakeBottom()</code>，兩個引數都是 Int 類型。</li>
<li>使用 repeat() 陳述式輸出一層<code>@</code> 符號 <code>age + 2</code> 次。在結尾輸出空白行。<br>如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printCakeBottom(age: Int, layers: Int) &#123;</span><br><span class="line">    repeat(age+2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用巢狀 repeat() 輸出蛋糕層 -&gt; 在函式中的所有程式碼周圍放置第二個 repeat() 陳述式。重複此循環 layers 次<br>如下所示：</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun printCakeBottom(age: Int, layers: Int) &#123;</span><br><span class="line">    repeat(layers) &#123;</span><br><span class="line">        repeat(age+2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>移除 main() 中 <code>printCakeBottom()</code> 的註解。</li>
</ol>
<p>現在程式碼：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">fun <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">    val age = 24</span><br><span class="line">    val layers = 5</span><br><span class="line">    printCakeCandles(age)</span><br><span class="line">    printCakeTop(age)</span><br><span class="line">    printCakeBottom(age, layers)</span><br><span class="line">&#125;</span><br><span class="line">fun printCakeTop(age: Int) &#123;</span><br><span class="line">    repeat(age+2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br><span class="line">fun printCakeCandles(age: Int) &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    repeat(age) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    repeat(age) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;|&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    println()</span><br><span class="line">&#125;</span><br><span class="line">fun printCakeBottom(age: Int, layers: Int) &#123;</span><br><span class="line">    repeat(layers) &#123;</span><br><span class="line">        repeat(age+2) &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;@&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        println()  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>執行結果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> ,,,,,,,,,,,,,,,,,,,,,,,,</span><br><span class="line"> ||||||||||||||||||||||||</span><br><span class="line">==========================</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="重要名詞"><a href="#重要名詞" class="headerlink" title="重要名詞"></a>重要名詞</h3><h4 id="1-函式"><a href="#1-函式" class="headerlink" title="1. 函式"></a>1. 函式</h4><p><strong>函式</strong></p>
<ul>
<li><strong>函式</strong>是獨立的程式碼區塊，會執行運算作業並傳回值。在 Kotlin 中，系統會使用<code>fun</code>關鍵字宣告函式，您可以在函式中置入指定或預設的引數。與特定<strong>類別</strong>相關聯的函式稱為<strong>方法</strong>。</li>
</ul>
<p><strong>建構函式</strong></p>
<ul>
<li>在建立<strong>類別</strong>的<strong>執行個體</strong>時，系統會自動執行名為建構函式的方法。建構函式會負責執行所有必要作業，讓應用程式的其餘部分能使用該物件。舉例來說，針對您要建構的物件，建構函式通常會初始化 (將第一個值填入) 該物件的所有欄位。建立物件的唯一方法是呼叫 (執行) 該物件的建構函式。</li>
<li>建構函式名稱與其所屬的類別名稱相同。一個類別可以有多個建構函式，前提是每個建構函式都要有不同的參數清單。</li>
</ul>
<p><strong>main()函式</strong></p>
<ul>
<li>Kotlin 程式的 <strong>main() 函式</strong>是指執行程式的進入點。執行 Kotlin 程式時，開頭一律是<code>main()</code>函式。在 <strong>Android 應用程式</strong>中，由於您的應用程式程式碼是由 Android 系統執行，因此不必在程式碼中特別指定<code>main()</code>函式。</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>方法是類別中定義的函式，且與類別的物件執行個體行為相關聯。</li>
</ul>
<p><strong>參數和引數的差異</strong></p>
<ul>
<li>在<strong>函式</strong> (或<strong>方法</strong>) 中，參數是指函式定義中的變數宣告。呼叫函式時，引數是指您傳送至參數的資料。</li>
</ul>
<hr>
<h4 id="2-類別"><a href="#2-類別" class="headerlink" title="2. 類別"></a>2. 類別</h4><p><strong>類別</strong></p>
<ul>
<li><strong>類別</strong>如同<strong>物件</strong>的藍圖，可對類別中敘述的所有物件定義通用的<strong>屬性</strong> (為<strong>變數</strong>)，以及這些物件的動作 (為名為<strong>方法</strong>的<strong>函式</strong>)。您必須以 Kotlin 中的<code>class</code>關鍵字來定義類別。</li>
<li>類別就像是建築師的藍圖設計 (而不是房屋本身)，也就是建造房屋的指示說明。房屋則是根據該藍圖而建立的實體或<strong>物件執行個體</strong>。舉例來說，您可能會設定<code>PetDog</code>類別，其中包含寵物名稱和品種的屬性。接著就能建立物件執行個體 <code>myPetDog</code>和<code>myFriendsPetDog</code>。這兩個執行個體的名稱和品種並不相同，但都屬於<code>PetDog</code>類別。</li>
</ul>
<p><strong>物件</strong></p>
<ul>
<li>在<strong>物件導向程式設計</strong>中，<strong>物件</strong>是指<strong>類別</strong>的特定<strong>執行個體</strong>，其中物件可以是<strong>變數</strong>、<strong>函式</strong>和資料結構的組合。</li>
</ul>
<p><strong>public和private</strong></p>
<ul>
<li>系統會將類別成員預設為<code>public</code>，表示其他程式碼也能存取。不過，建議您限制對外存取權，僅供必要程式碼進行存取。如果將方法或屬性標記為<code>private</code>，則表示僅供該類別的內部元素存取。這個作法可避免不慎暴露實作部分讓其他呼叫端存取或參照。</li>
</ul>
<p><strong>抽象類別</strong></p>
<ul>
<li><strong>抽象類別是</strong> Kotlin 中標示為<code>abstract</code>關鍵字的類別。抽象類別可包含尚未實作的屬性或方法。在這種情況下，您只能在子類別中初始化抽象屬性或實作抽象方法。因此，您無法直接對抽象類別執行個體化。</li>
</ul>
<p><strong>封裝</strong></p>
<ul>
<li><strong>封裝</strong>是指將邏輯相關的功能整合為同一處。其中一個封裝範例就是<strong>類別</strong>。</li>
</ul>
<hr>
<h4 id="3-命名"><a href="#3-命名" class="headerlink" title="3. 命名"></a>3. 命名</h4><p><strong>駝峰式大小寫</strong></p>
<ul>
<li><strong>駝峰式大小寫</strong>是指將每個字的首字母大寫，並移除每個字之間的所有空格。這是 Kotlin 中對<strong>函式</strong>、<strong>變數</strong>和<strong>類別</strong>的命名慣例，例如<code>LinearLayout</code>、<code>MainActivity</code>或<code>setOnClickListener</code>。</li>
</ul>
]]></content>
      <categories>
        <category>Android</category>
        <category>Android Kotlin基本概念課程</category>
        <category>Kotlin基本概念</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo筆記(1)-Hexo基本指令</title>
    <url>/2023/07/24/Hexo%E7%AD%86%E8%A8%98-1-Hexo%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4/</url>
    <content><![CDATA[<blockquote>
<p>學習關於 Hexo 的基本指令，包括建立專案、新文章、新增 menu、跑 server 和 deploy 等等</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="建立一個Hexo專案"><a href="#建立一個Hexo專案" class="headerlink" title="建立一個Hexo專案"></a>建立一個Hexo專案</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo init 專案名稱</span><br><span class="line">$ hexo init blog</span><br></pre></td></tr></table></figure>

<h3 id="新增menu"><a href="#新增menu" class="headerlink" title="新增menu"></a>新增menu</h3><p>(about&#x2F;tags&#x2F;categories…)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page about</span><br><span class="line">$ hexo new page tags</span><br><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>執行完成後source資料夾底下會出現<span class="label primary">對應資料夾</span>和其底下的<span class="label primary">index.md</span></p>
<h3 id="建立新文章"><a href="#建立新文章" class="headerlink" title="建立新文章"></a>建立新文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;我的第一篇文章&quot;</span></span><br></pre></td></tr></table></figure>
<p>執行完成後source&#x2F;_posts資料夾底下會出現<span class="label primary">我的第一篇文章.md</span></p>
<h3 id="跑server"><a href="#跑server" class="headerlink" title="跑server"></a>跑server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<h3 id="修改-config-yml的deploy設定"><a href="#修改-config-yml的deploy設定" class="headerlink" title="修改_config.yml的deploy設定"></a>修改_config.yml的deploy設定</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">deploy</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: git@github.com:你的帳號/你的帳號.github.io.git <span class="comment">#你的github倉庫</span></span><br><span class="line">  branch: main <span class="comment">#分支</span></span><br></pre></td></tr></table></figure>
<p>repository: 到你的github倉庫點選<span class="label success">Code -> copy按鈕</span>，即可複製完成<br><img src="https://i.imgur.com/6djPxpw.png" alt="Imgur"></p>
<h3 id="產生靜態檔案"><a href="#產生靜態檔案" class="headerlink" title="產生靜態檔案"></a>產生靜態檔案</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<h3 id="安裝hexo-deployer-git"><a href="#安裝hexo-deployer-git" class="headerlink" title="安裝hexo-deployer-git"></a>安裝hexo-deployer-git</h3><p>(第一次deploy前執行即可)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install --save hexo-deployer-git</span><br></pre></td></tr></table></figure>

<h3 id="部署到遠端"><a href="#部署到遠端" class="headerlink" title="部署到遠端"></a>部署到遠端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<h4 id="一鍵部屬"><a href="#一鍵部屬" class="headerlink" title="一鍵部屬"></a>一鍵部屬</h4><ol>
<li>安裝 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a></li>
<li>清空 <code>_config.yml</code> 的現有資料，並新增以下組態:</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;username&gt;/&lt;project&gt;</span></span><br><span class="line">  <span class="comment"># example, https://github.com/hexojs/hexojs.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">gh-pages</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>執行 <code>hexo clean &amp;&amp; hexo deploy</code> 。</li>
<li>瀏覽 <code>&lt;GitHub 用戶名&gt;.github.io</code> 檢查你的網站能否運作。</li>
</ol>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Website</tag>
      </tags>
  </entry>
</search>
